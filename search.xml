<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CSS基础知识总结</title>
    <url>/post/6b2d1dfa.html</url>
    <content><![CDATA[<blockquote>
<p>这篇文章仅仅是对<code>CSS</code>的一个总结笔记, 方便后期使用时查找相关知识点</p>
</blockquote>
<ul>
<li><code>Cascading Style Sheets</code>层叠样式表，WEB标准中的表现标准语言，主要对网页信息的显示进行控制</li>
<li>样式通常存储在样式表中: 内部样式、表外部样式表、内联样式表（行内样式、嵌入式样式）<ul>
<li>外部样式表可以极大提高工作效率</li>
<li>外部样式表通常存储在 CSS 文件中</li>
</ul>
</li>
</ul>
<span id="more"></span>


<h2 id="CSS样式"><a href="#CSS样式" class="headerlink" title="CSS样式"></a>CSS样式</h2><h3 id="内部样式表"><a href="#内部样式表" class="headerlink" title="内部样式表"></a>内部样式表</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">	<span class="comment">/*css语句*/</span></span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用<code>style</code>标记创建样式时，最好将该标记写在<code>&lt;head&gt;&lt;/head&gt;</code></p>
<h3 id="外部样式表"><a href="#外部样式表" class="headerlink" title="外部样式表"></a>外部样式表</h3><ul>
<li>外部样式表通常存储在 CSS 文件中</li>
<li>在CSS文件中创建<code>xxx.css</code>文件</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--方法1--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;目标文件的路径及文件名全称&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--方法2--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="keyword">@import</span> url(“目标文件的路径及文件名全称”);</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<div class="note warning"><p>需要说明</p></div>

<ul>
<li>使用<code>link</code>元素导入外部样式表时，需要将该元素写在文档头部，即<code>&lt;head&gt;与&lt;/head&gt;</code>中</li>
<li><code>@</code>和<code>import</code>之间没有空格, <code>url</code>和小括号之间也没有空格, 必须结尾以分号结束</li>
</ul>
<div class="note info"><p>`link`和`import`导入外部样式区别</p></div>

<ul>
<li>老祖宗的差别<ul>
<li><code>link</code>属于<code>XHTML</code>标签，而<code>@import</code>是<code>CSS</code>提供的一种方式。</li>
<li><code>link</code>标签除了可以加载<code>CSS</code>外，还可以做很多其它事情，比如定义<code>RSS</code>、定义<code>rel</code>连接属性等，<code>@import</code>只能加载<code>css</code></li>
</ul>
</li>
<li>加载顺序的差别<ul>
<li>当一个页面被加载的时候（就是被浏览者浏览的时候)，<code>link</code>引用的<code>CSS</code>会同时被加载</li>
<li>而<code>@import</code>引用的<code>CSS</code>会等到页面全部被下载完再被加载</li>
<li>所以有时候浏览<code>@import</code>加载<code>CSS</code>的页面时开始会没有样式</li>
</ul>
</li>
<li>兼容性的差别<ul>
<li><code>@import</code>是<code>CSS2.1</code>提出的，所以老的浏览器不支持</li>
<li><code>@import</code>只在IE5以上的才能识别，而<code>link</code>标签无此问题。</li>
</ul>
</li>
<li>使用DOM控制样式差别<ul>
<li>当使用<code>javascript</code>控制<code>dom</code>去改变样式的时候</li>
<li>只能使用<code>link</code>标签，因为<code>@import</code>不是<code>dom</code>可以控制的</li>
</ul>
</li>
<li>样式的优先级<ul>
<li>内联样式表优先级别最高</li>
<li>内部样式表与外部样式表的优先级和书写的顺序的顺序有关，后书写的优先级别高</li>
</ul>
</li>
</ul>
<h2 id="CSS语法"><a href="#CSS语法" class="headerlink" title="CSS语法"></a>CSS语法</h2><p><img data-src="http://titanjun.oss-cn-hangzhou.aliyuncs.com/html5/cssSel.png" alt="cssSelect"></p>
<ul>
<li>每个CSS样式由3个部分组成，选择器，属性和值。</li>
<li>属性必须放在{}花括号中，属性和属性值用冒号连接。</li>
<li>每条声明用分号结束。</li>
<li>当一个属性有多个属性值的时候，属性值与属性值不分先后顺序。</li>
<li>在书写样式过程中，空格、换行等操作不影响属性显示。</li>
</ul>
<h3 id="简单属性使用"><a href="#简单属性使用" class="headerlink" title="简单属性使用"></a>简单属性使用</h3><h4 id="常用属性介绍"><a href="#常用属性介绍" class="headerlink" title="常用属性介绍"></a>常用属性介绍</h4><ul>
<li><code>width</code>：宽度<ul>
<li>设置元素的宽度值，值为数字；单位为px（像素)、em（字符）、%（百分比）</li>
<li>默认值为auto（自动，通过浏览器自动计算出宽度值单位为像素）</li>
<li>像素在浏览器中的概念：<br>   像素数决定元素或文字在浏览器中显示的大小或位置，页面中的最小计量单位为1个像素，即1px。</li>
</ul>
</li>
<li><code>height</code>：高度<ul>
<li>设置元素的高度值，值为数字；单位为px（像素)、em（字符）、%（百分比）</li>
<li>默认值为auto（自动，通过浏览器自动计算出宽度值单位为像素）</li>
</ul>
</li>
</ul>
<h3 id="背景设置"><a href="#背景设置" class="headerlink" title="背景设置"></a>背景设置</h3><ul>
<li><code>background-color</code>：背景颜色<ul>
<li>背景颜色；规定颜色值为颜色单词名称例如（red）或者十六进制值得颜色例如（#ff0000）或者为rgb值的颜色例如（rgb(255, 0, 0)）</li>
<li>可以为所有元素设置背景色，这包括 body 一直到 em 和 a 等行内元素</li>
</ul>
</li>
<li><code>background-image</code>: 背景图像<ul>
<li><code>background-image: url(&quot;&quot;);</code></li>
<li>元素的背景图像, 默认情况下，背景图像进行平铺重复显示，以覆盖整个元素实体</li>
</ul>
</li>
<li><code>background-repeat</code>: 设置背景图像是否及如何重复<ul>
<li><code>repeat</code>: 背景图像将向垂直和水平方向重复,   这是默认</li>
<li><code>repeat-x</code>: 只有水平位置会重复背景图像</li>
<li><code>repeat-y</code>: 只有垂直位置会重复背景图像</li>
<li><code>no-repeat</code>: <code>background-image</code>不会重复</li>
<li><code>inherit</code>: 指定<code>background-repea</code>属性设置应该从父元素继承</li>
</ul>
</li>
<li><code>background-attachment</code>: 设置背景图像是否固定或者随着页面的其余部分滚动<ul>
<li><code>scroll</code>: 背景图片随页面的其余部分滚动。这是默认</li>
<li><code>fixed</code>: 背景图像是固定的</li>
<li><code>inherit</code>: 指定设置应该从父元素继承</li>
</ul>
</li>
<li><code>background-position</code>: 设置背景图像的起始位置<ul>
<li>设置方式</li>
</ul>
</li>
<li><code>background-size</code>: (CSS3)指定背景图片大小<ul>
<li><code>length</code>: 设置背景图片高度和宽度。第一个值设置宽度，第二个值设置的高度。如果只给出一个值，第二个是设置为 auto(自动)</li>
<li><code>percentage</code>: 将计算相对于背景定位区域的百分比。第一个值设置宽度，第二个值设置的高度。如果只给出一个值，第二个是设置为”auto(自动)”</li>
<li><code>cover</code>: 此时会保持图像的纵横比并将图像缩放成将完全覆盖背景定位区域的最小大小。</li>
<li><code>contain</code>: 此时会保持图像的纵横比并将图像缩放成将适合背景定位区域的最大大小</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--如果仅指定一个关键字，其他值将会是&quot;center&quot;--&gt;</span></span><br><span class="line">background-position: left top;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--第一个值是水平位置，第二个值是垂直--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--左上角是0％0％。右下角是100％100％--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--如果仅指定了一个值，其他值将是50％, 默认值为：0％0％--&gt;</span></span><br><span class="line">background-position: 30% 20%;</span><br></pre></td></tr></table></figure>

<p>设置背景图片样式的两种方式</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--第一种方式--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">div</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">&quot;http://pcatqk8cn.bkt.clouddn.com/cssSel.png&quot;</span>);</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-repeat</span>: repeat-x;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-attachment</span>: fixed;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-position</span>: <span class="number">30%</span> <span class="number">20%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">400px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--简写属性, 合并在一个属性中--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">div</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">&quot;http://pcatqk8cn.bkt.clouddn.com/cssSel.png&quot;</span>) repeat-x fixed <span class="number">30%</span> <span class="number">20%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">400px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h3 id="文本设置"><a href="#文本设置" class="headerlink" title="文本设置"></a>文本设置</h3><ul>
<li><code>color</code>：文本颜色<ul>
<li>规定颜色值为颜色单词名称例如（red）或者十六进制值的颜色例如（#ff0000）或者为rgb值的颜色例如（rgb(255, 0, 0)）</li>
<li>一般多为设置字体的颜色</li>
</ul>
</li>
<li><code>text-align</code>: 对齐元素中的文本<ul>
<li><code>left/right/center</code>: 左右居中对齐</li>
<li><code>justify</code>: 实现两端对齐文本效果</li>
</ul>
</li>
<li><code>text-decoration</code>: 用来设置或删除文本的装饰<ul>
<li><code>none</code>:	默认。定义标准的文本。</li>
<li><code>underline</code>: 定义文本下的一条线。</li>
<li><code>overline</code>:	定义文本上的一条线。</li>
<li><code>line-through</code>:	定义穿过文本下的一条线。</li>
<li><code>blink</code>:	定义闪烁的文本</li>
</ul>
</li>
<li><code>text-transform</code>: 属性控制文本的大小写<ul>
<li><code>capitalize</code>: 文本中的每个单词以大写字母开头。</li>
<li><code>uppercase</code>: 定义仅有大写字母。</li>
<li><code>lowercase</code>: 定义无大写字母，仅有小写字母</li>
</ul>
</li>
<li><code>text-indent</code>: 属性规定文本块中首行文本的缩进<ul>
<li><code>length</code>: 定义固定的缩进; %: 定义基于父元素宽度的百分比的缩进</li>
</ul>
</li>
<li><code>direction</code>: 设置文本方向<ul>
<li><code>ltr</code>: 默认, 从左到右; <code>rtl</code>: 从右到左</li>
</ul>
</li>
<li><code>letter-spacing </code>: 设置字符间距<ul>
<li><code>normal</code>: 默认, 无; <code>length</code>: 字符间的固定间距</li>
</ul>
</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    <span class="selector-tag">p</span>&#123;</span><br><span class="line">        <span class="comment">/*设置文本颜色*/</span></span><br><span class="line">        <span class="attribute">color</span>: <span class="number">#ff4040</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*设置文本方向*/</span></span><br><span class="line">        <span class="comment">/*ltr: 默认, 从左到右; rtl: 从右到左*/</span></span><br><span class="line">        <span class="attribute">direction</span>: ltr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*设置每一个字符间距, 可为负值, 默认0*/</span></span><br><span class="line">        <span class="attribute">letter-spacing</span>: <span class="number">2px</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*设置单词(有空格)的间距, 默认0*/</span></span><br><span class="line">        <span class="attribute">word-spacing</span>: <span class="number">20px</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*设置行高*/</span></span><br><span class="line">        <span class="attribute">line-height</span>: <span class="number">80%</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*设置文本的水平对齐方式*/</span></span><br><span class="line">        <span class="attribute">text-align</span>: center;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*设置文本的垂直对齐方式*/</span></span><br><span class="line">        <span class="attribute">vertical-align</span>: center;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*设置或删除文本的修饰*/</span></span><br><span class="line">        <span class="comment">/*第一个是下划线的样式, 第二个是下划线的颜色*/</span></span><br><span class="line">        <span class="attribute">text-decoration</span>: line-through chartreuse;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*设置文本的首行缩进*/</span></span><br><span class="line">        <span class="attribute">text-indent</span>: <span class="number">30%</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*设置文本中的字母显示大小写*/</span></span><br><span class="line">        <span class="attribute">text-transform</span>: uppercase;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>


<h3 id="文本字体设置"><a href="#文本字体设置" class="headerlink" title="文本字体设置"></a>文本字体设置</h3><ul>
<li><code>font-family</code>: 指定文本的字体系列</li>
<li><code>font-size</code>: 指定文本的字体大小</li>
<li><code>font-weight</code>: 设置文本的粗细; 默认400, bold: 700</li>
<li><code>font-style</code>: 属性指定文本的字体样式; <code>italic</code>: 斜体; <code>oblique</code>: 倾斜</li>
<li><code>font-variant</code>: 以小型大写字体或者正常字体显示文本; <code>small-caps</code>: 显示小型大写字母的字体</li>
<li><code>font</code>: 简写属性在一个声明中设置所有字体属性<ul>
<li>可设置的属性是（按顺序）： <code>font-style font-variant font-weight font-size/line-height font-family</code></li>
</ul>
</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    <span class="selector-tag">p</span><span class="selector-class">.ex1</span>&#123;</span><br><span class="line">        <span class="attribute">font</span>:<span class="number">15px</span> arial,sans-serif;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="selector-tag">p</span><span class="selector-class">.ex2</span>&#123;</span><br><span class="line">        <span class="attribute">font</span>:italic bold <span class="number">12px</span>/<span class="number">30px</span> Georgia, serif;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>


<h3 id="隐藏-x2F-显示元素"><a href="#隐藏-x2F-显示元素" class="headerlink" title="隐藏&#x2F;显示元素"></a>隐藏&#x2F;显示元素</h3><ul>
<li>控制元素现实和隐藏的属性是: <code>Display</code>(显示) 与 <code>Visibility</code>（可见性）</li>
<li>在介绍属性之前先介绍元素的分类</li>
<li>块级元素(block)<ul>
<li>总是独占一行，表现为另起一行开始，而且其后的元素也必须另起一行显示;</li>
<li>宽度(width)、高度(height)、内边距(padding)和外边距(margin)都可控制;</li>
<li>块级元素主要有： <code>address , blockquote , center , dir , div , dl , fieldset , form , h1 , h2 , h3 , h4 , h5 , h6 , hr , isindex , menu , noframes , noscript , ol , p , pre , table , ul , li</code></li>
</ul>
</li>
<li>内联元素(inline)<ul>
<li>和相邻的内联元素在同一行;</li>
<li>宽度(width)、高度(height)、内边距的<code>top/bottom(padding-top/padding-bottom)</code>和外边距的<code>top/bottom(margin-top/margin-bottom)</code>都不可改变，就是里面文字或图片的大小;</li>
<li>内联元素主要有：<code>a , abbr , acronym , b , bdo , big , br , cite , code , dfn , em , font , i , img , input , kbd , label , q , s , samp , select , small , span , strike , strong , sub , sup ,textarea , tt , u , var</code></li>
</ul>
</li>
<li>可变元素(根据上下文关系确定该元素是块元素还是内联元素)：<ul>
<li><code>applet ,button ,del ,iframe , ins ,map ,object , script</code></li>
</ul>
</li>
</ul>
<h4 id="display"><a href="#display" class="headerlink" title="display"></a>display</h4><ul>
<li>CSS中块级、内联元素的应用：<ul>
<li>利用CSS我们可以摆脱上面表格里HTML标签归类的限制，自由地在不同标签&#x2F;元素上应用我们需要的属性。</li>
<li>主要用的CSS样式有以下几个：</li>
<li><code>display:none</code> – 隐藏元素</li>
<li><code>display:block</code>  – 显示为块级元素</li>
<li><code>display:inline</code>  – 显示为内联元素</li>
<li><code>display:inline-block</code> – 显示为内联块元素，表现为同行显示并可修改宽高内外边距等属性</li>
<li>我们常将<ul>元素加上display:inline-block样式，原本垂直的列表就可以水平显示了</li>
</ul>
</li>
</ul>
<h4 id="visibility"><a href="#visibility" class="headerlink" title="visibility"></a>visibility</h4><ul>
<li>对于 CSS 里的 <code>visibility</code> 属性，通常其值被设置成 <code>visible</code> 或 <code>hidden</code></li>
<li><code>visibility: hidden</code> 相当于 <code>display:none</code>，能把元素隐藏起来，但两者的区别在于：<ul>
<li><code>display:none</code> – 元素不再占用空间。</li>
<li><code>visibility: hidden</code> – 使元素在网页上不可见，但仍占用空间。</li>
<li><code>visibility: collapse</code> – 一般的元素的表现与<code>hidden</code> 一样，也即其会占用空间。但如果该元素是与<code>table</code> 相关的元素，例如 <code>table row</code>、<code>table column</code>、<code>table column group</code>、<code>table column group</code> 等，其表现却跟 <code>display: none</code> 一样，也即其占用的空间会释放。</li>
</ul>
</li>
<li>在不同浏览器下，对 <code>visibility: collapse</code> 的处理方式不同：<ul>
<li><code>visibility: collapse</code> 的上述特性仅在 <code>Firefox</code> 下起作用。</li>
<li>在 IE 即使设置了 <code>visibility: collapse</code>，还是会显示元素。</li>
<li>在 <code>Chrome</code> 下，即使会将元素隐藏，但无论是否是与 <code>table</code> 相关的元素，<code>visibility: collapse</code> 都与 <code>visibility: hidden</code> 没有什么区别，即仍会占用空间。</li>
</ul>
</li>
</ul>
<h3 id="边框属性"><a href="#边框属性" class="headerlink" title="边框属性"></a>边框属性</h3><ul>
<li>CSS边框属性允许你指定一个元素边框的样式和颜色</li>
<li><code>border-style</code>: 用来定义边框的样式</li>
</ul>
<p><img data-src="http://titanjun.oss-cn-hangzhou.aliyuncs.com/html5/borderstyle.png" alt="BorderStyle"></p>
<ul>
<li><code>border-radius</code>: 设置边框圆切角</li>
<li><code>border-width</code>: 设置边框宽度<ul>
<li>设置具体的宽度: 2px</li>
<li><code>thin</code>: 细边框, <code>medium</code>: 默认中等, <code>thick</code>: 粗边框, 没有具体的值定义</li>
</ul>
</li>
<li><code>border-color</code>: 设置边框颜色</li>
<li><code>border-bottom</code>: 单独设置底部边框属性, 除此之外还有<code>border-left/right/top</code>属性</li>
<li><code>border-bottom-color</code>: 设置下边框的颜色, 类似的还有<code>border-bottom-style</code>、<code>border-bottom-width</code></li>
<li>代码示例如下</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    <span class="comment">/*单独设置一部分边框*/</span></span><br><span class="line">    <span class="selector-class">.p1</span>&#123;</span><br><span class="line">        <span class="comment">/*设置底部边框简写方式, 顺序: width style color*/</span></span><br><span class="line">        <span class="attribute">border-bottom</span>: <span class="number">2px</span> solid <span class="number">#ff4040</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*上述代码等同于下面三行代码*/</span></span><br><span class="line">        <span class="comment">/*border-bottom-style: solid;*/</span></span><br><span class="line">        <span class="comment">/*border-bottom-color: #ff4040;*/</span></span><br><span class="line">        <span class="comment">/*border-bottom-width: medium;*/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*设置整体的边框*/</span></span><br><span class="line">    <span class="selector-class">.p2</span>&#123;</span><br><span class="line">        <span class="comment">/*简写方式, 也是推荐方式*/</span></span><br><span class="line">        <span class="attribute">border</span>: <span class="number">2px</span> dashed darkviolet;</span><br><span class="line">        <span class="comment">/*设置圆切角*/</span></span><br><span class="line">        <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*具体设置*/</span></span><br><span class="line">        <span class="comment">/*border-width: 2px;*/</span></span><br><span class="line">        <span class="comment">/*border-style: dashed;*/</span></span><br><span class="line">        <span class="comment">/*border-color: darkviolet;*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>


<h3 id="内-x2F-外边距"><a href="#内-x2F-外边距" class="headerlink" title="内&#x2F;外边距"></a>内&#x2F;外边距</h3><ul>
<li>外边距: 改变元素之间上下左右的间距<ul>
<li>设置所有间距顺序: <code>margin: top right bottom left</code></li>
<li>单独设置上下左右间距: <code>margin-top/bottom/left/right</code></li>
</ul>
</li>
<li>内边距: 改变元素中的内容和元素之间上下左右的间距<ul>
<li>内边距设置方式同上</li>
</ul>
</li>
<li>设置方式, 以外边距为例<ul>
<li>margin:10px 5px 15px 20px;<ul>
<li>上边距是 10px</li>
<li>右边距是 5px</li>
<li>下边距是 15px</li>
<li>左边距是 20px</li>
</ul>
</li>
<li>margin:10px 5px 15px;<ul>
<li>上边距是 10px</li>
<li>右边距和左边距是 5px</li>
<li>下边距是 15px</li>
</ul>
</li>
<li>margin:10px 5px;<ul>
<li>上边距和下边距是 10px</li>
<li>右边距和左边距是 5px</li>
</ul>
</li>
<li>margin:10px;<ul>
<li>所有四个边距都是 10px</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    <span class="comment">/*单独设置内外边距*/</span></span><br><span class="line">    <span class="selector-class">.p3</span>&#123;</span><br><span class="line">        <span class="attribute">background-color</span>: <span class="number">#30a4e6</span>;</span><br><span class="line">        <span class="comment">/*设置外边距*/</span></span><br><span class="line">        <span class="attribute">margin-bottom</span>: <span class="number">12px</span>;</span><br><span class="line">        <span class="attribute">margin-top</span>: <span class="number">10px</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*设置内边距*/</span></span><br><span class="line">        <span class="attribute">padding-left</span>: <span class="number">10px</span>;</span><br><span class="line">        <span class="attribute">padding-bottom</span>: <span class="number">20px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>


<h3 id="Float-浮动"><a href="#Float-浮动" class="headerlink" title="Float(浮动)"></a>Float(浮动)</h3><ul>
<li>CSS 的 Float（浮动），会使元素向左或向右移动，其周围的元素也会重新排列</li>
<li>元素的水平方向浮动，意味着元素只能左右移动而不能上下移动。</li>
<li>一个浮动元素会尽量向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止</li>
<li>属性: <code>float</code>, 可选值<ul>
<li><code>left</code> – 元素向左浮动。</li>
<li><code>right</code> – 元素向右浮动。</li>
<li><code>none</code> – 默认值,  元素不浮动，并会显示在其在文本中出现的位置</li>
</ul>
</li>
<li>清除浮动 - 使用<code>clear</code></li>
<li>元素浮动之后，周围的元素会重新排列，为了避免这种情况，使用<code>clear</code>属性。</li>
<li><code>clear</code>属性指定元素两侧不能出现浮动元素<ul>
<li>属性: <code>clear</code>, 可选值</li>
<li><code>left</code> – 元素不允许向左浮动。</li>
<li><code>right</code> – 元素不允许向右浮动。</li>
<li><code>none</code> – 默认值, 允许元素浮动</li>
</ul>
</li>
</ul>
<h3 id="列表样式"><a href="#列表样式" class="headerlink" title="列表样式"></a>列表样式</h3><ul>
<li>在HTML中，有两种类型的列表：<ul>
<li>无序列表 - 列表项标记用特殊图形（如小黑点、小方框等）</li>
<li>有序列表 - 列表项的标记有数字或字母</li>
</ul>
</li>
<li>CSS列表属性作用如下：<ul>
<li>设置不同的列表项标记为有序列表</li>
<li>设置不同的列表项标记为无序列表</li>
<li>设置列表项标记为图像</li>
</ul>
</li>
<li>所有的CSS列表属性<ul>
<li><code>list-style-image</code>: 将图象设置为列表项标志。</li>
<li><code>list-style-position</code>: 设置列表中列表项标志的位置<ul>
<li><code>inside</code>: 列表项目标记放置在文本以内，且环绕文本根据标记对齐</li>
<li><code>outside</code>: 默认值, 保持标记位于文本的左侧。列表项目标记放置在文本以外，且环绕文本不根据标记对齐</li>
</ul>
</li>
<li><code>list-style-type</code>: 设置列表项标志的类型</li>
<li><code>list-style</code>: 简写属性, 把所有的属性设置在一个声明中, 顺序为: <code>type position image</code></li>
</ul>
</li>
</ul>
<blockquote>
<p><code>list-style-type</code>属性取值介绍</p>
</blockquote>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>none</td>
<td>无标记。</td>
</tr>
<tr>
<td>disc</td>
<td>默认。标记是实心圆。</td>
</tr>
<tr>
<td>circle</td>
<td>标记是空心圆。</td>
</tr>
<tr>
<td>square</td>
<td>标记是实心方块。</td>
</tr>
<tr>
<td>decimal</td>
<td>标记是数字。</td>
</tr>
<tr>
<td>decimal-leading-zero</td>
<td>0开头的数字标记。(01, 02, 03, 等。)</td>
</tr>
<tr>
<td>lower-roman</td>
<td>小写罗马数字(i, ii, iii, iv, v, 等。)</td>
</tr>
<tr>
<td>upper-roman</td>
<td>大写罗马数字(I, II, III, IV, V, 等。)</td>
</tr>
<tr>
<td>lower-alpha</td>
<td>小写英文字母The marker is lower-alpha (a, b, c, d, e, 等。)</td>
</tr>
<tr>
<td>upper-alpha</td>
<td>大写英文字母The marker is upper-alpha (A, B, C, D, E, 等。)</td>
</tr>
<tr>
<td>lower-greek</td>
<td>小写希腊字母(alpha, beta, gamma, 等。)</td>
</tr>
<tr>
<td>lower-latin</td>
<td>小写拉丁字母(a, b, c, d, e, 等。)</td>
</tr>
<tr>
<td>upper-latin</td>
<td>大写拉丁字母(A, B, C, D, E, 等。)</td>
</tr>
<tr>
<td>hebrew</td>
<td>传统的希伯来编号方式</td>
</tr>
<tr>
<td>armenian</td>
<td>传统的亚美尼亚编号方式</td>
</tr>
<tr>
<td>georgian</td>
<td>传统的乔治亚编号方式(an, ban, gan, 等。)</td>
</tr>
<tr>
<td>cjk-ideographic</td>
<td>简单的表意数字</td>
</tr>
<tr>
<td>hiragana</td>
<td>标记是：a, i, u, e, o, ka, ki, 等。（日文片假名）</td>
</tr>
<tr>
<td>katakana</td>
<td>标记是：A, I, U, E, O, KA, KI, 等。（日文片假名）</td>
</tr>
<tr>
<td>hiragana-iroha</td>
<td>标记是：i, ro, ha, ni, ho, he, to, 等。（日文片假名）</td>
</tr>
<tr>
<td>katakana-iroha</td>
<td>标记是：I, RO, HA, NI, HO, HE, TO, 等。（日文片假名）</td>
</tr>
</tbody></table>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    <span class="selector-tag">ul</span>&#123;</span><br><span class="line">        <span class="attribute">background-color</span>: chartreuse;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*简写方式*/</span></span><br><span class="line">        <span class="attribute">list-style</span>: circle outside <span class="built_in">url</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*分开设置*/</span></span><br><span class="line">        <span class="comment">/*list-style-position: outside;*/</span></span><br><span class="line">        <span class="comment">/*list-style-type: circle;*/</span></span><br><span class="line">        <span class="comment">/*list-style-image: url(&quot;&quot;);*/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>


<h3 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h3><h4 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a>标签选择器</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*元素名称&#123; 属性: 属性值; &#125;*/</span></span><br><span class="line"><span class="selector-tag">p</span>&#123; <span class="attribute">color</span>: red; &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>说明：<ul>
<li>标签选择器：以文档语言对象类型作为选择器，即使用结构中元素名称作为选择器。例如body、div、p、img、em、strong、span等等。</li>
<li>所有的页面元素都可以作为选择器</li>
</ul>
</li>
<li>用法：<ul>
<li>如果想改变某个元素的默认样式时，可以使用元素选择器。</li>
<li>统一文档某个元素显示效果时，可以使用类型选择器。</li>
</ul>
</li>
</ul>
<h4 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器"></a>id选择器</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*#id名&#123; 属性: 属性值;&#125;*/</span></span><br><span class="line"><span class="selector-id">#menu</span>&#123; <span class="attribute">color</span>: red;  &#125;</span><br><span class="line"><span class="selector-id">#top</span>&#123; </span><br><span class="line">    <span class="attribute">width</span>:<span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">300px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>使用id选择器时，应该为元素定义id属性。<br>如：<code>&lt;div id=&quot;top&quot;&gt;&lt;/div&gt;</code></li>
<li>id选择器的语法格式：“#”加上自定义的id名称。</li>
<li>id名命名取英文名，不能使用关键字（所有的标记和属性都是关键字）<br>如：head标记</li>
<li>一个id名称只能对应文档中的一个具体元素对象。<br>因为id只能定义页面中某一个唯一的元素对象。</li>
<li>id选择器最大的用处：创建网页的外围结构</li>
</ul>
<h4 id="class选择器"><a href="#class选择器" class="headerlink" title="class选择器"></a>class选择器</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* .class类名&#123; 属性: 属性值;&#125; */</span></span><br><span class="line"><span class="selector-class">.top</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">500px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>说明：<ul>
<li>使用类选择器时，应该先为每个元素定义一个类名称。</li>
<li>类选择器的语法格式是：<code>&lt;div class=&quot;top&quot;&gt;&lt;/div&gt;</code></li>
</ul>
</li>
<li>用法：<ul>
<li>class选择器更适合定义一类样式</li>
</ul>
</li>
<li>注意：<ul>
<li>类名的第一个字符不能使用数字，它无法再Mozilla或Firefox中起作用。</li>
</ul>
</li>
</ul>
<h4 id="通配符"><a href="#通配符" class="headerlink" title="*通配符"></a>*通配符</h4><ul>
<li>通配符选择器是一种全局选择器, 常用来重置样式</li>
<li>通配符的写法是<code>*</code>，其含义就是所有元素。</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*   *&#123; 属性: 属性值;&#125;   */</span></span><br><span class="line">*&#123; <span class="attribute">padding</span>:<span class="number">0</span>; <span class="attribute">margin</span>:<span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>


<h4 id="交集选择器"><a href="#交集选择器" class="headerlink" title="交集选择器"></a>交集选择器</h4><p>用于选择同时有多个选择器匹配的元素</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 选择器1选择器2&#123; 属性: 属性值; &#125; */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h1</span><span class="selector-class">.center</span> &#123; <span class="attribute">color</span>:red; <span class="attribute">text-align</span>:center; &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h1</span><span class="selector-id">#center</span> &#123; <span class="attribute">color</span>:red; <span class="attribute">text-align</span>:center; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>第一种格式类似于：<code>h1.center</code><ul>
<li>这种格式由标签选择器和类选择器组成。</li>
</ul>
</li>
<li>第二种格式类似于：<code>h1#center</code><ul>
<li>这种格式由标签选择器和id选择器组成。</li>
</ul>
</li>
<li>两个选择器之间不能有空格，必须连续书写。</li>
<li>以上这两种格式组成的选择器，也就是前者所定义的标签类型和后者的类或者id的元素，称之为交集选择器。</li>
</ul>
<h4 id="并集选择器"><a href="#并集选择器" class="headerlink" title="并集选择器"></a>并集选择器</h4><ul>
<li>并集选择器是一种群组选择器</li>
<li>当有多个选择器应用相同的样式时，可以将选择器用<code>,</code>分隔，合并为一组。</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">选择器<span class="number">1</span>,选择器<span class="number">2</span>,选择器<span class="number">3</span>&#123; 属性: 属性值; &#125;</span><br></pre></td></tr></table></figure>

<h4 id="后代选择器"><a href="#后代选择器" class="headerlink" title="后代选择器"></a>后代选择器</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">选择器1 选择器2&#123; 属性: 属性值; &#125;</span><br></pre></td></tr></table></figure>

<p>选择器1和选择器2用空格隔开，含义就是选择器1中包含的所有选择器2;</p>
<h4 id="子选择器"><a href="#子选择器" class="headerlink" title="子选择器"></a>子选择器</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">选择器1&gt;选择器2&#123; 属性: 属性值; &#125;</span><br></pre></td></tr></table></figure>

<p>选择器1和选择器2用&gt;连接，含义就是选择器1中所有子一级选择器2.</p>
<h4 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:link</span>&#123;属性：属性值;&#125;超链接的初始状态;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:visited</span>&#123;属性：属性值;&#125;超链接被访问后的状态;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>&#123;属性：属性值;&#125;鼠标悬停，即鼠标划过超链接时的状态;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:active</span>&#123;属性：属性值;&#125;超链接被激活时的状态，即鼠标按下时超链接的状态;</span><br></pre></td></tr></table></figure>

<ul>
<li>当这4个超链接伪类选择器联合使用时，应注意他们的顺序，正常顺序为：<code>a:link,a:visited,a:hover,a:active</code>,错误的顺序有时会使超链接的样式失效；</li>
<li>为了简化代码，可以把伪类选择符中相同的声明提出来放在a选择符中；<br>例如：<code>a&#123;color:red;&#125; a:hover&#123;color:green;&#125;</code> 表示超链接的三种状态都相同，只有鼠标划过变颜色</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter中App的主题和导航</title>
    <url>/post/425f3607.html</url>
    <content><![CDATA[<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/flutter/flutter_appbar.png" alt="image"></p>
<span id="more"></span>

<ul>
<li><code>Flutter</code>一切皆<code>Widget</code>的核心思想, 为我们提供了两种主题风格</li>
<li><code>CupertinoApp</code>: 一个封装了很多<code>iOS</code>风格的小部件，一般作为顶层<code>widget</code>使用</li>
<li><code>MaterialApp</code>: 一个封装了很多安卓风格的小部件，一般作为顶层<code>widget</code>使用, 下面我们先看下这个<code>Widget</code></li>
</ul>
<h2 id="MaterialApp"><a href="#MaterialApp" class="headerlink" title="MaterialApp"></a>MaterialApp</h2><p>这里我们先看看<code>MaterialApp</code>的构造函数和相关函数</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MaterialApp(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="comment">// 导航主键, GlobalKey&lt;NavigatorState&gt;</span></span><br><span class="line">    <span class="keyword">this</span>.navigatorKey,</span><br><span class="line">    <span class="comment">// 主页, Widget</span></span><br><span class="line">    <span class="keyword">this</span>.home,</span><br><span class="line">    <span class="comment">// 路由</span></span><br><span class="line">    <span class="keyword">this</span>.routes = <span class="keyword">const</span> &lt;<span class="built_in">String</span>, WidgetBuilder&gt;&#123;&#125;,</span><br><span class="line">    <span class="comment">// 初始化路由, String</span></span><br><span class="line">    <span class="keyword">this</span>.initialRoute,</span><br><span class="line">    <span class="comment">// 构造路由, RouteFactory</span></span><br><span class="line">    <span class="keyword">this</span>.onGenerateRoute,</span><br><span class="line">    <span class="comment">// 为止路由, RouteFactory</span></span><br><span class="line">    <span class="keyword">this</span>.onUnknownRoute,</span><br><span class="line">    <span class="comment">// 导航观察器</span></span><br><span class="line">    <span class="keyword">this</span>.navigatorObservers = <span class="keyword">const</span> &lt;NavigatorObserver&gt;[],</span><br><span class="line">    <span class="comment">// widget的构建</span></span><br><span class="line">    <span class="keyword">this</span>.builder,</span><br><span class="line">    <span class="comment">// APP的名字</span></span><br><span class="line">    <span class="keyword">this</span>.title = <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="comment">// GenerateAppTitle, 每次在WidgetsApp构建时都会重新生成</span></span><br><span class="line">    <span class="keyword">this</span>.onGenerateTitle,</span><br><span class="line">    <span class="comment">// 背景颜色</span></span><br><span class="line">    <span class="keyword">this</span>.color,</span><br><span class="line">    <span class="comment">// 主题, ThemeData</span></span><br><span class="line">    <span class="keyword">this</span>.theme,</span><br><span class="line">    <span class="comment">// app语言支持, Locale</span></span><br><span class="line">    <span class="keyword">this</span>.locale,</span><br><span class="line">    <span class="comment">// 多语言代理, Iterable&lt;LocalizationsDelegate&lt;dynamic&gt;&gt;</span></span><br><span class="line">    <span class="keyword">this</span>.localizationsDelegates,</span><br><span class="line">    <span class="comment">// flutter.widgets.widgetsApp.localeListResolutionCallback</span></span><br><span class="line">    <span class="keyword">this</span>.localeListResolutionCallback,</span><br><span class="line">    <span class="comment">// flutter.widgets.widgetsApp.localeResolutionCallback</span></span><br><span class="line">    <span class="keyword">this</span>.localeResolutionCallback,</span><br><span class="line">    <span class="comment">// 支持的多语言, Iterable&lt;Locale&gt;</span></span><br><span class="line">    <span class="keyword">this</span>.supportedLocales = <span class="keyword">const</span> &lt;Locale&gt;[Locale(<span class="string">&#x27;en&#x27;</span>, <span class="string">&#x27;US&#x27;</span>)],</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 是否显示网格</span></span><br><span class="line">    <span class="keyword">this</span>.debugShowMaterialGrid = <span class="keyword">false</span>,</span><br><span class="line">    <span class="comment">// 是否打开性能监控，覆盖在屏幕最上面</span></span><br><span class="line">    <span class="keyword">this</span>.showPerformanceOverlay = <span class="keyword">false</span>,</span><br><span class="line">    <span class="comment">// 是否打开栅格缓存图像的检查板</span></span><br><span class="line">    <span class="keyword">this</span>.checkerboardRasterCacheImages = <span class="keyword">false</span>,</span><br><span class="line">    <span class="comment">// 是否打开显示到屏幕外位图的图层的检查面板</span></span><br><span class="line">    <span class="keyword">this</span>.checkerboardOffscreenLayers = <span class="keyword">false</span>,</span><br><span class="line">    <span class="comment">// 是否打开覆盖图，显示框架报告的可访问性信息 显示边框</span></span><br><span class="line">    <span class="keyword">this</span>.showSemanticsDebugger = <span class="keyword">false</span>,</span><br><span class="line">    <span class="comment">// 是否显示右上角的Debug标签</span></span><br><span class="line">    <span class="keyword">this</span>.debugShowCheckedModeBanner = <span class="keyword">true</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<div class="note warning"><p>需要注意的几点</p></div>

<ul>
<li>如果<code>home</code>首页指定了，<code>routes</code>里面就不能有<code>&#39;/&#39;</code>的根路由了，会报错，<code>/</code>指定的根路由就多余了</li>
<li>如果没有<code>home</code>指定具体的页面，那<code>routes</code>里面就有<code>/</code>来指定根路由</li>
<li>路由的顺序按照下面的规则来：<ul>
<li>1、如果有<code>home</code>，就会从<code>home</code>进入</li>
<li>2、如果没有<code>home</code>，有<code>routes</code>，并且<code>routes</code>指定了入口<code>&#39;/&#39;</code>，就会从<code>routes</code>的<code>/</code>进入</li>
<li>3、如果上面两个都没有，或者路由达不到，如果有<code>onGenerateRoute</code>，就会进入生成的路由</li>
<li>4、如果连上面的生成路由也没有，就会走到<code>onUnknownRoute</code>，不明所以的路由，比如网络连接失败，可以进入断网的页面</li>
</ul>
</li>
</ul>
<h3 id="routes"><a href="#routes" class="headerlink" title="routes"></a>routes</h3><ul>
<li>声明程序中有哪个通过<code>Navigation.of(context).pushNamed</code>跳转的路由</li>
<li>参数以键值对的形式传递<ul>
<li><code>key</code>:路由名字</li>
<li><code>value</code>:对应的<code>Widget</code></li>
</ul>
</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">routes: &#123;</span><br><span class="line">  <span class="string">&#x27;/home&#x27;</span>: (BuildContext content) =&gt; Home(),</span><br><span class="line">  <span class="string">&#x27;/mine&#x27;</span>: (BuildContext content) =&gt; Mine(),</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h3 id="initialRoute"><a href="#initialRoute" class="headerlink" title="initialRoute"></a>initialRoute</h3><ul>
<li>初始化路由, 当用户进入程序时，自动打开对应的路由(home还是位于一级)</li>
<li>传入的是上面<code>routes</code>的<code>key</code>, 跳转的是对应的<code>Widget</code>（如果该<code>Widget</code>有<code>Scaffold.AppBar</code>,并不做任何修改，左上角有返回键）</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">routes: &#123;</span><br><span class="line">  <span class="string">&#x27;/home&#x27;</span>: (BuildContext content) =&gt; Home(),</span><br><span class="line">  <span class="string">&#x27;/mine&#x27;</span>: (BuildContext content) =&gt; Mine(),</span><br><span class="line">&#125;,</span><br><span class="line">initialRoute: <span class="string">&#x27;/mine&#x27;</span>,</span><br></pre></td></tr></table></figure>

<h3 id="onGenerateRoute"><a href="#onGenerateRoute" class="headerlink" title="onGenerateRoute"></a>onGenerateRoute</h3><p>当通过<code>Navigation.of(context).pushNamed</code>跳转路由时，<br>在<code>routes</code>查找不到时，会调用该方法</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">onGenerateRoute: (RouteSettings setting) &#123;</span><br><span class="line">  <span class="keyword">return</span> MaterialPageRoute(</span><br><span class="line">    settings: setting,</span><br><span class="line">    builder: (BuildContext content) =&gt; Text(<span class="string">&#x27;生成一个路由&#x27;</span>)</span><br><span class="line">  );</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h3 id="onUnknownRoute"><a href="#onUnknownRoute" class="headerlink" title="onUnknownRoute"></a>onUnknownRoute</h3><p>未知路由, 效果跟<code>onGenerateRoute</code>一样, 在未设置<code>onGenerateRoute</code>的情况下, 才会去调用<code>onUnknownRoute</code></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">onUnknownRoute: (RouteSettings setting) &#123;</span><br><span class="line">  <span class="keyword">return</span> MaterialPageRoute(</span><br><span class="line">    settings: setting,</span><br><span class="line">    builder: (BuildContext content) =&gt; Text(<span class="string">&#x27;这是一个未知路由&#x27;</span>)</span><br><span class="line">  );</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h3 id="navigatorObservers"><a href="#navigatorObservers" class="headerlink" title="navigatorObservers"></a>navigatorObservers</h3><ul>
<li>路由观察器，当调用<code>Navigator</code>的相关方法时，会回调相关的操作</li>
<li>比如<code>push</code>，<code>pop</code>，<code>remove</code>，<code>replace</code>是可以拿到当前路由和后面路由的信息</li>
<li>获取路由的名字: <code>route.settings.name</code></li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// navigatorObservers: [HomeObserver()],</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承NavigatorObserver</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeObserver</span> <span class="keyword">extends</span> <span class="title">NavigatorObserver</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> didPush(Route route, Route previousRoute) &#123;</span><br><span class="line">    <span class="keyword">super</span>.didPush(route, previousRoute);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取路由的名字</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;name = <span class="subst">$&#123;route.settings.name&#125;</span>&#x27;</span>);</span><br><span class="line">    <span class="comment">// 获取返回的内容</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;reaule = <span class="subst">$&#123;route.currentResult&#125;</span>&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="builder"><a href="#builder" class="headerlink" title="builder"></a>builder</h3><p>如果设置了这个参数, 那么将会优先渲染这个<code>builder</code>, 而不会在走路由</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">builder: (BuildContext content, Widget widget) =&gt; Text(<span class="string">&#x27;builder&#x27;</span>),</span><br></pre></td></tr></table></figure>

<h3 id="title"><a href="#title" class="headerlink" title="title"></a>title</h3><ul>
<li>设备用于识别用户的应用程序的单行描述</li>
<li>在<code>Android</code>上，标题显示在任务管理器的应用程序快照上方，当用户按下“最近的应用程序”按钮时会显示这些快照</li>
<li>在<code>iOS</code>上，无法使用此值。来自应用程序的<code>Info.plist</code>的<code>CFBundleDisplayName</code>在任何时候都会被引用，否则就会引用<code>CFBundleName</code></li>
<li>要提供初始化的标题，可以用<code>onGenerateTitle</code></li>
</ul>
<h2 id="CupertinoApp"><a href="#CupertinoApp" class="headerlink" title="CupertinoApp"></a>CupertinoApp</h2><p>用于创建<code>iOS</code>风格应用的顶层组件, 相关属性和<code>MaterialApp</code>相比只是少了<code>theme</code>和<code>debugShowMaterialGrid</code>, 其他属性都一样, 如下所示</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> CupertinoApp(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="keyword">this</span>.navigatorKey,</span><br><span class="line">    <span class="keyword">this</span>.home,</span><br><span class="line">    <span class="keyword">this</span>.routes = <span class="keyword">const</span> &lt;<span class="built_in">String</span>, WidgetBuilder&gt;&#123;&#125;,</span><br><span class="line">    <span class="keyword">this</span>.initialRoute,</span><br><span class="line">    <span class="keyword">this</span>.onGenerateRoute,</span><br><span class="line">    <span class="keyword">this</span>.onUnknownRoute,</span><br><span class="line">    <span class="keyword">this</span>.navigatorObservers = <span class="keyword">const</span> &lt;NavigatorObserver&gt;[],</span><br><span class="line">    <span class="keyword">this</span>.builder,</span><br><span class="line">    <span class="keyword">this</span>.title = <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="keyword">this</span>.onGenerateTitle,</span><br><span class="line">    <span class="keyword">this</span>.color,</span><br><span class="line">    <span class="keyword">this</span>.locale,</span><br><span class="line">    <span class="keyword">this</span>.localizationsDelegates,</span><br><span class="line">    <span class="keyword">this</span>.localeListResolutionCallback,</span><br><span class="line">    <span class="keyword">this</span>.localeResolutionCallback,</span><br><span class="line">    <span class="keyword">this</span>.supportedLocales = <span class="keyword">const</span> &lt;Locale&gt;[Locale(<span class="string">&#x27;en&#x27;</span>, <span class="string">&#x27;US&#x27;</span>)],</span><br><span class="line">    <span class="keyword">this</span>.showPerformanceOverlay = <span class="keyword">false</span>,</span><br><span class="line">    <span class="keyword">this</span>.checkerboardRasterCacheImages = <span class="keyword">false</span>,</span><br><span class="line">    <span class="keyword">this</span>.checkerboardOffscreenLayers = <span class="keyword">false</span>,</span><br><span class="line">    <span class="keyword">this</span>.showSemanticsDebugger = <span class="keyword">false</span>,</span><br><span class="line">    <span class="keyword">this</span>.debugShowCheckedModeBanner = <span class="keyword">true</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>使用示例如下</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> CupertinoApp(</span><br><span class="line">  title: <span class="string">&#x27;Cupertino App&#x27;</span>,</span><br><span class="line">  color: Colors.red,</span><br><span class="line">  home: CupertinoPageScaffold(</span><br><span class="line">    backgroundColor: Colors.yellow,</span><br><span class="line">    resizeToAvoidBottomInset: <span class="keyword">true</span>,</span><br><span class="line">    navigationBar: CupertinoNavigationBar(</span><br><span class="line">      middle: Text(<span class="string">&#x27;Cupertino App Bar&#x27;</span>),</span><br><span class="line">      backgroundColor: Colors.blue,</span><br><span class="line">    ),</span><br><span class="line">    child: Center(</span><br><span class="line">      child: Container(</span><br><span class="line">        child: Text(<span class="string">&#x27;Hello World&#x27;</span>),</span><br><span class="line">      ),</span><br><span class="line">    ),</span><br><span class="line">  ),</span><br><span class="line">);</span><br></pre></td></tr></table></figure>


<h2 id="CupertinoPageScaffold"><a href="#CupertinoPageScaffold" class="headerlink" title="CupertinoPageScaffold"></a>CupertinoPageScaffold</h2><p>一个<code>iOS</code>风格的页面的基本布局结构。包含内容和导航栏</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const CupertinoPageScaffold(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    // 设置导航栏, 后面会详解</span><br><span class="line">    this.navigationBar,</span><br><span class="line">    // 设置内容页面的背景色</span><br><span class="line">    this.backgroundColor = CupertinoColors.white,</span><br><span class="line">    // 子widget是否应该自动调整自身大小以适应底部安全距离</span><br><span class="line">    this.resizeToAvoidBottomInset = true,</span><br><span class="line">    @required this.child,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="navigationBar"><a href="#navigationBar" class="headerlink" title="navigationBar"></a>navigationBar</h2><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> CupertinoNavigationBar(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="comment">//导航栏左侧组件</span></span><br><span class="line">    <span class="keyword">this</span>.leading,</span><br><span class="line">    <span class="comment">//是否显示左边组件, 好像无效</span></span><br><span class="line">    <span class="keyword">this</span>.automaticallyImplyLeading = <span class="keyword">true</span>,</span><br><span class="line">    <span class="comment">//是否显示中间组件, 好像无效</span></span><br><span class="line">    <span class="keyword">this</span>.automaticallyImplyMiddle = <span class="keyword">true</span>,</span><br><span class="line">    <span class="comment">//导航栏左侧组件的右边的文本, 好像无效</span></span><br><span class="line">    <span class="keyword">this</span>.previousPageTitle,</span><br><span class="line">    <span class="comment">// 导航栏中间组件</span></span><br><span class="line">    <span class="keyword">this</span>.middle,</span><br><span class="line">    <span class="comment">// 导航栏右侧组件    </span></span><br><span class="line">    <span class="keyword">this</span>.backgroundColor = _kDefaultNavBarBackgroundColor,</span><br><span class="line">    <span class="comment">// 设置左右组件的内边距, EdgeInsetsDirectional</span></span><br><span class="line">    <span class="keyword">this</span>.padding,</span><br><span class="line">    <span class="comment">//左侧默认组件和左侧组件右边文本的颜色</span></span><br><span class="line">    <span class="keyword">this</span>.actionsForegroundColor = CupertinoColors.activeBlue,</span><br><span class="line">    <span class="keyword">this</span>.transitionBetweenRoutes = <span class="keyword">true</span>,</span><br><span class="line">    <span class="keyword">this</span>.heroTag = _defaultHeroTag,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>使用示例</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> CupertinoApp(</span><br><span class="line">  title: <span class="string">&#x27;Cupertino App&#x27;</span>,</span><br><span class="line">  color: Colors.red,</span><br><span class="line">  debugShowCheckedModeBanner: <span class="keyword">false</span>,</span><br><span class="line">  home: CupertinoPageScaffold(</span><br><span class="line">    backgroundColor: Colors.yellow,</span><br><span class="line">    resizeToAvoidBottomInset: <span class="keyword">true</span>,</span><br><span class="line">    navigationBar: CupertinoNavigationBar(</span><br><span class="line">      leading: Icon(Icons.person),</span><br><span class="line">      automaticallyImplyLeading: <span class="keyword">false</span>,</span><br><span class="line">      automaticallyImplyMiddle: <span class="keyword">false</span>,</span><br><span class="line">      previousPageTitle: <span class="string">&#x27;返回&#x27;</span>,</span><br><span class="line">      middle: Text(<span class="string">&#x27;Cupertino App Bar&#x27;</span>),</span><br><span class="line">      trailing: Icon(Icons.money_off),</span><br><span class="line">      border: Border.all(),</span><br><span class="line">      backgroundColor: Colors.white,</span><br><span class="line">      padding: EdgeInsetsDirectional.fromSTEB(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>),</span><br><span class="line">      actionsForegroundColor: Colors.red,</span><br><span class="line">      transitionBetweenRoutes: <span class="keyword">false</span>,</span><br><span class="line">      heroTag: Text(<span class="string">&#x27;data&#x27;</span>),</span><br><span class="line">    ),</span><br><span class="line">    child: Center(</span><br><span class="line">      child: Container(</span><br><span class="line">        child: Text(<span class="string">&#x27;Hello World&#x27;</span>),</span><br><span class="line">      ),</span><br><span class="line">    ),</span><br><span class="line">  ),</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h2 id="Scaffold"><a href="#Scaffold" class="headerlink" title="Scaffold"></a>Scaffold</h2><ul>
<li><code>Scaffold</code>通常被用作<code>MaterialApp</code>的子<code>Widget</code>(安卓风格)，它会填充可用空间，占据整个窗口或设备屏幕</li>
<li><code>Scaffold</code>提供了大多数应用程序都应该具备的功能，例如顶部的<code>appBar</code>，底部的<code>bottomNavigationBar</code>，隐藏的侧边栏<code>drawer</code>等</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Scaffold(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="comment">// 显示在界面顶部的一个AppBar</span></span><br><span class="line">    <span class="keyword">this</span>.appBar,</span><br><span class="line">    <span class="comment">// 当前界面所显示的主要内容Widget</span></span><br><span class="line">    <span class="keyword">this</span>.body,</span><br><span class="line">    <span class="comment">// 悬浮按钮, 默认在右下角位置显示</span></span><br><span class="line">    <span class="keyword">this</span>.floatingActionButton,</span><br><span class="line">    <span class="comment">// 设置悬浮按钮的位置</span></span><br><span class="line">    <span class="keyword">this</span>.floatingActionButtonLocation,</span><br><span class="line">    <span class="comment">// 悬浮按钮出现消失的动画</span></span><br><span class="line">    <span class="keyword">this</span>.floatingActionButtonAnimator,</span><br><span class="line">    <span class="comment">// 在底部呈现一组button，显示于[bottomNavigationBar]之上，[body]之下</span></span><br><span class="line">    <span class="keyword">this</span>.persistentFooterButtons,</span><br><span class="line">    <span class="comment">// 一个垂直面板，显示于左侧，初始处于隐藏状态</span></span><br><span class="line">    <span class="keyword">this</span>.drawer,</span><br><span class="line">    <span class="comment">// 一个垂直面板，显示于右侧，初始处于隐藏状态</span></span><br><span class="line">    <span class="keyword">this</span>.endDrawer,</span><br><span class="line">    <span class="comment">// 出现于底部的一系列水平按钮</span></span><br><span class="line">    <span class="keyword">this</span>.bottomNavigationBar,</span><br><span class="line">    <span class="comment">// 底部的持久化提示框</span></span><br><span class="line">    <span class="keyword">this</span>.bottomSheet,</span><br><span class="line">    <span class="comment">// 背景色</span></span><br><span class="line">    <span class="keyword">this</span>.backgroundColor,</span><br><span class="line">    <span class="comment">// 重新计算布局空间大小</span></span><br><span class="line">    <span class="keyword">this</span>.resizeToAvoidBottomPadding = <span class="keyword">true</span>,</span><br><span class="line">    <span class="comment">// 是否显示到底部, 默认为true将显示到顶部状态栏</span></span><br><span class="line">    <span class="keyword">this</span>.primary = <span class="keyword">true</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="appBar"><a href="#appBar" class="headerlink" title="appBar"></a>appBar</h3><p>设置导航栏, 接受一个抽象类<code>PreferredSizeWidget</code>, 这里使用其子类<code>AppBar</code>进行设置, 后面会详解</p>
<h3 id="floatingActionButton"><a href="#floatingActionButton" class="headerlink" title="floatingActionButton"></a>floatingActionButton</h3><ul>
<li>设置一个悬浮按钮, 默认在右下角位置显示, 这里使用<code>FloatingActionButton</code>设置</li>
<li><code>FloatingActionButton</code>是<code>Material</code>设计规范中的一种特殊<code>Button</code>，通常悬浮在页面的某一个位置作为某种常用动作的快捷入口, 后面会详解</li>
</ul>
<h3 id="floatingActionButtonLocation"><a href="#floatingActionButtonLocation" class="headerlink" title="floatingActionButtonLocation"></a>floatingActionButtonLocation</h3><p>设置悬浮按钮的位置, 接受一个抽象类<code>FloatingActionButtonLocation</code></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 右下角, 距离底部有一点距离, 默认值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> FloatingActionButtonLocation endFloat = _EndFloatFabLocation();</span><br><span class="line"><span class="comment">// 中下方, 距离底部有一点距离</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> FloatingActionButtonLocation centerFloat = _CenterFloatFabLocation();</span><br><span class="line"><span class="comment">// 右下角, 距离底部没有间距</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> FloatingActionButtonLocation endDocked = _EndDockedFloatingActionButtonLocation();</span><br><span class="line"><span class="comment">// 中下方, 距离底部没有间距</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> FloatingActionButtonLocation centerDocked = _CenterDockedFloatingActionButtonLocation();</span><br></pre></td></tr></table></figure>


<h2 id="FloatingActionButton"><a href="#FloatingActionButton" class="headerlink" title="FloatingActionButton"></a>FloatingActionButton</h2><p>在<code>Material Design</code>中，一般用来处理界面中最常用，最基础的用户动作。它一般出现在屏幕内容的前面，通常是一个圆形，中间有一个图标, 有以下几种构造函数</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> FloatingActionButton(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="keyword">this</span>.child,</span><br><span class="line">    <span class="comment">// 文字解释, 按钮呗长按时显示</span></span><br><span class="line">    <span class="keyword">this</span>.tooltip,</span><br><span class="line">    <span class="comment">// 前景色</span></span><br><span class="line">    <span class="keyword">this</span>.foregroundColor,</span><br><span class="line">    <span class="comment">// 背景色</span></span><br><span class="line">    <span class="keyword">this</span>.backgroundColor,</span><br><span class="line">    <span class="comment">// hero效果使用的tag,系统默认会给所有FAB使用同一个tag,方便做动画效果</span></span><br><span class="line">    <span class="keyword">this</span>.heroTag = <span class="keyword">const</span> _DefaultHeroTag(),</span><br><span class="line">    <span class="comment">// 未点击时阴影值，默认6.0</span></span><br><span class="line">    <span class="keyword">this</span>.elevation = <span class="number">6.0</span>,</span><br><span class="line">    <span class="comment">// 点击时阴影值，默认12.0</span></span><br><span class="line">    <span class="keyword">this</span>.highlightElevation = <span class="number">12.0</span>,</span><br><span class="line">    <span class="comment">// 点击事件监听</span></span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.onPressed,</span><br><span class="line">    <span class="comment">// 是否为“mini”类型，默认为false</span></span><br><span class="line">    <span class="keyword">this</span>.mini = <span class="keyword">false</span>,</span><br><span class="line">    <span class="comment">// 设置阴影, 设置shape时，默认的elevation将会失效,默认为CircleBorder</span></span><br><span class="line">    <span class="keyword">this</span>.shape = <span class="keyword">const</span> CircleBorder(),</span><br><span class="line">    <span class="comment">// 剪切样式</span></span><br><span class="line">    <span class="keyword">this</span>.clipBehavior = Clip.none,</span><br><span class="line">    <span class="comment">// 设置点击区域大小的样式, MaterialTapTargetSize的枚举值</span></span><br><span class="line">    <span class="keyword">this</span>.materialTapTargetSize,</span><br><span class="line">    <span class="comment">// 是否为”extended”类型</span></span><br><span class="line">    <span class="keyword">this</span>.isExtended = <span class="keyword">false</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="mini"><a href="#mini" class="headerlink" title="mini"></a>mini</h3><ul>
<li>是否为<code>mini</code>类型，默认为<code>false</code></li>
<li><code>FloatingActionButton</code>分为三种类型：<code>regular</code>, <code>mini</code>, <code>extended</code></li>
<li><code>regular</code>和<code>mini</code>两种类型通过默认的构造方法实现, 只有图片</li>
<li>大小限制如下</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> BoxConstraints _kSizeConstraints = <span class="keyword">const</span> BoxConstraints.tightFor(</span><br><span class="line">  width: <span class="number">56.0</span>,</span><br><span class="line">  height: <span class="number">56.0</span>,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> BoxConstraints _kMiniSizeConstraints = <span class="keyword">const</span> BoxConstraints.tightFor(</span><br><span class="line">  width: <span class="number">40.0</span>,</span><br><span class="line">  height: <span class="number">40.0</span>,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> BoxConstraints _kExtendedSizeConstraints = <span class="keyword">const</span> BoxConstraints(</span><br><span class="line">  minHeight: <span class="number">48.0</span>,</span><br><span class="line">  maxHeight: <span class="number">48.0</span>,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="isExtended"><a href="#isExtended" class="headerlink" title="isExtended"></a>isExtended</h3><ul>
<li>是否为<code>extended</code>类型, 设置为<code>true</code>即可</li>
<li>除此之外, 还可以使用<code>extended</code>构造函数创建该类型</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">FloatingActionButton.extended(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="keyword">this</span>.tooltip,</span><br><span class="line">    <span class="keyword">this</span>.foregroundColor,</span><br><span class="line">    <span class="keyword">this</span>.backgroundColor,</span><br><span class="line">    <span class="keyword">this</span>.heroTag = <span class="keyword">const</span> _DefaultHeroTag(),</span><br><span class="line">    <span class="keyword">this</span>.elevation = <span class="number">6.0</span>,</span><br><span class="line">    <span class="keyword">this</span>.highlightElevation = <span class="number">12.0</span>,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.onPressed,</span><br><span class="line">    <span class="keyword">this</span>.shape = <span class="keyword">const</span> StadiumBorder(),</span><br><span class="line">    <span class="keyword">this</span>.isExtended = <span class="keyword">true</span>,</span><br><span class="line">    <span class="keyword">this</span>.materialTapTargetSize,</span><br><span class="line">    <span class="keyword">this</span>.clipBehavior = Clip.none,</span><br><span class="line">    <span class="comment">// 设置图片</span></span><br><span class="line">    <span class="meta">@required</span> Widget icon,</span><br><span class="line">    <span class="comment">// 设置文字</span></span><br><span class="line">    <span class="meta">@required</span> Widget label,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>从参数上看差异并不大，只是把默认构造方法中的<code>child</code>换成了<code>icon</code>和<code>label</code>，不过通过下面的代码可以看到，传入的<code>label</code>和<code>icon</code>也是用来构建<code>child</code>的，不过使用的是<code>Row</code>来做一层包装而已</p>
<h2 id="AppBar"><a href="#AppBar" class="headerlink" title="AppBar"></a>AppBar</h2><p><code>AppBar</code>是一个<code>Material</code>风格的导航栏，它可以设置标题、导航栏菜单、底部<code>Tab</code>等</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">AppBar(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="comment">// 导航栏左侧weidget</span></span><br><span class="line">    <span class="keyword">this</span>.leading,</span><br><span class="line">    <span class="comment">// 如果leading为null，是否自动实现默认的leading按钮</span></span><br><span class="line">    <span class="keyword">this</span>.automaticallyImplyLeading = <span class="keyword">true</span>,</span><br><span class="line">    <span class="comment">// 导航栏标题</span></span><br><span class="line">    <span class="keyword">this</span>.title,</span><br><span class="line">    <span class="comment">// 导航栏右侧按钮, 接受一个数组</span></span><br><span class="line">    <span class="keyword">this</span>.actions,</span><br><span class="line">    <span class="comment">// 一个显示在AppBar下方的控件，高度和AppBar高度一样，可以实现一些特殊的效果，该属性通常在SliverAppBar中使用</span></span><br><span class="line">    <span class="keyword">this</span>.flexibleSpace,</span><br><span class="line">    <span class="comment">// 一个AppBarBottomWidget对象, 设置TabBar</span></span><br><span class="line">    <span class="keyword">this</span>.bottom,</span><br><span class="line">    <span class="comment">//中控件的z坐标顺序，默认值为4，对于可滚动的SliverAppBar，当 SliverAppBar和内容同级的时候，该值为0，当内容滚动 SliverAppBar 变为 Toolbar 的时候，修改elevation的值</span></span><br><span class="line">    <span class="keyword">this</span>.elevation = <span class="number">4.0</span>,</span><br><span class="line">    <span class="comment">// 背景颜色，默认值为 ThemeData.primaryColor。改值通常和下面的三个属性一起使用</span></span><br><span class="line">    <span class="keyword">this</span>.backgroundColor,</span><br><span class="line">    <span class="comment">// 状态栏的颜色, 黑白两种, 取值: Brightness.dark</span></span><br><span class="line">    <span class="keyword">this</span>.brightness,</span><br><span class="line">    <span class="comment">// 设置导航栏上图标的颜色、透明度、和尺寸信息</span></span><br><span class="line">    <span class="keyword">this</span>.iconTheme,</span><br><span class="line">    <span class="comment">// 设置导航栏上文字样式</span></span><br><span class="line">    <span class="keyword">this</span>.textTheme,</span><br><span class="line">    <span class="comment">// 导航栏的内容是否显示在顶部, 状态栏的下面</span></span><br><span class="line">    <span class="keyword">this</span>.primary = <span class="keyword">true</span>,</span><br><span class="line">    <span class="comment">// 标题是否居中显示，默认值根据不同的操作系统，显示方式不一样</span></span><br><span class="line">    <span class="keyword">this</span>.centerTitle,</span><br><span class="line">    <span class="comment">// 标题间距，如果希望title占用所有可用空间，请将此值设置为0.0</span></span><br><span class="line">    <span class="keyword">this</span>.titleSpacing = NavigationToolbar.kMiddleSpacing,</span><br><span class="line">    <span class="comment">// 应用栏的工具栏部分透明度</span></span><br><span class="line">    <span class="keyword">this</span>.toolbarOpacity = <span class="number">1.0</span>,</span><br><span class="line">    <span class="comment">// 底部导航栏的透明度设置</span></span><br><span class="line">    <span class="keyword">this</span>.bottomOpacity = <span class="number">1.0</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="leading"><a href="#leading" class="headerlink" title="leading"></a>leading</h3><p>导航栏左侧<code>weidget</code></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Widget leading;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line">leading: Icon(Icons.home),</span><br></pre></td></tr></table></figure>

<h3 id="actions"><a href="#actions" class="headerlink" title="actions"></a>actions</h3><p>导航栏右侧按钮, 接受一个数组</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="built_in">List</span>&lt;Widget&gt; actions;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line">actions: &lt;Widget&gt;[</span><br><span class="line">    Icon(Icons.add),</span><br><span class="line">    Icon(Icons.home),</span><br><span class="line">],</span><br></pre></td></tr></table></figure>

<h3 id="brightness"><a href="#brightness" class="headerlink" title="brightness"></a>brightness</h3><p>状态栏的颜色, 黑白两种</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 状态栏白色</span></span><br><span class="line">brightness: Brightness.dark,</span><br><span class="line"><span class="comment">// 状态栏黑色</span></span><br><span class="line">brightness: Brightness.light,</span><br></pre></td></tr></table></figure>

<h3 id="iconTheme"><a href="#iconTheme" class="headerlink" title="iconTheme"></a>iconTheme</h3><p>设置导航栏上图标的颜色、透明度、和尺寸信息</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> IconThemeData(&#123;<span class="keyword">this</span>.color, <span class="built_in">double</span> opacity, <span class="keyword">this</span>.size&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line">iconTheme: IconThemeData(color: Colors.white, opacity: <span class="number">0.56</span>, size: <span class="number">30</span>),</span><br></pre></td></tr></table></figure>


<h2 id="TabBar"><a href="#TabBar" class="headerlink" title="TabBar"></a>TabBar</h2><ul>
<li>在<code>AppBar</code>中通过<code>bottom</code>属性来添加一个导航栏底部<code>tab</code>按钮组, 接受一个<code>PreferredSizeWidget</code>类型</li>
<li><code>PreferredSizeWidget</code>是一个抽象类, 这里我们使用<code>TabBar</code></li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TabBar</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> <span class="keyword">implements</span> <span class="title">PreferredSizeWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> TabBar(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="comment">// 数组,显示的标签内容,一般使用Tab对象,当然也可以是其他的Widget</span></span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.tabs,</span><br><span class="line">    <span class="comment">// TabController对象</span></span><br><span class="line">    <span class="keyword">this</span>.controller,</span><br><span class="line">    <span class="comment">// 是否可滚动</span></span><br><span class="line">    <span class="keyword">this</span>.isScrollable = <span class="keyword">false</span>,</span><br><span class="line">    <span class="comment">// 指示器颜色</span></span><br><span class="line">    <span class="keyword">this</span>.indicatorColor,</span><br><span class="line">    <span class="comment">// 指示器高度</span></span><br><span class="line">    <span class="keyword">this</span>.indicatorWeight = <span class="number">2.0</span>,</span><br><span class="line">    <span class="comment">// 指示器内边距</span></span><br><span class="line">    <span class="keyword">this</span>.indicatorPadding = EdgeInsets.zero,</span><br><span class="line">    <span class="comment">// 设置选中的样式decoration，例如边框等</span></span><br><span class="line">    <span class="keyword">this</span>.indicator,</span><br><span class="line">    <span class="comment">// 指示器大小, 枚举值TabBarIndicatorSize</span></span><br><span class="line">    <span class="keyword">this</span>.indicatorSize,</span><br><span class="line">    <span class="comment">// 选中文字颜色</span></span><br><span class="line">    <span class="keyword">this</span>.labelColor,</span><br><span class="line">    <span class="comment">// 选中文字样式</span></span><br><span class="line">    <span class="keyword">this</span>.labelStyle,</span><br><span class="line">    <span class="comment">// 文字内边距</span></span><br><span class="line">    <span class="keyword">this</span>.labelPadding,</span><br><span class="line">    <span class="comment">// 未选中文字颜色</span></span><br><span class="line">    <span class="keyword">this</span>.unselectedLabelColor,</span><br><span class="line">    <span class="comment">// 未选中文字样式</span></span><br><span class="line">    <span class="keyword">this</span>.unselectedLabelStyle,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tab的构造函数</span></span><br><span class="line"><span class="keyword">const</span> Tab(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="comment">// 文本</span></span><br><span class="line">    <span class="keyword">this</span>.text,</span><br><span class="line">    <span class="comment">// 图标</span></span><br><span class="line">    <span class="keyword">this</span>.icon,</span><br><span class="line">    <span class="comment">// 子widget</span></span><br><span class="line">    <span class="keyword">this</span>.child,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>效果如下</p>
<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/flutter/tabbar_scroll.png" alt="image"></p>
<p>相关代码如下</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) =&gt; runApp(NewApp());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewApp</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  State&lt;StatefulWidget&gt; createState() &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement createState</span></span><br><span class="line">    <span class="keyword">return</span> App();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">NewApp</span>&gt; <span class="title">with</span> <span class="title">SingleTickerProviderStateMixin</span> </span>&#123;</span><br><span class="line">  <span class="built_in">List</span> tabs = [<span class="string">&#x27;语文&#x27;</span>, <span class="string">&#x27;数学&#x27;</span>, <span class="string">&#x27;英语&#x27;</span>, <span class="string">&#x27;政治&#x27;</span>, <span class="string">&#x27;历史&#x27;</span>, <span class="string">&#x27;地理&#x27;</span>, <span class="string">&#x27;物理&#x27;</span>, <span class="string">&#x27;化学&#x27;</span>, <span class="string">&#x27;生物&#x27;</span>];</span><br><span class="line">  TabController _tabController;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    _tabController = TabController(initialIndex: <span class="number">0</span>, length: tabs.length, vsync: <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">        home: Scaffold(</span><br><span class="line">            appBar: AppBar(</span><br><span class="line">              title: Text(<span class="string">&#x27;CoderTitan&#x27;</span>),</span><br><span class="line">              backgroundColor: Colors.blueAccent,</span><br><span class="line">              brightness: Brightness.dark,</span><br><span class="line">              centerTitle: <span class="keyword">true</span>,</span><br><span class="line">              bottom: TabBar(</span><br><span class="line">                controller: _tabController,</span><br><span class="line">                tabs: tabs.map((e) =&gt; Tab(text: e)).toList(),</span><br><span class="line">                isScrollable: <span class="keyword">true</span>,</span><br><span class="line">                indicatorColor: Colors.red,</span><br><span class="line">                indicatorWeight: <span class="number">2</span>,</span><br><span class="line">                indicatorSize: TabBarIndicatorSize.label,</span><br><span class="line">                labelColor: Colors.orange,</span><br><span class="line">                unselectedLabelColor: Colors.white,</span><br><span class="line">                labelStyle: TextStyle(fontSize: <span class="number">18</span>, color: Colors.orange),</span><br><span class="line">                unselectedLabelStyle: TextStyle(fontSize: <span class="number">15</span>, color: Colors.white),</span><br><span class="line">              ),</span><br><span class="line">            ),</span><br><span class="line">            body: TabBarView(</span><br><span class="line">              controller: _tabController,</span><br><span class="line">              children: tabs.map((e) &#123;</span><br><span class="line">                <span class="keyword">return</span> Container(</span><br><span class="line">                  alignment: Alignment.center,</span><br><span class="line">                  child: Text(e, style:TextStyle(fontSize: <span class="number">50</span>)),</span><br><span class="line">                );</span><br><span class="line">              &#125;).toList(),</span><br><span class="line">            ),</span><br><span class="line">        ),</span><br><span class="line">        debugShowCheckedModeBanner: <span class="keyword">false</span>,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="BottomNavigationBar"><a href="#BottomNavigationBar" class="headerlink" title="BottomNavigationBar"></a>BottomNavigationBar</h2><ul>
<li>在<code>Scaffold</code>中有一个属性<code>bottomNavigationBar</code>用于设置最底部的<code>tabbar</code>导航栏</li>
<li>使用<code>Material</code>组件库提供的<code>BottomNavigationBar</code>和<code>BottomNavigationBarItem</code>两个<code>Widget</code>来实现Material风格的底部导航栏</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">BottomNavigationBar(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="comment">// 子widget数组</span></span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.items,</span><br><span class="line">    <span class="comment">// 每一个item的点击事件</span></span><br><span class="line">    <span class="keyword">this</span>.onTap,</span><br><span class="line">    <span class="comment">// 当前选中的索引</span></span><br><span class="line">    <span class="keyword">this</span>.currentIndex = <span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 类型</span></span><br><span class="line">    BottomNavigationBarType type,</span><br><span class="line">    <span class="comment">// 文字颜色</span></span><br><span class="line">    <span class="keyword">this</span>.fixedColor,</span><br><span class="line">    <span class="comment">// 图片大小</span></span><br><span class="line">    <span class="keyword">this</span>.iconSize = <span class="number">24.0</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="items"><a href="#items" class="headerlink" title="items"></a>items</h3><p>包含所有子<code>Widget</code>的数组</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="built_in">List</span>&lt;BottomNavigationBarItem&gt; items;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> BottomNavigationBarItem(&#123;</span><br><span class="line">    <span class="comment">// 未选中图片</span></span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.icon,</span><br><span class="line">    <span class="comment">// 标题</span></span><br><span class="line">    <span class="keyword">this</span>.title,</span><br><span class="line">    <span class="comment">// 选中的图片</span></span><br><span class="line">    Widget activeIcon,</span><br><span class="line">    <span class="comment">// 背景色</span></span><br><span class="line">    <span class="keyword">this</span>.backgroundColor,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>




<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://flutterchina.club/widgets/cupertino/">Cupertino (iOS风格) Widgets</a></li>
<li><a href="https://flutterchina.club/widgets/material/">Material (安卓风格) Widgets</a></li>
<li><a href="https://book.flutterchina.club/chapter5/material_scaffold.html">Scaffold、TabBar和AppBar</a></li>
</ul>
<hr>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
        <tag>Widget</tag>
        <tag>Dart</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter中Widget的生命周期和渲染原理</title>
    <url>/post/f26f2a71.html</url>
    <content><![CDATA[<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/flutter/maxresdefault.png?x-oss-process=style/titanjun" alt="widget"></p>
<span id="more"></span>


<ul>
<li>原文博客地址: <a href="https://www.titanjun.top/Flutter%E4%B8%ADWidget%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86.html">Flutter中Widget的生命周期和渲染原理</a></li>
<li>之前的<a href="https://www.titanjun.top/categories/Flutter%E7%AC%94%E8%AE%B0/"><code>Flutter</code>系列文章</a>中都有介绍一些常用的<code>Widget</code>这里就主要了解<code>Flutter</code>的渲染原理和<code>Widget</code>的生命周期</li>
</ul>
<h2 id="Flutter中Widget的生命周期"><a href="#Flutter中Widget的生命周期" class="headerlink" title="Flutter中Widget的生命周期"></a><code>Flutter</code>中<code>Widget</code>的生命周期</h2><ul>
<li><code>StatelessWidget</code>是通过构造函数(<code>Constructor</code>)接收父<code>Widget</code>直接传入值，然后调用<code>build</code>方法来构建，整个过程非常简单</li>
<li>而<code>StatefulWidget</code>需要通过<code>State</code>来管理其数据，并且还要监控状态的改变决定是否重新<code>build</code>整个<code>Widget</code></li>
<li>这里主要讨论<code>StatefulWidget</code>的生命周期，就是它从创建到显示再到更新最后到销毁的整个过程</li>
<li><code>StatefulWidget</code>本身由两个类组成的：<code>StatefulWidget</code>和<code>State</code></li>
<li>在<code>StatefulWidget</code>中的相关方法主要就是<ul>
<li>执行<code>StatefulWidget</code>的构造函数（<code>Constructor</code>）来创建出<code>StatefulWidget</code></li>
<li>执行<code>StatefulWidget</code>的<code>createState</code>方法，来创建一个维护<code>StatefulWidget</code>的<code>State</code>对象</li>
<li>所以我们探讨<code>StatefulWidget</code>的生命周期, 最终是探讨<code>State</code>的生命周期</li>
</ul>
</li>
<li>那么为什么<code>Flutter</code>在设计的时候, <code>StatefulWidget</code>的<code>build</code>方法要放在<code>State</code>中而不是自身呢<ul>
<li>首先<code>build</code>出来的<code>Widget</code>是需要依赖<code>State</code>中的变量(数据&#x2F;自定义的状态)的</li>
<li><code>Flutter</code>在运行过程中, <code>Widget</code>是不断的创建和销毁的, 当我们自己的状态改变时, 我们只希望刷新当前<code>Widget</code>, 并不希望创建新的<code>State</code></li>
</ul>
</li>
</ul>
<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/flutter/widget_life.jpg" alt="图片来源网络"></p>
<p>上面图片大概列出了<code>StatefulWidget</code>的简单的函数调用过程</p>
<h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><p>调用<code>createState</code>创建<code>State</code>对象时, 执行<code>State</code>类的构造方法（<code>Constructor</code>）来创建<code>State</code>对象</p>
<h3 id="initState"><a href="#initState" class="headerlink" title="initState"></a>initState</h3><ul>
<li><code>initState</code>是<code>StatefulWidget</code>创建完后调用的第一个方法，而且只执行一次</li>
<li>类似于<code>iOS</code>的<code>viewDidLoad</code>，所以在这里<code>View</code>并没有完成渲染</li>
<li>我们可以在这个方法中执行一些数据初始化的操作，或者发送网络请求</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> initState() &#123;</span><br><span class="line">  <span class="comment">// 这里必须调用super的方法</span></span><br><span class="line">  <span class="keyword">super</span>.initState();</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;4. 调用_HomeScreenState----initState&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>这个方法是重写父类的方法，必须调用<code>super</code>，因为父类中会进行一些其他操作</li>
<li>另一点在源码中, 会看到这个方法中有一个<code>mustCallSuper</code>的注解, 这里就限制了必须调用父类的方法</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="meta">@protected</span></span><br><span class="line"><span class="meta">@mustCallSuper</span></span><br><span class="line"><span class="keyword">void</span> initState() &#123;</span><br><span class="line">  <span class="keyword">assert</span>(_debugLifecycleState == _StateLifecycle.created);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="didChangeDependencies"><a href="#didChangeDependencies" class="headerlink" title="didChangeDependencies"></a>didChangeDependencies</h3><ul>
<li><code>didChangeDependencies</code>在整个过程中可能会被调用多次, 但是也只有下面两种情况下会被调用</li>
</ul>
<ol>
<li>在<code>StatefulWidget</code>第一次创建的时候<code>didChangeDependencies</code>会被调用一次, 会在<code>initState</code>方法之后会被立即调用</li>
<li>从其他对象中依赖一些数据发生改变时, 比如所依赖的<code>InheritedWidget</code>状态发生改变时, 也会被调用</li>
</ol>
<h3 id="build"><a href="#build" class="headerlink" title="build"></a>build</h3><ul>
<li><code>build</code>同样也会被调用多次</li>
<li>在上述<code>didChangeDependencies</code>方法被调用之后, 会重新调用<code>build</code>方法, 来看一下我们当前需要重新渲染哪些<code>Widget</code></li>
<li>当每次所依赖的状态发生改变的时候<code>build</code>就会被调用, 所以一般不要将比较好使的操作放在<code> build</code>方法中执行</li>
</ul>
<h3 id="didUpdateWidget"><a href="#didUpdateWidget" class="headerlink" title="didUpdateWidget"></a>didUpdateWidget</h3><p>执行<code>didUpdateWidget</code>方法是在当父<code>Widget</code>触发重建时，系统会调用<code>didUpdateWidget</code>方法</p>
<h3 id="dispose"><a href="#dispose" class="headerlink" title="dispose"></a>dispose</h3><ul>
<li>当前的<code>Widget</code>不再使用时，会调用<code>dispose</code>进行销毁</li>
<li>这时候就可以在<code>dispose</code>里做一些取消监听、动画的操作</li>
<li>到这里, 也就意味着整个生命周期的过程也就结束了</li>
</ul>
<h3 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h3><ul>
<li><code>setState</code>方法可以修改在<code>State</code>中定义的变量</li>
<li>当我们手动调用<code>setState</code>方法，会根据最新的状态（数据）来重新调用<code>build</code>方法，构建对应的<code>Widgets</code></li>
<li><code>setState</code>内部其实是通过调用<code>_element.markNeedsBuild();</code>实现更新<code>Widget</code></li>
</ul>
<p>整个过程的代码如下:</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeScreen</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  HomeScreen() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;1. 调用HomeScreen---constructor&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _HomeScreenState createState() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;2. 调用的HomeScreen---createState&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> _HomeScreenState();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_HomeScreenState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">HomeScreen</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">int</span> _counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  _HomeScreenState() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;3. 调用_HomeScreenState----constructor&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="comment">// 这里必须调用super的方法</span></span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;4. 调用_HomeScreenState----initState&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> didChangeDependencies() &#123;</span><br><span class="line">    <span class="keyword">super</span>.didChangeDependencies();</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;调用_HomeScreenState----didChangeDependencies&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;5. 调用_HomeScreenState----build&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(title: Text(<span class="string">&#x27;生命周期&#x27;</span>, style: TextStyle(fontSize: <span class="number">20</span>))),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: Column(</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            Text(<span class="string">&#x27;当前计数: <span class="subst">$_counter</span>&#x27;</span>, style: TextStyle(fontSize: <span class="number">20</span>),),</span><br><span class="line">            RaisedButton(</span><br><span class="line">              child: Text(<span class="string">&#x27;点击增加计数&#x27;</span>, style: TextStyle(fontSize: <span class="number">20</span>),),</span><br><span class="line">              onPressed: () &#123;</span><br><span class="line">                setState(() &#123;</span><br><span class="line">                  _counter++;</span><br><span class="line">                &#125;);</span><br><span class="line">              &#125;</span><br><span class="line">            )</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;6. 调用_HomeScreenState---dispose&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果如下: </p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">flutter: <span class="number">1.</span> 调用HomeScreen---constructor</span><br><span class="line">flutter: <span class="number">2.</span> 调用的HomeScreen---createState</span><br><span class="line">flutter: <span class="number">3.</span> 调用_HomeScreenState----constructor</span><br><span class="line">flutter: <span class="number">4.</span> 调用_HomeScreenState----initState</span><br><span class="line">flutter: 调用_HomeScreenState----didChangeDependencies</span><br><span class="line">flutter: <span class="number">5.</span> 调用_HomeScreenState----build</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每次调用setState, 都会执行build</span></span><br><span class="line">flutter: <span class="number">5.</span> 调用_HomeScreenState----build</span><br><span class="line">flutter: <span class="number">5.</span> 调用_HomeScreenState----build</span><br></pre></td></tr></table></figure>



<h2 id="Flutter渲染原理"><a href="#Flutter渲染原理" class="headerlink" title="Flutter渲染原理"></a>Flutter渲染原理</h2><p>在<code>Flutter</code>中渲染过程是通过<code>Widget</code>, <code>Element</code>和<code>RenderObject</code>实现的, 下面是<code>FLutter</code>中的三种树结构</p>
<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/flutter/flutter_tree.png?x-oss-process=style/titanjun" alt="Flutter"></p>
<h3 id="Widget"><a href="#Widget" class="headerlink" title="Widget"></a>Widget</h3><p>这是<code>Flutter</code>官网对<a href="https://flutter.dev/docs/development/ui/widgets-intro"><code>Widget</code>的说明</a></p>
<blockquote>
<p>Flutter widgets are built using a modern framework that takes inspiration from React. The central idea is that you build your UI out of widgets. Widgets describe what their view should look like given their current configuration and state. When a widget’s state changes, the widget rebuilds its description, which the framework diffs against the previous description in order to determine the minimal changes needed in the underlying render tree to transition from one state to the next.</p>
</blockquote>
<ul>
<li><code>Flutter</code>的<code>Widgets</code>的灵感来自<code>React</code>，中心思想是使用这些<code>Widgets</code>来搭建自己的UI界面</li>
<li>通过当前<code>Widgets</code>的配置和状态描述这个页面应该展示成什么样子</li>
<li>当一个<code>Widget</code>发生改变时，<code>Widget</code>就会重新<code>build</code>它的描述,框架会和之前的描述进行对比，来决定使用最小的改变在渲染树中，从一个状态到另一个状态</li>
<li>从这段说明中大概意思也就是<ul>
<li><code>Widgets</code>只是页面描述层面的, 并不涉及渲染层面的东西, 而且如果所依赖的配置和状态发生变化的时候, 该<code>Widgets</code>会重新<code>build</code></li>
<li>而对于渲染对象来说, 只会使用最小的开销重新渲染发生改变的部分而不是全部重新渲染</li>
</ul>
</li>
<li><code>Widget Tree</code>树结构<ul>
<li>在整个<code>Flutter</code>项目结构也是由很多个<code>Widget</code>构成的, 本质上就是一个<code>Widget Tree</code></li>
<li>在上面的类似<code>Widget Tree</code>结构中, 很可能会有大量的<code>Widget</code>在树结构中存在引用关系, 而且每个<code>Widget</code>所依赖的配置和状态发生改变的时候, <code>Widget</code>都会重新<code>build</code>, <code>Widget</code>会被不断的销毁和重建，那么意味着这棵树非常不稳定</li>
<li>所以<code>Flutter Engin</code>也不可能直接把<code>Widget</code>渲染到界面上, 这事极其损耗性能的, 所以在渲染层面<code>Flutter</code>引用了另外一个树结构<code>RenderObject Tree</code></li>
</ul>
</li>
</ul>
<h3 id="RenderObject"><a href="#RenderObject" class="headerlink" title="RenderObject"></a>RenderObject</h3><p>下面是<code>Flutter</code>官网对<a href="https://api.flutter.dev/flutter/rendering/RenderObject-class.html"><code>RenderObject</code>的说明</a></p>
<blockquote>
<p>An object in the render tree.</p>
</blockquote>
<blockquote>
<p>The RenderObject class hierarchy is the core of the rendering library’s reason for being.</p>
</blockquote>
<blockquote>
<p>RenderObjects have a parent, and have a slot called parentData in which the parent RenderObject can store child-specific data, for example, the child position. The RenderObject class also implements the basic layout and paint protocols.</p>
</blockquote>
<ul>
<li>每一个<code>RenderObject</code>都是渲染树上的一个对象</li>
<li><code>RenderObject</code>层是渲染库的核心, 最终<code>Flutter Engin</code>是把<code>RenderObject</code>真正渲染到界面上的</li>
<li><code>RenderObject Tree</code><ul>
<li>在渲染过程中, 最终都会把<code>Widget</code>转成<code>RenderObject</code>, <code>Flutter</code>最后在解析的时候解析的也是我们的<code>RenderObject Tree</code>, 但是并不是每一个<code>Widget</code>都会有一个与之对应的<code>RenderObject</code></li>
<li>因为很多的Widget都不是壳渲染的Widget, 而是类似于一个盒子的东西, 对其他Widget进行包装的作用</li>
</ul>
</li>
</ul>
<h3 id="Element"><a href="#Element" class="headerlink" title="Element"></a>Element</h3><p>下面是<code>Flutter</code>官网对<a href="https://api.flutter.dev/flutter/widgets/Element-class.html"><code>Element</code>的说明</a></p>
<blockquote>
<p>An instantiation of a Widget at a particular location in the tree.</p>
</blockquote>
<blockquote>
<p>Widgets describe how to configure a subtree but the same widget can be used to configure multiple subtrees simultaneously because widgets are immutable. An Element represents the use of a widget to configure a specific location in the tree. Over time, the widget associated with a given element can change, for example, if the parent widget rebuilds and creates a new widget for this location.</p>
</blockquote>
<blockquote>
<p>Elements form a tree. Most elements have a unique child, but some widgets (e.g., subclasses of RenderObjectElement) can have multiple children.</p>
</blockquote>
<ul>
<li><code>Element</code>是<code>Widget</code>在树中具有特定位置的是实例化</li>
<li><code>Widget</code>描述如何配置子树和当前页面的展示样式, 每一个<code>Element</code>代表了在<code>Element Tree</code>中的特定位置</li>
<li>如果<code>Widget</code>所依赖的配置和状态发生改变的时候, 和<code>Element</code>关联的<code>Widget</code>是会发生改变的, 但是<code>Element</code>的特定位置是不会发生改变的</li>
<li><code>Element Tree</code>中的每一个<code>Element</code>是和<code>Widget Tree</code>中的每一个<code>Widget</code>一一对应的<ul>
<li><code>Element Tree</code>类似于<code>HTML</code>中的虚拟<code>DOM</code>, 用于判断和决定哪些<code>RenderObject</code>是需要更新的</li>
<li>当<code>Widget Tree</code>所依赖的状态发生改变(更新或者重新创建<code>Widget</code>)的时候, <code>Element</code>根据拿到之前所保存的旧的<code>Widget</code>和新的<code>Widget</code>做一个对比, 判断两者的<code>Key</code>和类型是否是相同的, 相同的就不需要重新创建, 有需要的话, 只需要更新对应的属性即可</li>
</ul>
</li>
</ul>
<h2 id="对象的创建过程"><a href="#对象的创建过程" class="headerlink" title="对象的创建过程"></a>对象的创建过程</h2><h3 id="Widget-1"><a href="#Widget-1" class="headerlink" title="Widget"></a>Widget</h3><ul>
<li>在<code>Flutter</code>中<code>Widget</code>有可渲染的和不可渲染的(组件<code>Widget</code>)<ul>
<li>组件<code>Widget</code>: 类似<code>Container</code>….等等</li>
<li>可渲染<code>Widget</code>: 类似<code>Padding</code>…..等等</li>
</ul>
</li>
<li>下面我们先看一下组件<code>Widget</code>(<code>Container</code>)的实现过程和继承关系</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 继承关系Container --&gt; StatelessWidget --&gt; Widget</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Container</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">StatelessWidget</span> <span class="keyword">extends</span> <span class="title">Widget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  StatelessElement createElement() =&gt; StatelessElement(<span class="keyword">this</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  Widget build(BuildContext context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>从上面的代码可以看到, 继承关系比较简单, 并没有创建<code>RenderObject</code>对象</li>
<li>我们经常使用<code>StatelessWidget</code>和<code>StatefulWidget</code>，这种<code>Widget</code>只是将其他的<code>Widget</code>在<code>build</code>方法中组装起来，并不是一个真正可以渲染的<code>Widget</code></li>
</ul>
<h3 id="RenderObject-1"><a href="#RenderObject-1" class="headerlink" title="RenderObject"></a>RenderObject</h3><p>这里来看一下可渲染<code>Widget</code>的继承关系和相关源代码, 这里以<code>Padding</code>为例</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 继承关系: Padding --&gt; SingleChildRenderObjectWidget --&gt; RenderObjectWidget --&gt; Widget</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Padding</span> <span class="keyword">extends</span> <span class="title">SingleChildRenderObjectWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  RenderPadding createRenderObject(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> RenderPadding(</span><br><span class="line">      padding: padding,</span><br><span class="line">      textDirection: Directionality.of(context),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> updateRenderObject(BuildContext context, RenderPadding renderObject) &#123;</span><br><span class="line">    renderObject</span><br><span class="line">      ..padding = padding</span><br><span class="line">      ..textDirection = Directionality.of(context);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleChildRenderObjectWidget</span> <span class="keyword">extends</span> <span class="title">RenderObjectWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  SingleChildRenderObjectElement createElement() =&gt; SingleChildRenderObjectElement(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RenderObjectWidget</span> <span class="keyword">extends</span> <span class="title">Widget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  RenderObjectElement createElement();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  RenderObject createRenderObject(BuildContext context);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  <span class="keyword">void</span> updateRenderObject(BuildContext context, <span class="keyword">covariant</span> RenderObject renderObject) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  <span class="keyword">void</span> didUnmountRenderObject(<span class="keyword">covariant</span> RenderObject renderObject) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在<code>Padding</code>的类中，我们找不到任何和渲染相关的代码，这是因为Padding仅仅作为一个配置信息，这个配置信息会随着我们设置的属性不同，频繁的销毁和创建</li>
<li>所以真正的渲染相关的代码那就只能在<code>RenderObject</code>里面了</li>
<li>上面代码中, 在<code>Padding</code>类里面有一个核心方法<code>createRenderObject</code>是用于创建一个<code>RenderObject</code>的</li>
<li>而且方法<code>createRenderObject</code>是来源于<code>RenderObjectWidget</code>这个抽象类里面的一个抽象方法</li>
<li>抽象方法是必须被子类实现的，但是它的子类<code>SingleChildRenderObjectWidget</code>也是一个抽象类，所以可以不实现父类的抽象方法</li>
<li>但是<code>Padding</code>不是一个抽象类，必须在这里实现对应的抽象方法，而它的实现就是下面的实现</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里目的是为了创建一个RenderPadding</span></span><br><span class="line">RenderPadding createRenderObject(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> RenderPadding(</span><br><span class="line">      padding: padding,</span><br><span class="line">      textDirection: Directionality.of(context),</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码中, 最终是创建了一个<code>RenderPadding</code>, 而这个<code>RenderPadding</code>又是什么呢? 下面看看他的继承关系和相关源代码</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 继承关系: RenderPadding --&gt; RenderShiftedBox --&gt; RenderBox --&gt; RenderObject</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RenderPadding</span> <span class="keyword">extends</span> <span class="title">RenderShiftedBox</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RenderShiftedBox</span> <span class="keyword">extends</span> <span class="title">RenderBox</span> <span class="title">with</span> <span class="title">RenderObjectWithChildMixin</span>&lt;<span class="title">RenderBox</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RenderBox</span> <span class="keyword">extends</span> <span class="title">RenderObject</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p><code>RenderObject</code>又是如何实现布局和渲染的呢</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当外面修改padding时</span></span><br><span class="line">RenderPadding createRenderObject(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> RenderPadding(</span><br><span class="line">      padding: padding,</span><br><span class="line">      textDirection: Directionality.of(context),</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RenderPadding类里面会调用padding属性的set方法</span></span><br><span class="line"><span class="keyword">set</span> padding(EdgeInsetsGeometry value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (_padding == value)</span><br><span class="line">      <span class="comment">// 如果传过来的值和之前的一样, 就不会被重新渲染, 直接return</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    _padding = value;</span><br><span class="line">    _markNeedResolution();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部会调用markNeedsLayout</span></span><br><span class="line"><span class="keyword">void</span> _markNeedResolution() &#123;</span><br><span class="line">    _resolvedPadding = <span class="keyword">null</span>;</span><br><span class="line">    markNeedsLayout();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里是RenderObject里面的一些核心方法</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RenderObject</span> <span class="keyword">extends</span> <span class="title">AbstractNode</span> <span class="title">with</span> <span class="title">DiagnosticableTreeMixin</span> <span class="keyword">implements</span> <span class="title">HitTestTarget</span> </span>&#123;</span><br><span class="line">  <span class="comment">// markNeedsLayout是RenderObject类里面的方法</span></span><br><span class="line">  <span class="comment">// markNeedsLayout的目的就是标记在下一帧绘制时，需要重新布局performLayout</span></span><br><span class="line">  <span class="keyword">void</span> markNeedsLayout() &#123;</span><br><span class="line">    <span class="keyword">if</span> (_needsLayout) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (_relayoutBoundary != <span class="keyword">this</span>) &#123;</span><br><span class="line">      markParentNeedsLayout();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      _needsLayout = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">if</span> (owner != <span class="keyword">null</span>) &#123;</span><br><span class="line">        owner._nodesNeedingLayout.add(<span class="keyword">this</span>);</span><br><span class="line">        owner.requestVisualUpdate();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">  <span class="keyword">void</span> layout(Constraints constraints, &#123; <span class="built_in">bool</span> parentUsesSize = <span class="keyword">false</span> &#125;) &#123;</span><br><span class="line">    RenderObject relayoutBoundary;</span><br><span class="line">    <span class="keyword">if</span> (!parentUsesSize || sizedByParent || constraints.isTight || parent <span class="keyword">is</span>! RenderObject) &#123;</span><br><span class="line">      relayoutBoundary = <span class="keyword">this</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      relayoutBoundary = (parent <span class="keyword">as</span> RenderObject)._relayoutBoundary;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!_needsLayout &amp;&amp; constraints == _constraints &amp;&amp; relayoutBoundary == _relayoutBoundary) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _constraints = constraints;</span><br><span class="line">    <span class="keyword">if</span> (_relayoutBoundary != <span class="keyword">null</span> &amp;&amp; relayoutBoundary != _relayoutBoundary) &#123;</span><br><span class="line">      visitChildren(_cleanChildRelayoutBoundary);</span><br><span class="line">    &#125;</span><br><span class="line">    _relayoutBoundary = relayoutBoundary;</span><br><span class="line">    <span class="keyword">if</span> (sizedByParent) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        performResize();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e, stack) &#123;</span><br><span class="line">        _debugReportException(<span class="string">&#x27;performResize&#x27;</span>, e, stack);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    RenderObject debugPreviousActiveLayout;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      performLayout();</span><br><span class="line">      markNeedsSemanticsUpdate();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e, stack) &#123;</span><br><span class="line">      _debugReportException(<span class="string">&#x27;performLayout&#x27;</span>, e, stack);</span><br><span class="line">    &#125;</span><br><span class="line">    _needsLayout = <span class="keyword">false</span>;</span><br><span class="line">    markNeedsPaint();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// RenderObject还有一个可被子类重写的paint方法</span></span><br><span class="line">  <span class="keyword">void</span> paint(PaintingContext context, Offset offset) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="Element-1"><a href="#Element-1" class="headerlink" title="Element"></a>Element</h3><ul>
<li>在上面介绍<code>Widget</code>中提到过我们写的大量的<code>Widget</code>在树结构中存在引用关系，但是<code>Widget</code>会被不断的销毁和重建，那么意味着这棵树非常不稳定</li>
<li>如果<code>Widget</code>所依赖的配置和状态发生改变的时候, 和<code>Element</code>关联的<code>Widget</code>是会发生改变的, 但是<code>Element</code>的特定位置是不会发生改变的</li>
<li><code>Element</code>是<code>Widget</code>在树中具有特定位置的是实例化, 是维系整个<code>Flutter</code>应用程序的树形结构的稳定</li>
<li>接下来看下<code>Element</code>是如何被创建和引用的, 这里还是以<code>Container</code>和<code>Padding</code>为例</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在Container的父类StatelessWidget中, 实例化了其父类的一个抽象方法</span></span><br><span class="line"><span class="comment">// 继承关系: StatelessElement --&gt; ComponentElement --&gt; Element</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">StatelessWidget</span> <span class="keyword">extends</span> <span class="title">Widget</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 实例化父类的抽象方法, 并把当前Widget作为参数传入了(this)</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  StatelessElement createElement() =&gt; StatelessElement(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在Padding的父类SingleChildRenderObjectWidget中, 实例化了其父类的一个抽象方法</span></span><br><span class="line"><span class="comment">// 继承关系: SingleChildRenderObjectElement --&gt; RenderObjectElement --&gt; Element</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleChildRenderObjectWidget</span> <span class="keyword">extends</span> <span class="title">RenderObjectWidget</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 实例化父类的抽象方法, 并把当前Widget作为参数传入了(this)</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  SingleChildRenderObjectElement createElement() =&gt; SingleChildRenderObjectElement(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在每一次创建<code>Widget</code>的时候，会创建一个对应的<code>Element</code>，然后将该元素插入树中</li>
<li>上面代码<code>SingleChildRenderObjectWidget</code>实例化了父类的抽象方法<code>createElement</code>创建一个<code>Element</code>, 并把当前<code>Widget(this)</code>作为<code>SingleChildRenderObjectElement</code>构造方法的参数传入</li>
<li>这也就意味着创建出来的<code>Element</code>保存了对当前<code>Widget</code>的引用</li>
<li>在创建完一个<code>Element</code>之后，<code>Framework</code>会调用<code>mount</code>方法来将<code>Element</code>插入到树中具体的位置</li>
<li>这是在<code>Element</code>类中的<code>mount</code>方法, 这里主要的作用就是把自己做一个挂载操作</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">Add this element to the tree in the given slot of the given parent.</span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">The framework calls this function when a newly created element is added to</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">the tree for the first time. Use this method to initialize state that</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">depends on having a parent. State that is independent of the parent can</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">more easily be initialized in the constructor.</span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">This method transitions the element from the &quot;initial&quot; lifecycle state to</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">the &quot;active&quot; lifecycle state.</span></span></span><br><span class="line"><span class="meta">@mustCallSuper</span></span><br><span class="line"><span class="keyword">void</span> mount(<span class="built_in">Element</span> parent, <span class="built_in">dynamic</span> newSlot) &#123;</span><br><span class="line">  _parent = parent;</span><br><span class="line">  _slot = newSlot;</span><br><span class="line">  _depth = _parent != <span class="keyword">null</span> ? _parent.depth + <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">  _active = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (parent != <span class="keyword">null</span>) <span class="comment">// Only assign ownership if the parent is non-null</span></span><br><span class="line">    _owner = parent.owner;</span><br><span class="line">  <span class="keyword">final</span> Key key = widget.key;</span><br><span class="line">  <span class="keyword">if</span> (key <span class="keyword">is</span> GlobalKey) &#123;</span><br><span class="line">    key._register(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  _updateInheritance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="StatelessElement"><a href="#StatelessElement" class="headerlink" title="StatelessElement"></a>StatelessElement</h3><p><code>Container</code>创建出来的是<code>StatelessElement</code>, 下面我们探索一下<code>StatelessElement</code>创建完成后, <code>framework</code>调用<code>mount</code>方法的过程, 这里只留下了相关核心代码</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ComponentElement</span> <span class="keyword">extends</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> mount(<span class="built_in">Element</span> parent, <span class="built_in">dynamic</span> newSlot) &#123;</span><br><span class="line">    <span class="keyword">super</span>.mount(parent, newSlot);</span><br><span class="line">    </span><br><span class="line">    _firstBuild();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _firstBuild() &#123;</span><br><span class="line">    rebuild();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> performRebuild() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!kReleaseMode &amp;&amp; debugProfileBuildsEnabled)</span><br><span class="line">      Timeline.startSync(<span class="string">&#x27;<span class="subst">$&#123;widget.runtimeType&#125;</span>&#x27;</span>,  arguments: timelineWhitelistArguments);</span><br><span class="line"></span><br><span class="line">    Widget built;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 这里调用的build方法, 当前类也没有实现, 所以还是只能到调用者(子类里面找该方法的实现)</span></span><br><span class="line">      built = build();</span><br><span class="line">      debugWidgetBuilderValue(widget, built);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e, stack) &#123;</span><br><span class="line">      _debugDoingBuild = <span class="keyword">false</span>;</span><br><span class="line">      </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      _dirty = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      _child = updateChild(_child, built, slot);</span><br><span class="line">      </span><br><span class="line">    &#125; <span class="keyword">catch</span> (e, stack) &#123;</span><br><span class="line">      </span><br><span class="line">      _child = updateChild(<span class="keyword">null</span>, built, slot);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!kReleaseMode &amp;&amp; debugProfileBuildsEnabled)</span><br><span class="line">      Timeline.finishSync();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  Widget build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Element</span> <span class="keyword">extends</span> <span class="title">DiagnosticableTree</span> <span class="keyword">implements</span> <span class="title">BuildContext</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 构造方法, 接收一个widget参数</span></span><br><span class="line">  <span class="built_in">Element</span>(Widget widget)</span><br><span class="line">    : <span class="keyword">assert</span>(widget != <span class="keyword">null</span>),</span><br><span class="line">      _widget = widget;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget <span class="keyword">get</span> widget =&gt; _widget;</span><br><span class="line">  Widget _widget;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">void</span> rebuild() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_active || !_dirty)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">      </span><br><span class="line">    <span class="built_in">Element</span> debugPreviousBuildTarget;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里调用的performRebuild方法, 在当前类并没有实现, 只能去自己的类里面查找实现</span></span><br><span class="line">    performRebuild();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">Called by rebuild() after the appropriate checks have been made.</span></span></span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  <span class="keyword">void</span> performRebuild();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StatelessElement</span> <span class="keyword">extends</span> <span class="title">ComponentElement</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 这里的widget就是之前StatelessWidget中调用createElement创建element时传过来的this(widget)</span></span><br><span class="line">  StatelessElement(StatelessWidget widget) : <span class="keyword">super</span>(widget);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  StatelessWidget <span class="keyword">get</span> widget =&gt; <span class="keyword">super</span>.widget <span class="keyword">as</span> StatelessWidget;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里的build方法就是拿到当前的widget, 并且调用自己的build方法</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build() =&gt; widget.build(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>上面的代码看着有点乱, 下面就理一下</p>
<ol>
<li>这里我们创建的是<code>StatelessElement</code>, 在创建完一个<code>Element</code>之后，<code>Framework</code>会调用<code>mount</code>方法</li>
<li>在<code>ComponentElement</code>类中重写了<code>mount</code>方法, 所以<code>framwork</code>会调用这里的<code>mount</code>方法</li>
<li>在<code>mount</code>方法中直接调用的<code>_firstBuild</code>方法(第一次构建)</li>
<li>在<code>_firstBuild</code>方法又是直接调用的<code>rebuild</code>方法(重新构建)</li>
<li>然而在<code>ComponentElement</code>类中没有重写<code>rebuild</code>方法, 所以还是要调用父类的<code>rebuild</code>方法</li>
<li>在<code>rebuild</code>方法会调用<code>performRebuild</code>方法, 而且是调用<code>ComponentElement</code>内重写的<code>performRebuild</code>方法</li>
<li>在<code>performRebuild</code>方法内, 会调用<code>build</code>方法, 并用<code>Widget</code>类型的<code>build</code>接收返回值</li>
<li>而这个<code>build</code>方法在<code>StatelessElement</code>中的实现如下</li>
<li>也就是说, 在创建<code>Element</code>之后, 创建出来的<code>elment</code>会拿到传过来的<code>widget</code>, 然后调用<code>widget</code>自己的<code>build</code>方法, 这也就是为什么所有的<code>Widget</code>创建出来之后都会调用<code>build</code>方法的原因</li>
</ol>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Widget build() =&gt; widget.build(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>所以在<code>StatelessElement</code>调用<code>mount</code>烦恼歌发最主要的作用就是挂在之后调用<code>_firstBuild</code>方法, 最终通过<code>widget</code>调用对应<code>widget</code>的<code>build</code>方法构建更多的东西</p>
</blockquote>
<h3 id="RenderObjectElement"><a href="#RenderObjectElement" class="headerlink" title="RenderObjectElement"></a>RenderObjectElement</h3><ul>
<li>下面看一下可渲染的<code>Widget</code>又是如何创建<code>Element</code>的, 这里还是以<code>Padding</code>为例</li>
<li>之前有提到<code>Padding</code>是继承自<code>SingleChildRenderObjectWidget</code>的, 而<code>createElement</code>方法也是在这个类中被实现的</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleChildRenderObjectWidget</span> <span class="keyword">extends</span> <span class="title">RenderObjectWidget</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 这里是创建了一个SingleChildRenderObjectElement对象</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  SingleChildRenderObjectElement createElement() =&gt; SingleChildRenderObjectElement(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>上面的代码中<code>Padding</code>是通过父类创建了一个<code>SingleChildRenderObjectElement</code>对象</li>
<li><code>SingleChildRenderObjectElement</code>是继承自<code>RenderObjectElement</code></li>
<li><code>RenderObjectElement</code>继承自<code>Element</code></li>
<li>接下来就是看一下<code>mount</code>方法的调用过程</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">以下源码并不全, 这里只是拷贝了一些核心方法和相关源码</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleChildRenderObjectElement</span> <span class="keyword">extends</span> <span class="title">RenderObjectElement</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 同样构造函数接收一个widget参数</span></span><br><span class="line">  SingleChildRenderObjectElement(SingleChildRenderObjectWidget widget) : <span class="keyword">super</span>(widget);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  SingleChildRenderObjectWidget <span class="keyword">get</span> widget =&gt; <span class="keyword">super</span>.widget <span class="keyword">as</span> SingleChildRenderObjectWidget;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> mount(<span class="built_in">Element</span> parent, <span class="built_in">dynamic</span> newSlot) &#123;</span><br><span class="line">    <span class="keyword">super</span>.mount(parent, newSlot);</span><br><span class="line">    _child = updateChild(_child, widget.child, <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// RenderObjectElement类的相关实现</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RenderObjectElement</span> <span class="keyword">extends</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 构造函数接收一个widget参数</span></span><br><span class="line">  RenderObjectElement(RenderObjectWidget widget) : <span class="keyword">super</span>(widget);</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  RenderObjectWidget <span class="keyword">get</span> widget =&gt; <span class="keyword">super</span>.widget <span class="keyword">as</span> RenderObjectWidget;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">创建一个RenderObject类型的变量</span></span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  RenderObject <span class="keyword">get</span> renderObject =&gt; _renderObject;</span><br><span class="line">  RenderObject _renderObject;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> mount(<span class="built_in">Element</span> parent, <span class="built_in">dynamic</span> newSlot) &#123;</span><br><span class="line">    <span class="keyword">super</span>.mount(parent, newSlot);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在这里通过传过来的widget调用createRenderObject创建一个_renderObject</span></span><br><span class="line">    _renderObject = widget.createRenderObject(<span class="keyword">this</span>);</span><br><span class="line">    _dirty = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>从上面的代码看<code>SingleChildRenderObjectElement</code>类中的<code>mount</code>方法核心是调用父类(<code>RenderObjectElement</code>)的<code>mount</code>方法</li>
<li>而<code>RenderObjectElement</code>中的<code>mount</code>方法, 主要就是通过<code>widget</code>调用它的<code>createRenderObject</code>方法创建一个<code>renderObject</code></li>
<li>所以对于<code>RenderObjectElement</code>来说, <code>fromework</code>调用<code>mount</code>方法, 其目的就是为了创建<code>renderObject</code></li>
<li>这也就意味着<code>Element</code>对<code>_renderObject</code>也会有一个引用</li>
<li>也就是说<code>Element</code>不但对<code>_widget</code>有一个引用, 对<code>_renderObject</code>也会有一个引用</li>
</ul>
<h3 id="StatefulElement"><a href="#StatefulElement" class="headerlink" title="StatefulElement"></a>StatefulElement</h3><ul>
<li>上面提到<code>StatefulWidget</code>是由两部分构成的<code>StatefulWidget</code>的<code>State</code></li>
<li>而<code>StatefulWidget</code>是通过<code>createState</code>方法，来创建一个维护<code>StatefulWidget</code>的<code>State</code>对象</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StatefulElement</span> <span class="keyword">extends</span> <span class="title">ComponentElement</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="language-markdown">构造函数</span></span></span><br><span class="line">  StatefulElement(StatefulWidget widget)</span><br><span class="line">      : _state = widget.createState(),</span><br><span class="line">        <span class="keyword">super</span>(widget) &#123;</span><br><span class="line">    </span><br><span class="line">    _state._element = <span class="keyword">this</span>;</span><br><span class="line">    </span><br><span class="line">    _state._widget = widget;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  State&lt;StatefulWidget&gt; <span class="keyword">get</span> state =&gt; _state;</span><br><span class="line">  State&lt;StatefulWidget&gt; _state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在<code>StatefulElement</code>内定义了一个<code>_state</code>变量, 并且存在对<code>_widget</code>的引用</li>
<li>而在<code>StatefulElement</code>的构造方法中, 直接通过参数<code>widget</code>调用其内部的<code>createState</code>方法, 这个是<code>StatefulWidget</code>中的一个抽象方法(子类必须实现), 相信这个方法都比较熟悉</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeScreen</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  HomeScreen() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;1. 调用HomeScreen---constructor&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _HomeScreenState createState() &#123;</span><br><span class="line">    <span class="keyword">return</span> _HomeScreenState();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_HomeScreenState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">HomeScreen</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Container()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>StatefulElement</code>创建完成之后, <code>fromework</code>就会调用<code>mount</code>方法挂载, 这个过程就和上面<code>StatelessElement</code>中的<code>mount</code>方法的调用过程基本一样了</li>
<li>两者不同的是:<ul>
<li><code>StatelessElement</code>中最后是通过<code>widget</code>调用<code>widget.build(this)</code>方法</li>
<li><code>StatefulElement</code>中最后是通过<code>_state</code>调用<code>_state.build(this)</code>方法, 也就是上面<code>_HomeScreenState</code>的<code>build</code>方法</li>
</ul>
</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line">Widget build() =&gt; _state.build(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>


<h3 id="BuildContext"><a href="#BuildContext" class="headerlink" title="BuildContext"></a>BuildContext</h3><p>上面多次提到的<code>build</code>方法是有参数的, 而且不管是<code>StatelessWidget</code>还是<code>State</code>, 他们<code>build</code>方法的参数都是<code>BuildContext</code></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// StatelessWidget</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">StatelessWidget</span> <span class="keyword">extends</span> <span class="title">Widget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  Widget build(BuildContext context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// State</span></span><br><span class="line"><span class="meta">@optionalTypeArgs</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">State</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span>&gt; <span class="title">with</span> <span class="title">Diagnosticable</span> </span>&#123;</span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  Widget build(BuildContext context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>ComponentElement</code>创建完成之后, 会调用<code>mount</code>方法, 最终都会调用对应的<code>build</code>方法</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StatelessElement</span> <span class="keyword">extends</span> <span class="title">ComponentElement</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build() =&gt; widget.build(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StatefulElement</span> <span class="keyword">extends</span> <span class="title">ComponentElement</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build() =&gt; _state.build(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>上面的<code>build</code>方法传入的参数都是<code>Element</code>, 所以本质上<code>BuildContext</code>就是当前的<code>Element</code></li>
<li><code>BuildContext</code>主要的作用就是知道我当前构建的这个<code>Widget</code>在这个<code>Element Tree</code>上面的位置信息, 之后就可以沿着这这个<code>Tree</code>喜爱那个上查找相关的信息</li>
<li>下面是两者的继承关系</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Element</span> <span class="keyword">extends</span> <span class="title">DiagnosticableTree</span> <span class="keyword">implements</span> <span class="title">BuildContext</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><h4 id="StatelessElement-1"><a href="#StatelessElement-1" class="headerlink" title="StatelessElement"></a>StatelessElement</h4><ul>
<li>在<code>Widget</code>创建出来之后, <code>Flutter</code>框架一定会根据这个<code>Widget</code>创建出一个对应的<code>Element</code>, 每一个<code>Widget</code>都有一个与之对应的<code>Element</code></li>
<li><code>Element</code>对对当前<code>Widget</code>产生一个引用<code>_widget</code></li>
<li><code>element</code>创建完成后, <code>fromework</code>会调用<code>mount</code>方法, 最终调用<code>_widget.build(this)</code>方法</li>
</ul>
<h4 id="StatefulElement-1"><a href="#StatefulElement-1" class="headerlink" title="StatefulElement"></a>StatefulElement</h4><ul>
<li>在<code>Widget</code>创建出来之后, <code>Flutter</code>框架一定会根据这个<code>Widget</code>创建出一个对应的<code>Element</code>, 每一个<code>Widget</code>都有一个与之对应的<code>Element</code></li>
<li>在<code>StatefulElement</code>构造函数中会调用<code>widget.createState()</code>创建一个<code>_state</code>, 并引用<code>_state</code></li>
<li>并且会把<code>widget</code>赋值给<code>_state</code>的一个引用<code>_widget</code>: <code>_state._widget = widget;</code>, 这样在<code>State</code>类中就可以通过<code>this.state</code>拿到当前的<code>Widget</code></li>
<li><code>element</code>创建完成后, <code>fromework</code>会调用<code>mount</code>方法, 最终调用<code>_state.build(this)</code>方法</li>
</ul>
<h4 id="RenderObjectElement-1"><a href="#RenderObjectElement-1" class="headerlink" title="RenderObjectElement"></a>RenderObjectElement</h4><ul>
<li>在<code>Widget</code>创建出来之后, <code>Flutter</code>框架一定会根据这个<code>Widget</code>创建出一个对应的<code>Element</code>, 每一个<code>Widget</code>都有一个与之对应的<code>Element</code></li>
<li><code>element</code>创建完成后, <code>fromework</code>会调用<code>mount</code>方法, 在<code>mount</code>方法中会通过<code>widget</code>调用<code>widget.createRenderObject(this)</code>创建一个<code>renderObject</code>, 并赋值给<code>_renderObject</code></li>
<li>所以创建的<code>RenderObjectElement</code>对象也会对<code>RenderObject</code>产生一个引用</li>
</ul>
<h2 id="Widget的key"><a href="#Widget的key" class="headerlink" title="Widget的key"></a>Widget的key</h2><p>我们之前创建的每一个<code>Widget</code>, 在其构造方法中我们都会看到一个参数<code>Key</code>, name这个<code>Key</code>到底有何作用又何时使用呢</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Scaffold(&#123; Key key, ... &#125;)</span><br><span class="line"><span class="keyword">const</span> Container(&#123; Key key, ... &#125;)</span><br><span class="line"><span class="keyword">const</span> Text(&#123; Key key, ... &#125;)</span><br></pre></td></tr></table></figure>

<p>我们先看一个示例需求代码如下: 希望每次点击删除按钮删除数组的元素后, <code>ListView</code>中其他<code>item</code>的展示信息不变(包括颜色和字体)</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_HomeScreenState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">HomeScreen</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; names = [<span class="string">&quot;111111&quot;</span>, <span class="string">&quot;222222&quot;</span>, <span class="string">&quot;333333&quot;</span>];</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">&quot;Key Demo&quot;</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: ListView(</span><br><span class="line">        children: names.map((name) &#123;</span><br><span class="line">          <span class="keyword">return</span> ListItemLess(name);</span><br><span class="line">        &#125;).toList(),</span><br><span class="line">      ),</span><br><span class="line"></span><br><span class="line">      floatingActionButton: FloatingActionButton(</span><br><span class="line">        child: Icon(Icons.delete),</span><br><span class="line">        onPressed: () &#123;</span><br><span class="line">          setState(() &#123;</span><br><span class="line">            names.removeAt(<span class="number">0</span>);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>我们吧<code>ListView</code>的<code>item</code>分别使用<code>StatelessWidget</code>和<code>StatefulWidget</code>实现, 看看两者区别</p>
<h3 id="StatelessWidget"><a href="#StatelessWidget" class="headerlink" title="StatelessWidget"></a>StatelessWidget</h3><p>我们先对<code>ListItem</code>使用一个<code>StatelessWidget</code>进行实现：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListItemLess</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> name;</span><br><span class="line">  <span class="keyword">final</span> Color randomColor = Color.fromARGB(<span class="number">255</span>, Random().nextInt(<span class="number">256</span>), Random().nextInt(<span class="number">256</span>), Random().nextInt(<span class="number">256</span>));</span><br><span class="line"></span><br><span class="line">  ListItemLess(<span class="keyword">this</span>.name);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      height: <span class="number">60</span>,</span><br><span class="line">      child: Text(name, style: TextStyle(fontSize: <span class="number">30</span>, color: Colors.white)),</span><br><span class="line">      color: randomColor,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过实践很明显, 每次删除第一个元素后, 虽然也能删除第一个<code>ListItem</code>, 剩余的每一个<code>ListItem</code>展示的信息也是对的, 但是他们的颜色却是每次都会发生变化</li>
<li>这主要就是因为, 每次删除之后都会调用<code>setState</code>，也就会重新<code>build</code>，重新build<code>出来的新的</code>StatelessWidget&#96;会重新生成一个新的随机颜色</li>
</ul>
<h3 id="StatefulWidget"><a href="#StatefulWidget" class="headerlink" title="StatefulWidget"></a>StatefulWidget</h3><p>现在对<code>ListItem</code>使用<code>StatefulWidget</code>实现同样的功能</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListItemFul</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> name;</span><br><span class="line">  ListItemFul(<span class="keyword">this</span>.name): <span class="keyword">super</span>();</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _ListItemFulState createState() =&gt; _ListItemFulState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_ListItemFulState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">ListItemFul</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Color randomColor = Color.fromARGB(<span class="number">255</span>, Random().nextInt(<span class="number">256</span>), Random().nextInt(<span class="number">256</span>), Random().nextInt(<span class="number">256</span>));</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      height: <span class="number">60</span>,</span><br><span class="line">      child: Text(widget.name),</span><br><span class="line">      color: randomColor,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>我们发现一个很奇怪的现象, 信息展示正常(删除了第一条数据)，但是从颜色上看, 是删除了最后一条</li>
<li>在我们每次调用<code>setState</code>的时候, <code>Widget</code>都会调用一个<code>canUpdate</code>函数判断是否需要重建<code>element</code></li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">bool</span> canUpdate(Widget oldWidget, Widget newWidget) &#123;</span><br><span class="line">  <span class="keyword">return</span> oldWidget.runtimeType == newWidget.runtimeType</span><br><span class="line">      &amp;&amp; oldWidget.key == newWidget.key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在删除第一条数据的时候，<code>Widget</code>对应的<code>Element</code>并没有改变</li>
<li>而目前是没有设置<code>Key</code>的, 所以<code>Element</code>中对应的<code>State</code>引用也没有发生改变</li>
<li>在更新<code>Widget</code>的时候，<code>Widget</code>使用了没有改变的<code>Element</code>中的<code>State</code>, 也就是之前创建的三个<code>element</code>中的前两个</li>
<li>这也就是为什么删除之后, 从颜色上看, 删除的是最后一条</li>
</ul>
<h3 id="添加Key"><a href="#添加Key" class="headerlink" title="添加Key"></a>添加Key</h3><p>在上面<code>ListItemFul</code>的基础上, 为每一个<code>ListItemFul</code>加上一个<code>key</code></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListItemFulKey</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> name;</span><br><span class="line">  ListItemFulKey(<span class="keyword">this</span>.name, &#123;Key key&#125;): <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _ListItemFulKeyState createState() =&gt; _ListItemFulKeyState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在上面使用的时候, 传入一个不同的key</span></span><br><span class="line">ListItemFulKey(name, key: ValueKey(name))</span><br></pre></td></tr></table></figure>

<ul>
<li>最终这就是我们想要实现的效果了</li>
<li>上述代码中, 为每一个<code>ListItemFulKey</code>添加了一个<code>key</code>值, 而且每一个的<code>Key</code>值都是不一样的</li>
<li>在删除一个元素调用<code>setState</code>方法后, 会重新<code>build</code>的一个<code>Widget Tree</code></li>
<li><code>Element</code>会拿到新的<code>Widget Tree</code>和原来保存的旧的<code>Widget Tree</code>做一个<code>diff</code>算法</li>
<li>根据<code>runtimeType</code>和<code>key</code>进行比对, 和新的<code>Widget Tree</code>相同的会被继续复用, 否则就会调用<code>unnmount</code>方法删除</li>
</ul>
<h3 id="Key的分类"><a href="#Key的分类" class="headerlink" title="Key的分类"></a>Key的分类</h3><ul>
<li><code>Key</code>本身是一个抽象，不过它也有一个工厂构造器，创建出来一个<code>ValueKey</code></li>
<li>直接子类主要有：<code>LocalKey</code>和<code>GlobalKey</code><ul>
<li><code>LocalKey</code>，它应用于具有相同父<code>Element</code>的<code>Widget</code>进行比较，也是<code>diff</code>算法的核心所在；</li>
<li><code>GlobalKey</code>，通常我们会使用<code>GlobalKey</code>某个<code>Widget</code>对应的<code>Widget</code>或<code>State</code>或<code>Element</code></li>
</ul>
</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="meta">@immutable</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Key</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="language-markdown">工厂构造函数</span></span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">factory</span> Key(<span class="built_in">String</span> value) = ValueKey&lt;<span class="built_in">String</span>&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  <span class="keyword">const</span> Key.empty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalKey</span> <span class="keyword">extends</span> <span class="title">Key</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="language-markdown">Default constructor, used by subclasses.</span></span></span><br><span class="line">  <span class="keyword">const</span> LocalKey() : <span class="keyword">super</span>.empty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalKey</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">StatefulWidget</span>&gt;&gt; <span class="keyword">extends</span> <span class="title">Key</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<h4 id="LocalKey"><a href="#LocalKey" class="headerlink" title="LocalKey"></a>LocalKey</h4><p><code>LocalKey</code>有三个子类</p>
<p><code>ValueKey</code>：</p>
<ul>
<li><code>ValueKey</code>是当我们以特定的值作为<code>key</code>时使用，比如一个字符串、数字等等</li>
</ul>
<p><code>ObjectKey</code>：</p>
<ul>
<li>如果两个学生，他们的名字一样，使用<code>name</code>作为他们的<code>key</code>就不合适了</li>
<li>我们可以创建出一个学生对象，使用对象来作为<code>key</code></li>
</ul>
<p><code>UniqueKey</code>:</p>
<ul>
<li>如果我们要确保<code>key</code>的唯一性，可以使用<code>UniqueKey</code></li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ValueKey</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">LocalKey</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ValueKey(<span class="keyword">this</span>.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectKey</span> <span class="keyword">extends</span> <span class="title">LocalKey</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ObjectKey(<span class="keyword">this</span>.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UniqueKey</span> <span class="keyword">extends</span> <span class="title">LocalKey</span> </span>&#123;</span><br><span class="line">  UniqueKey();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="GlobalKey"><a href="#GlobalKey" class="headerlink" title="GlobalKey"></a>GlobalKey</h4><ul>
<li><code>GlobalKey</code>可以帮助我们访问某个<code>Widget</code>的信息，包括<code>Widget</code>或<code>State</code>或<code>Element</code>等对象, 有点类似于<code>React</code>中的<code>ref</code></li>
<li>比如我们想在<code>HomePage</code>中访问<code>HomeContenet</code>中的<code>widget</code></li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> GlobalKey&lt;_HomeContentState&gt; homeKey = GlobalKey();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">&quot;GlobalKey Demo&quot;</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: HomeContent(key: homeKey),</span><br><span class="line">      floatingActionButton: FloatingActionButton(</span><br><span class="line">        child: Icon(Icons.delete),</span><br><span class="line">        onPressed: () &#123;</span><br><span class="line">          <span class="keyword">final</span> message = homeKey.currentState.message;</span><br><span class="line">          <span class="keyword">final</span> name = homeKey.currentState.widget.name;</span><br><span class="line">          <span class="built_in">print</span>(<span class="string">&#x27;message = <span class="subst">$message</span>, name = <span class="subst">$name</span>&#x27;</span>);</span><br><span class="line">          homeKey.currentState.newPrint();</span><br><span class="line"></span><br><span class="line">          <span class="keyword">final</span> currentCtx = homeKey.currentContext;</span><br><span class="line">          <span class="built_in">print</span>(<span class="string">&#x27;currentCtx = <span class="subst">$currentCtx</span>&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeContent</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> name = <span class="string">&#x27;homeContent&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  HomeContent(&#123; Key key &#125;): <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _HomeContentState createState() =&gt; _HomeContentState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_HomeContentState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">HomeContent</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> message = <span class="string">&#x27;message&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> newPrint() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;new---print&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Container();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a href="https://api.flutter.dev/flutter/widgets/State-class.html">State-class</a></li>
<li><a href="https://api.flutter.dev/flutter/foundation/Key-class.html">Key-class</a></li>
</ul>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
        <tag>Widget</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter之基础Widget之TextField</title>
    <url>/post/88da4080.html</url>
    <content><![CDATA[<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/flutter/widget_field.png?x-oss-process=style/titanjun" alt="Flutter"></p>
<span id="more"></span>

<ul>
<li><a href="https://www.titanjun.top/categories/Flutter%E7%AC%94%E8%AE%B0/">Flutter和Dart系列文章</a></li>
<li><a href="https://github.com/CoderTitan/Flutter_Widget">项目GitHub地址</a></li>
<li>上一篇<a href="https://www.titanjun.top/Flutter%E4%B9%8B%E5%9F%BA%E7%A1%80Widget.html">Flutter之基础Widget</a>文章介绍了<code>Flutter</code>中基础的<code>Widget</code>, 但是由于篇幅的原因, 这篇文章就主要介绍<code>TextField</code></li>
</ul>
<h2 id="TextField"><a href="#TextField" class="headerlink" title="TextField"></a><code>TextField</code></h2><p><code>TextField</code>用于文本输入，它提供了很多属性，我们先简单介绍一下主要属性的作用</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> TextField(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="comment">// 编辑框的控制器，跟文本框的交互一般都通过该属性完成，如果不创建的话默认会自动创建</span></span><br><span class="line">    <span class="keyword">this</span>.controller,</span><br><span class="line">    <span class="comment">// 用于控制`TextField`是否占有当前键盘的输入焦点, 使我们和键盘交互的`handle`</span></span><br><span class="line">    <span class="keyword">this</span>.focusNode,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 用于控制`TextField`的外观显示，如提示文本、背景颜色、边框等</span></span><br><span class="line">    <span class="keyword">this</span>.decoration = <span class="keyword">const</span> InputDecoration(),</span><br><span class="line">    <span class="comment">// 键盘类型</span></span><br><span class="line">    TextInputType keyboardType,</span><br><span class="line">    <span class="comment">// 决定键盘右下角按钮显示的内容</span></span><br><span class="line">    <span class="keyword">this</span>.textInputAction,</span><br><span class="line">    <span class="comment">// 设置什么情况下使用大写字母, 默认不使用大写字母</span></span><br><span class="line">    <span class="keyword">this</span>.textCapitalization = TextCapitalization.none,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 正在编辑的文本样式, `TextStyle`</span></span><br><span class="line">    <span class="keyword">this</span>.style,</span><br><span class="line">    <span class="comment">// 输入框文本的对其方式</span></span><br><span class="line">    <span class="keyword">this</span>.textAlign = TextAlign.start,</span><br><span class="line">    <span class="comment">// 输入框文本的其实位置</span></span><br><span class="line">    <span class="keyword">this</span>.textDirection,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 是否自动获取焦点, 默认`false`</span></span><br><span class="line">    <span class="keyword">this</span>.autofocus = <span class="keyword">false</span>,</span><br><span class="line">    <span class="comment">// 是否隐藏正在编辑的文本，如用于输入密码的场景等，文本内容会用“•”替换, 默认`false`</span></span><br><span class="line">    <span class="keyword">this</span>.obscureText = <span class="keyword">false</span>,</span><br><span class="line">    <span class="comment">// 是否自动校验, 默认`false`</span></span><br><span class="line">    <span class="keyword">this</span>.autocorrect = <span class="keyword">true</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输入框能输入的最大行数</span></span><br><span class="line">    <span class="keyword">this</span>.maxLines = <span class="number">1</span>,</span><br><span class="line">    <span class="comment">// 输入框能输入的最多字符个数</span></span><br><span class="line">    <span class="keyword">this</span>.maxLength,</span><br><span class="line">    <span class="comment">// 达到最大长度(`maxLength`)时是否阻止输入, 默认`true`: 不能继续输入, `false`可以继续输入</span></span><br><span class="line">    <span class="keyword">this</span>.maxLengthEnforced = <span class="keyword">true</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输入文本发生变化时的回调</span></span><br><span class="line">    <span class="keyword">this</span>.onChanged,</span><br><span class="line">    <span class="comment">// 点击键盘完成按钮时触发的回调，该回调没有参数，()&#123;&#125;</span></span><br><span class="line">    <span class="keyword">this</span>.onEditingComplete,</span><br><span class="line">    <span class="comment">// 点击键盘完成按钮时触发的回调，该回调有参数，参数即为当前输入框中的值。(String)&#123;&#125;</span></span><br><span class="line">    <span class="keyword">this</span>.onSubmitted,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对输入文本的校验</span></span><br><span class="line">    <span class="keyword">this</span>.inputFormatters,</span><br><span class="line">    <span class="comment">// 输入框是否可用, `false`则输入框会被禁用</span></span><br><span class="line">    <span class="keyword">this</span>.enabled,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 光标的宽度</span></span><br><span class="line">    <span class="keyword">this</span>.cursorWidth = <span class="number">2.0</span>,</span><br><span class="line">    <span class="comment">// 光标的圆角</span></span><br><span class="line">    <span class="keyword">this</span>.cursorRadius,</span><br><span class="line">    <span class="comment">// 光标的颜色</span></span><br><span class="line">    <span class="keyword">this</span>.cursorColor,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 键盘的外观, Brightness.light和dark</span></span><br><span class="line">    <span class="keyword">this</span>.keyboardAppearance,</span><br><span class="line">    <span class="comment">// 当TextField滚动时, 设置文本字段在滚动后的位置与可滚动项的边缘的距离</span></span><br><span class="line">    <span class="keyword">this</span>.scrollPadding = <span class="keyword">const</span> EdgeInsets.all(<span class="number">20.0</span>),</span><br><span class="line">    <span class="comment">// 长按输入的文本, 设置是否显示剪切，复制，粘贴按钮, 默认是显示的</span></span><br><span class="line">    <span class="keyword">this</span>.enableInteractiveSelection = <span class="keyword">true</span>,</span><br><span class="line">    <span class="comment">// 点击输入框时的回调()&#123;&#125;</span></span><br><span class="line">    <span class="keyword">this</span>.onTap,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h3><ul>
<li>编辑框的控制器，通过它可以设置&#x2F;获取编辑框的内容、选择编辑内容、监听编辑文本改变事件</li>
<li>大多数情况下我们都需要显式提供一个<code>controller</code>来与文本框交互</li>
<li>如果没有提供<code>controller</code>，则<code>TextField</code>内部会自动创建一个</li>
<li>下面是一个<code>TextField</code>的取值和赋值的操作</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextFieldWidget</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  State&lt;StatefulWidget&gt; createState() &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement createState</span></span><br><span class="line">    <span class="keyword">return</span> ControllerText();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ControllerText</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">TextFieldWidget</span>&gt; </span>&#123;</span><br><span class="line">  TextEditingController _textController = TextEditingController();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement build</span></span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      width: <span class="number">414.0</span>,</span><br><span class="line">      height: <span class="number">600.0</span>,</span><br><span class="line">      color: Colors.white12,</span><br><span class="line">      child: Column(</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          TextField(</span><br><span class="line">            controller: _textController,</span><br><span class="line">            decoration: InputDecoration(icon: Icon(Icons.phone_iphone), hintText: <span class="string">&#x27;hintText&#x27;</span>),</span><br><span class="line">          ),</span><br><span class="line">          RaisedButton(</span><br><span class="line">            child: Text(<span class="string">&#x27;赋值&#x27;</span>),</span><br><span class="line">            onPressed: ()&#123;</span><br><span class="line">              setState(() &#123;</span><br><span class="line">                  _textController.text = <span class="string">&quot;https://www.titanjun.top&quot;</span>;</span><br><span class="line">              &#125;);</span><br><span class="line">            &#125;,</span><br><span class="line">          ),</span><br><span class="line">          RaisedButton(</span><br><span class="line">            child: Text(<span class="string">&#x27;取值&#x27;</span>),</span><br><span class="line">            onPressed: ()&#123;</span><br><span class="line">              setState(() &#123;&#125;);</span><br><span class="line">            &#125;,</span><br><span class="line">          ),</span><br><span class="line">          Text(_textController.text)</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/flutter/textfield_controller.gif" alt="image"></p>
<h3 id="focusNode"><a href="#focusNode" class="headerlink" title="focusNode"></a>focusNode</h3><p>用于控制<code>TextField</code>是否占有当前键盘的输入焦点, 使我们和键盘交互的<code>handle</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FocusNode focusNode1 = new FocusNode();</span><br><span class="line"></span><br><span class="line">TextField(</span><br><span class="line">    autofocus: true, </span><br><span class="line">    focusNode: focusNode1,//关联focusNode1</span><br><span class="line">    decoration: InputDecoration(</span><br><span class="line">        labelText: &quot;input1&quot;</span><br><span class="line">    ),</span><br><span class="line">),</span><br><span class="line"></span><br><span class="line">RaisedButton(</span><br><span class="line">    child: Text(&quot;隐藏键盘&quot;),</span><br><span class="line">    onPressed: () &#123;</span><br><span class="line">    // 当所有编辑框都失去焦点时键盘就会收起  </span><br><span class="line">        focusNode1.unfocus();</span><br><span class="line">    &#125;,</span><br><span class="line">),</span><br></pre></td></tr></table></figure>


<h3 id="decoration"><a href="#decoration" class="headerlink" title="decoration"></a>decoration</h3><p>用于控制<code>TextField</code>的外观显示，如提示文本、背景颜色、边框等, 下面是<code>InputDecoration</code>的构造方法</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> InputDecoration(&#123;</span><br><span class="line">    <span class="comment">// 接收Widget, 在输入框左侧显示的图片                  </span></span><br><span class="line">    <span class="keyword">this</span>.icon,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// String, 输入框的描述, 当输入框获取焦点时默认会浮动到上方</span></span><br><span class="line">    <span class="keyword">this</span>.labelText,</span><br><span class="line">    <span class="comment">// TextStyle, 样式</span></span><br><span class="line">    <span class="keyword">this</span>.labelStyle,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 辅助文本, 位于输入框下方，如果errorText不为空的话，则helperText不显示</span></span><br><span class="line">    <span class="keyword">this</span>.helperText,</span><br><span class="line">    <span class="keyword">this</span>.helperStyle,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// <span class="language-markdown">提示文本，位于输入框内部</span></span></span><br><span class="line">    <span class="keyword">this</span>.hintText,</span><br><span class="line">    <span class="keyword">this</span>.hintStyle,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 错误信息提示文本</span></span><br><span class="line">    <span class="keyword">this</span>.errorText,</span><br><span class="line">    <span class="keyword">this</span>.errorStyle,</span><br><span class="line">    <span class="comment">// errorText显示的最大行数</span></span><br><span class="line">    <span class="keyword">this</span>.errorMaxLines,</span><br><span class="line">    <span class="comment">// errorText不为空，输入框没有焦点时要显示的边框</span></span><br><span class="line">    <span class="keyword">this</span>.errorBorder,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// labelText是否浮动，默认为true，修改为false则labelText在输入框获取焦点时不会浮动且不显示</span></span><br><span class="line">    <span class="keyword">this</span>.hasFloatingPlaceholder = <span class="keyword">true</span>,</span><br><span class="line">    <span class="comment">// 改变输入框是否为密集型，默认为false，修改为true时，图标及间距会变小</span></span><br><span class="line">    <span class="keyword">this</span>.isDense,</span><br><span class="line">    <span class="comment">// 内间距</span></span><br><span class="line">    <span class="keyword">this</span>.contentPadding,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 位于输入框内部起左侧置的图标</span></span><br><span class="line">    <span class="keyword">this</span>.prefixIcon,</span><br><span class="line">    <span class="comment">// 预先填充在输入框左侧的Widget,跟prefixText同时只能出现一个</span></span><br><span class="line">    <span class="keyword">this</span>.prefix,</span><br><span class="line">    <span class="comment">//预填充在输入框左侧的文本, 不可修改删除，例如手机号前面预先加上区号等</span></span><br><span class="line">    <span class="keyword">this</span>.prefixText,</span><br><span class="line">    <span class="keyword">this</span>.prefixStyle,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 位于输入框内部右侧位置的图标</span></span><br><span class="line">    <span class="keyword">this</span>.suffixIcon,</span><br><span class="line">    <span class="comment">// 预先填充在输入框右侧的Widget,跟suffixText同时只能出现一个</span></span><br><span class="line">    <span class="keyword">this</span>.suffix,</span><br><span class="line">    <span class="comment">// 预填充在输入框右侧的文本, 不可修改删除</span></span><br><span class="line">    <span class="keyword">this</span>.suffixText,</span><br><span class="line">    <span class="keyword">this</span>.suffixStyle,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 位于右下方显示的文本，常用于显示输入的字符数量</span></span><br><span class="line">    <span class="keyword">this</span>.counterText,</span><br><span class="line">    <span class="keyword">this</span>.counterStyle,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 相当于输入框的背景颜色</span></span><br><span class="line">    <span class="keyword">this</span>.fillColor,</span><br><span class="line">    <span class="comment">// 如果为true，则输入使用fillColor指定的颜色填充</span></span><br><span class="line">    <span class="keyword">this</span>.filled,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输入框有焦点时的边框,如果errorText不为空的话，该属性无效</span></span><br><span class="line">    <span class="keyword">this</span>.focusedBorder,</span><br><span class="line">    <span class="comment">// errorText不为空时，输入框有焦点时的边框</span></span><br><span class="line">    <span class="keyword">this</span>.focusedErrorBorder,</span><br><span class="line">    <span class="comment">// 输入框禁用时显示的边框，如果errorText不为空的话，该属性无效</span></span><br><span class="line">    <span class="keyword">this</span>.disabledBorder,</span><br><span class="line">    <span class="comment">// 输入框可用时显示的边框，如果errorText不为空的话，该属性无效</span></span><br><span class="line">    <span class="keyword">this</span>.enabledBorder,</span><br><span class="line">    <span class="comment">// 正常情况下的边框</span></span><br><span class="line">    <span class="keyword">this</span>.border,</span><br><span class="line">    <span class="comment">// 输入框是否可用</span></span><br><span class="line">    <span class="keyword">this</span>.enabled = <span class="keyword">true</span>,</span><br><span class="line">    <span class="comment">// counterText的语义标签, 如果赋值将替换counterText, 但是我试了好像没什么效果</span></span><br><span class="line">    <span class="keyword">this</span>.semanticCounterText,</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/flutter/widget_textfield.png" alt="image"></p>
<h3 id="keyboardType"><a href="#keyboardType" class="headerlink" title="keyboardType"></a>keyboardType</h3><p>用于设置该输入框默认的键盘输入类型，取值如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">keyboardType: TextInputType.number,</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><code>TextInputType</code></th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>text</code></td>
<td>文本输入键盘</td>
</tr>
<tr>
<td><code>multiline</code></td>
<td>多行文本，需和<code>maxLines</code>配合使用(设为<code>null</code>或大于1)</td>
</tr>
<tr>
<td><code>number</code></td>
<td>纯数字键盘</td>
</tr>
<tr>
<td><code>phone</code></td>
<td>电话号码输入键盘会弹出数字键盘并显示<code>* #</code></td>
</tr>
<tr>
<td><code>datetime</code></td>
<td>日期输入键盘, <code>Android</code>上会显示<code>: -</code></td>
</tr>
<tr>
<td><code>emailAddress</code></td>
<td>电子邮件地址,会显示<code>@ .</code></td>
</tr>
<tr>
<td><code>url</code></td>
<td>连接输入键盘, 会显示<code>/ .</code></td>
</tr>
</tbody></table>
<h3 id="textInputAction"><a href="#textInputAction" class="headerlink" title="textInputAction"></a>textInputAction</h3><p>决定键盘右下角按钮显示的内容, <code>TextInputAction</code>枚举值</p>
<table>
<thead>
<tr>
<th><code>textInputAction</code></th>
<th>样式</th>
</tr>
</thead>
<tbody><tr>
<td><code>none</code></td>
<td>不支持<code>iOS</code></td>
</tr>
<tr>
<td><code>unspecified</code></td>
<td>显示<code>return</code></td>
</tr>
<tr>
<td><code>done</code></td>
<td>显示<code>Done</code></td>
</tr>
<tr>
<td><code>go</code></td>
<td>显示<code>Go</code></td>
</tr>
<tr>
<td><code>search</code></td>
<td>显示<code>Search</code></td>
</tr>
<tr>
<td><code>send</code></td>
<td>显示<code>Send</code></td>
</tr>
<tr>
<td><code>next</code></td>
<td>显示<code>Next</code></td>
</tr>
<tr>
<td><code>previous</code></td>
<td>不支持<code>iOS</code></td>
</tr>
<tr>
<td><code>continueAction</code></td>
<td>显示<code>Continue</code></td>
</tr>
<tr>
<td><code>join</code></td>
<td>显示<code>Join</code></td>
</tr>
<tr>
<td><code>route</code></td>
<td>显示<code>Route</code></td>
</tr>
<tr>
<td><code>emergencyCall</code></td>
<td>显示<code>Emergency Call</code></td>
</tr>
<tr>
<td><code>newline</code></td>
<td></td>
</tr>
</tbody></table>
<h3 id="textCapitalization"><a href="#textCapitalization" class="headerlink" title="textCapitalization"></a>textCapitalization</h3><p>设置什么状态下使用大写字母键盘<code>TextCapitalization</code>枚举值</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> TextCapitalization &#123;</span><br><span class="line">  <span class="comment">// 每个单词的第一个字母使用大写字母</span></span><br><span class="line">  words,</span><br><span class="line">  <span class="comment">// 默认为每个句子的第一个字母使用大写键盘。</span></span><br><span class="line">  sentences,</span><br><span class="line">  <span class="comment">// 每个字符默认使用大写键盘</span></span><br><span class="line">  characters,</span><br><span class="line">  <span class="comment">/// <span class="language-markdown">不使用大写字母键盘</span></span></span><br><span class="line">  none,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="textAlign"><a href="#textAlign" class="headerlink" title="textAlign"></a>textAlign</h3><p>输入框内文本在水平方向的对齐方式</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认值</span></span><br><span class="line"><span class="keyword">this</span>.textAlign = TextAlign.start</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有枚举值</span></span><br><span class="line">left: 左对齐</span><br><span class="line">right: 右对齐</span><br><span class="line">center: 居中</span><br><span class="line">start: 起始位置, 和textDirection有关</span><br><span class="line">end: 终点位置, 和textDirection有关</span><br><span class="line">justify: 文本的拉伸行，以软换行符结束，以填充容器的宽度</span><br></pre></td></tr></table></figure>

<h3 id="textDirection"><a href="#textDirection" class="headerlink" title="textDirection"></a>textDirection</h3><p>决定文本是从右向左对其还是从左向右对齐</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> TextDirection &#123;</span><br><span class="line">  rtl,</span><br><span class="line">  ltr,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="inputFormatters"><a href="#inputFormatters" class="headerlink" title="inputFormatters"></a>inputFormatters</h3><ul>
<li>用于限制输入的内容，接收一个<code>TextInputFormatter</code>类型的集合</li>
<li><code>TextInputFormatter</code>是一个抽象类, 官方给我们提供了他的三个子类，分别是<ul>
<li><code>WhitelistingTextInputFormatter</code>: 白名单校验，也就是只允许输入符合规则的字符</li>
<li><code>BlacklistingTextInputFormatter</code>: 黑名单校验，除了规定的字符其他的都可以输入</li>
<li><code>LengthLimitingTextInputFormatter</code>: 长度限制，跟maxLength作用类似</li>
</ul>
</li>
<li>构造函数如下</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 白名单校验</span></span><br><span class="line">WhitelistingTextInputFormatter(<span class="keyword">this</span>.whitelistedPattern)</span><br><span class="line"><span class="comment">// 黑名单校验</span></span><br><span class="line">BlacklistingTextInputFormatter(</span><br><span class="line">    <span class="keyword">this</span>.blacklistedPattern, &#123;</span><br><span class="line">    <span class="comment">// 当输入禁止输入的字符时候, 会被替换成设置的replacementString字符</span></span><br><span class="line">    <span class="keyword">this</span>.replacementString = <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 长度校验</span></span><br><span class="line">LengthLimitingTextInputFormatter(<span class="keyword">this</span>.maxLength)</span><br><span class="line"></span><br><span class="line"><span class="comment">// whitelistedPattern和blacklistedPattern都是Pattern类型的,</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RegExp</span> <span class="keyword">implements</span> <span class="title">Pattern</span> </span>&#123;</span><br><span class="line">    <span class="keyword">external</span> <span class="keyword">factory</span> <span class="built_in">RegExp</span>(<span class="built_in">String</span> source,</span><br><span class="line">      &#123;<span class="built_in">bool</span> multiLine: <span class="keyword">false</span>, <span class="built_in">bool</span> caseSensitive: <span class="keyword">true</span>&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用介绍</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 白名单</span></span><br><span class="line">inputFormatters: [</span><br><span class="line">    <span class="comment">// 只能输入数字</span></span><br><span class="line">    WhitelistingTextInputFormatter.digitsOnly,</span><br><span class="line">    <span class="comment">// 是能输入小写字母</span></span><br><span class="line">    WhitelistingTextInputFormatter(<span class="built_in">RegExp</span>(<span class="string">&quot;[a-z]&quot;</span>))</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line"><span class="comment">// 黑名单</span></span><br><span class="line">inputFormatters: [</span><br><span class="line">    <span class="comment">// 不能输入回车符</span></span><br><span class="line">    BlacklistingTextInputFormatter.singleLineFormatter,</span><br><span class="line">    <span class="comment">// 不能输入小写字母</span></span><br><span class="line">    BlacklistingTextInputFormatter(<span class="built_in">RegExp</span>(<span class="string">&quot;[a-z]&quot;</span>), replacementString: <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符限制</span></span><br><span class="line">[LengthLimitingTextInputFormatter(<span class="number">10</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可是三种或两种一起使用一起使用</span></span><br><span class="line">inputFormatters: [</span><br><span class="line">  <span class="comment">// 不能输入小写字母</span></span><br><span class="line">  BlacklistingTextInputFormatter(<span class="built_in">RegExp</span>(<span class="string">&quot;[a-z]&quot;</span>)),</span><br><span class="line">  <span class="comment">// 限制输入10个字符</span></span><br><span class="line">  LengthLimitingTextInputFormatter(<span class="number">10</span>)</span><br><span class="line">],</span><br></pre></td></tr></table></figure>


<h3 id="光标设置"><a href="#光标设置" class="headerlink" title="光标设置"></a>光标设置</h3><p>设置输入框光标的样式</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 光标的宽度</span></span><br><span class="line"><span class="keyword">this</span>.cursorWidth = <span class="number">2.0</span>,</span><br><span class="line"><span class="comment">// 光标的圆角</span></span><br><span class="line"><span class="keyword">this</span>.cursorRadius,</span><br><span class="line"><span class="comment">// 光标的颜色</span></span><br><span class="line"><span class="keyword">this</span>.cursorColor,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例如下</span></span><br><span class="line">cursorWidth: <span class="number">10</span>,</span><br><span class="line">cursorColor: Colors.cyan,</span><br><span class="line">cursorRadius: Radius.circular(<span class="number">5</span>),</span><br></pre></td></tr></table></figure>


<h3 id="enableInteractiveSelection"><a href="#enableInteractiveSelection" class="headerlink" title="enableInteractiveSelection"></a>enableInteractiveSelection</h3><p>长按输入的文本, 设置是否显示剪切，复制，粘贴按钮, 默认是显示的</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认值</span></span><br><span class="line"><span class="keyword">this</span>.enableInteractiveSelection = <span class="keyword">true</span>,</span><br></pre></td></tr></table></figure>

<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/flutter/textfield_true.png" alt="image"></p>
<h3 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输入文本发生变化时的回调，参数即为输入框中的值</span></span><br><span class="line">onChanged: (val) &#123;</span><br><span class="line">    <span class="built_in">print</span>(val);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 点击键盘的动作按钮时的回调，没有参数</span></span><br><span class="line">onEditingComplete: ()&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;点击了键盘上的动作按钮&quot;</span>);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 点击键盘的动作按钮时的回调，参数为当前输入框中的值</span></span><br><span class="line">onSubmitted: (val)&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;点击了键盘上的动作按钮，当前输入框的值为：<span class="subst">$&#123;val&#125;</span>&quot;</span>);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 点击输入框时的回调()&#123;&#125;, 没有参数</span></span><br><span class="line">onTap: ()&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;点击输入框&#x27;</span>);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>


<h2 id="Form"><a href="#Form" class="headerlink" title="Form"></a>Form</h2><ul>
<li>实际业务中，在正式向服务器提交数据前，都会对各个输入框数据进行合法性校验，但是对每一个<code>TextField</code>都分别进行校验将会是一件很麻烦的事</li>
<li><code>Flutter</code>提供了一个表单<code>Form</code>，它可以对输入框进行分组，然后进行一些统一操作，如输入内容校验、输入框重置以及输入内容保存。</li>
<li><code>Form</code>继承自<code>StatefulWidget</code>对象，它对应的状态类为<code>FormState</code></li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Form类的定义</span></span><br><span class="line"><span class="keyword">const</span> Form(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.child,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 是否自动校验输入内容；当为true时，每一个子FormField内容发生变化时都会自动校验合法性，并直接显示错误信息。否则，需要通过调用FormState.validate()来手动校验</span></span><br><span class="line">    <span class="keyword">this</span>.autovalidate = <span class="keyword">false</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 决定Form所在的路由是否可以直接返回（如点击返回按钮），该回调返回一个Future对象，如果Future的最终结果是false，则当前路由不会返回；如果为true，则会返回到上一个路由。此属性通常用于拦截返回按钮</span></span><br><span class="line">    <span class="keyword">this</span>.onWillPop,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Form的任意一个子FormField内容发生变化时会触发此回调</span></span><br><span class="line">    <span class="keyword">this</span>.onChanged,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="FormField"><a href="#FormField" class="headerlink" title="FormField"></a>FormField</h3><p><code>Form</code>的子元素必须是<code>FormField</code>类型，<code>FormField</code>是一个抽象类，<code>FormState</code>内部通过定义的属性来完成操作，<code>FormField</code>部分定义如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> FormField(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.builder,</span><br><span class="line">    <span class="comment">// 保存回调</span></span><br><span class="line">    <span class="keyword">this</span>.onSaved,</span><br><span class="line">    <span class="comment">// 验证回调</span></span><br><span class="line">    <span class="keyword">this</span>.validator,</span><br><span class="line">    <span class="comment">// 初始值</span></span><br><span class="line">    <span class="keyword">this</span>.initialValue,</span><br><span class="line">    <span class="comment">// 是否自动校验。</span></span><br><span class="line">    <span class="keyword">this</span>.autovalidate = <span class="keyword">false</span>,</span><br><span class="line">    <span class="keyword">this</span>.enabled = <span class="keyword">true</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="TextFormField"><a href="#TextFormField" class="headerlink" title="TextFormField"></a>TextFormField</h3><p>为了方便使用，<code>Flutter</code>提供了一个<code>TextFormField</code>，它继承自<code>FormField</code>类，也是<code>TextField</code>的一个包装类，所以除了<code>FormField</code>定义的属性之外，它还包括<code>TextField</code>的属性。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextFormField</span> <span class="keyword">extends</span> <span class="title">FormField</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">  </span><br><span class="line">  TextFormField(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="keyword">this</span>.controller,</span><br><span class="line">    <span class="built_in">String</span> initialValue,</span><br><span class="line">    FocusNode focusNode,</span><br><span class="line">    InputDecoration decoration = <span class="keyword">const</span> InputDecoration(),</span><br><span class="line">    TextInputType keyboardType,</span><br><span class="line">    TextCapitalization textCapitalization = TextCapitalization.none,</span><br><span class="line">    TextInputAction textInputAction,</span><br><span class="line">    TextStyle style,</span><br><span class="line">    TextDirection textDirection,</span><br><span class="line">    TextAlign textAlign = TextAlign.start,</span><br><span class="line">    <span class="built_in">bool</span> autofocus = <span class="keyword">false</span>,</span><br><span class="line">    <span class="built_in">bool</span> obscureText = <span class="keyword">false</span>,</span><br><span class="line">    <span class="built_in">bool</span> autocorrect = <span class="keyword">true</span>,</span><br><span class="line">    <span class="built_in">bool</span> autovalidate = <span class="keyword">false</span>,</span><br><span class="line">    <span class="built_in">bool</span> maxLengthEnforced = <span class="keyword">true</span>,</span><br><span class="line">    <span class="built_in">int</span> maxLines = <span class="number">1</span>,</span><br><span class="line">    <span class="built_in">int</span> maxLength,</span><br><span class="line">    VoidCallback onEditingComplete,</span><br><span class="line">    ValueChanged&lt;<span class="built_in">String</span>&gt; onFieldSubmitted,</span><br><span class="line">    FormFieldSetter&lt;<span class="built_in">String</span>&gt; onSaved,</span><br><span class="line">    FormFieldValidator&lt;<span class="built_in">String</span>&gt; validator,</span><br><span class="line">    <span class="built_in">List</span>&lt;TextInputFormatter&gt; inputFormatters,</span><br><span class="line">    <span class="built_in">bool</span> enabled = <span class="keyword">true</span>,</span><br><span class="line">    Brightness keyboardAppearance,</span><br><span class="line">    EdgeInsets scrollPadding = <span class="keyword">const</span> EdgeInsets.all(<span class="number">20.0</span>),</span><br><span class="line">    <span class="built_in">bool</span> enableInteractiveSelection = <span class="keyword">true</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="FormState"><a href="#FormState" class="headerlink" title="FormState"></a>FormState</h3><ul>
<li><code>FormState</code>为<code>Form</code>的<code>State</code>类，可以通过<code>Form.of()</code>或<code>GlobalKey</code>获得。</li>
<li>我们可以通过它来对<code>Form</code>的子元素<code>FormField</code>进行统一操作</li>
<li>我们看看其常用的三个方法：</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用此方法后，会调用Form子元素FormField的save回调，用于保存表单内容</span></span><br><span class="line"><span class="keyword">void</span> save() &#123;</span><br><span class="line">  <span class="keyword">for</span> (FormFieldState&lt;<span class="built_in">dynamic</span>&gt; field <span class="keyword">in</span> _fields)</span><br><span class="line">    field.save();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">调用此方法后，会将子元素FormField的内容清空。</span></span></span><br><span class="line"><span class="keyword">void</span> reset() &#123;</span><br><span class="line">  <span class="keyword">for</span> (FormFieldState&lt;<span class="built_in">dynamic</span>&gt; field <span class="keyword">in</span> _fields)</span><br><span class="line">    field.reset();</span><br><span class="line">  _fieldDidChange();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">调用此方法后，会调用Form子元素FormField的validate回调，如果有一个校验失败，则返回false，所有校验失败项都会返回用户返回的错误提示。</span></span></span><br><span class="line"><span class="built_in">bool</span> validate() &#123;</span><br><span class="line">  _forceRebuild();</span><br><span class="line">  <span class="keyword">return</span> _validate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="需求示例"><a href="#需求示例" class="headerlink" title="需求示例"></a>需求示例</h3><p>用户登录示例, 在提交之前校验：</p>
<ul>
<li>用户名不能为空，如果为空则提示“用户名不能为空”。</li>
<li>密码不能小于6位，如果小于6为则提示“密码不能少于6位”。</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextStateWidget</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  State&lt;StatefulWidget&gt; createState() &#123;</span><br><span class="line">    <span class="keyword">return</span> TextWidget();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextWidget</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">TextStateWidget</span>&gt;  </span>&#123;</span><br><span class="line">  TextEditingController _nameController = TextEditingController();</span><br><span class="line">  TextEditingController _psdController = TextEditingController();</span><br><span class="line">  GlobalKey _formKey = GlobalKey&lt;FormState&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Padding(</span><br><span class="line">      padding: EdgeInsets.symmetric(vertical: <span class="number">20</span>, horizontal: <span class="number">30</span>),</span><br><span class="line">      child: Form(</span><br><span class="line">        key: _formKey,</span><br><span class="line">        autovalidate: <span class="keyword">true</span>,</span><br><span class="line">        child: Column(</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            TextFormField(</span><br><span class="line">              autofocus: <span class="keyword">true</span>,</span><br><span class="line">              controller: _nameController,</span><br><span class="line">              decoration: InputDecoration(</span><br><span class="line">                labelText: <span class="string">&#x27;用户名&#x27;</span>,</span><br><span class="line">                hintText: <span class="string">&#x27;用户名或密码&#x27;</span>,</span><br><span class="line">                icon: Icon(Icons.person)</span><br><span class="line">              ),</span><br><span class="line">              validator: (value) &#123;<span class="comment">// 校验用户名</span></span><br><span class="line">                <span class="keyword">return</span> value.trim().length &gt; <span class="number">0</span> ? <span class="keyword">null</span> : <span class="string">&#x27;用户名不能为空&#x27;</span>;</span><br><span class="line">              &#125;,</span><br><span class="line">            ),</span><br><span class="line">            TextFormField(</span><br><span class="line">              controller: _psdController,</span><br><span class="line">              obscureText: <span class="keyword">true</span>,</span><br><span class="line">              decoration: InputDecoration(</span><br><span class="line">                labelText: <span class="string">&#x27;密码&#x27;</span>,</span><br><span class="line">                hintText: <span class="string">&#x27;登录密码&#x27;</span>,</span><br><span class="line">                icon: Icon(Icons.lock)</span><br><span class="line">              ),</span><br><span class="line">              validator: (psd) &#123;</span><br><span class="line">                <span class="keyword">return</span> psd.trim().length &gt; <span class="number">5</span> ? <span class="keyword">null</span> : <span class="string">&#x27;密码不能少于6位&#x27;</span>;</span><br><span class="line">              &#125;,</span><br><span class="line">            ),</span><br><span class="line">            Padding(</span><br><span class="line">              padding: EdgeInsets.only(top: <span class="number">30</span>),</span><br><span class="line">              child: Row(</span><br><span class="line">                children: &lt;Widget&gt;[</span><br><span class="line">                  Expanded(</span><br><span class="line">                    child: RaisedButton(</span><br><span class="line">                      padding: EdgeInsets.all(<span class="number">15</span>),</span><br><span class="line">                      child: Text(<span class="string">&#x27;登录&#x27;</span>),</span><br><span class="line">                      color: Theme.of(context).primaryColor,</span><br><span class="line">                      textColor: Colors.white,</span><br><span class="line">                      onPressed: () &#123;</span><br><span class="line">                        <span class="comment">// 反正这里我是没看懂, 后面再慢慢学习吧</span></span><br><span class="line">                        <span class="keyword">if</span>((_formKey.currentState <span class="keyword">as</span> FormState).validate())&#123;</span><br><span class="line">                          <span class="comment">//验证通过提交数据</span></span><br><span class="line">                        &#125;</span><br><span class="line">                      &#125;,</span><br><span class="line">                    ),</span><br><span class="line">                  )</span><br><span class="line">                ],</span><br><span class="line">              ),</span><br><span class="line">            )</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://cdn.jsdelivr.net/gh/flutterchina/flutter-in-action@1.0/docs/imgs/image-20180904174217682.png" alt="image"></p>
<blockquote>
<p>好了, 到这里<code>TextField</code>相关的知识已经介绍完了, 下一篇应该就是介绍容器类<code>Widget</code>了, 拭目以待吧</p>
</blockquote>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://book.flutterchina.club/chapter3/input_and_form.html">Flutter实战</a></li>
<li><a href="https://docs.flutter.io/flutter/material/TextField-class.html">Flutter官网</a></li>
</ul>
<hr>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
        <tag>Widget</tag>
        <tag>Dart</tag>
        <tag>TextField</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter之容器类Widget</title>
    <url>/post/e3d2ac3e.html</url>
    <content><![CDATA[<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/flutter/flutter_container.png" alt="Flutter"></p>
<span id="more"></span>

<ul>
<li><a href="https://www.titanjun.top/categories/Flutter%E7%AC%94%E8%AE%B0/">Flutter和Dart系列文章</a></li>
<li><a href="https://github.com/CoderTitan/Flutter_Widget">项目GitHub地址</a></li>
<li>容器类<code>Widget</code>和布局类<code>Widget</code>都作用于其子<code>Widget</code>，不同的是：<ul>
<li>布局类<code>Widget</code>一般都需要接收一个<code>widget</code>数组（<code>children</code>)，他们直接或间接继承自（或包含）<code>MultiChildRenderObjectWidget</code> </li>
<li>而容器类<code>Widget</code>一般只需要接受一个子<code>Widget</code>（<code>child</code>），他们直接或间接继承自（或包含）<code>SingleChildRenderObjectWidget</code></li>
<li>布局类<code>Widget</code>是按照一定的排列方式来对其子<code>Widget</code>进行排列</li>
<li>而容器类<code>Widget</code>一般只是包装其子<code>Widget</code>，对其添加一些修饰（补白或背景色等）、变换(旋转或剪裁等)、或限制(大小等)。</li>
</ul>
</li>
<li><code>Flutter</code>官方并没有对<code>Widget</code>进行官方分类，我们对其分类主要是为了方便讨论和对<code>Widget</code>功能的区分记忆</li>
<li>相关容器类<code>Widget</code>主要分为以下几种<ul>
<li>填充类容器<code>Padding</code></li>
<li>布局限制类容器<code>ConstrainedBox</code>、<code>SizeBox</code></li>
<li>装饰类容器<code>DecoratedBox</code></li>
<li>变换类容器<code>Transform</code></li>
<li>组合容器<code>Container</code></li>
<li>导航类容器<code>Scaffold</code>、<code>TabBar</code>、<code>AppBar</code>等</li>
</ul>
</li>
</ul>
<h2 id="Padding"><a href="#Padding" class="headerlink" title="Padding"></a>Padding</h2><p><code>Padding</code>可以给其子元素设置内边距</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Padding</span> <span class="keyword">extends</span> <span class="title">SingleChildRenderObjectWidget</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> Padding(&#123;</span><br><span class="line">        Key key,</span><br><span class="line">        <span class="comment">// 内边距</span></span><br><span class="line">        <span class="meta">@required</span> <span class="keyword">this</span>.padding,</span><br><span class="line">        Widget child,</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> EdgeInsetsGeometry padding;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>EdgeInsetsGeometry</code>是一个抽象类，一般情况都使用<code>EdgeInsets</code>，它是<code>EdgeInsetsGeometry</code>的一个子类, 下面是的定义的一些方法</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EdgeInsets</span> <span class="keyword">extends</span> <span class="title">EdgeInsetsGeometry</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据上下左右分别设置边距</span></span><br><span class="line">    <span class="keyword">const</span> EdgeInsets.fromLTRB(<span class="keyword">this</span>.left, <span class="keyword">this</span>.top, <span class="keyword">this</span>.right, <span class="keyword">this</span>.bottom);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统一设置四周边距</span></span><br><span class="line">    <span class="keyword">const</span> EdgeInsets.all(<span class="built_in">double</span> value)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 只设置其中某几个边距</span></span><br><span class="line">    <span class="keyword">const</span> EdgeInsets.only(&#123;</span><br><span class="line">        <span class="comment">// 下面的都是默认值</span></span><br><span class="line">        <span class="keyword">this</span>.left = <span class="number">0.0</span>,</span><br><span class="line">        <span class="keyword">this</span>.top = <span class="number">0.0</span>,</span><br><span class="line">        <span class="keyword">this</span>.right = <span class="number">0.0</span>,</span><br><span class="line">        <span class="keyword">this</span>.bottom = <span class="number">0.0</span></span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据水平和垂直方向设置, 上下间距一样, 左右间距一样</span></span><br><span class="line">    <span class="keyword">const</span> EdgeInsets.symmetric(&#123; <span class="built_in">double</span> vertical = <span class="number">0.0</span>,</span><br><span class="line">                             <span class="built_in">double</span> horizontal = <span class="number">0.0</span> &#125;)</span><br><span class="line">                             </span><br><span class="line">    <span class="comment">// 静态变量, 上下左右, 都是0</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> EdgeInsets zero = EdgeInsets.only();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Padding(</span><br><span class="line">      padding: EdgeInsets.all(<span class="number">20</span>),</span><br><span class="line">      child: Icon(Icons.phone, color: Colors.cyan,),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ConstrainedBox"><a href="#ConstrainedBox" class="headerlink" title="ConstrainedBox"></a>ConstrainedBox</h2><ul>
<li><code>ConstrainedBox</code>和<code>SizedBox</code>都是通过<code>RenderConstrainedBox</code>来渲染的</li>
<li><code>SizedBox</code>只是<code>ConstrainedBox</code>一个定制</li>
<li><code>ConstrainedBox</code>主要用于对子<code>widget</code>添加额外的约束</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConstrainedBox</span> <span class="keyword">extends</span> <span class="title">SingleChildRenderObjectWidget</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  ConstrainedBox(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.constraints,</span><br><span class="line">    Widget child</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">给子widget添加约束</span></span></span><br><span class="line">  <span class="keyword">final</span> BoxConstraints constraints;</span><br></pre></td></tr></table></figure>

<h2 id="BoxConstraints"><a href="#BoxConstraints" class="headerlink" title="BoxConstraints"></a>BoxConstraints</h2><p><code>BoxConstraints</code>设置<code>Widget</code>的约束, 内部设置了四个属性: 最大&#x2F;小宽度和最大小高度, 下面是其相关构造函数和实例函数</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoxConstraints</span> <span class="keyword">extends</span> <span class="title">Constraints</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="language-markdown">构造函数</span></span></span><br><span class="line">  <span class="keyword">const</span> BoxConstraints(&#123;</span><br><span class="line">    <span class="comment">// 最小宽度</span></span><br><span class="line">    <span class="keyword">this</span>.minWidth = <span class="number">0.0</span>,</span><br><span class="line">    <span class="comment">// 最大宽度</span></span><br><span class="line">    <span class="keyword">this</span>.maxWidth = <span class="built_in">double</span>.infinity,</span><br><span class="line">    <span class="comment">// 最小高度</span></span><br><span class="line">    <span class="keyword">this</span>.minHeight = <span class="number">0.0</span>,</span><br><span class="line">    <span class="comment">// 最大高度</span></span><br><span class="line">    <span class="keyword">this</span>.maxHeight = <span class="built_in">double</span>.infinity</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">根据指定的Size设置约束</span></span></span><br><span class="line">  BoxConstraints.tight(Size size)</span><br><span class="line">    : minWidth = size.width,</span><br><span class="line">      maxWidth = size.width,</span><br><span class="line">      minHeight = size.height,</span><br><span class="line">      maxHeight = size.height;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据指定的宽高设置, 参数可为空</span></span><br><span class="line">  <span class="keyword">const</span> BoxConstraints.tightFor(&#123;</span><br><span class="line">    <span class="built_in">double</span> width,</span><br><span class="line">    <span class="built_in">double</span> height</span><br><span class="line">  &#125;): minWidth = width != <span class="keyword">null</span> ? width : <span class="number">0.0</span>,</span><br><span class="line">      maxWidth = width != <span class="keyword">null</span> ? width : <span class="built_in">double</span>.infinity,</span><br><span class="line">      minHeight = height != <span class="keyword">null</span> ? height : <span class="number">0.0</span>,</span><br><span class="line">      maxHeight = height != <span class="keyword">null</span> ? height : <span class="built_in">double</span>.infinity;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 默认宽高都是最大值, 参数可为空</span></span><br><span class="line">  <span class="keyword">const</span> BoxConstraints.tightForFinite(&#123;</span><br><span class="line">    <span class="built_in">double</span> width = <span class="built_in">double</span>.infinity,</span><br><span class="line">    <span class="built_in">double</span> height = <span class="built_in">double</span>.infinity</span><br><span class="line">  &#125;): minWidth = width != <span class="built_in">double</span>.infinity ? width : <span class="number">0.0</span>,</span><br><span class="line">      maxWidth = width != <span class="built_in">double</span>.infinity ? width : <span class="built_in">double</span>.infinity,</span><br><span class="line">      minHeight = height != <span class="built_in">double</span>.infinity ? height : <span class="number">0.0</span>,</span><br><span class="line">      maxHeight = height != <span class="built_in">double</span>.infinity ? height : <span class="built_in">double</span>.infinity;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据Size参数, 设置其最大值, 最小值为0</span></span><br><span class="line">  BoxConstraints.loose(Size size)</span><br><span class="line">    : minWidth = <span class="number">0.0</span>,</span><br><span class="line">      maxWidth = size.width,</span><br><span class="line">      minHeight = <span class="number">0.0</span>,</span><br><span class="line">      maxHeight = size.height;</span><br><span class="line">      </span><br><span class="line">  <span class="comment">// 根据宽高设置, 如果参数为空则默认为最大值</span></span><br><span class="line">  <span class="keyword">const</span> BoxConstraints.expand(&#123;</span><br><span class="line">    <span class="built_in">double</span> width,</span><br><span class="line">    <span class="built_in">double</span> height</span><br><span class="line">  &#125;): minWidth = width != <span class="keyword">null</span> ? width : <span class="built_in">double</span>.infinity,</span><br><span class="line">      maxWidth = width != <span class="keyword">null</span> ? width : <span class="built_in">double</span>.infinity,</span><br><span class="line">      minHeight = height != <span class="keyword">null</span> ? height : <span class="built_in">double</span>.infinity,</span><br><span class="line">      maxHeight = height != <span class="keyword">null</span> ? height : <span class="built_in">double</span>.infinity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用实例</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConstrainedBoxView</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement build</span></span><br><span class="line">    <span class="keyword">return</span> ConstrainedBox(</span><br><span class="line">      constraints: BoxConstraints(</span><br><span class="line">        minWidth: <span class="built_in">double</span>.infinity,  <span class="comment">// 宽度设置最大</span></span><br><span class="line">        minHeight: <span class="number">50</span>,    <span class="comment">// 高度最小值设置50</span></span><br><span class="line">      ),</span><br><span class="line">      child: Container(</span><br><span class="line">        height: <span class="number">10</span>,   <span class="comment">// 设置高度为10</span></span><br><span class="line">        child: DecoratedBox(decoration: BoxDecoration(color: Colors.orange)),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/flutter/container_min.png" alt="image"></p>
<ul>
<li>可以看到, 虽然将<code>Container</code>的高度设置为10像素，但是最终却是50像素，这正是<code>ConstrainedBox</code>的最小高度限制生效了</li>
<li>如果将<code>Container</code>的高度设置为80像素，那么最终红色区域的高度也会是80像素，因为在此示例中，<code>ConstrainedBox</code>只限制了最小高度，并未限制最大高度</li>
</ul>
<h2 id="SizedBox"><a href="#SizedBox" class="headerlink" title="SizedBox"></a>SizedBox</h2><p><code>SizedBox</code>用于给子<code>widget</code>指定固定的宽高</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SizedBox的几种构造函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SizedBox</span> <span class="keyword">extends</span> <span class="title">SingleChildRenderObjectWidget</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="language-markdown">设置固定的高度</span></span></span><br><span class="line">  <span class="keyword">const</span> SizedBox(&#123; Key key, <span class="keyword">this</span>.width, <span class="keyword">this</span>.height, Widget child &#125;)</span><br><span class="line">    : <span class="keyword">super</span>(key: key, child: child);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">创建一个最大宽高的box</span></span></span><br><span class="line">  <span class="keyword">const</span> SizedBox.expand(&#123; Key key, Widget child &#125;)</span><br><span class="line">    : width = <span class="built_in">double</span>.infinity,</span><br><span class="line">      height = <span class="built_in">double</span>.infinity,</span><br><span class="line">      <span class="keyword">super</span>(key: key, child: child);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">创建一个最小宽高(都是0)的box</span></span></span><br><span class="line">  <span class="keyword">const</span> SizedBox.shrink(&#123; Key key, Widget child &#125;)</span><br><span class="line">    : width = <span class="number">0.0</span>,</span><br><span class="line">      height = <span class="number">0.0</span>,</span><br><span class="line">      <span class="keyword">super</span>(key: key, child: child);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">创建一个指定size 的box</span></span></span><br><span class="line">  SizedBox.fromSize(&#123; Key key, Widget child, Size size &#125;)</span><br><span class="line">    : width = size?.width,</span><br><span class="line">      height = size?.height,</span><br><span class="line">      <span class="keyword">super</span>(key: key, child: child);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们创建一个指定宽高的<code>Widget</code></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SizedBoxView</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement build</span></span><br><span class="line">    <span class="keyword">return</span> SizedBox(</span><br><span class="line">      width: <span class="number">80</span>,</span><br><span class="line">      height: <span class="number">80</span>,</span><br><span class="line">      child: Container(</span><br><span class="line">        child: DecoratedBox(decoration: BoxDecoration(color: Colors.orange)),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际上SizedBox和只是ConstrainedBox一个定制, 上面的代码等价于</span></span><br><span class="line">ConstrainedBox(</span><br><span class="line">  constraints: BoxConstraints.tightFor(width: <span class="number">80.0</span>,height: <span class="number">80.0</span>),</span><br><span class="line">  child: Container(</span><br><span class="line">    child: DecoratedBox(decoration: BoxDecoration(color: Colors.orange)),</span><br><span class="line">  ),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>而实际上<code>ConstrainedBox</code>和<code>SizedBox</code>都是通过<code>RenderConstrainedBox</code>来渲染的，我们可以看到<code>ConstrainedBox</code>和<code>SizedBox</code>的<code>createRenderObject()</code>方法都返回的是一个<code>RenderConstrainedBox</code>对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SizedBox</span><br><span class="line">class SizedBox extends SingleChildRenderObjectWidget &#123;</span><br><span class="line"> RenderConstrainedBox createRenderObject(BuildContext context) &#123;</span><br><span class="line">    return RenderConstrainedBox(</span><br><span class="line">      additionalConstraints: _additionalConstraints,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  BoxConstraints get _additionalConstraints &#123;</span><br><span class="line">    return BoxConstraints.tightFor(width: width, height: height);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ConstrainedBox</span><br><span class="line">class ConstrainedBox extends SingleChildRenderObjectWidget &#123;</span><br><span class="line">  RenderConstrainedBox createRenderObject(BuildContext context) &#123;</span><br><span class="line">    return RenderConstrainedBox(additionalConstraints: constraints);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  final BoxConstraints constraints;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note warning"><p>多重限制问题</p></div>

<ul>
<li>如果某一个<code>widget</code>有多个父<code>ConstrainedBox</code>限制</li>
<li>对于<code>minWidth</code>和<code>minHeight</code>来说，是取父子中相应数值较大的。只有这样才能保证父限制与子限制不冲突</li>
<li>对于<code>maxWidth</code>和<code>maxHeight</code>来说, 无效, 最终宽高都是0</li>
</ul>
<h2 id="UnconstrainedBox"><a href="#UnconstrainedBox" class="headerlink" title="UnconstrainedBox"></a>UnconstrainedBox</h2><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> UnconstrainedBox(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    Widget child,</span><br><span class="line">    <span class="comment">// TextDirection, 表示水平方向子widget的布局顺序</span></span><br><span class="line">    <span class="keyword">this</span>.textDirection,</span><br><span class="line">    <span class="comment">// 子Widget在主轴上的对其方式</span></span><br><span class="line">    <span class="keyword">this</span>.alignment = Alignment.center,</span><br><span class="line">    <span class="comment">// 设置约束的轴, 水平or垂直, Axis.horizontal</span></span><br><span class="line">    <span class="keyword">this</span>.constrainedAxis,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>UnconstrainedBox</code>不会对子<code>Widget</code>产生任何限制，它允许其子<code>Widget</code>按照其本身大小绘制</li>
<li>一般情况下，我们会很少直接使用此<code>widget</code>，但在”去除”多重限制的时候也许会有帮助</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">ConstrainedBox(</span><br><span class="line">  constraints: BoxConstraints(</span><br><span class="line">    minWidth: <span class="number">60</span>,</span><br><span class="line">    minHeight: <span class="number">100</span>,</span><br><span class="line">  ),</span><br><span class="line">  child: UnconstrainedBox(  <span class="comment">// “去除”父级限制</span></span><br><span class="line">    textDirection: TextDirection.ltr,</span><br><span class="line">    alignment: Alignment.center,</span><br><span class="line">    constrainedAxis: Axis.horizontal,</span><br><span class="line">    child: ConstrainedBox(</span><br><span class="line">      constraints: BoxConstraints(</span><br><span class="line">        minWidth: <span class="number">90</span>,</span><br><span class="line">        minHeight: <span class="number">20</span>,</span><br><span class="line">      ),</span><br><span class="line">      child: DecoratedBox(decoration: BoxDecoration(color: Colors.red)),</span><br><span class="line">    ),</span><br><span class="line">  )</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li>上面代码中，如果没有中间的<code>UnconstrainedBox</code>，那么根据上面所述的多重限制规则，那么最终将显示一个90×100的红色框</li>
<li>但是由于<code>UnconstrainedBox</code>“去除”了父<code>ConstrainedBox</code>的限制，则最终会按照子<code>ConstrainedBox</code>的限制来绘制红色框，即90×20：</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/flutterchina/flutter-in-action@1.0/docs/imgs/image-20180910105830808.png" alt="image"></p>
<ul>
<li>但是需要注意，<code>UnconstrainedBox</code>对父限制的“去除”并非是真正的去除，上面例子中虽然红色区域大小是90×20，但上方仍然有80的空白空间。</li>
<li>也就是说父限制的<code>minHeight</code>(100.0)仍然是生效的，只不过它不影响最终子元素的大小，但仍然还是占有相应的空间，可以认为此时的父<code>ConstrainedBox</code>是作用于子<code>ConstrainedBox</code>上，而红色框只受子<code>ConstrainedBox</code>限制，这一点请读者务必注意</li>
<li>并且目前没有什么方式能够彻底去除父<code>BoxConstraints</code>的限制</li>
<li>在定义一个通用的<code>widget</code>时，如果对子<code>widget</code>指定限制时一定要注意，因为一旦指定限制条件，子<code>widget</code>如果要进行相关自定义大小时将可能非常困难，因为子<code>widget</code>在不更改父<code>widget</code>的代码的情况下无法彻底去除其限制条件</li>
</ul>
<h1 id="AspectRatio"><a href="#AspectRatio" class="headerlink" title="AspectRatio"></a>AspectRatio</h1><p><code>AspectRatio</code>组件是固定宽高比的组件</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> AspectRatio(&#123;</span><br><span class="line">  Key key,</span><br><span class="line">  <span class="comment">// 宽高比，可以直接写成分数的形式，也可以写成小数的形式，但建议写成分数的形式，可读性更高</span></span><br><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.aspectRatio,</span><br><span class="line">  Widget child,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>如果组件的宽度固定，希望高是宽的1&#x2F;2，可以用<code>AspectRatio</code>实现此效果</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">AspectRatio(</span><br><span class="line">  aspectRatio: <span class="number">2</span> / <span class="number">1</span>,</span><br><span class="line">  child: Container(color: Colors.red),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>


<h2 id="FractionallySizedBox"><a href="#FractionallySizedBox" class="headerlink" title="FractionallySizedBox"></a>FractionallySizedBox</h2><p>设置一个控件的尺寸是相对尺寸时，比如当前按钮的宽度占父组件的70%，可以使用<code>FractionallySizedBox</code>来实现此效果</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> FractionallySizedBox(&#123;</span><br><span class="line">  Key key,</span><br><span class="line">  <span class="comment">// 控制子组件显示的位置</span></span><br><span class="line">  <span class="keyword">this</span>.alignment = Alignment.center,</span><br><span class="line">  <span class="comment">// 设置宽度系数，系数值的范围是0-1</span></span><br><span class="line">  <span class="keyword">this</span>.widthFactor,</span><br><span class="line">  <span class="comment">// 设置高度系数，系数值的范围是0-1</span></span><br><span class="line">  <span class="keyword">this</span>.heightFactor,</span><br><span class="line">  Widget child,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="LimitedBox"><a href="#LimitedBox" class="headerlink" title="LimitedBox"></a>LimitedBox</h2><p><code>LimitedBox</code>组件是当不受父组件约束时限制它的尺寸, <code>LimitedBox</code>的父组件受到约束，此时<code>LimitedBox</code>将会不做任何操作，我们可以认为没有这个组件</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> LimitedBox(&#123;</span><br><span class="line">  Key key,</span><br><span class="line">  <span class="keyword">this</span>.maxWidth = <span class="built_in">double</span>.infinity,</span><br><span class="line">  <span class="keyword">this</span>.maxHeight = <span class="built_in">double</span>.infinity,</span><br><span class="line">  Widget child,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


<h2 id="DecoratedBox"><a href="#DecoratedBox" class="headerlink" title="DecoratedBox"></a>DecoratedBox</h2><p><code>DecoratedBox</code>可以在其子<code>widget</code>绘制前(或后)绘制一个装饰<code>Decoration</code>（如背景、边框、渐变等）, 构造函数如下</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> DecoratedBox(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.decoration,</span><br><span class="line">    <span class="keyword">this</span>.position = DecorationPosition.background,</span><br><span class="line">    Widget child</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>decoration</code>: 代表将要绘制的装饰，它类型为<code>Decoration</code>是一个抽象类，它定义了一个接口 <code>createBoxPainter()</code>，子类的主要职责是需要通过实现它来创建一个装饰器, 所以后面我们将使用<code>BoxDecoration</code>来实现该属性</li>
<li><code>position</code>：此属性决定在哪里绘制<code>Decoration</code>，它接收<code>DecorationPosition</code>的枚举类型，该枚举类两个值：<ul>
<li><code>background</code>：在子<code>widget</code>之后绘制，即背景装饰(是默认值)</li>
<li><code>foreground</code>：在子<code>widget</code>之上绘制，即前景</li>
</ul>
</li>
</ul>
<h2 id="BoxDecoration"><a href="#BoxDecoration" class="headerlink" title="BoxDecoration"></a>BoxDecoration</h2><p><code>BoxDecoration</code>是一个<code>Decoration</code>的子类, 通常我们都是使用它来实现上面的类似<code>decoration</code>的相关属性</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> BoxDecoration(&#123;</span><br><span class="line">    <span class="comment">// 背景颜色</span></span><br><span class="line">    <span class="keyword">this</span>.color,</span><br><span class="line">    <span class="comment">// 背景图片, DecorationImage</span></span><br><span class="line">    <span class="keyword">this</span>.image,</span><br><span class="line">    <span class="comment">// 边框</span></span><br><span class="line">    <span class="keyword">this</span>.border,</span><br><span class="line">    <span class="comment">// 圆角</span></span><br><span class="line">    <span class="keyword">this</span>.borderRadius,</span><br><span class="line">    <span class="comment">// 阴影</span></span><br><span class="line">    <span class="keyword">this</span>.boxShadow,</span><br><span class="line">    <span class="comment">// 渐变色</span></span><br><span class="line">    <span class="keyword">this</span>.gradient,</span><br><span class="line">    <span class="comment">// 背景颜色和背景图片的混合渲染模式`BlendMode`, 下面会介绍该枚举值</span></span><br><span class="line">    <span class="keyword">this</span>.backgroundBlendMode,</span><br><span class="line">    <span class="comment">// 形状</span></span><br><span class="line">    <span class="keyword">this</span>.shape = BoxShape.rectangle,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="image"><a href="#image" class="headerlink" title="image"></a>image</h3><p>设置背景图片<code>DecorationImage</code></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> DecorationImage(&#123;</span><br><span class="line">    <span class="comment">// ImageProvider类型</span></span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.image,</span><br><span class="line">    <span class="keyword">this</span>.colorFilter,</span><br><span class="line">    <span class="keyword">this</span>.fit,</span><br><span class="line">    <span class="keyword">this</span>.alignment = Alignment.center,</span><br><span class="line">    <span class="keyword">this</span>.centerSlice,</span><br><span class="line">    <span class="keyword">this</span>.repeat = ImageRepeat.noRepeat,</span><br><span class="line">    <span class="keyword">this</span>.matchTextDirection = <span class="keyword">false</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="image-1"><a href="#image-1" class="headerlink" title="image"></a>image</h4><ul>
<li>图片的设置方式, 是<code>ImageProvider</code>类型的</li>
<li><code>ImageProvider</code>是一个抽象类, 需要使用其子类实现<ul>
<li><code>NetworkImage</code></li>
<li><code>FileImage</code></li>
<li><code>MemoryImage</code></li>
</ul>
</li>
</ul>
<h4 id="colorFilter"><a href="#colorFilter" class="headerlink" title="colorFilter"></a>colorFilter</h4><ul>
<li>在绘制图像之前应用于图像的滤色器, 这个属性值是<code>ColorFilter</code>类</li>
<li><code>ColorFilter</code>的构造方法中有两个属性, 分别设置颜色图像和图片图像, 后面也将使用这两个名词解释各个枚举值</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 两个属性, 分别设置颜色图像和图片图像</span></span><br><span class="line"><span class="keyword">const</span> ColorFilter.mode(Color color, BlendMode blendMode)</span><br></pre></td></tr></table></figure>

<p><code>BlendMode</code>有以下枚举值, 带有<code>src</code>表示图片图像不显示, <code>dst</code>表示颜色图像不显示</p>
<table>
<thead>
<tr>
<th><code>blendMode</code></th>
<th>枚举值意义</th>
</tr>
</thead>
<tbody><tr>
<td><code>clear</code></td>
<td>颜色图像和图片图像都不显示</td>
</tr>
<tr>
<td><code>src</code></td>
<td>显示颜色图像不显示图片图像</td>
</tr>
<tr>
<td><code>dst</code></td>
<td>显示图片图像不显示颜色图像</td>
</tr>
<tr>
<td><code>srcOver</code></td>
<td>颜色图像在图片图像的上面</td>
</tr>
<tr>
<td><code>dstOver</code></td>
<td>颜色图像在图片图像的下面</td>
</tr>
<tr>
<td><code>srcIn</code></td>
<td>显示图片图像, 但只显示和颜色图像重合的部分(两者的交集)</td>
</tr>
<tr>
<td><code>dstIn</code></td>
<td>显示颜色图像, 但只显示和图片图像重合的部分(两者的交集)</td>
</tr>
<tr>
<td><code>srcOut</code></td>
<td>显示图片图像, 但只显示和颜色图像不重合的部分(两者的差集)</td>
</tr>
<tr>
<td><code>dstOut</code></td>
<td>显示颜色图像, 但只显示和图片图像不重合的部分(两者的差集), 一般都是空了</td>
</tr>
<tr>
<td><code>srcATop</code></td>
<td>将图片图像合成到颜色图像上面, 只合成交集的部分</td>
</tr>
<tr>
<td><code>dstATop</code></td>
<td>将颜色图像合成到图片图像上面, 只合成交集的部分</td>
</tr>
<tr>
<td><code>xor</code></td>
<td>图片图像和颜色图像合成的结果</td>
</tr>
<tr>
<td><code>plus</code></td>
<td>图片和颜色的合成, 但是会受透明度的影响</td>
</tr>
<tr>
<td><code>modulate</code></td>
<td>将图片图像和颜色图像的颜色分量相乘。这只能产生相同或较暗的颜色（乘以白色，1.0，结果不变;乘以黑色，0.0，结果为黑色</td>
</tr>
<tr>
<td><code>screen</code></td>
<td>将图片图像和颜色图像的颜色分量的倒数相乘, 并反转结果</td>
</tr>
<tr>
<td><code>overlay</code></td>
<td>在调整图片图像和颜色图像的组件以使其有利于目标之后，将其相乘</td>
</tr>
<tr>
<td><code>darken</code></td>
<td>通过从每个颜色通道中选择最低值来合成图片图像和颜色图像</td>
</tr>
<tr>
<td><code>lighten</code></td>
<td>通过从每个颜色通道中选择最高值来合成图片图像和颜色图像</td>
</tr>
</tbody></table>
<p>除此之外还有好几个枚举值, 但是我确实不知道该怎么解释了, 上面的解释好像也不是很清晰, 模模糊糊, 还是建议大家自测看效果图吧, 或者看看官方文档, 也有效果图, 其实很多枚举值还是用不到的, 如果有比较好的解释的话, 欢迎大家多多提出建议………大写的尴尬</p>
<h3 id="border"><a href="#border" class="headerlink" title="border"></a>border</h3><p>设置边框的样式,<code>BoxBorder</code>是一个抽象类, 有以下两个类共三种实现方式</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Border的两种实现方式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Border</span> <span class="keyword">extends</span> <span class="title">BoxBorder</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> Border(&#123;</span><br><span class="line">    <span class="keyword">this</span>.top = BorderSide.none,</span><br><span class="line">    <span class="keyword">this</span>.right = BorderSide.none,</span><br><span class="line">    <span class="keyword">this</span>.bottom = BorderSide.none,</span><br><span class="line">    <span class="keyword">this</span>.left = BorderSide.none,</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">factory</span> Border.all(&#123;</span><br><span class="line">    Color color = <span class="keyword">const</span> Color(<span class="number">0xFF000000</span>),</span><br><span class="line">    <span class="built_in">double</span> width = <span class="number">1.0</span>,</span><br><span class="line">    BorderStyle style = BorderStyle.solid,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面是BorderSide的构造函数, 之前的文字中都介绍过, 这里就不在提及了</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BorderSide</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> BorderSide(&#123;</span><br><span class="line">    <span class="keyword">this</span>.color = <span class="keyword">const</span> Color(<span class="number">0xFF000000</span>),</span><br><span class="line">    <span class="keyword">this</span>.width = <span class="number">1.0</span>,</span><br><span class="line">    <span class="keyword">this</span>.style = BorderStyle.solid,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BorderDirectional的构造函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BorderDirectional</span> <span class="keyword">extends</span> <span class="title">BoxBorder</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> BorderDirectional(&#123;</span><br><span class="line">    <span class="keyword">this</span>.top = BorderSide.none,</span><br><span class="line">    <span class="keyword">this</span>.start = BorderSide.none,</span><br><span class="line">    <span class="keyword">this</span>.end = BorderSide.none,</span><br><span class="line">    <span class="keyword">this</span>.bottom = BorderSide.none,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="boxShadow"><a href="#boxShadow" class="headerlink" title="boxShadow"></a>boxShadow</h3><p>设置盒子的阴影, 这个阴影和盒子的形状保持一致, 接受的值是一个存储<code>BoxShadow</code>的列表, 下面下看一下<code>BoxShadow</code>的构造函数</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> BoxShadow(&#123;</span><br><span class="line">    <span class="comment">// 颜色</span></span><br><span class="line">    Color color = <span class="keyword">const</span> Color(<span class="number">0xFF000000</span>),</span><br><span class="line">    <span class="comment">// 阴影相对于盒子的偏移量</span></span><br><span class="line">    Offset offset = Offset.zero,</span><br><span class="line">    <span class="comment">// 阴影的模糊程度, 值越大阴影越模糊</span></span><br><span class="line">    <span class="built_in">double</span> blurRadius = <span class="number">0.0</span>,</span><br><span class="line">    <span class="comment">// 阴影向相反方向增加的像素值</span></span><br><span class="line">    <span class="keyword">this</span>.spreadRadius = <span class="number">0.0</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 演示示例, 四个边都添加阴影</span></span><br><span class="line">[</span><br><span class="line">    BoxShadow(color: Colors.grey, offset: Offset(<span class="number">-5</span>, <span class="number">-5</span>), blurRadius: <span class="number">10</span>, spreadRadius: <span class="number">0</span>),</span><br><span class="line">    BoxShadow(color: Colors.red, offset: Offset(<span class="number">5</span>, <span class="number">5</span>), blurRadius: <span class="number">10</span>, spreadRadius: <span class="number">0</span>),</span><br><span class="line">],</span><br></pre></td></tr></table></figure>

<h3 id="gradient"><a href="#gradient" class="headerlink" title="gradient"></a>gradient</h3><p>设置背景颜色为渐变色, <code>Gradient</code>又是一个抽象类, 如下一共有三个子类</p>
<ul>
<li><code>LinearGradient</code></li>
<li><code>RadialGradient</code></li>
<li><code>SweepGradient</code></li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 线性渐变</span></span><br><span class="line"><span class="keyword">const</span> LinearGradient(&#123;</span><br><span class="line">    <span class="comment">// 起始点</span></span><br><span class="line">    <span class="keyword">this</span>.begin = Alignment.centerLeft,</span><br><span class="line">    <span class="comment">// 终点</span></span><br><span class="line">    <span class="keyword">this</span>.end = Alignment.centerRight,</span><br><span class="line">    <span class="comment">// 色值数组</span></span><br><span class="line">    <span class="meta">@required</span> <span class="built_in">List</span>&lt;Color&gt; colors,</span><br><span class="line">    <span class="comment">// 值列表，装有0.0到1.0的数值</span></span><br><span class="line">    <span class="built_in">List</span>&lt;<span class="built_in">double</span>&gt; stops,</span><br><span class="line">    <span class="comment">// 渐变平铺模式，指定在开始和结束以外的区域平铺模式</span></span><br><span class="line">    <span class="keyword">this</span>.tileMode = TileMode.clamp,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 圆形渐变, </span></span><br><span class="line"><span class="keyword">const</span> RadialGradient(&#123;</span><br><span class="line">    <span class="comment">// 渐变的中心)</span></span><br><span class="line">    <span class="keyword">this</span>.center = Alignment.center,</span><br><span class="line">    <span class="comment">// 渐变的半径，浮点型，具体数值需要乘以盒子的宽度</span></span><br><span class="line">    <span class="keyword">this</span>.radius = <span class="number">0.5</span>,</span><br><span class="line">    <span class="meta">@required</span> <span class="built_in">List</span>&lt;Color&gt; colors,</span><br><span class="line">    <span class="built_in">List</span>&lt;<span class="built_in">double</span>&gt; stops,</span><br><span class="line">    <span class="keyword">this</span>.tileMode = TileMode.clamp,</span><br><span class="line">    <span class="keyword">this</span>.focal,</span><br><span class="line">    <span class="keyword">this</span>.focalRadius = <span class="number">0.0</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> SweepGradient(&#123;</span><br><span class="line">    <span class="comment">// 位置的中心点</span></span><br><span class="line">    <span class="keyword">this</span>.center = Alignment.center,</span><br><span class="line">    <span class="comment">// 起始点的角度</span></span><br><span class="line">    <span class="keyword">this</span>.startAngle = <span class="number">0.0</span>,</span><br><span class="line">    <span class="comment">// 终点的角度</span></span><br><span class="line">    <span class="keyword">this</span>.endAngle = math.pi * <span class="number">2</span>,</span><br><span class="line">    <span class="meta">@required</span> <span class="built_in">List</span>&lt;Color&gt; colors,</span><br><span class="line">    <span class="built_in">List</span>&lt;<span class="built_in">double</span>&gt; stops,</span><br><span class="line">    <span class="keyword">this</span>.tileMode = TileMode.clamp,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>三种渐变色效果如下所示</p>
<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/flutter/graintColor.png" alt="image"></p>
<p><code>LinearGradient</code>线性渐变色下, 渐变模式<code>TileMode</code>各枚举值对应的效果如下</p>
<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/flutter/gradientmode.png" alt="image"></p>
<h3 id="shape"><a href="#shape" class="headerlink" title="shape"></a>shape</h3><p>设置背景的形状, 针对背景色, 背景图片和渐变色, <code>BoxShape</code>类型是个枚举值</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> BoxShape &#123;</span><br><span class="line">  <span class="comment">// 保持不变</span></span><br><span class="line">  rectangle,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 剪切成圆形, 和borderRadius属性冲突</span></span><br><span class="line">  circle,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Transform"><a href="#Transform" class="headerlink" title="Transform"></a>Transform</h2><ul>
<li><code>Transform</code>可以在其子<code>Widget</code>绘制时对其进行一个矩阵变换, 可以对<code>child</code>做平移、旋转、缩放等操作</li>
<li><code>Matrix4</code>是一个4D矩阵，通过它可以实现各种矩阵操作</li>
</ul>
<h3 id="Transform-1"><a href="#Transform-1" class="headerlink" title="Transform"></a>Transform</h3><p>先来看下<code>Transform</code>的一些构造函数吧</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Transform</span> <span class="keyword">extends</span> <span class="title">SingleChildRenderObjectWidget</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个矩阵变换Widget</span></span><br><span class="line">  <span class="keyword">const</span> Transform(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="comment">// 矩阵执行的变换操作, 接受一个Matrix4对象</span></span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.transform,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 旋转点，相对于左上角顶点的偏移。默认旋转点事左上角顶点, </span></span><br><span class="line">    <span class="comment">// 接受一个Offset对象</span></span><br><span class="line">    <span class="keyword">this</span>.origin,</span><br><span class="line">    <span class="comment">// 对其方式</span></span><br><span class="line">    <span class="keyword">this</span>.alignment,</span><br><span class="line">    <span class="comment">// 点击区域是否也做相应的改变</span></span><br><span class="line">    <span class="keyword">this</span>.transformHitTests = <span class="keyword">true</span>,</span><br><span class="line">    Widget child,</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 创建一个旋转变换矩阵</span></span><br><span class="line">  Transform.rotate(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="comment">// 设置旋转角度</span></span><br><span class="line">    <span class="meta">@required</span> <span class="built_in">double</span> angle,</span><br><span class="line">    <span class="keyword">this</span>.origin,</span><br><span class="line">    <span class="keyword">this</span>.alignment = Alignment.center,</span><br><span class="line">    <span class="keyword">this</span>.transformHitTests = <span class="keyword">true</span>,</span><br><span class="line">    Widget child,</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 创建一个平移矩阵</span></span><br><span class="line">  Transform.translate(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="meta">@required</span> Offset offset,</span><br><span class="line">    <span class="keyword">this</span>.transformHitTests = <span class="keyword">true</span>,</span><br><span class="line">    Widget child,</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 创建一个缩放矩阵</span></span><br><span class="line">  Transform.scale(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="comment">// 设置缩放比例, 0-1的数值</span></span><br><span class="line">    <span class="meta">@required</span> <span class="built_in">double</span> scale,</span><br><span class="line">    <span class="keyword">this</span>.origin,</span><br><span class="line">    <span class="keyword">this</span>.alignment = Alignment.center,</span><br><span class="line">    <span class="keyword">this</span>.transformHitTests = <span class="keyword">true</span>,</span><br><span class="line">    Widget child,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是每一种变换形式的具体示例</p>
<h4 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h4><p><code>Transform.rotate</code>可以对子<code>widget</code>进行旋转变换, 如下代码</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Container(</span><br><span class="line">  color: Colors.black,</span><br><span class="line">  child: Transform.rotate(</span><br><span class="line">    <span class="comment">// 这里☞旋转的角度, math.pi是指180度</span></span><br><span class="line">    angle: -math.pi / <span class="number">4</span>,</span><br><span class="line">    child: Container(</span><br><span class="line">      padding: <span class="keyword">const</span> EdgeInsets.all(<span class="number">8.0</span>),</span><br><span class="line">      color: <span class="keyword">const</span> Color(<span class="number">0xFFE8581C</span>),</span><br><span class="line">      child: <span class="keyword">const</span> Text(<span class="string">&#x27;https://titanjun.top&#x27;</span>),</span><br><span class="line">    ),</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/flutter/transform_rotate.png" alt="image"></p>
<h4 id="平移"><a href="#平移" class="headerlink" title="平移"></a>平移</h4><p><code>Transform.translate</code>接收一个<code>offset</code>参数，可以在绘制时沿x、y轴对子<code>widget</code>平移指定的距离</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Container(</span><br><span class="line">  color: Colors.black,</span><br><span class="line">  child: Transform.translate(</span><br><span class="line">    <span class="comment">// 默认原点为左上角，右移5像素，向下平移15像素 </span></span><br><span class="line">    offset: <span class="keyword">const</span> Offset(<span class="number">5.0</span>, <span class="number">15.0</span>),</span><br><span class="line">    child: Container(</span><br><span class="line">      padding: <span class="keyword">const</span> EdgeInsets.all(<span class="number">8.0</span>),</span><br><span class="line">      color: <span class="keyword">const</span> Color(<span class="number">0xFF7F7F7F</span>),</span><br><span class="line">      child: <span class="keyword">const</span> Text(<span class="string">&#x27;Quarter&#x27;</span>),</span><br><span class="line">    ),</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/flutter/transform_translate.png" alt="image"></p>
<h4 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h4><p><code>Transform.scale</code>可以对子<code>Widget</code>进行缩小或放大</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Container(</span><br><span class="line">  color: Colors.black,</span><br><span class="line">  child: Transform.scale(</span><br><span class="line">    origin: Offset(<span class="number">5</span>, <span class="number">5</span>),</span><br><span class="line">    <span class="comment">// 缩小为原来的0.5倍</span></span><br><span class="line">    scale: <span class="number">0.5</span>,</span><br><span class="line">    child: Container(</span><br><span class="line">      padding: <span class="keyword">const</span> EdgeInsets.all(<span class="number">8.0</span>),</span><br><span class="line">      color: <span class="keyword">const</span> Color(<span class="number">0xFFE8581C</span>),</span><br><span class="line">      child: <span class="keyword">const</span> Text(<span class="string">&#x27;Bad Ideas&#x27;</span>),</span><br><span class="line">    ),</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ul>
<li><code>Transform</code>的变换是应用在绘制阶段，而并不是应用在布局(<code>layout</code>)阶段</li>
<li>所以无论对子widget应用何种变化，其占用空间的大小和在屏幕上的位置都是固定不变的，因为这些是在布局阶段就确定的</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Row(</span><br><span class="line">  mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">  children: &lt;Widget&gt;[</span><br><span class="line">    DecoratedBox(</span><br><span class="line">      decoration:BoxDecoration(color: Colors.red),</span><br><span class="line">      child: Transform.scale(scale: <span class="number">1.5</span>,</span><br><span class="line">          child: Text(<span class="string">&quot;Hello world&quot;</span>)</span><br><span class="line">      )</span><br><span class="line">    ),</span><br><span class="line">    Text(<span class="string">&quot;你好&quot;</span>, style: TextStyle(color: Colors.green, fontSize: <span class="number">18.0</span>),)</span><br><span class="line">  ],</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><img data-src="https://cdn.jsdelivr.net/gh/flutterchina/flutter-in-action@1.0/docs/imgs/image-20180910164454967.png" alt="image"></p>
<ul>
<li>由于第一个<code>Text</code>应用变换(放大)后，其在绘制时会放大，但其占用的空间依然为红色部分，所以第二个<code>text</code>会紧挨着红色部分，最终就会出现文字有重合部分。</li>
<li>由于矩阵变化只会作用在绘制阶段，所以在某些场景下，在UI需要变化时，可以直接通过矩阵变化来达到视觉上的UI改变，而不需要去重新触发build流程，这样会节省<code>layout</code>的开销，所以性能会比较好</li>
<li>如之前介绍的<code>Flow widget</code>，它内部就是用矩阵变换来更新UI，除此之外，<code>Flutter</code>的动画<code>widget</code>中也大量使用了<code>Transform</code>以提高性能</li>
</ul>
<h3 id="RotatedBox"><a href="#RotatedBox" class="headerlink" title="RotatedBox"></a>RotatedBox</h3><ul>
<li><code>RotatedBox</code>和<code>Transform.rotate</code>功能相似，它们都可以对子<code>widget</code>进行旋转变换，但是有一点不同：<code>RotatedBox</code>的变换是在<code>layout</code>阶段，会影响在子<code>widget</code>的位置和大小</li>
<li>我们将上面介绍<code>Transform.rotate</code>时的示例改一下</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Row(</span><br><span class="line">  mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">  children: &lt;Widget&gt;[</span><br><span class="line">    DecoratedBox(</span><br><span class="line">      decoration: BoxDecoration(color: Colors.red),</span><br><span class="line">      <span class="comment">//将Transform.rotate换成RotatedBox  </span></span><br><span class="line">      child: RotatedBox(</span><br><span class="line">        <span class="comment">// int类型</span></span><br><span class="line">        quarterTurns: <span class="number">1</span>, <span class="comment">//旋转90度(1/4圈)</span></span><br><span class="line">        child: Text(<span class="string">&quot;Hello world&quot;</span>),</span><br><span class="line">      ),</span><br><span class="line">    ),</span><br><span class="line">    Text(<span class="string">&quot;你好&quot;</span>, style: TextStyle(color: Colors.green, fontSize: <span class="number">18.0</span>),)</span><br><span class="line">  ],</span><br><span class="line">),</span><br></pre></td></tr></table></figure>

<p><img data-src="https://cdn.jsdelivr.net/gh/flutterchina/flutter-in-action@1.0/docs/imgs/image-20180910170603964.png" alt="image"></p>
<blockquote>
<p>由于<code>RotatedBox</code>是作用于<code>layout</code>阶段，所以<code>widget</code>会旋转90度（而不只是绘制的内容），<code>decoration</code>会作用到<code>widget</code>所占用的实际空间上，所以就是上图的效果。读者可以和前面<code>Transform.rotate</code>示例对比理解</p>
</blockquote>
<h3 id="Matrix4"><a href="#Matrix4" class="headerlink" title="Matrix4"></a>Matrix4</h3><p>一个4D变换矩阵, <code>Transform</code>使用<code>Matrix4</code>使其子<code>Widget</code>进行矩阵变换, 下面是其相关构造函数</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 4 x 4矩阵</span></span><br><span class="line"><span class="keyword">factory</span> Matrix4(<span class="built_in">double</span> arg0, <span class="built_in">double</span> arg1, <span class="built_in">double</span> arg2, <span class="built_in">double</span> arg3, <span class="built_in">double</span> arg4, <span class="built_in">double</span> arg5, <span class="built_in">double</span> arg6, <span class="built_in">double</span> arg7, <span class="built_in">double</span> arg8, <span class="built_in">double</span> arg9, <span class="built_in">double</span> arg10, <span class="built_in">double</span> arg11, <span class="built_in">double</span> arg12, <span class="built_in">double</span> arg13, <span class="built_in">double</span> arg14, <span class="built_in">double</span> arg15)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置一个新的矩阵</span></span><br><span class="line"><span class="keyword">factory</span> Matrix4.columns(Vector4 arg0, Vector4 arg1, Vector4 arg2, Vector4 arg3)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复合平移、旋转、缩放，形成新的转换矩阵</span></span><br><span class="line"><span class="keyword">factory</span> Matrix4.compose(Vector3 translation, Quaternion rotation, Vector3 scale)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复制一个4*4的张量(矩阵)</span></span><br><span class="line"><span class="keyword">factory</span> Matrix4.copy(Matrix4 other)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缩放矩阵, Vector3(double x, double y, double z)</span></span><br><span class="line"><span class="keyword">factory</span> Matrix4.diagonal3(Vector3 scale)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缩放矩阵, 只是参数不同而已</span></span><br><span class="line"><span class="keyword">factory</span> Matrix4.diagonal3Values(<span class="built_in">double</span> x, <span class="built_in">double</span> y, <span class="built_in">double</span> z)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Matrix4.fromBuffer(ByteBuffer buffer, <span class="built_in">int</span> offset)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用给定的Float64List构造Matrix4 </span></span><br><span class="line">Matrix4.fromFloat64List(Float64List _m4storage)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将一个16位的一维数组转换成4*4的矩阵</span></span><br><span class="line"><span class="keyword">factory</span> Matrix4.fromList(<span class="built_in">List</span>&lt;<span class="built_in">double</span>&gt; values)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 恢复初始状态，也就是4*4的单位矩阵</span></span><br><span class="line"><span class="keyword">factory</span> Matrix4.identity()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取相反的矩阵，就是反着来</span></span><br><span class="line"><span class="keyword">factory</span> Matrix4.inverted(Matrix4 other)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个4维向量的乘积合并</span></span><br><span class="line"><span class="keyword">factory</span> Matrix4.outer(Vector4 u, Vector4 v)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 围绕X轴旋转</span></span><br><span class="line"><span class="keyword">factory</span> Matrix4.rotationX(<span class="built_in">double</span> radians)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 围绕Y轴旋转</span></span><br><span class="line"><span class="keyword">factory</span> Matrix4.rotationY(<span class="built_in">double</span> radians)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 围绕Z轴旋转</span></span><br><span class="line"><span class="keyword">factory</span> Matrix4.rotationZ(<span class="built_in">double</span> radians)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扭曲变换</span></span><br><span class="line"><span class="keyword">factory</span> Matrix4.skew(<span class="built_in">double</span> alpha, <span class="built_in">double</span> beta)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 沿着x轴扭曲</span></span><br><span class="line"><span class="keyword">factory</span> Matrix4.skewX(<span class="built_in">double</span> alpha)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 沿着y轴扭曲</span></span><br><span class="line"><span class="keyword">factory</span> Matrix4.skewY(<span class="built_in">double</span> beta)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移动矩阵</span></span><br><span class="line"><span class="keyword">factory</span> Matrix4.translation(Vector3 translation)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移动矩阵, 参数不同而已</span></span><br><span class="line"><span class="keyword">factory</span> Matrix4.translationValues(<span class="built_in">double</span> x, <span class="built_in">double</span> y, <span class="built_in">double</span> z)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全是0的4*4的张量</span></span><br><span class="line"><span class="keyword">factory</span> Matrix4.zero()</span><br></pre></td></tr></table></figure>

<h2 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h2><ul>
<li><code>Container</code>是一个容器类<code>widget</code>，它本身不对应具体的<code>RenderObject</code>，它是<code>DecoratedBox</code>、<code>ConstrainedBox</code>、<code>Transform</code>、<code>Padding</code>、<code>Align</code>等<code>widget</code>的一个组合widget</li>
<li>所以我们只需通过一个<code>Container</code>可以实现同时需要装饰、变换、限制的场景</li>
<li>下面是<code>Container</code>的相关定义</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Container(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="comment">// 对其方式</span></span><br><span class="line">    <span class="keyword">this</span>.alignment,</span><br><span class="line">    <span class="comment">// 内边距</span></span><br><span class="line">    <span class="keyword">this</span>.padding,</span><br><span class="line">    <span class="comment">// 背景颜色</span></span><br><span class="line">    Color color,</span><br><span class="line">    <span class="comment">// 背景装饰</span></span><br><span class="line">    Decoration decoration,</span><br><span class="line">    <span class="comment">// 前景装饰</span></span><br><span class="line">    <span class="keyword">this</span>.foregroundDecoration,</span><br><span class="line">    <span class="built_in">double</span> width,</span><br><span class="line">    <span class="built_in">double</span> height,</span><br><span class="line">    <span class="comment">//容器大小的限制条件</span></span><br><span class="line">    BoxConstraints constraints,</span><br><span class="line">    <span class="comment">// 容器的外边距, EdgeInsets</span></span><br><span class="line">    <span class="keyword">this</span>.margin,</span><br><span class="line">    <span class="comment">// 设置变换矩阵</span></span><br><span class="line">    <span class="keyword">this</span>.transform,</span><br><span class="line">    <span class="keyword">this</span>.child,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>容器的大小可以通过<code>width</code>、<code>height</code>属性来指定，也可以通过<code>constraints</code>来指定，如果同时存在时，<code>width</code>、<code>height</code>优先。实际上<code>Container</code>内部会根据<code>width</code>、<code>height</code>来生成一个<code>constraints</code></li>
<li><code>color</code>和<code>decoration</code>是互斥的，实际上，当指定<code>color</code>时，<code>Container</code>内会自动创建一个<code>decoration</code></li>
</ul>
<h3 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h3><p>通过使用来实现如下效果</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/flutterchina/flutter-in-action@1.0/docs/imgs/image-20180910205356331.png" alt="image"></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Container(</span><br><span class="line">  margin: EdgeInsets.only(top: <span class="number">50.0</span>, left: <span class="number">120.0</span>), <span class="comment">//容器外补白</span></span><br><span class="line">  constraints: BoxConstraints.tightFor(width: <span class="number">200.0</span>, height: <span class="number">150.0</span>), <span class="comment">//卡片大小</span></span><br><span class="line">  decoration: BoxDecoration(<span class="comment">//背景装饰</span></span><br><span class="line">      gradient: RadialGradient( <span class="comment">//背景径向渐变</span></span><br><span class="line">          colors: [Colors.red, Colors.orange],</span><br><span class="line">          center: Alignment.topLeft,</span><br><span class="line">          radius: <span class="number">.98</span></span><br><span class="line">      ),</span><br><span class="line">      boxShadow: [ <span class="comment">//卡片阴影</span></span><br><span class="line">        BoxShadow(</span><br><span class="line">            color: Colors.black54,</span><br><span class="line">            offset: Offset(<span class="number">2.0</span>, <span class="number">2.0</span>),</span><br><span class="line">            blurRadius: <span class="number">4.0</span></span><br><span class="line">        )</span><br><span class="line">      ]</span><br><span class="line">  ),</span><br><span class="line">  transform: Matrix4.rotationZ(<span class="number">.2</span>), <span class="comment">//卡片倾斜变换</span></span><br><span class="line">  alignment: Alignment.center, <span class="comment">//卡片内文字居中</span></span><br><span class="line">  child: Text( <span class="comment">//卡片文字</span></span><br><span class="line">    <span class="string">&quot;5.20&quot;</span>, style: TextStyle(color: Colors.white, fontSize: <span class="number">40.0</span>),</span><br><span class="line">  ),</span><br><span class="line">);</span><br></pre></td></tr></table></figure>


<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><code>ConstrainedBox</code>：适用于需要设置最大&#x2F;小宽高，组件大小以来子组件大小，但不能超过设置的界限。</li>
<li><code>UnconstrainedBox</code>：用到情况不多，当作<code>ConstrainedBox</code>的子组件可以“突破”<code>ConstrainedBox</code>的限制，超出界限的部分会被截取。</li>
<li><code>SizedBox</code>：适用于固定宽高的情况，常用于当作2个组件之间间隙组件。</li>
<li><code>AspectRatio</code>：适用于固定宽高比的情况。</li>
<li><code>FractionallySizedBox</code>：适用于占父组件百分比的情况。</li>
<li><code>LimitedBox</code>：适用于没有父组件约束的情况。</li>
<li><code>Container</code>：适用于不仅有尺寸的约束，还有装饰（颜色、边框、等）、内外边距等需求的情况。</li>
</ul>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://book.flutterchina.club/chapter5/">Flutter容器类Widget–中文网</a></li>
<li><a href="https://flutterchina.club/widgets/painting/">Flutter官网</a></li>
</ul>
<hr>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
        <tag>Widget</tag>
        <tag>Dart</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter之布局类Widget</title>
    <url>/post/20517d5b.html</url>
    <content><![CDATA[<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/flutter/flutter_layout.png?x-oss-process=style/titanjun" alt="Flutter"></p>
<span id="more"></span>


<ul>
<li>相关博客系列文章: <a href="https://www.titanjun.top/categories/Flutter%E7%AC%94%E8%AE%B0/">Flutter和Dart系列文章</a></li>
<li>相关<code>Demo</code>地址: <a href="https://github.com/CoderTitan/Flutter_Widget">GitHub地址</a></li>
<li>布局类<code>Widget</code>都会包含一个或多个子<code>widget</code>，不同的布局类<code>Widget</code>对子<code>widget</code>排版(<code>layout</code>)方式不同</li>
<li><a href="https://www.titanjun.top/Flutter%E4%B9%8BText%E5%92%8CImage.html">上一篇文章</a>中提到: <code>Widget</code>实际上就是<code>Element</code>的配置数据, <code>Widget</code>的功能是描述一个<code>UI</code>元素的一个配置数据, 而真正的<code>UI</code>渲染是由<code>Element</code>构成</li>
<li>在<code>Flutter</code>中，根据<code>Widget</code>是否需要包含子节点将<code>Widget</code>分为了三类，分别对应三种<code>Element</code>，如下表</li>
</ul>
<table>
<thead>
<tr>
<th>Widget</th>
<th>对应的Element</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td><code>LeafRenderObjectWidget</code></td>
<td><code>LeafRenderObjectElement</code></td>
<td><code>Widget</code>树的叶子节点，用于没有子节点的<code>widget</code>，通常基础<code>widget</code>都属于这一类，如<code>Text</code>、<code>Image</code></td>
</tr>
<tr>
<td><code>SingleChildRenderObjectWidget</code></td>
<td><code>SingleChildRenderObjectElement</code></td>
<td>包含一个子<code>Widget</code>，如：<code>ConstrainedBox</code>、<code>DecoratedBox</code>等</td>
</tr>
<tr>
<td><code>MultiChildRenderObjectWidget</code></td>
<td><code>MultiChildRenderObjectElement</code></td>
<td>包含多个子<code>Widget</code>，一般都有一个<code>children</code>参数，接受一个<code>Widget</code>数组。如<code>Row</code>、<code>Column</code>、<code>Stack</code>等</td>
</tr>
</tbody></table>
<h2 id="布局类Widget"><a href="#布局类Widget" class="headerlink" title="布局类Widget"></a>布局类Widget</h2><ul>
<li>布局类<code>Widget</code>就是指直接或间接继承(包含)<code>MultiChildRenderObjectWidget</code>的<code>Widget</code>，它们一般都会有一个<code>children</code>属性用于接收子<code>Widget</code></li>
<li><code>Widget</code>的继承关系如下:<ul>
<li><code>Widget</code> &gt; <code>RenderObjectWidget</code> &gt; <code>(Leaf/SingleChild/MultiChild)RenderObjectWidget</code></li>
</ul>
</li>
<li><code>RenderObjectWidget</code>类中定义了创建、更新<code>RenderObject</code>的方法，子类必须实现他们</li>
<li>对于布局类<code>Widget</code>来说，其布局算法都是通过对应的<code>RenderObject</code>对象来实现的</li>
<li><code>Flutter</code>中主要有以下几种布局类的<code>Widget</code>：<ul>
<li>线性布局<code>Row</code>和<code>Column</code></li>
<li>弹性布局<code>Flex</code></li>
<li>流式布局<code>Wrap</code>、<code>Flow</code></li>
<li>层叠布局<code>Stack</code>、<code>Positioned</code></li>
</ul>
</li>
</ul>
<h2 id="线性布局"><a href="#线性布局" class="headerlink" title="线性布局"></a>线性布局</h2><ul>
<li><code>Row</code>和<code>Column</code>是一种现行布局的<code>Widget</code>, 都继承自<code>Flex</code></li>
<li>所谓线性布局，即指沿水平或垂直方向排布<code>子Widget</code></li>
<li>对于线性布局，有主轴和纵轴之分，如果布局是沿水平方，那么主轴就指是水平方向，而纵轴即垂直方向；如果布局沿垂直方向，那么主轴就是指垂直方向，而纵轴就是水平方向</li>
<li><code>Row</code>的主轴即为水平方向, <code>Column</code>的主轴是垂直方向, 切两者的属性和使用都一样</li>
<li>相关下定义的源码如下:</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Row(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start,</span><br><span class="line">    MainAxisSize mainAxisSize = MainAxisSize.max,</span><br><span class="line">    CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center,</span><br><span class="line">    TextDirection textDirection,</span><br><span class="line">    VerticalDirection verticalDirection = VerticalDirection.down,</span><br><span class="line">    TextBaseline textBaseline,</span><br><span class="line">    <span class="built_in">List</span>&lt;Widget&gt; children = <span class="keyword">const</span> &lt;Widget&gt;[],</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Column(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start,</span><br><span class="line">    MainAxisSize mainAxisSize = MainAxisSize.max,</span><br><span class="line">    CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center,</span><br><span class="line">    TextDirection textDirection,</span><br><span class="line">    VerticalDirection verticalDirection = VerticalDirection.down,</span><br><span class="line">    TextBaseline textBaseline,</span><br><span class="line">    <span class="built_in">List</span>&lt;Widget&gt; children = <span class="keyword">const</span> &lt;Widget&gt;[],</span><br><span class="line">&#125;)  </span><br></pre></td></tr></table></figure>

<h3 id="相关属性如下"><a href="#相关属性如下" class="headerlink" title="相关属性如下"></a>相关属性如下</h3><h4 id="mainAxisAlignment"><a href="#mainAxisAlignment" class="headerlink" title="mainAxisAlignment"></a><code>mainAxisAlignment</code></h4><p>子<code>Widget</code>在主轴方向的排列方式, 为方便以下皆称<code>Widget</code>为组件</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认值</span></span><br><span class="line">MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start</span><br></pre></td></tr></table></figure>

<ul>
<li><code>start</code>: 子<code>widgets</code>向主轴起点对其, 依次排列</li>
<li><code>end</code>: 子<code>widgets</code>向主轴终点对其, 依次排列</li>
<li><code>center</code>: 所有子<code>widgets</code>居中排列</li>
<li><code>spaceBetween</code>: 均匀分配,相邻<code>widgets</code>间距离相同。每行第一个<code>widgets</code>与行首对齐，每行最后一个<code>widgets</code>与行尾对齐</li>
<li><code>spaceAround</code>: 均匀分配,相邻<code>widgets</code>间距离相同。每行第一个<code>widgets</code>到行首的距离和每行最后一个<code>widgets</code>到行尾的距离将会是相邻<code>widgets</code>之间距离的一半</li>
<li><code>spaceEvenly</code>: 均匀分配,相邻<code>widgets</code>间距离相同。每行第一个<code>widgets</code>到行首的距离和每行最后一个<code>widgets</code>到行尾的距离和相邻<code>widgets</code>之间距离相同</li>
</ul>
<table>
<thead>
<tr>
<th>属性</th>
<th>效果</th>
</tr>
</thead>
<tbody><tr>
<td><code>start</code></td>
<td><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/flutter/row_start.png" alt="start"></td>
</tr>
<tr>
<td><code>end</code></td>
<td><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/flutter/row_end.png" alt="end"></td>
</tr>
<tr>
<td><code>center</code></td>
<td><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/flutter/row_center.png" alt="center"></td>
</tr>
<tr>
<td><code>spaceBetween</code></td>
<td><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/flutter/row_between.png" alt="spaceBetween"></td>
</tr>
<tr>
<td><code>spaceAround</code></td>
<td><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/flutter/row_around.png" alt="spaceAround"></td>
</tr>
<tr>
<td><code>spaceEvenly</code></td>
<td><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/flutter/row_evenly.png" alt="spaceEvenly"></td>
</tr>
</tbody></table>
<h4 id="mainAxisSize"><a href="#mainAxisSize" class="headerlink" title="mainAxisSize"></a><code>mainAxisSize</code></h4><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认值</span></span><br><span class="line">MainAxisSize mainAxisSize = MainAxisSize.max</span><br></pre></td></tr></table></figure>

<ul>
<li>表示<code>Row</code>在主轴(水平)方向占用的空间，默认是<code>MainAxisSize.max</code></li>
<li><code>max</code>表示尽可能多的占用水平方向的空间，此时无论子<code>widgets</code>实际占用多少水平空间，<code>Row</code>的宽度始终等于水平方向的最大宽度；</li>
<li><code>MainAxisSize.min</code>表示尽可能少的占用水平空间，当子<code>widgets</code>没有占满水平剩余空间，则<code>Row</code>的实际宽度等于所有子<code>widgets</code>占用的的水平空间</li>
</ul>
<h4 id="verticalDirection"><a href="#verticalDirection" class="headerlink" title="verticalDirection"></a><code>verticalDirection</code></h4><p>表示Row纵轴（垂直）的对齐方向, 默认值<code>down</code>，表示从上到下; <code>up</code>表示从下到上</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认值</span></span><br><span class="line">VerticalDirection verticalDirection = VerticalDirection.down</span><br></pre></td></tr></table></figure>

<h4 id="crossAxisAlignment"><a href="#crossAxisAlignment" class="headerlink" title="crossAxisAlignment"></a><code>crossAxisAlignment</code></h4><ul>
<li>表示子<code>Widgets</code>在纵轴方向的对齐方式，<code>Row</code>的高度等于子<code>Widgets</code>中最高的子元素高度</li>
<li><code>crossAxisAlignment</code>的参考系是<code>verticalDirection</code></li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认值</span></span><br><span class="line">CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="language-markdown">/<span class="strong">**</span></span></span></span><br><span class="line"><span class="strong"><span class="language-markdown"><span class="comment"> <span class="emphasis">* VerticalDirection.down时, crossAxisAlignment.start指顶部对齐</span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="language-markdown"><span class="comment"> *</span> VerticalDirection.up时，crossAxisAlignment.start指底部对齐</span></span></span></span><br><span class="line"><span class="strong"><span class="language-markdown"><span class="comment"> <span class="emphasis">* crossAxisAlignment.end和crossAxisAlignment.start正好相反</span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="language-markdown"><span class="comment"> *</span>/</span></span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>当<code>VerticalDirection.down</code>时, <code>crossAxisAlignment</code>个枚举值如下</li>
<li><code>start</code>: 顶部对其</li>
<li><code>end</code>: 底部对其</li>
<li><code>center</code>: 居中对其</li>
<li><code>stretch</code>: 侧轴方向上, 子<code>Widget</code>的高度拉伸至和<code>Row</code>的高度相同</li>
<li><code>baseline</code>: 不论<code>VerticalDirection</code>取值如何, 子<code>Widget</code>的顶部和<code>Row</code>的顶部对其</li>
</ul>
<h4 id="textDirection"><a href="#textDirection" class="headerlink" title="textDirection"></a><code>textDirection</code></h4><p>表示水平方向子widget的布局顺序(是从左往右还是从右往左)，默认为系统当前Locale环境的文本方向(如中文、英语都是从左往右，而阿拉伯语是从右往左)</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">TextDirection textDirection</span><br><span class="line"><span class="comment"><span class="language-markdown">/<span class="strong">**</span></span></span></span><br><span class="line"><span class="strong"><span class="language-markdown"><span class="comment"> <span class="emphasis">* ltr: 从左往右</span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="language-markdown"><span class="comment"> *</span> rtl: 从右往左</span></span></span></span><br><span class="line"><span class="strong"><span class="language-markdown"><span class="comment"> <span class="emphasis">*/</span></span></span></span></span><br></pre></td></tr></table></figure>


<h4 id="textBaseline"><a href="#textBaseline" class="headerlink" title="textBaseline"></a><code>textBaseline</code></h4><p>用于对其文本的水平线, <a href="http://www.runoob.com/tags/canvas-textbaseline.html">详情可参考</a></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">TextBaseline textBaseline</span><br><span class="line"><span class="comment"><span class="language-markdown">/<span class="strong">**</span></span></span></span><br><span class="line"><span class="strong"><span class="language-markdown"><span class="comment"> <span class="emphasis">* alphabetic: 用于对齐普通的字母基线</span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="language-markdown"><span class="comment"> *</span> ideographic: 用于对齐表意基线</span></span></span></span><br><span class="line"><span class="strong"><span class="language-markdown"><span class="comment"> <span class="emphasis">*/</span></span></span></span></span><br></pre></td></tr></table></figure>

<h3 id="使用代码"><a href="#使用代码" class="headerlink" title="使用代码"></a>使用代码</h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Row(</span><br><span class="line">    mainAxisAlignment: MainAxisAlignment.spaceEvenly,</span><br><span class="line">    mainAxisSize: MainAxisSize.min,</span><br><span class="line">    crossAxisAlignment: CrossAxisAlignment.center,</span><br><span class="line">    textDirection: TextDirection.ltr,</span><br><span class="line">    verticalDirection: VerticalDirection.down,</span><br><span class="line">    textBaseline: TextBaseline.ideographic,</span><br><span class="line">    children: &lt;Widget&gt;[</span><br><span class="line">      <span class="keyword">new</span> Container(width: <span class="number">80.0</span>, height:<span class="number">80.0</span>, color: Colors.red,),</span><br><span class="line">      <span class="keyword">new</span> Container(width: <span class="number">80.0</span>, height:<span class="number">90.0</span>, color: Colors.green,),</span><br><span class="line">      <span class="keyword">new</span> Container(width: <span class="number">80.0</span>, height:<span class="number">100.0</span>, color: Colors.blue,),</span><br><span class="line">    ],</span><br><span class="line">)</span><br></pre></td></tr></table></figure>


<div class="note warning"><p>特别注意</p></div>

<p>在<code>Row</code>和<code>Column</code>中, 如果子<code>widget</code>超出屏幕范围，则会报溢出错误</p>
<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/flutter/row_column.png" alt="image"></p>
<h2 id="弹性布局"><a href="#弹性布局" class="headerlink" title="弹性布局"></a>弹性布局</h2><ul>
<li>弹性布局允许子<code>widget</code>按照一定比例来分配父容器空间</li>
<li><code>Flutter</code>中的弹性布局主要通过<code>Flex</code>和<code>Expanded</code>来配合实现</li>
<li><code>Flex</code>可以沿着水平或垂直方向排列子<code>widget</code></li>
<li>如果已知主轴方向，建议使用<code>Row</code>或<code>Column</code>，因为<code>Row</code>和<code>Column</code>都继承自<code>Flex</code>，参数基本相同，所以能使用<code>Flex</code>的地方一定可以使用<code>Row</code>或<code>Column</code></li>
<li><code>Flex</code>本身功能是很强大的，它也可以和<code>Expanded</code>配合实现弹性布局，接下来我们只讨论<code>Flex</code>和弹性布局相关的属性(其它属性已经在介绍<code>Row</code>和<code>Column</code>时介绍过了)</li>
</ul>
<h3 id="Flex"><a href="#Flex" class="headerlink" title="Flex"></a>Flex</h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Flex(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="comment">//弹性布局的方向</span></span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.direction,</span><br><span class="line">    <span class="keyword">this</span>.mainAxisAlignment = MainAxisAlignment.start,</span><br><span class="line">    <span class="keyword">this</span>.mainAxisSize = MainAxisSize.max,</span><br><span class="line">    <span class="keyword">this</span>.crossAxisAlignment = CrossAxisAlignment.center,</span><br><span class="line">    <span class="keyword">this</span>.textDirection,</span><br><span class="line">    <span class="keyword">this</span>.verticalDirection = VerticalDirection.down,</span><br><span class="line">    <span class="keyword">this</span>.textBaseline,</span><br><span class="line">    <span class="built_in">List</span>&lt;Widget&gt; children = <span class="keyword">const</span> &lt;Widget&gt;[],</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// direction</span></span><br><span class="line"><span class="comment">// 水平方向</span></span><br><span class="line">Axis direction = Axis.horizontal</span><br><span class="line"><span class="comment">// 垂直方向, 默认为垂直方向</span></span><br><span class="line">Axis direction = Axis.vertical</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>Flex</code>继承自<code>MultiChildRenderObjectWidget</code>，对应的<code>RenderObject</code>为<code>RenderFlex</code>，<code>RenderFlex</code>中实现了其布局算法</p>
</blockquote>
<h3 id="Expanded"><a href="#Expanded" class="headerlink" title="Expanded"></a>Expanded</h3><p>可以按比例缩放<code>Row</code>、<code>Column</code>和<code>Flex</code>子<code>widget</code>所占用的空间</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Expanded</span> <span class="keyword">extends</span> <span class="title">Flexible</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> Expanded(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="built_in">int</span> flex = <span class="number">1</span>,</span><br><span class="line">    <span class="meta">@required</span> Widget child,</span><br><span class="line">  &#125;) : <span class="keyword">super</span>(key: key, flex: flex, fit: FlexFit.tight, child: child);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>flex</code>为弹性系数，如果为0或<code>null</code>，则<code>child</code>是没有弹性的，即不会被扩伸占用的空间<br>如果大于0，所有的<code>Expanded</code>按照其<code>flex</code>的比例来分割主轴的全部空闲空间</p>
</blockquote>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Row(</span><br><span class="line">    children: &lt;Widget&gt;[</span><br><span class="line">      Container(width: <span class="number">80.0</span>, height:<span class="number">80.0</span>, color: Colors.red,),</span><br><span class="line">      Expanded(</span><br><span class="line">        flex: <span class="number">1</span>,</span><br><span class="line">        child: Container(width: <span class="number">80.0</span>, height:<span class="number">80.0</span>, color: Colors.blue,),</span><br><span class="line">      ),</span><br><span class="line">      Expanded(</span><br><span class="line">        flex: <span class="number">1</span>,</span><br><span class="line">        child: Container(width: <span class="number">80.0</span>, height:<span class="number">80.0</span>, color: Colors.yellow,),</span><br><span class="line">      )</span><br><span class="line">    ],</span><br><span class="line">  ),</span><br></pre></td></tr></table></figure>


<h2 id="流式布局"><a href="#流式布局" class="headerlink" title="流式布局"></a>流式布局</h2><ul>
<li>上面提到在<code>Row</code>和<code>Column</code>中, 如果子<code>widget</code>超出屏幕范围，则会报溢出错误</li>
<li>这是因为<code>Row</code>默认只有一行，如果超出屏幕不会折行</li>
<li>我们把超出屏幕显示范围会自动折行的布局称为流式布局</li>
<li><code>Flutter</code>中通过<code>Wrap</code>和<code>Flow</code>来支持流式布局</li>
</ul>
<h3 id="Wrap"><a href="#Wrap" class="headerlink" title="Wrap"></a>Wrap</h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Wrap(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="keyword">this</span>.direction = Axis.horizontal,</span><br><span class="line">    <span class="keyword">this</span>.alignment = WrapAlignment.start,</span><br><span class="line">    <span class="keyword">this</span>.spacing = <span class="number">0.0</span>,</span><br><span class="line">    <span class="keyword">this</span>.runAlignment = WrapAlignment.start,</span><br><span class="line">    <span class="keyword">this</span>.runSpacing = <span class="number">0.0</span>,</span><br><span class="line">    <span class="keyword">this</span>.crossAxisAlignment = WrapCrossAlignment.start,</span><br><span class="line">    <span class="keyword">this</span>.textDirection,</span><br><span class="line">    <span class="keyword">this</span>.verticalDirection = VerticalDirection.down,</span><br><span class="line">    <span class="built_in">List</span>&lt;Widget&gt; children = <span class="keyword">const</span> &lt;Widget&gt;[],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>可以看到<code>Wrap</code>中的很多属性和<code>Row</code>中相同, 这里就不在赘述了, 这里主要看一下<code>Wrap</code>中特有的属性</p>
<h4 id="alignment"><a href="#alignment" class="headerlink" title="alignment"></a>alignment</h4><p>子<code>Widget</code>在主轴上的对其方式</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认值</span></span><br><span class="line"><span class="keyword">this</span>.alignment = WrapAlignment.start</span><br><span class="line"><span class="comment">// 取值: start, end, center, spaceBetween, spaceAround, spaceEvenly</span></span><br></pre></td></tr></table></figure>

<h4 id="runAlignment"><a href="#runAlignment" class="headerlink" title="runAlignment"></a>runAlignment</h4><p>子<code>Widget</code>在纵轴上的对其方式</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认值</span></span><br><span class="line"><span class="keyword">this</span>.runAlignment = WrapAlignment.start</span><br><span class="line"><span class="comment">// 取值: start, end, center, spaceBetween, spaceAround, spaceEvenly</span></span><br></pre></td></tr></table></figure>

<h4 id="spacing"><a href="#spacing" class="headerlink" title="spacing"></a>spacing</h4><p>主轴方向子<code>widget</code>的间距: <code>spacing: 10</code></p>
<h4 id="runSpacing"><a href="#runSpacing" class="headerlink" title="runSpacing"></a>runSpacing</h4><p>纵轴方向子<code>widget</code>的间距: <code>runSpacing: 10</code></p>
<h3 id="Flow"><a href="#Flow" class="headerlink" title="Flow"></a>Flow</h3><ul>
<li>一般很少会使用<code>Flow</code>，因为其过于复杂，需要自己实现子<code>widget</code>的位置转换，在很多场景下首先要考虑的是<code>Wrap</code>是否满足需求</li>
<li><code>Flow</code>主要用于一些需要自定义布局的UI或性能要求较高(如动画中)的场景</li>
<li><code>Flow</code>有如下优点：<ul>
<li>性能好: <code>Flow</code>是一个对<code>child</code>尺寸以及位置调整非常高效的控件，<code>Flow</code>用转换矩阵对<code>child</code>进行位置调整的时候进行了优化</li>
<li>在<code>Flow</code>定位过后，如果<code>child</code>的尺寸或者位置发生了变化，在<code>FlowDelegate</code>中的<code>paintChildren()</code>方法中调用<code>context.paintChild</code> 进行重绘，而<code>context.paintChild</code>在重绘时使用了转换矩阵，并没有实际调整<code>Widget</code>位置。</li>
<li>灵活: 由于我们需要自己实现<code>FlowDelegate</code>的<code>paintChildren()</code>方法，所以我们需要自己计算每一个<code>widget</code>的位置，因此，可以实现自定义布局。</li>
</ul>
</li>
<li>缺点：<ul>
<li>使用复杂.</li>
<li>不能自适应子<code>widget</code>大小，必须通过指定父容器大小或重写<code>FlowDelegate</code>的<code>getSize</code>返回固定大小</li>
</ul>
</li>
<li>下面是一个简单的示例代码:</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlowWidget</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement build</span></span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      color: Colors.orange,</span><br><span class="line">      child: Flow(</span><br><span class="line">        delegate: ShowFlowDelegate(margin: EdgeInsets.all(<span class="number">10</span>)),</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          Container(width: <span class="number">100.0</span>, height:<span class="number">100.0</span>, color: Colors.red),</span><br><span class="line">          Container(width: <span class="number">100.0</span>, height:<span class="number">100.0</span>, color: Colors.yellow),</span><br><span class="line">          Container(width: <span class="number">100.0</span>, height:<span class="number">100.0</span>, color: Colors.blue),</span><br><span class="line">          Container(width: <span class="number">100.0</span>, height:<span class="number">100.0</span>, color: Colors.cyan),</span><br><span class="line">          Container(width: <span class="number">100.0</span>, height:<span class="number">100.0</span>, color: Colors.pink)</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现一个继承自<code>FlowDelegate</code>的类, 并重写响应的方法</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShowFlowDelegate</span> <span class="keyword">extends</span> <span class="title">FlowDelegate</span> </span>&#123;</span><br><span class="line">  EdgeInsets margin =EdgeInsets.zero;</span><br><span class="line">  ShowFlowDelegate(&#123;<span class="keyword">this</span>.margin&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> paintChildren(FlowPaintingContext context) &#123;</span><br><span class="line">    <span class="keyword">var</span> x = margin.left;</span><br><span class="line">    <span class="keyword">var</span> y = margin.top;</span><br><span class="line">    <span class="comment">//计算每一个子widget的位置  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; context.childCount; i++) &#123;</span><br><span class="line">      <span class="keyword">var</span> w = context.getChildSize(i).width + x + margin.right;</span><br><span class="line">      <span class="keyword">if</span> (w &lt; context.size.width) &#123;</span><br><span class="line">        context.paintChild(i,</span><br><span class="line">            transform: <span class="keyword">new</span> Matrix4.translationValues(</span><br><span class="line">                x, y, <span class="number">0.0</span>));</span><br><span class="line">        x = w + margin.left;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        x = margin.left;</span><br><span class="line">        y += context.getChildSize(i).height + margin.top + margin.bottom;</span><br><span class="line">        <span class="comment">//绘制子widget(有优化)  </span></span><br><span class="line">        context.paintChild(i,</span><br><span class="line">            transform: <span class="keyword">new</span> Matrix4.translationValues(</span><br><span class="line">                x, y, <span class="number">0.0</span>));</span><br><span class="line">         x += context.getChildSize(i).width + margin.left + margin.right;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Size getSize(BoxConstraints constraints) &#123;</span><br><span class="line">    <span class="comment">// 设置Flow的大小</span></span><br><span class="line">    <span class="keyword">return</span> Size(<span class="built_in">double</span>.infinity, <span class="number">300</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">bool</span> shouldRepaint(FlowDelegate oldDelegate) &#123;</span><br><span class="line">    <span class="keyword">return</span> oldDelegate !=<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="层叠布局"><a href="#层叠布局" class="headerlink" title="层叠布局"></a>层叠布局</h2><ul>
<li>层叠布局和<code>Web</code>中的绝对定位、<code>iOS</code>中的<code>Frame</code>布局是相似的，子<code>widget</code>可以根据到父容器四个角的位置来确定本身的位置</li>
<li>绝对定位允许子<code>widget</code>堆叠（按照代码中声明的顺序）</li>
<li><code>Flutter</code>中使用<code>Stack</code>和<code>Positioned</code>来实现绝对定位，<code>Stack</code>允许子<code>widget</code>堆叠，而<code>Positioned</code>可以给子<code>widget</code>定位</li>
</ul>
<h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Stack(&#123;</span><br><span class="line">  Key key,</span><br><span class="line">  <span class="keyword">this</span>.alignment = AlignmentDirectional.topStart,</span><br><span class="line">  <span class="keyword">this</span>.textDirection,</span><br><span class="line">  <span class="keyword">this</span>.fit = StackFit.loose,</span><br><span class="line">  <span class="keyword">this</span>.overflow = Overflow.clip,</span><br><span class="line">  <span class="built_in">List</span>&lt;Widget&gt; children = <span class="keyword">const</span> &lt;Widget&gt;[],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="alignment-1"><a href="#alignment-1" class="headerlink" title="alignment"></a>alignment</h4><p>决定子<code>Widget</code>在<code>Stack</code>中的定位</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认值</span></span><br><span class="line"><span class="keyword">this</span>.alignment = AlignmentDirectional.topStart</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取值如下, start和end为水平方向, top和bottom是垂直方向</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> AlignmentDirectional topStart = AlignmentDirectional(<span class="number">-1.0</span>, <span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> AlignmentDirectional topCenter = AlignmentDirectional(<span class="number">0.0</span>, <span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> AlignmentDirectional topEnd = AlignmentDirectional(<span class="number">1.0</span>, <span class="number">-1.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> AlignmentDirectional centerStart = AlignmentDirectional(<span class="number">-1.0</span>, <span class="number">0.0</span>);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> AlignmentDirectional center = AlignmentDirectional(<span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> AlignmentDirectional centerEnd = AlignmentDirectional(<span class="number">1.0</span>, <span class="number">0.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> AlignmentDirectional bottomStart = AlignmentDirectional(<span class="number">-1.0</span>, <span class="number">1.0</span>);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> AlignmentDirectional bottomCenter = AlignmentDirectional(<span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> AlignmentDirectional bottomEnd = AlignmentDirectional(<span class="number">1.0</span>, <span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 还可以使用具体数值比例定位, 设置值在0~1之间</span></span><br><span class="line">AlignmentDirectional(<span class="number">0.8</span>, <span class="number">0.9</span>)</span><br></pre></td></tr></table></figure>

<h4 id="textDirection-1"><a href="#textDirection-1" class="headerlink" title="textDirection"></a>textDirection</h4><p>决定<code>alignment</code>对齐的参考系</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认ltr</span></span><br><span class="line">textDirection: TextDirection.ltr</span><br><span class="line"></span><br><span class="line"><span class="comment">// textDirection的值为TextDirection.ltr，则alignment的start代表左，end代表右</span></span><br><span class="line"><span class="comment">// textDirection的值为TextDirection.rtl，则alignment的start代表右，end代表左</span></span><br></pre></td></tr></table></figure>

<h4 id="fit"><a href="#fit" class="headerlink" title="fit"></a>fit</h4><p>用于决定没有定位的子<code>widget</code>如何去适应<code>Stack</code>的大小</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认值</span></span><br><span class="line"><span class="keyword">this</span>.fit = StackFit.loose</span><br><span class="line"></span><br><span class="line"><span class="comment">// StackFit.loose表示使用子widget的大小</span></span><br><span class="line"><span class="comment">// StackFit.expand表示扩伸到Stack的大小</span></span><br></pre></td></tr></table></figure>

<h4 id="overflow"><a href="#overflow" class="headerlink" title="overflow"></a>overflow</h4><p>决定如何显示超出<code>Stack</code>显示空间的子<code>widget</code></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认值</span></span><br><span class="line"><span class="keyword">this</span>.overflow = Overflow.clip</span><br><span class="line"></span><br><span class="line"><span class="comment">// Overflow.clip时，超出部分会被剪裁（隐藏)</span></span><br><span class="line"><span class="comment">// Overflow.visible时，时则不会被剪裁</span></span><br></pre></td></tr></table></figure>

<h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Stack(</span><br><span class="line">  <span class="comment">// alignment: AlignmentDirectional.center,</span></span><br><span class="line">  alignment: AlignmentDirectional(<span class="number">0.8</span>, <span class="number">0.8</span>),</span><br><span class="line">  textDirection: TextDirection.ltr,</span><br><span class="line">  fit: StackFit.loose,</span><br><span class="line">  overflow: Overflow.visible,</span><br><span class="line">  children: &lt;Widget&gt;[</span><br><span class="line">    Container(width: <span class="number">100.0</span>, height:<span class="number">100.0</span>, color: Colors.red),</span><br><span class="line">    Container(width: <span class="number">100.0</span>, height:<span class="number">100.0</span>, color: Colors.yellow),</span><br><span class="line">  ],</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="Positioned"><a href="#Positioned" class="headerlink" title="Positioned"></a>Positioned</h3><p><code>Positioned</code>和<code>iOS</code>中的<code>Frame</code>设置位置和大小一样, 根据上下左右和宽高设置<code>Widget</code>的定位和大小</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Positioned(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="keyword">this</span>.left,</span><br><span class="line">    <span class="keyword">this</span>.top,</span><br><span class="line">    <span class="keyword">this</span>.right,</span><br><span class="line">    <span class="keyword">this</span>.bottom,</span><br><span class="line">    <span class="keyword">this</span>.width,</span><br><span class="line">    <span class="keyword">this</span>.height,</span><br><span class="line">    <span class="meta">@required</span> Widget child,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>left、top 、right、 bottom</code>分别代表离Stack左、上、右、底四边的距离, <code>width</code>和<code>height</code>用于指定定位元素的宽度和高度</p>
</blockquote>
<blockquote>
<p>注意，此处的width、height 和其它地方的意义稍微有点区别，此处用于配合left、top 、right、 bottom来定位widget，举个例子，在水平方向时，你只能指定left、right、width三个属性中的两个，如指定left和width后，right会自动算出(left+width)，如果同时指定三个属性则会报错，垂直方向同理</p>
</blockquote>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">child: Stack(</span><br><span class="line">  alignment: AlignmentDirectional.center,</span><br><span class="line">  children: &lt;Widget&gt;[</span><br><span class="line">    <span class="comment">// 这个widget会根据alignment的设置展示</span></span><br><span class="line">    Container(child: Text(<span class="string">&#x27;https&#x27;</span>, style: TextStyle(color: Colors.red)), color: Colors.yellow,),</span><br><span class="line">    <span class="comment">// 这个widget会根据left和top和width的设置显示和alignment无关了, 实际width为80</span></span><br><span class="line">    Positioned(</span><br><span class="line">      left: <span class="number">10</span>,</span><br><span class="line">      top: <span class="number">30</span>,</span><br><span class="line">      width: <span class="number">80</span>,</span><br><span class="line">      child: Container(width: <span class="number">100.0</span>, height:<span class="number">100.0</span>, color: Colors.red),</span><br><span class="line">    ),</span><br><span class="line">    Positioned(</span><br><span class="line">      right: <span class="number">10</span>,</span><br><span class="line">      bottom: <span class="number">50</span>,</span><br><span class="line">      child: Container(width: <span class="number">100.0</span>, height:<span class="number">100.0</span>, color: Colors.blue),</span><br><span class="line">    )</span><br><span class="line">  ],</span><br><span class="line">),</span><br></pre></td></tr></table></figure>

<blockquote>
<p>至此, <code>Flutter</code>中布局相关的<code>Widget</code>也都学习完了……接下来就是容器类<code>Widget</code>了</p>
</blockquote>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://book.flutterchina.club/chapter5/">Flutter实战</a></li>
<li><a href="https://flutterchina.club/widgets/layout/">Flutter中文网</a></li>
</ul>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
        <tag>Widget</tag>
        <tag>Dart</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter之可滑动Widget</title>
    <url>/post/3ab4e07d.html</url>
    <content><![CDATA[<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/flutter/flutter_scroll.png" alt="可滚动Widget"></p>
<span id="more"></span>

<ul>
<li><a href="https://www.titanjun.top/categories/Flutter%E7%AC%94%E8%AE%B0/">Flutter和Dart系列文章</a>和<a href="https://github.com/CoderTitan/Flutter_Widget">代码GitHub地址</a></li>
<li>在<code>Flutter</code>中, 当内容超过显示视图时，如果没有特殊处理，<code>Flutter</code>则会提示<code>Overflow</code>错误</li>
<li><code>Flutter</code>提供了多种可滚动（<code>Scrollable Widget</code>）用于显示列表和长布局</li>
<li>可滚动<code>Widget</code>都直接或间接包含一个<code>Scrollable</code>, 下面是常用的几个可滚动的<code>Widget</code><ul>
<li><code>SingleChildScrollView</code></li>
<li><code>ListView</code></li>
<li><code>GridView</code></li>
<li><code>CustomScrollView</code></li>
<li>滚动监听及控制<code>ScrollController</code></li>
</ul>
</li>
</ul>
<h2 id="Scrollbar"><a href="#Scrollbar" class="headerlink" title="Scrollbar"></a>Scrollbar</h2><ul>
<li><code>Scrollbar</code>是一个<code>Material</code>风格的滚动指示器（滚动条），如果要给可滚动<code>widget</code>添加滚动条，只需将<code>Scrollbar</code>作为可滚动<code>widget</code>的父<code>widget</code>即可</li>
<li><code>CupertinoScrollbar</code>是<code>iOS</code>风格的滚动条，如果你使用的是<code>Scrollbar</code>，那么在<code>iOS</code>平台它会自动切换为<code>CupertinoScrollbar</code></li>
<li><code>Scrollbar</code>和<code>CupertinoScrollbar</code>都是通过<code>ScrollController</code>来监听滚动事件来确定滚动条位置，关于<code>ScrollController</code>详细的内容我们将在后面专门一节介绍</li>
<li>下面是<code>Scrollbar</code>和<code>CupertinoScrollbar</code>的构造函数, 都只有一个<code>child</code>属性, 用于接受一个可滚动的<code>Widget</code></li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Scrollbar(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.child,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> CupertinoScrollbar(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.child,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<div class="note info"><p>主轴和纵轴</p></div>

<ul>
<li>在可滚动<code>widget</code>的坐标描述中，通常将滚动方向称为主轴，非滚动方向称为纵轴。</li>
<li>由于可滚动<code>widget</code>的默认方向一般都是沿垂直方向，所以默认情况下主轴就是指垂直方向，水平方向同理</li>
</ul>
<h2 id="SingleChildScrollView"><a href="#SingleChildScrollView" class="headerlink" title="SingleChildScrollView"></a>SingleChildScrollView</h2><p><code>SingleChildScrollView</code>类似于开发中常用的<code>ScrollView</code>, 不再详细介绍了, 下面看一下具体使用介绍吧</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> SingleChildScrollView(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="comment">// 设置滚动的方向, 默认垂直方向</span></span><br><span class="line">    <span class="keyword">this</span>.scrollDirection = Axis.vertical,</span><br><span class="line">    <span class="comment">// 设置显示方式</span></span><br><span class="line">    <span class="keyword">this</span>.reverse = <span class="keyword">false</span>,</span><br><span class="line">    <span class="comment">// 内边距</span></span><br><span class="line">    <span class="keyword">this</span>.padding,</span><br><span class="line">    <span class="comment">// 是否使用默认的controller</span></span><br><span class="line">    <span class="built_in">bool</span> primary,</span><br><span class="line">    <span class="comment">// 设置可滚动Widget如何响应用户操作</span></span><br><span class="line">    <span class="keyword">this</span>.physics,</span><br><span class="line">    <span class="keyword">this</span>.controller,</span><br><span class="line">    <span class="keyword">this</span>.child,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="scrollDirection"><a href="#scrollDirection" class="headerlink" title="scrollDirection"></a>scrollDirection</h3><p>设置视图的滚动方向(默认垂直方向), 需要对应的设置其子<code>Widget</code>是<code>Column</code>或者<code>Row</code>, 否则会报<code>Overflow</code>错误</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">scrollDirection: Axis.vertical,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举值</span></span><br><span class="line"><span class="keyword">enum</span> Axis &#123;</span><br><span class="line">  <span class="comment">/// <span class="language-markdown">水平滚动</span></span></span><br><span class="line">  horizontal,</span><br><span class="line">  <span class="comment">/// <span class="language-markdown">垂直滚动</span></span></span><br><span class="line">  vertical,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h3><ul>
<li>是否按照阅读方向相反的方向滑动</li>
<li>设置水平滚动时<ul>
<li>若<code>reverse: false</code>，则滚动内容头部和左侧对其, 那么滑动方向就是从左向右</li>
<li><code>reverse: true</code>时，则滚动内容尾部和右侧对其, 那么滑动方向就是从右往左。</li>
</ul>
</li>
<li>其实此属性本质上是决定可滚动<code>widget</code>的初始滚动位置是在头还是尾，取<code>false</code>时，初始滚动位置在头，反之则在尾</li>
</ul>
<h3 id="physics"><a href="#physics" class="headerlink" title="physics"></a>physics</h3><ul>
<li>此属性接受一个<code>ScrollPhysics</code>对象，它决定可滚动<code>Widget</code>如何响应用户操作</li>
<li>比如用户滑动完抬起手指后，继续执行动画；或者滑动到边界时，如何显示。</li>
<li>默认情况下，<code>Flutter</code>会根据具体平台分别使用不同的<code>ScrollPhysics</code>对象，应用不同的显示效果，如当滑动到边界时，继续拖动的话，在<code>iOS</code>上会出现弹性效果，而在<code>Android</code>上会出现微光效果。</li>
<li>如果你想在所有平台下使用同一种效果，可以显式指定，<code>Flutter SDK</code>中包含了两个<code>ScrollPhysics</code>的子类可以直接使用：<ul>
<li><code>ClampingScrollPhysics</code>：安卓下微光效果。</li>
<li><code>BouncingScrollPhysics</code>：<code>iOS</code>下弹性效果。</li>
</ul>
</li>
</ul>
<h3 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h3><ul>
<li>此属性接受一个<code>ScrollController</code>对象</li>
<li><code>ScrollController</code>的主要作用是控制滚动位置和监听滚动事件。</li>
<li>默认情况下，<code>widget</code>中会有一个默认的<code>PrimaryScrollController</code>，如果子<code>widget</code>中的可滚动<code>widget</code>没有显式的指定<code>controller</code>并且<code>primary</code>属性值为<code>true</code>时（默认就为<code>true</code>），可滚动<code>widget</code>会使用这个默认的<code>PrimaryScrollController</code></li>
<li>这种机制带来的好处是父<code>widget</code>可以控制子树中可滚动<code>widget</code>的滚动，例如，<code>Scaffold</code>使用这种机制在<code>iOS</code>中实现了”回到顶部”的手势</li>
</ul>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScrollView</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="built_in">String</span> str = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> Scrollbar(</span><br><span class="line">      child: SingleChildScrollView(</span><br><span class="line">        scrollDirection: Axis.vertical,</span><br><span class="line">        reverse: <span class="keyword">true</span>,</span><br><span class="line">        padding: EdgeInsets.all(<span class="number">0.0</span>),</span><br><span class="line">        physics: BouncingScrollPhysics(),</span><br><span class="line">        child: Center(</span><br><span class="line">          child: Column( </span><br><span class="line">            <span class="comment">//动态创建一个List&lt;Widget&gt;  </span></span><br><span class="line">            children: str.split(<span class="string">&quot;&quot;</span>) </span><br><span class="line">                <span class="comment">//每一个字母都用一个Text显示,字体为原来的两倍</span></span><br><span class="line">                .map((c) =&gt; Text(c, textScaleFactor: <span class="number">2.0</span>)) </span><br><span class="line">                .toList(),</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="ListView"><a href="#ListView" class="headerlink" title="ListView"></a>ListView</h2><ul>
<li><code>ListView</code>是最常用的可滚动<code>widget</code>，它可以沿一个方向线性排布所有子<code>widget</code>, 类似于<code>ReactNative</code>中的<code>ListView</code></li>
<li><code>ListView</code>共有四种构造函数<ul>
<li><code>ListView()</code>默认构造函数</li>
<li><code>ListView.builder()</code></li>
<li><code>ListView.separated()</code></li>
<li><code>ListView custom()</code></li>
</ul>
</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">ListView(&#123;</span><br><span class="line">    <span class="comment">// 公共参数上面都介绍过了</span></span><br><span class="line">    Key key,</span><br><span class="line">    Axis scrollDirection = Axis.vertical,</span><br><span class="line">    <span class="built_in">bool</span> reverse = <span class="keyword">false</span>,</span><br><span class="line">    ScrollController controller,</span><br><span class="line">    <span class="built_in">bool</span> primary,</span><br><span class="line">    ScrollPhysics physics,</span><br><span class="line">    EdgeInsetsGeometry padding,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 是否根据子widget的总长度来设置ListView的长度，默认值为false</span></span><br><span class="line">    <span class="built_in">bool</span> shrinkWrap = <span class="keyword">false</span>,</span><br><span class="line">    <span class="comment">// cell高度</span></span><br><span class="line">    <span class="keyword">this</span>.itemExtent,</span><br><span class="line">    <span class="comment">// 子widget是否包裹在AutomaticKeepAlive中</span></span><br><span class="line">    <span class="built_in">bool</span> addAutomaticKeepAlives = <span class="keyword">true</span>,</span><br><span class="line">    <span class="comment">// 子widget是否包裹在RepaintBoundary中</span></span><br><span class="line">    <span class="built_in">bool</span> addRepaintBoundaries = <span class="keyword">true</span>,</span><br><span class="line">    <span class="built_in">bool</span> addSemanticIndexes = <span class="keyword">true</span>,</span><br><span class="line">    <span class="comment">// 设置预加载的区域, moren 0.0</span></span><br><span class="line">    <span class="built_in">double</span> cacheExtent,</span><br><span class="line">    <span class="comment">//子widget列表</span></span><br><span class="line">    <span class="built_in">List</span>&lt;Widget&gt; children = <span class="keyword">const</span> &lt;Widget&gt;[],</span><br><span class="line">    <span class="comment">// 子widget的个数</span></span><br><span class="line">    <span class="built_in">int</span> semanticChildCount,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="属性介绍"><a href="#属性介绍" class="headerlink" title="属性介绍"></a>属性介绍</h3><h4 id="shrinkWrap"><a href="#shrinkWrap" class="headerlink" title="shrinkWrap"></a>shrinkWrap</h4><ul>
<li>表示是否根据子<code>widget</code>的总长度来设置<code>ListView</code>的长度，默认值为<code>false</code> 。</li>
<li>默认情况下，<code>ListView</code>的会在滚动方向尽可能多的占用空间</li>
<li>当<code>ListView</code>在一个无边界(滚动方向上)的容器中时，<code>shrinkWrap</code>必须为<code>true</code></li>
</ul>
<h4 id="itemExtent"><a href="#itemExtent" class="headerlink" title="itemExtent"></a>itemExtent</h4><ul>
<li>该参数如果不为<code>null</code>，则会强制<code>children</code>的”长度”为<code>itemExtent</code>的值</li>
<li>这里的”长度”是指滚动方向上子<code>widget</code>的长度，即如果滚动方向是垂直方向，则代表子<code>widget</code>的高度，如果滚动方向为水平方向，则代表子<code>widget</code>的长度</li>
<li>在<code>ListView</code>中，指定<code>itemExtent</code>比让子<code>widget</code>自己决定自身长度会更高效，这是因为指定<code>itemExtent</code>后，滚动系统可以提前知道列表的长度，而不是总是动态去计算，尤其是在滚动位置频繁变化时</li>
</ul>
<h4 id="addAutomaticKeepAlives"><a href="#addAutomaticKeepAlives" class="headerlink" title="addAutomaticKeepAlives"></a>addAutomaticKeepAlives</h4><ul>
<li>表示是否将列表项包裹在<code>AutomaticKeepAlive</code>中</li>
<li>在一个懒加载列表中，如果将列表项包裹在<code>AutomaticKeepAlive</code>中，在该列表项滑出视口时该列表项不会被GC，它会使用<code>KeepAliveNotification</code>来保存其状态</li>
<li>如果列表项自己维护其<code>KeepAlive</code>状态，那么此参数必须置为<code>false</code></li>
</ul>
<h4 id="addRepaintBoundaries"><a href="#addRepaintBoundaries" class="headerlink" title="addRepaintBoundaries"></a>addRepaintBoundaries</h4><ul>
<li>性表示是否将列表项包裹在<code>RepaintBoundary</code>中</li>
<li>当可滚动<code>widget</code>滚动时，将列表项包裹在<code>RepaintBoundary</code>中可以避免列表项重绘，但是当列表项重绘的开销非常小（如一个颜色块，或者一个较短的文本）时，不添加<code>RepaintBoundary</code>反而会更高效</li>
<li>和<code>addAutomaticKeepAlive</code>一样，如果列表项自己维护其<code>KeepAlive</code>状态，那么此参数必须置为<code>false</code></li>
</ul>
<h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScrollView</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> ListView(</span><br><span class="line">      itemExtent: <span class="number">60</span>,</span><br><span class="line">      cacheExtent: <span class="number">100</span>,</span><br><span class="line">      addAutomaticKeepAlives: <span class="keyword">false</span>,</span><br><span class="line">      children: renderCell(),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">List</span>&lt;Widget&gt; renderCell() &#123;</span><br><span class="line">    <span class="built_in">String</span> str = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> str.split(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    .map((item) =&gt; ListTile(</span><br><span class="line">      title: Text(<span class="string">&#x27;字母--<span class="subst">$item</span>&#x27;</span>),</span><br><span class="line">      subtitle: Text(<span class="string">&#x27;这是字母列表&#x27;</span>),</span><br><span class="line">      leading: Icon(Icons.wifi),</span><br><span class="line">    )).toList();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ListTile"><a href="#ListTile" class="headerlink" title="ListTile"></a>ListTile</h3><ul>
<li><code>ListTile</code>是<code>Flutter</code>给我们准备好的用于创建<code>ListView</code>的子<code>widget</code> </li>
<li>提供非常常见的构造和定义方式，包括文字，icon，点击事件，一般是能够满足基本需求，但是就不能自己定义了</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ListTile(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="comment">// 前置(左侧)图标, Widget类型</span></span><br><span class="line">    <span class="keyword">this</span>.leading,</span><br><span class="line">    <span class="comment">// 标题, Widget类型</span></span><br><span class="line">    <span class="keyword">this</span>.title,</span><br><span class="line">    <span class="comment">// 副标题, Widget类型</span></span><br><span class="line">    <span class="keyword">this</span>.subtitle,</span><br><span class="line">    <span class="comment">// 后置(右侧)图标, Widget类型</span></span><br><span class="line">    <span class="keyword">this</span>.trailing,</span><br><span class="line">    <span class="comment">// 是否三行显示, subtitle不为空时才能使用</span></span><br><span class="line">    <span class="keyword">this</span>.isThreeLine = <span class="keyword">false</span>,</span><br><span class="line">    <span class="comment">// 设置为true后字体变小</span></span><br><span class="line">    <span class="keyword">this</span>.dense,</span><br><span class="line">    <span class="comment">// 内容的内边距</span></span><br><span class="line">    <span class="keyword">this</span>.contentPadding,</span><br><span class="line">    <span class="comment">// 是否可被点击</span></span><br><span class="line">    <span class="keyword">this</span>.enabled = <span class="keyword">true</span>,</span><br><span class="line">    <span class="comment">// 点击事件</span></span><br><span class="line">    <span class="keyword">this</span>.onTap,</span><br><span class="line">    <span class="comment">// 长按操作事件</span></span><br><span class="line">    <span class="keyword">this</span>.onLongPress,</span><br><span class="line">    <span class="comment">// 是否是选中状态</span></span><br><span class="line">    <span class="keyword">this</span>.selected = <span class="keyword">false</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="keyword">return</span> ListTile(</span><br><span class="line">  title: Text(<span class="string">&#x27;index--<span class="subst">$index</span>&#x27;</span>),</span><br><span class="line">  subtitle: Text(<span class="string">&#x27;我是一只小鸭子, 咿呀咿呀哟; 我是一只小鸭子, 咿呀咿呀哟; 我是一只小鸭子, 咿呀咿呀哟;&#x27;</span>),</span><br><span class="line">  leading: Icon(Icons.wifi),</span><br><span class="line">  trailing: Icon(Icons.keyboard_arrow_right),</span><br><span class="line">  isThreeLine: <span class="keyword">true</span>,</span><br><span class="line">  dense: <span class="keyword">false</span>,</span><br><span class="line">  contentPadding: EdgeInsets.all(<span class="number">10</span>),</span><br><span class="line">  enabled: index % <span class="number">3</span> != <span class="number">0</span>,</span><br><span class="line">  onTap: () =&gt; <span class="built_in">print</span>(<span class="string">&#x27;index = <span class="subst">$index</span>&#x27;</span>),</span><br><span class="line">  onLongPress: () =&gt; <span class="built_in">print</span>(<span class="string">&#x27;long-Index = <span class="subst">$index</span>&#x27;</span>),</span><br><span class="line">  selected: index % <span class="number">2</span> == <span class="number">0</span>,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>


<h3 id="ListView-builder"><a href="#ListView-builder" class="headerlink" title="ListView.builder"></a>ListView.builder</h3><ul>
<li><code>ListView.builder</code>适合列表项比较多（或者无限）的情况，因为只有当子<code>Widget</code>真正显示的时候才会被创建</li>
<li>适用于自定义子<code>Widget</code>且所有子<code>Widget</code>的样式一样</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">ListView.builder(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    Axis scrollDirection = Axis.vertical,</span><br><span class="line">    <span class="built_in">bool</span> reverse = <span class="keyword">false</span>,</span><br><span class="line">    ScrollController controller,</span><br><span class="line">    <span class="built_in">bool</span> primary,</span><br><span class="line">    ScrollPhysics physics,</span><br><span class="line">    <span class="built_in">bool</span> shrinkWrap = <span class="keyword">false</span>,</span><br><span class="line">    EdgeInsetsGeometry padding,</span><br><span class="line">    <span class="keyword">this</span>.itemExtent,</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="meta">@required</span> IndexedWidgetBuilder itemBuilder,</span><br><span class="line">    <span class="comment">// 列表项的数量，如果为null，则为无限列表</span></span><br><span class="line">    <span class="built_in">int</span> itemCount,</span><br><span class="line">    <span class="built_in">bool</span> addAutomaticKeepAlives = <span class="keyword">true</span>,</span><br><span class="line">    <span class="built_in">bool</span> addRepaintBoundaries = <span class="keyword">true</span>,</span><br><span class="line">    <span class="built_in">bool</span> addSemanticIndexes = <span class="keyword">true</span>,</span><br><span class="line">    <span class="built_in">double</span> cacheExtent,</span><br><span class="line">    <span class="built_in">int</span> semanticChildCount,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="itemCount"><a href="#itemCount" class="headerlink" title="itemCount"></a>itemCount</h4><p>列表项的数量，如果为null，则为无限列表</p>
<h4 id="itemBuilder"><a href="#itemBuilder" class="headerlink" title="itemBuilder"></a>itemBuilder</h4><ul>
<li>它是列表项的构建器，类型为<code>IndexedWidgetBuilder</code>，返回值为一个<code>widget</code></li>
<li>当列表滚动到具体的<code>index</code>位置时，会调用该构建器构建列表项</li>
</ul>
<h4 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListBuild</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    Widget build(BuildContext context) &#123;</span><br><span class="line">      <span class="keyword">return</span> ListView.builder(</span><br><span class="line">        itemCount: <span class="number">30</span>,</span><br><span class="line">        itemBuilder: (content, index) &#123;</span><br><span class="line">          <span class="keyword">return</span> ListTile(</span><br><span class="line">            title: Text(<span class="string">&#x27;index--<span class="subst">$index</span>&#x27;</span>),</span><br><span class="line">            subtitle: Text(<span class="string">&#x27;数字列表&#x27;</span>),</span><br><span class="line">            leading: Icon(Icons.wifi),</span><br><span class="line">          );</span><br><span class="line">        &#125;,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ListView-separated"><a href="#ListView-separated" class="headerlink" title="ListView.separated"></a>ListView.separated</h3><p><code>ListView.separated</code>可以生成列表项之间的分割器，它除了比<code>ListView.builder</code>多了一个<code>separatorBuilder</code>参数外, 其他参数都一样</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">ListView.separated(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    Axis scrollDirection = Axis.vertical,</span><br><span class="line">    <span class="built_in">bool</span> reverse = <span class="keyword">false</span>,</span><br><span class="line">    ScrollController controller,</span><br><span class="line">    <span class="built_in">bool</span> primary,</span><br><span class="line">    ScrollPhysics physics,</span><br><span class="line">    <span class="built_in">bool</span> shrinkWrap = <span class="keyword">false</span>,</span><br><span class="line">    EdgeInsetsGeometry padding,</span><br><span class="line">    <span class="meta">@required</span> IndexedWidgetBuilder itemBuilder,</span><br><span class="line">    <span class="comment">// 一个分割生成器</span></span><br><span class="line">    <span class="meta">@required</span> IndexedWidgetBuilder separatorBuilder,</span><br><span class="line">    <span class="meta">@required</span> <span class="built_in">int</span> itemCount,</span><br><span class="line">    <span class="built_in">bool</span> addAutomaticKeepAlives = <span class="keyword">true</span>,</span><br><span class="line">    <span class="built_in">bool</span> addRepaintBoundaries = <span class="keyword">true</span>,</span><br><span class="line">    <span class="built_in">bool</span> addSemanticIndexes = <span class="keyword">true</span>,</span><br><span class="line">    <span class="built_in">double</span> cacheExtent,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="separatorBuilder"><a href="#separatorBuilder" class="headerlink" title="separatorBuilder"></a>separatorBuilder</h4><p>该参数是一个分割生成器, 同样是一个<code>IndexedWidgetBuilder</code>类型的参数</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> IndexedWidgetBuilder = Widget <span class="built_in">Function</span>(BuildContext context, <span class="built_in">int</span> index);</span><br></pre></td></tr></table></figure>

<h4 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h4><p>奇数行添加一条红色下划线，偶数行添加一条蓝色下划线。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">lass SeparatedList <span class="keyword">extends</span> StatelessWidget &#123;</span><br><span class="line">  <span class="comment">//下划线widget预定义以供复用。  </span></span><br><span class="line">  Widget lineView1 = Divider(color: Colors.red, height: <span class="number">2</span>, indent: <span class="number">10</span>,);</span><br><span class="line">  Widget lineView2 = Divider(color: Colors.blue, height: <span class="number">5</span>, indent: <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement build</span></span><br><span class="line">    <span class="keyword">return</span> ListView.separated(</span><br><span class="line">      itemCount: <span class="number">30</span>,</span><br><span class="line">        itemBuilder: (content, index) &#123;</span><br><span class="line">          <span class="keyword">return</span> ListTile(</span><br><span class="line">            title: Text(<span class="string">&#x27;index--<span class="subst">$index</span>&#x27;</span>),</span><br><span class="line">            subtitle: Text(<span class="string">&#x27;数字列表&#x27;</span>),</span><br><span class="line">            leading: Icon(Icons.wifi),</span><br><span class="line">          );</span><br><span class="line">        &#125;,</span><br><span class="line">        separatorBuilder: (context, index) &#123;</span><br><span class="line">          <span class="keyword">return</span> index % <span class="number">2</span> == <span class="number">0</span> ? lineView1 : lineView2;</span><br><span class="line">        &#125;,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Divider"><a href="#Divider" class="headerlink" title="Divider"></a>Divider</h3><p>设置每一个子<code>WIdget</code>的分割线</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Divider(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="comment">// 分割线所在的SizedBox的高度, 除内边距之外的距离上面的间距</span></span><br><span class="line">    <span class="keyword">this</span>.height = <span class="number">16.0</span>,</span><br><span class="line">    <span class="comment">// 分割线左侧间距</span></span><br><span class="line">    <span class="keyword">this</span>.indent = <span class="number">0.0</span>,</span><br><span class="line">    <span class="comment">// 分割线颜色</span></span><br><span class="line">    <span class="keyword">this</span>.color</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="ListView-custom"><a href="#ListView-custom" class="headerlink" title="ListView.custom"></a>ListView.custom</h3><ul>
<li>大家可能对前两种比较熟悉，分别是传入一个子元素列表或是传入一个根据索引创建子元素的函数。</li>
<li>其实前两种方式都是<code>custom</code>方式的“快捷方式”</li>
<li><code>ListView</code>内部是靠这个<code>childrenDelegate</code>属性动态初始化子元素的</li>
<li>我们使用<code>builder</code>和<code>separated</code>比较多，这个<code>custom</code>相对来说就比较少了</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ListView.custom(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    Axis scrollDirection = Axis.vertical,</span><br><span class="line">    <span class="built_in">bool</span> reverse = <span class="keyword">false</span>,</span><br><span class="line">    ScrollController controller,</span><br><span class="line">    <span class="built_in">bool</span> primary,</span><br><span class="line">    ScrollPhysics physics,</span><br><span class="line">    <span class="built_in">bool</span> shrinkWrap = <span class="keyword">false</span>,</span><br><span class="line">    EdgeInsetsGeometry padding,</span><br><span class="line">    <span class="keyword">this</span>.itemExtent,</span><br><span class="line">    <span class="comment">// 动态初始化子元素</span></span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.childrenDelegate,</span><br><span class="line">    <span class="built_in">double</span> cacheExtent,</span><br><span class="line">    <span class="built_in">int</span> semanticChildCount,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="childrenDelegate"><a href="#childrenDelegate" class="headerlink" title="childrenDelegate"></a>childrenDelegate</h4><p>其实在<code>ListView</code>的前面几种构造函数中, 都默认设置了<code>childrenDelegate</code>这个属性, 更多可参考官方文档</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ListView</span></span><br><span class="line">ListView(&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;) : childrenDelegate = SliverChildListDelegate(</span><br><span class="line">         children,</span><br><span class="line">         addAutomaticKeepAlives: addAutomaticKeepAlives,</span><br><span class="line">         addRepaintBoundaries: addRepaintBoundaries,</span><br><span class="line">         addSemanticIndexes: addSemanticIndexes,</span><br><span class="line">       ), <span class="keyword">super</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ListView.builder</span></span><br><span class="line">ListView.builder(&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;) : childrenDelegate = SliverChildBuilderDelegate(</span><br><span class="line">         itemBuilder,</span><br><span class="line">         childCount: itemCount,</span><br><span class="line">         addAutomaticKeepAlives: addAutomaticKeepAlives,</span><br><span class="line">         addRepaintBoundaries: addRepaintBoundaries,</span><br><span class="line">         addSemanticIndexes: addSemanticIndexes,</span><br><span class="line">       ), <span class="keyword">super</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ListView.separated</span></span><br><span class="line">ListView.separated(&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;) : childrenDelegate = SliverChildBuilderDelegate(</span><br><span class="line">         <span class="comment">// ...</span></span><br><span class="line">       ), <span class="keyword">super</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li>上面代码中可见，这里自动帮我们创建了一个<code>SliverChildListDelegate</code>的实例</li>
<li>而<code>SliverChildListDelegate</code>是抽象类<code>SliverChildDelegate</code>的子类</li>
<li><code>SliverChildListDelegate</code>中主要逻辑就是实现了<code>SliverChildDelegate</code>中定义的<code>build</code>方法</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Widget build(BuildContext context, <span class="built_in">int</span> index) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(builder != <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || (childCount != <span class="keyword">null</span> &amp;&amp; index &gt;= childCount))</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    Widget child;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      child = builder(context, index);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (exception, stackTrace) &#123;</span><br><span class="line">      child = _createErrorWidget(exception, stackTrace);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (child == <span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (addRepaintBoundaries)</span><br><span class="line">      child = RepaintBoundary.wrap(child, index);</span><br><span class="line">    <span class="keyword">if</span> (addSemanticIndexes) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="built_in">int</span> semanticIndex = semanticIndexCallback(child, index);</span><br><span class="line">      <span class="keyword">if</span> (semanticIndex != <span class="keyword">null</span>)</span><br><span class="line">        child = IndexedSemantics(index: semanticIndex + semanticIndexOffset, child: child);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (addAutomaticKeepAlives)</span><br><span class="line">      child = AutomaticKeepAlive(child: child);</span><br><span class="line">    <span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>从上面代码的逻辑可以看出, 就是根据传入的索引返回<code>children</code>列表中对应的元素</li>
<li>每当<code>ListView</code>的底层实现需要加载一个元素时，就会把该元素的索引传递给<code>SliverChildDelegate</code>的<code>build</code>方法，由该方法返回具体的元素</li>
<li>另外在<code>SliverChildDelegate</code>内部，除了定义了<code>build</code>方法外，还定义了 一个名为<code>didFinishLayout</code>的方法</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> didFinishLayout() &#123;</span><br><span class="line">    <span class="keyword">assert</span>(debugAssertChildListLocked());</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">int</span> firstIndex = _childElements.firstKey() ?? <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">int</span> lastIndex = _childElements.lastKey() ?? <span class="number">0</span>;</span><br><span class="line">    widget.delegate.didFinishLayout(firstIndex, lastIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>每当<code>ListView</code>完成一次<code>layout</code>之后都会调用该方法, 同时传入两个索引值</li>
<li>这两个值分别是此次<code>layout</code>中第一个元素和最后一个元素在<code>ListView</code>所有子元素中的索引值, 也就是可视区域内的元素在子元素列表中的位置</li>
<li>然而不论是<code>SliverChildListDelegate</code>还是<code>SliverChildBuilderDelegate</code>的代码中，都没有<code>didFinishLayout</code>的具体实现。所以我们需要编写一个它们的子类</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySliverBuilderDelegate</span> <span class="keyword">extends</span> <span class="title">SliverChildBuilderDelegate</span> </span>&#123;</span><br><span class="line">  MySliverBuilderDelegate(</span><br><span class="line">    Widget <span class="built_in">Function</span>(BuildContext, <span class="built_in">int</span>) builder, &#123;</span><br><span class="line">    <span class="built_in">int</span> childCount,</span><br><span class="line">    <span class="built_in">bool</span> addAutomaticKeepAlives = <span class="keyword">true</span>,</span><br><span class="line">    <span class="built_in">bool</span> addRepaintBoundaries = <span class="keyword">true</span>,</span><br><span class="line">  &#125;) : <span class="keyword">super</span>(builder,</span><br><span class="line">            childCount: childCount,</span><br><span class="line">            addAutomaticKeepAlives: addAutomaticKeepAlives,</span><br><span class="line">            addRepaintBoundaries: addRepaintBoundaries);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> didFinishLayout(<span class="built_in">int</span> firstIndex, <span class="built_in">int</span> lastIndex) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;firstIndex: <span class="subst">$firstIndex</span>, lastIndex: <span class="subst">$lastIndex</span>&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们创建一个<code>ListView.custom</code>的列表视图</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomList</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement build</span></span><br><span class="line">    <span class="keyword">return</span> ListView.custom(</span><br><span class="line">      childrenDelegate: MySliverBuilderDelegate(</span><br><span class="line">        (BuildContext context, <span class="built_in">int</span> index) &#123;</span><br><span class="line">          <span class="keyword">return</span> ListTile(</span><br><span class="line">            title: Text(<span class="string">&#x27;index--<span class="subst">$index</span>&#x27;</span>),</span><br><span class="line">            subtitle: Text(<span class="string">&#x27;数字列表&#x27;</span>),</span><br><span class="line">            leading: Icon(Icons.wifi),</span><br><span class="line">          );</span><br><span class="line">        &#125;, childCount: <span class="number">30</span>,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="GridView"><a href="#GridView" class="headerlink" title="GridView"></a>GridView</h2><p><code>GridView</code>可以构建二维网格列表, 系统给出了五中构造函数</p>
<ul>
<li><code>GridView()</code></li>
<li><code>GridView.count</code></li>
<li><code>GridView.extent</code></li>
<li><code>GridView.builder</code></li>
<li><code>GridView.custom</code></li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认构造函数</span></span><br><span class="line">GridView(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    Axis scrollDirection = Axis.vertical,</span><br><span class="line">    <span class="built_in">bool</span> reverse = <span class="keyword">false</span>,</span><br><span class="line">    ScrollController controller,</span><br><span class="line">    <span class="built_in">bool</span> primary,</span><br><span class="line">    ScrollPhysics physics,</span><br><span class="line">    <span class="built_in">bool</span> shrinkWrap = <span class="keyword">false</span>,</span><br><span class="line">    EdgeInsetsGeometry padding,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.gridDelegate,</span><br><span class="line">    <span class="built_in">bool</span> addAutomaticKeepAlives = <span class="keyword">true</span>,</span><br><span class="line">    <span class="built_in">bool</span> addRepaintBoundaries = <span class="keyword">true</span>,</span><br><span class="line">    <span class="built_in">bool</span> addSemanticIndexes = <span class="keyword">true</span>,</span><br><span class="line">    <span class="built_in">double</span> cacheExtent,</span><br><span class="line">    <span class="built_in">List</span>&lt;Widget&gt; children = <span class="keyword">const</span> &lt;Widget&gt;[],</span><br><span class="line">    <span class="built_in">int</span> semanticChildCount,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>可以看到, 除了<code>gridDelegate</code>属性外, 其他属性和<code>ListView</code>的属性都一样, 含义也都相同</li>
<li><code>gridDelegate</code>参数的类型是<code>SliverGridDelegate</code>，它的作用是控制<code>GridView</code>子<code>widget</code>如何排列</li>
<li><code>SliverGridDelegate</code>是一个抽象类，定义了<code>GridView</code>排列相关接口，子类需要通过实现它们来实现具体的布局算法</li>
<li><code>Flutter</code>中提供了两个<code>SliverGridDelegate</code>的子类<code>SliverGridDelegateWithFixedCrossAxisCount</code>和<code>SliverGridDelegateWithMaxCrossAxisExtent</code>, 下面我们分别介绍</li>
</ul>
<h3 id="SliverGridDelegateWithFixedCrossAxisCount"><a href="#SliverGridDelegateWithFixedCrossAxisCount" class="headerlink" title="SliverGridDelegateWithFixedCrossAxisCount"></a>SliverGridDelegateWithFixedCrossAxisCount</h3><p>该子类实现了一个横轴为固定数量子元素的排列算法，其构造函数为：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> SliverGridDelegateWithFixedCrossAxisCount(&#123;</span><br><span class="line">    <span class="comment">// 横轴子元素的数量,此属性值确定后子元素在横轴的长度就确定了,即ViewPort横轴长度/crossAxisCount。</span></span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.crossAxisCount,</span><br><span class="line">    <span class="comment">// 主轴方向的间距</span></span><br><span class="line">    <span class="keyword">this</span>.mainAxisSpacing = <span class="number">0.0</span>,</span><br><span class="line">    <span class="comment">// 侧轴方向子元素的间距</span></span><br><span class="line">    <span class="keyword">this</span>.crossAxisSpacing = <span class="number">0.0</span>,</span><br><span class="line">    <span class="comment">// 子元素在侧轴长度和主轴长度的比例, 由于crossAxisCount指定后子元素横轴长度就确定了，然后通过此参数值就可以确定子元素在主轴的长度</span></span><br><span class="line">    <span class="keyword">this</span>.childAspectRatio = <span class="number">1.0</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>从上面的个属性可以发现，子元素的大小是通过<code>crossAxisCount</code>和<code>childAspectRatio</code>两个参数共同决定的。注意，这里的子元素指的是子<code>widget</code>的最大显示空间，注意确保子<code>widget</code>的实际大小不要超出子元素的空间, 代码示例如下</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScrollView</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> GridView(</span><br><span class="line">      padding: EdgeInsets.all(<span class="number">10</span>),</span><br><span class="line">      gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(</span><br><span class="line">        crossAxisCount: <span class="number">3</span>,</span><br><span class="line">        childAspectRatio: <span class="number">1</span>,</span><br><span class="line">        mainAxisSpacing: <span class="number">10</span>,</span><br><span class="line">        crossAxisSpacing: <span class="number">10</span></span><br><span class="line">      ),</span><br><span class="line">      children: &lt;Widget&gt;[</span><br><span class="line">        Container(color: Colors.orange),</span><br><span class="line">        Container(color: Colors.blue),</span><br><span class="line">        Container(color: Colors.orange),</span><br><span class="line">        Container(color: Colors.yellow),</span><br><span class="line">        Container(color: Colors.pink)</span><br><span class="line">      ],</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="GridView-count"><a href="#GridView-count" class="headerlink" title="GridView.count"></a>GridView.count</h3><p><code>GridView.count</code>构造函数内部使用了<code>SliverGridDelegateWithFixedCrossAxisCount</code>，我们通过它可以快速的创建横轴固定数量子元素的<code>GridView</code></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">GridView.count(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    Axis scrollDirection = Axis.vertical,</span><br><span class="line">    <span class="built_in">bool</span> reverse = <span class="keyword">false</span>,</span><br><span class="line">    ScrollController controller,</span><br><span class="line">    <span class="built_in">bool</span> primary,</span><br><span class="line">    ScrollPhysics physics,</span><br><span class="line">    <span class="built_in">bool</span> shrinkWrap = <span class="keyword">false</span>,</span><br><span class="line">    EdgeInsetsGeometry padding,</span><br><span class="line">    <span class="meta">@required</span> <span class="built_in">int</span> crossAxisCount,</span><br><span class="line">    <span class="built_in">double</span> mainAxisSpacing = <span class="number">0.0</span>,</span><br><span class="line">    <span class="built_in">double</span> crossAxisSpacing = <span class="number">0.0</span>,</span><br><span class="line">    <span class="built_in">double</span> childAspectRatio = <span class="number">1.0</span>,</span><br><span class="line">    <span class="built_in">bool</span> addAutomaticKeepAlives = <span class="keyword">true</span>,</span><br><span class="line">    <span class="built_in">bool</span> addRepaintBoundaries = <span class="keyword">true</span>,</span><br><span class="line">    <span class="built_in">bool</span> addSemanticIndexes = <span class="keyword">true</span>,</span><br><span class="line">    <span class="built_in">double</span> cacheExtent,</span><br><span class="line">    <span class="built_in">List</span>&lt;Widget&gt; children = <span class="keyword">const</span> &lt;Widget&gt;[],</span><br><span class="line">    <span class="built_in">int</span> semanticChildCount,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>上面<code>SliverGridDelegateWithFixedCrossAxisCount</code>中给出的示例代码等价于：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CountGridView</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement build</span></span><br><span class="line">    <span class="keyword">return</span> GridView.count(</span><br><span class="line">      padding: EdgeInsets.all(<span class="number">10</span>),</span><br><span class="line">      crossAxisCount: <span class="number">3</span>,</span><br><span class="line">      mainAxisSpacing: <span class="number">10</span>,</span><br><span class="line">      crossAxisSpacing: <span class="number">10</span>,</span><br><span class="line">      childAspectRatio: <span class="number">1</span>,</span><br><span class="line">      children: &lt;Widget&gt;[</span><br><span class="line">        Container(color: Colors.orange),</span><br><span class="line">        Container(color: Colors.blue),</span><br><span class="line">        Container(color: Colors.orange),</span><br><span class="line">        Container(color: Colors.yellow),</span><br><span class="line">        Container(color: Colors.pink)</span><br><span class="line">      ],</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="SliverGridDelegateWithMaxCrossAxisExtent"><a href="#SliverGridDelegateWithMaxCrossAxisExtent" class="headerlink" title="SliverGridDelegateWithMaxCrossAxisExtent"></a>SliverGridDelegateWithMaxCrossAxisExtent</h3><p>该子类实现了一个侧轴子元素为固定最大长度的排列算法，其构造函数为：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> SliverGridDelegateWithMaxCrossAxisExtent(&#123;</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.maxCrossAxisExtent,</span><br><span class="line">    <span class="keyword">this</span>.mainAxisSpacing = <span class="number">0.0</span>,</span><br><span class="line">    <span class="keyword">this</span>.crossAxisSpacing = <span class="number">0.0</span>,</span><br><span class="line">    <span class="keyword">this</span>.childAspectRatio = <span class="number">1.0</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>maxCrossAxisExtent</code>为子元素在侧轴上的最大长度，之所以是“最大”长度，是因为横轴方向每个子元素的长度仍然是等分的</li>
<li>同样侧轴上子<code>Widget</code>的个数, 也是由该属性决定</li>
<li>其它参数和<code>SliverGridDelegateWithFixedCrossAxisCount</code>相同</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExtentScrollView</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> GridView(</span><br><span class="line">      padding: EdgeInsets.all(<span class="number">10</span>),</span><br><span class="line">      gridDelegate: SliverGridDelegateWithMaxCrossAxisExtent(</span><br><span class="line">        maxCrossAxisExtent: <span class="number">100</span>,</span><br><span class="line">        childAspectRatio: <span class="number">1</span>,</span><br><span class="line">        mainAxisSpacing: <span class="number">10</span>,</span><br><span class="line">        crossAxisSpacing: <span class="number">10</span></span><br><span class="line">      ),</span><br><span class="line">      children: &lt;Widget&gt;[</span><br><span class="line">        Container(color: Colors.orange),</span><br><span class="line">        Container(color: Colors.blue),</span><br><span class="line">        Container(color: Colors.orange),</span><br><span class="line">        Container(color: Colors.yellow),</span><br><span class="line">        Container(color: Colors.pink)</span><br><span class="line">      ],</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="GridView-extent"><a href="#GridView-extent" class="headerlink" title="GridView.extent"></a>GridView.extent</h3><p>同样<code>GridView.extent</code>构造函数内部使用了<code>SliverGridDelegateWithMaxCrossAxisExtent</code>，我们通过它可以快速的创建侧轴子元素为固定最大长度的的<code>GridView</code></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">GridView.extent(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    Axis scrollDirection = Axis.vertical,</span><br><span class="line">    <span class="built_in">bool</span> reverse = <span class="keyword">false</span>,</span><br><span class="line">    ScrollController controller,</span><br><span class="line">    <span class="built_in">bool</span> primary,</span><br><span class="line">    ScrollPhysics physics,</span><br><span class="line">    <span class="built_in">bool</span> shrinkWrap = <span class="keyword">false</span>,</span><br><span class="line">    EdgeInsetsGeometry padding,</span><br><span class="line">    <span class="meta">@required</span> <span class="built_in">double</span> maxCrossAxisExtent,</span><br><span class="line">    <span class="built_in">double</span> mainAxisSpacing = <span class="number">0.0</span>,</span><br><span class="line">    <span class="built_in">double</span> crossAxisSpacing = <span class="number">0.0</span>,</span><br><span class="line">    <span class="built_in">double</span> childAspectRatio = <span class="number">1.0</span>,</span><br><span class="line">    <span class="built_in">bool</span> addAutomaticKeepAlives = <span class="keyword">true</span>,</span><br><span class="line">    <span class="built_in">bool</span> addRepaintBoundaries = <span class="keyword">true</span>,</span><br><span class="line">    <span class="built_in">bool</span> addSemanticIndexes = <span class="keyword">true</span>,</span><br><span class="line">    <span class="built_in">List</span>&lt;Widget&gt; children = <span class="keyword">const</span> &lt;Widget&gt;[],</span><br><span class="line">    <span class="built_in">int</span> semanticChildCount,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>上面<code>SliverGridDelegateWithMaxCrossAxisExtent</code>中给出的示例代码等价于：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExtentScrollView</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> GridView.extent(</span><br><span class="line">      padding: EdgeInsets.all(<span class="number">10</span>),</span><br><span class="line">      maxCrossAxisExtent: <span class="number">100</span>,</span><br><span class="line">      childAspectRatio: <span class="number">1</span>,</span><br><span class="line">      mainAxisSpacing: <span class="number">10</span>,</span><br><span class="line">      crossAxisSpacing: <span class="number">10</span>,</span><br><span class="line">      children: &lt;Widget&gt;[</span><br><span class="line">        Container(color: Colors.orange),</span><br><span class="line">        Container(color: Colors.blue),</span><br><span class="line">        Container(color: Colors.orange),</span><br><span class="line">        Container(color: Colors.yellow),</span><br><span class="line">        Container(color: Colors.pink)</span><br><span class="line">      ],</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="GridView-builder"><a href="#GridView-builder" class="headerlink" title="GridView.builder"></a>GridView.builder</h3><ul>
<li>上面我们介绍的<code>GridView</code>都需要一个<code>Widget</code>数组作为其子元素，这些方式都会提前将所有子<code>widget</code>都构建好，所以只适用于子<code>Widget</code>数量比较少时</li>
<li>当子<code>widget</code>比较多时，我们可以通过<code>GridView.builder</code>来动态创建子<code>Widget</code></li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">GridView.builder(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    Axis scrollDirection = Axis.vertical,</span><br><span class="line">    <span class="built_in">bool</span> reverse = <span class="keyword">false</span>,</span><br><span class="line">    ScrollController controller,</span><br><span class="line">    <span class="built_in">bool</span> primary,</span><br><span class="line">    ScrollPhysics physics,</span><br><span class="line">    <span class="built_in">bool</span> shrinkWrap = <span class="keyword">false</span>,</span><br><span class="line">    EdgeInsetsGeometry padding,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.gridDelegate,</span><br><span class="line">    <span class="meta">@required</span> IndexedWidgetBuilder itemBuilder,</span><br><span class="line">    <span class="built_in">int</span> itemCount,</span><br><span class="line">    <span class="built_in">bool</span> addAutomaticKeepAlives = <span class="keyword">true</span>,</span><br><span class="line">    <span class="built_in">bool</span> addRepaintBoundaries = <span class="keyword">true</span>,</span><br><span class="line">    <span class="built_in">bool</span> addSemanticIndexes = <span class="keyword">true</span>,</span><br><span class="line">    <span class="built_in">double</span> cacheExtent,</span><br><span class="line">    <span class="built_in">int</span> semanticChildCount,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>可以看出<code>GridView.builder</code>必须指定的参数有两个,其中<code>gridDelegate</code>之前已经介绍过了</li>
<li>属性<code>itemBuilder</code>在之前<code>ListView</code>中也有介绍过类似的, 用于构建子<code>Widget</code></li>
<li>使用示例如下</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuilderGridView</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> GridView.builder(</span><br><span class="line">      itemCount: <span class="number">50</span>,</span><br><span class="line">      gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(</span><br><span class="line">        crossAxisCount: <span class="number">4</span>,</span><br><span class="line">        mainAxisSpacing: <span class="number">10</span>,</span><br><span class="line">        crossAxisSpacing: <span class="number">10</span></span><br><span class="line">      ),</span><br><span class="line">      itemBuilder: (content, index) &#123;</span><br><span class="line">        <span class="keyword">return</span> Container(</span><br><span class="line">          color: Colors.orange,</span><br><span class="line">          child: Center(</span><br><span class="line">            child: Text(<span class="string">&#x27;<span class="subst">$index</span>&#x27;</span>),</span><br><span class="line">          ),</span><br><span class="line">        );</span><br><span class="line">      &#125;,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="GridView-custom"><a href="#GridView-custom" class="headerlink" title="GridView.custom"></a>GridView.custom</h3><p>和<code>ListView.custom</code>一样, 用于构建自定义子<code>Widget</code>, 有两个必须指定的参数, 这里就不在赘述了</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> GridView.custom(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    Axis scrollDirection = Axis.vertical,</span><br><span class="line">    <span class="built_in">bool</span> reverse = <span class="keyword">false</span>,</span><br><span class="line">    ScrollController controller,</span><br><span class="line">    <span class="built_in">bool</span> primary,</span><br><span class="line">    ScrollPhysics physics,</span><br><span class="line">    <span class="built_in">bool</span> shrinkWrap = <span class="keyword">false</span>,</span><br><span class="line">    EdgeInsetsGeometry padding,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.gridDelegate,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.childrenDelegate,</span><br><span class="line">    <span class="built_in">double</span> cacheExtent,</span><br><span class="line">    <span class="built_in">int</span> semanticChildCount,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


<h2 id="CustomScrollView"><a href="#CustomScrollView" class="headerlink" title="CustomScrollView"></a>CustomScrollView</h2><ul>
<li><code>CustomScrollView</code>使用<code>sliver</code>来自定义滚动模型（效果, 它可以包含多种滚动模型</li>
<li>假设有一个页面，顶部需要一个<code>GridView</code>，底部需要一个<code>ListView</code>，而要求整个页面的滑动效果是统一的，即它们看起来是一个整体</li>
<li>如果使用<code>GridView+ListView</code>来实现的话，就不能保证一致的滑动效果，因为它们的滚动效果是分离的，所以这时就需要一个”胶水”，把这些彼此独立的可滚动<code>widget</code>“粘”起来，而<code>CustomScrollView</code>的功能就相当于“胶水”</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> CustomScrollView(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="comment">// 滑动方向</span></span><br><span class="line">    Axis scrollDirection = Axis.vertical,</span><br><span class="line">    <span class="built_in">bool</span> reverse = <span class="keyword">false</span>,</span><br><span class="line">    ScrollController controller,</span><br><span class="line">    <span class="built_in">bool</span> primary,</span><br><span class="line">    ScrollPhysics physics,</span><br><span class="line">    <span class="built_in">bool</span> shrinkWrap = <span class="keyword">false</span>,</span><br><span class="line">    <span class="built_in">double</span> cacheExtent,</span><br><span class="line">    <span class="keyword">this</span>.slivers = <span class="keyword">const</span> &lt;Widget&gt;[],</span><br><span class="line">    <span class="built_in">int</span> semanticChildCount,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>上述属性除了<code>slivers</code>之外, 前面都有提到过, 接受一个<code>Widget</code>数组, 但是这里的<code>Widget</code>必须是<code>Sliver</code>类型的, 至于原因, 下面会详解</p>
<div class="note warning"><p>什么是Sliver ?</p></div>

<ul>
<li>在<code>Flutter</code>中，<code>Sliver</code>通常指具有特定滚动效果的可滚动块</li>
<li>可滚动<code>widget</code>，如<code>ListView</code>、<code>GridView</code>等都有对应的<code>Sliver</code>实现如<code>SliverList</code>、<code>SliverGrid</code>等</li>
<li>对于大多数<code>Sliver</code>来说，它们和可滚动<code>Widget</code>最主要的区别是<code>Sliver</code>不会包含<code>Scrollable</code>，也就是说<code>Sliver</code>本身不包含滚动交互模型</li>
<li>正因如此，<code>CustomScrollView</code>才可以将多个<code>Sliver</code>“粘”在一起，这些<code>Sliver</code>共用<code>CustomScrollView</code>的<code>Scrollable</code>，最终实现统一的滑动效果</li>
<li>前面之所以说“大多数“<code>Sliver</code>都和可滚动<code>Widget</code>对应，是由于还有一些如<code>SliverPadding</code>、<code>SliverAppBar</code>等是和可滚动<code>Widget</code>无关的</li>
<li>它们主要是为了结合<code>CustomScrollView</code>一起使用，这是因为<code>CustomScrollView</code>的子<code>widget</code>必须都是<code>Sliver</code></li>
<li>下面是常用的一些<code>Sliver</code>：<ul>
<li><code>SliverToBoxAdapter</code>: 将各种视图组合在一起, 类似于<code>Container</code></li>
<li><code>SliverPersistentHeader</code>: 实现<code>sticky</code>吸顶的效果的<code>Sliver</code></li>
<li><code>SliverList</code>：类似于我们之前使用过的<code>ListView</code>；</li>
<li><code>SliverFixedExtentList</code>：类似于<code>SliverList</code>只是可以设置滚动的高度；</li>
<li><code>SliverGrid</code>：类似于我们之前使用过的<code>GridView</code></li>
<li><code>SliverPadding</code>：设置<code>Sliver</code>的内边距，因为可能要单独给<code>Sliver</code>设置内边距；</li>
<li><code>SliverAppBar</code>：添加一个<code>AppBar</code>，通常用来作为<code>CustomScrollView</code>的<code>HeaderView</code></li>
<li><code>SliverSafeArea</code>：设置内容显示在安全区域（比如不让齐刘海挡住我们的内容）</li>
</ul>
</li>
</ul>
<h3 id="SliverAppBar"><a href="#SliverAppBar" class="headerlink" title="SliverAppBar"></a>SliverAppBar</h3><ul>
<li><code>AppBar</code>和<code>SliverAppBar</code>是<code>Material Design</code>中的导航栏</li>
<li><code>AppBar</code>和<code>SliverAppBar</code>都是继承<code>StatefulWidget</code>类，二者的区别在于<code>AppBar</code>位置的固定的应用最上面的；而<code>SliverAppBar</code>是可以跟随内容滚动的</li>
<li>其中大部分的属性和<code>AppBar</code>都一样</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> SliverAppBar(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="comment">// 导航栏左侧weidget</span></span><br><span class="line">    <span class="keyword">this</span>.leading,</span><br><span class="line">    <span class="comment">// 如果leading为null，是否自动实现默认的leading按钮</span></span><br><span class="line">    <span class="keyword">this</span>.automaticallyImplyLeading = <span class="keyword">true</span>,</span><br><span class="line">    <span class="comment">// 导航栏标题</span></span><br><span class="line">    <span class="keyword">this</span>.title,</span><br><span class="line">    <span class="comment">// 导航栏右侧按钮, 接受一个数组</span></span><br><span class="line">    <span class="keyword">this</span>.actions,</span><br><span class="line">    <span class="comment">// 一个显示在AppBar下方的控件，高度和AppBar高度一样，可以实现一些特殊的效果，该属性通常在SliverAppBar中使用</span></span><br><span class="line">    <span class="keyword">this</span>.flexibleSpace,</span><br><span class="line">    <span class="comment">// 一个AppBarBottomWidget对象, 设置TabBar</span></span><br><span class="line">    <span class="keyword">this</span>.bottom,</span><br><span class="line">    <span class="comment">//中控件的z坐标顺序，默认值为4，对于可滚动的SliverAppBar，当 SliverAppBar和内容同级的时候，该值为0，当内容滚动 SliverAppBar 变为 Toolbar 的时候，修改elevation的值</span></span><br><span class="line">    <span class="keyword">this</span>.elevation = <span class="number">4.0</span>,</span><br><span class="line">    <span class="comment">// 背景颜色，默认值为 ThemeData.primaryColor。改值通常和下面的三个属性一起使用</span></span><br><span class="line">    <span class="keyword">this</span>.backgroundColor,</span><br><span class="line">    <span class="comment">// 状态栏的颜色, 黑白两种, 取值: Brightness.dark</span></span><br><span class="line">    <span class="keyword">this</span>.brightness,</span><br><span class="line">    <span class="comment">// 设置导航栏上图标的颜色、透明度、和尺寸信息</span></span><br><span class="line">    <span class="keyword">this</span>.iconTheme,</span><br><span class="line">    <span class="comment">// 设置导航栏上文字样式</span></span><br><span class="line">    <span class="keyword">this</span>.textTheme,</span><br><span class="line">    <span class="comment">// 导航栏的内容是否显示在顶部, 状态栏的下面</span></span><br><span class="line">    <span class="keyword">this</span>.primary = <span class="keyword">true</span>,</span><br><span class="line">    <span class="comment">// 标题是否居中显示，默认值根据不同的操作系统，显示方式不一样</span></span><br><span class="line">    <span class="keyword">this</span>.centerTitle,</span><br><span class="line">    <span class="comment">// 标题间距，如果希望title占用所有可用空间，请将此值设置为0.0</span></span><br><span class="line">    <span class="keyword">this</span>.titleSpacing = NavigationToolbar.kMiddleSpacing,</span><br><span class="line">    <span class="comment">// 展开的最大高度</span></span><br><span class="line">    <span class="keyword">this</span>.expandedHeight,</span><br><span class="line">    <span class="comment">// 是否随着华东隐藏标题</span></span><br><span class="line">    <span class="keyword">this</span>.floating = <span class="keyword">false</span>,</span><br><span class="line">    <span class="comment">// 是否固定在顶部</span></span><br><span class="line">    <span class="keyword">this</span>.pinned = <span class="keyword">false</span>,</span><br><span class="line">    <span class="comment">// 只跟floating相对应，如果为true，floating必须为true，也就是向下滑动一点儿，整个大背景就会动画显示全部，网上滑动整个导航栏的内容就会消失</span></span><br><span class="line">    <span class="keyword">this</span>.snap = <span class="keyword">false</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="使用示例-1"><a href="#使用示例-1" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomScrollViewTestRoute</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">//因为本路由没有使用Scaffold，为了让子级Widget(如Text)使用</span></span><br><span class="line">    <span class="comment">//Material Design 默认的样式风格,我们使用Material作为本路由的根。</span></span><br><span class="line">    <span class="keyword">return</span> Material(</span><br><span class="line">      child: CustomScrollView(</span><br><span class="line">        slivers: &lt;Widget&gt;[</span><br><span class="line">          <span class="comment">//AppBar，包含一个导航栏</span></span><br><span class="line">          SliverAppBar(</span><br><span class="line">            pinned: <span class="keyword">true</span>,</span><br><span class="line">            expandedHeight: <span class="number">250.0</span>,</span><br><span class="line">            flexibleSpace: FlexibleSpaceBar(</span><br><span class="line">              title: <span class="keyword">const</span> Text(<span class="string">&#x27;Demo&#x27;</span>),</span><br><span class="line">              background: Image.asset(</span><br><span class="line">                <span class="string">&quot;./images/avatar.png&quot;</span>, fit: BoxFit.cover,),</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line"></span><br><span class="line">          SliverPadding(</span><br><span class="line">            padding: <span class="keyword">const</span> EdgeInsets.all(<span class="number">8.0</span>),</span><br><span class="line">            sliver: <span class="keyword">new</span> SliverGrid( <span class="comment">//Grid</span></span><br><span class="line">              gridDelegate: <span class="keyword">new</span> SliverGridDelegateWithFixedCrossAxisCount(</span><br><span class="line">                crossAxisCount: <span class="number">2</span>, <span class="comment">//Grid按两列显示</span></span><br><span class="line">                mainAxisSpacing: <span class="number">10.0</span>,</span><br><span class="line">                crossAxisSpacing: <span class="number">10.0</span>,</span><br><span class="line">                childAspectRatio: <span class="number">4.0</span>,</span><br><span class="line">              ),</span><br><span class="line">              delegate: <span class="keyword">new</span> SliverChildBuilderDelegate(</span><br><span class="line">                    (BuildContext context, <span class="built_in">int</span> index) &#123;</span><br><span class="line">                  <span class="comment">//创建子widget      </span></span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">new</span> Container(</span><br><span class="line">                    alignment: Alignment.center,</span><br><span class="line">                    color: Colors.cyan[<span class="number">100</span> * (index % <span class="number">9</span>)],</span><br><span class="line">                    child: <span class="keyword">new</span> Text(<span class="string">&#x27;grid item <span class="subst">$index</span>&#x27;</span>),</span><br><span class="line">                  );</span><br><span class="line">                &#125;,</span><br><span class="line">                childCount: <span class="number">20</span>,</span><br><span class="line">              ),</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">          <span class="comment">//List</span></span><br><span class="line">          <span class="keyword">new</span> SliverFixedExtentList(</span><br><span class="line">            itemExtent: <span class="number">50.0</span>,</span><br><span class="line">            delegate: <span class="keyword">new</span> SliverChildBuilderDelegate(</span><br><span class="line">                    (BuildContext context, <span class="built_in">int</span> index) &#123;</span><br><span class="line">                  <span class="comment">//创建列表项      </span></span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">new</span> Container(</span><br><span class="line">                    alignment: Alignment.center,</span><br><span class="line">                    color: Colors.lightBlue[<span class="number">100</span> * (index % <span class="number">9</span>)],</span><br><span class="line">                    child: <span class="keyword">new</span> Text(<span class="string">&#x27;list item <span class="subst">$index</span>&#x27;</span>),</span><br><span class="line">                  );</span><br><span class="line">                &#125;,</span><br><span class="line">                childCount: <span class="number">50</span> <span class="comment">//50个列表项</span></span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="ScrollController"><a href="#ScrollController" class="headerlink" title="ScrollController"></a>ScrollController</h2><ul>
<li><code>ScrollController</code>用于控制可滚动<code>widget</code>的滚动位置，这里以<code>ListView</code>为例，展示一下<code>ScrollController</code>的具体用法</li>
<li>最后再介绍一下路由切换时如何来保存滚动位置</li>
<li>下面先看一下<code>ScrollController</code>的构造函数</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">ScrollController(&#123;</span><br><span class="line">    <span class="comment">// 初始滚动位置</span></span><br><span class="line">    <span class="built_in">double</span> initialScrollOffset = <span class="number">0.0</span>,</span><br><span class="line">    <span class="comment">// 是否保存滚动位置</span></span><br><span class="line">    <span class="keyword">this</span>.keepScrollOffset = <span class="keyword">true</span>,</span><br><span class="line">    <span class="comment">// 调试使用的输出标签</span></span><br><span class="line">    <span class="keyword">this</span>.debugLabel,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="相关属性和方法"><a href="#相关属性和方法" class="headerlink" title="相关属性和方法"></a>相关属性和方法</h3><h4 id="offset"><a href="#offset" class="headerlink" title="offset"></a>offset</h4><p>可滚动<code>Widget</code>当前滚动的位置</p>
<h4 id="jumpTo"><a href="#jumpTo" class="headerlink" title="jumpTo()"></a>jumpTo()</h4><p>跳转到指定的位置, 没有动画效果</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> jumpTo(<span class="built_in">double</span> value) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(_positions.isNotEmpty, <span class="string">&#x27;ScrollController not attached to any scroll views.&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (ScrollPosition position <span class="keyword">in</span> <span class="built_in">List</span>&lt;ScrollPosition&gt;.from(_positions))</span><br><span class="line">      position.jumpTo(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="animateTo"><a href="#animateTo" class="headerlink" title="animateTo()"></a>animateTo()</h4><p>跳转到指定的位置, 跳转时会有一个动画效果</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Future&lt;<span class="keyword">void</span>&gt; animateTo(<span class="built_in">double</span> offset, &#123;</span><br><span class="line">    <span class="meta">@required</span> <span class="built_in">Duration</span> duration,</span><br><span class="line">    <span class="meta">@required</span> Curve curve,</span><br><span class="line">  &#125;) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(_positions.isNotEmpty, <span class="string">&#x27;ScrollController not attached to any scroll views.&#x27;</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">List</span>&lt;Future&lt;<span class="keyword">void</span>&gt;&gt; animations = <span class="built_in">List</span>&lt;Future&lt;<span class="keyword">void</span>&gt;&gt;(_positions.length);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; _positions.length; i += <span class="number">1</span>)</span><br><span class="line">      animations[i] = _positions[i].animateTo(offset, duration: duration, curve: curve);</span><br><span class="line">    <span class="keyword">return</span> Future.wait&lt;<span class="keyword">void</span>&gt;(animations).then&lt;<span class="keyword">void</span>&gt;((<span class="built_in">List</span>&lt;<span class="keyword">void</span>&gt; _) =&gt; <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="positions"><a href="#positions" class="headerlink" title="positions"></a>positions</h4><ul>
<li>一个<code>ScrollController</code>可以同时被多个<code>Scrollable</code>使用，<code>ScrollController</code>会为每一个<code>Scrollable</code>创建一个<code>ScrollPosition</code>对象，这些<code>ScrollPosition</code>保存在<code>ScrollController</code>的<code>positions</code>属性中(是一个数组)</li>
<li><code>ScrollPosition</code>是真正保存滑动位置信息的对象，<code>offset</code>只是一个便捷属性, 其他更多属性可查看相关官方文档</li>
<li>一个<code>ScrollController</code>虽然可以对应多个<code>Scrollable</code>，但是有一些操作，如读取滚动位置<code>offset</code>，则需要一对一，但是我们仍然可以在一对多的情况下，通过其它方法读取滚动位置</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// controller的offset属性</span></span><br><span class="line"><span class="built_in">double</span> <span class="keyword">get</span> offset =&gt; position.pixels;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取相关的滚动位置</span></span><br><span class="line">controller.positions.elementAt(<span class="number">0</span>).pixels</span><br><span class="line">controller.positions.elementAt(<span class="number">1</span>).pixels</span><br></pre></td></tr></table></figure>

<h4 id="滚动监听"><a href="#滚动监听" class="headerlink" title="滚动监听"></a>滚动监听</h4><p><code>ScrollController</code>间接继承自<code>Listenable</code>，我们可以根据<code>ScrollController</code>来监听滚动事件。如：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">controller.addListener(()=&gt;<span class="built_in">print</span>(controller.offset))</span><br></pre></td></tr></table></figure>


<h3 id="ScrollController控制原理"><a href="#ScrollController控制原理" class="headerlink" title="ScrollController控制原理"></a>ScrollController控制原理</h3><p>先看一下<code>ScrollController</code>另外几个方法的实现</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个存储位置信息的ScrollPosition</span></span><br><span class="line"> ScrollPosition createScrollPosition(</span><br><span class="line">    ScrollPhysics physics,</span><br><span class="line">    ScrollContext context,</span><br><span class="line">    ScrollPosition oldPosition,</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span> ScrollPositionWithSingleContext(</span><br><span class="line">      physics: physics,</span><br><span class="line">      context: context,</span><br><span class="line">      initialPixels: initialScrollOffset,</span><br><span class="line">      keepScrollOffset: keepScrollOffset,</span><br><span class="line">      oldPosition: oldPosition,</span><br><span class="line">      debugLabel: debugLabel,</span><br><span class="line">    );</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 注册位置信息</span></span><br><span class="line"> <span class="keyword">void</span> attach(ScrollPosition position) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(!_positions.contains(position));</span><br><span class="line">    _positions.add(position);</span><br><span class="line">    position.addListener(notifyListeners);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注销位置信息</span></span><br><span class="line">  <span class="keyword">void</span> detach(ScrollPosition position) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(_positions.contains(position));</span><br><span class="line">    position.removeListener(notifyListeners);</span><br><span class="line">    _positions.remove(position);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 销毁ScrollController</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    <span class="keyword">for</span> (ScrollPosition position <span class="keyword">in</span> _positions)</span><br><span class="line">      position.removeListener(notifyListeners);</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当<code>ScrollController</code>和<code>Scrollable</code>关联时，<code>Scrollable</code>首先会调用<code>ScrollController</code>的<code>createScrollPosition()</code>方法来创建一个<code>ScrollPosition</code>来存储滚动位置信息</li>
<li>然后<code>Scrollable</code>会调用<code>attach()</code>方法，将创建的<code>ScrollPosition</code>添加到<code>ScrollController</code>的<code>positions</code>属性中，这一步称为“注册位置”，只有注册后<code>animateTo()</code>和<code>jumpTo()</code>才可以被调用</li>
<li>当<code>Scrollable</code>销毁时，会调用<code>ScrollController</code>的<code>detach()</code>方法，将其<code>ScrollPosition</code>对象从<code>ScrollController</code>的<code>positions</code>属性中移除，这一步称为“注销位置”，注销后<code>animateTo()</code>和<code>jumpTo()</code>将不能再被调用</li>
<li>需要注意的是，<code>ScrollController</code>的<code>animateTo()</code>和<code>jumpTo()</code>内部会调用所有<code>ScrollPosition</code>的<code>animateTo()</code>和<code>jumpTo()</code>，以实现所有和该<code>ScrollController</code>关联的<code>Scrollable</code>都滚动到指定的位置</li>
</ul>
<h3 id="代码示例-3"><a href="#代码示例-3" class="headerlink" title="代码示例"></a>代码示例</h3><p>创建一个<code>ListView</code>，当滚动位置发生变化时，我们先打印出当前滚动位置，然后判断当前位置是否超过1000像素，如果超过则在屏幕右下角显示一个“返回顶部”的按钮，该按钮点击后可以使<code>ListView</code>恢复到初始位置；如果没有超过1000像素，则隐藏“返回顶部”按钮。代码如下</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScrollControllerTestRoute</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  ScrollControllerTestRouteState createState() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScrollControllerTestRouteState();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScrollControllerTestRouteState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">ScrollControllerTestRoute</span>&gt; </span>&#123;</span><br><span class="line">  ScrollController _controller = <span class="keyword">new</span> ScrollController();</span><br><span class="line">  <span class="built_in">bool</span> showToTopBtn = <span class="keyword">false</span>; <span class="comment">//是否显示“返回到顶部”按钮</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="comment">//监听滚动事件，打印滚动位置</span></span><br><span class="line">    _controller.addListener(() &#123;</span><br><span class="line">      <span class="built_in">print</span>(_controller.offset); <span class="comment">//打印滚动位置</span></span><br><span class="line">      <span class="keyword">if</span> (_controller.offset &lt; <span class="number">1000</span> &amp;&amp; showToTopBtn) &#123;</span><br><span class="line">        setState(() &#123;</span><br><span class="line">          showToTopBtn = <span class="keyword">false</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_controller.offset &gt;= <span class="number">1000</span> &amp;&amp; showToTopBtn == <span class="keyword">false</span>) &#123;</span><br><span class="line">        setState(() &#123;</span><br><span class="line">          showToTopBtn = <span class="keyword">true</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    <span class="comment">//为了避免内存泄露，需要调用_controller.dispose</span></span><br><span class="line">    _controller.dispose();</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(title: Text(<span class="string">&quot;滚动控制&quot;</span>)),</span><br><span class="line">      body: Scrollbar(</span><br><span class="line">        child: ListView.builder(</span><br><span class="line">            itemCount: <span class="number">100</span>,</span><br><span class="line">            itemExtent: <span class="number">50.0</span>, <span class="comment">//列表项高度固定时，显式指定高度是一个好习惯(性能消耗小)</span></span><br><span class="line">            controller: _controller,</span><br><span class="line">            itemBuilder: (context, index) &#123;</span><br><span class="line">              <span class="keyword">return</span> ListTile(title: Text(<span class="string">&quot;<span class="subst">$index</span>&quot;</span>),);</span><br><span class="line">            &#125;</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      floatingActionButton: !showToTopBtn ? <span class="keyword">null</span> : FloatingActionButton(</span><br><span class="line">          child: Icon(Icons.arrow_upward),</span><br><span class="line">          onPressed: () &#123;</span><br><span class="line">            <span class="comment">//返回到顶部时执行动画</span></span><br><span class="line">            _controller.animateTo(<span class="number">.0</span>,</span><br><span class="line">                duration: <span class="built_in">Duration</span>(milliseconds: <span class="number">200</span>),</span><br><span class="line">                curve: Curves.ease</span><br><span class="line">            );</span><br><span class="line">          &#125;</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://book.flutterchina.club/chapter6/">Flutter可滚动Widget</a></li>
<li><a href="https://flutterchina.club/widgets/scrolling/">Flutter中文网–可滚动Widget</a></li>
</ul>
<hr>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
        <tag>Widget</tag>
        <tag>Dart</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter开发之Dart中的类和对象</title>
    <url>/post/ee7c7428.html</url>
    <content><![CDATA[<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/flutter/dart-logo.png?x-oss-process=style/titanjun" alt="dart-logo"></p>
<span id="more"></span>


<ul>
<li>原文博客地址: <a href="https://www.titanjun.top/categories/Flutter%E7%AC%94%E8%AE%B0/">Flutter和Dart系列文章</a></li>
<li>上次学习<code>Flutter</code>已经是整整一年前的事情了,之后因为工作重心主要放在了<code>React Native</code>开发形式上</li>
<li>现在重新捡起<code>Flutter</code>, 也是计划系统性的从头开始重新学习<code>Dart</code>和<code>Flutter</code></li>
<li>这篇<code>Dart</code>笔记主要就是记录<code>Dart</code>语言中的类和对象</li>
</ul>
<h2 id="类及其构造方法"><a href="#类及其构造方法" class="headerlink" title="类及其构造方法"></a>类及其构造方法</h2><p><code>Dart</code>也是一门面向对象的开发语言，面向对象中非常重要的概念就是类，通过类的初始化创建一个对象</p>
<h3 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h3><ul>
<li>在<code>Dart</code>中，定义类用<code>class</code>关键字</li>
<li>当未指明其父类的时候, 默认是继承自<code>Object</code>的, 格式如下:</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名 </span>&#123;</span><br><span class="line">  类型 成员名;</span><br><span class="line">  返回值类型 方法名(参数列表) &#123;</span><br><span class="line">    方法体</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在<code>Dart</code>语言中, 在类中使用属性(成员&#x2F;实例变量)时, 有必要时是通过<code>this</code>获取的</li>
<li>但是下面在<code>getsize</code>方法中并没有加<code>this</code></li>
<li>这里需要注意的是: <code>Dart</code>的开发风格中，在方法中通常使用属性时，会省略<code>this</code>，但是有命名冲突时，<code>this</code>不能省略</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 定义变量</span></span><br><span class="line">  <span class="built_in">int</span> x;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> getsize() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;x = <span class="subst">$x</span>&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类的初始化</span></span><br><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">    <span class="comment">// 从Dart2开始，new关键字可以省略</span></span><br><span class="line">    <span class="keyword">var</span> point = <span class="keyword">new</span> Point();</span><br><span class="line">    point.x = <span class="number">1</span>;</span><br><span class="line">    point.getsize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li>当通过类创建一个对象时，会调用这个类的构造方法<ul>
<li>在<code>Dart</code>语言中,如果类中没有明确指定构造方法时，将默认拥有一个无参的构造方法()</li>
<li>上面得到的<code>point</code>对象调用的就是默认的无参构造方法</li>
</ul>
</li>
<li>也可以根据自己的需求自定义构造方法<ul>
<li>当我们创建了自己的构造方法时，默认的无参的构造方法将会失效，不能使用,否则会报错</li>
<li>因为<code>Dart</code>本身不支持函数的重载, 所以如果我们明确的写一个默认的构造方法，就会和我们自定义的构造方法冲突</li>
</ul>
</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line">  <span class="built_in">int</span> age;</span><br><span class="line"></span><br><span class="line">  Student(<span class="built_in">String</span> name, <span class="built_in">int</span> age) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在上面构造方法中主要实现的就是通过构造函数的参数给类的户型赋值</li>
<li>为了简化这一过程, <code>Dart</code>提供了一种更加简洁的语法糖形式</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student1</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line">  <span class="built_in">int</span> age;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里和上面的Studeng的构造方法等价</span></span><br><span class="line">  Student1(<span class="keyword">this</span>.name, <span class="keyword">this</span>.age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="命名构造方法"><a href="#命名构造方法" class="headerlink" title="命名构造方法"></a>命名构造方法</h3><ul>
<li>在实际开发中, 很明显一个构造方法的确是不够我们使用的</li>
<li>而且<code>Dart</code>又不支持函数的重载, 不能创建爱你相同名称不同参数的构造方法</li>
<li>这就衍生出了另外一中构造方法:命名构造方法</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line">  <span class="built_in">int</span> age;</span><br><span class="line"></span><br><span class="line">  Model(<span class="keyword">this</span>.name, <span class="keyword">this</span>.age);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 命名构造方法</span></span><br><span class="line">  Model.withNameAndAge(<span class="built_in">String</span> name, <span class="built_in">int</span> age) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 命名构造方法</span></span><br><span class="line">  Model.initJson(<span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Object</span>&gt; map) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = map[<span class="string">&#x27;name&#x27;</span>];</span><br><span class="line">    <span class="keyword">this</span>.age = map[<span class="string">&#x27;age&#x27;</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化对象</span></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="comment">// 普通构造方法</span></span><br><span class="line">  <span class="keyword">var</span> model0 = Model(<span class="string">&#x27;name&#x27;</span>, <span class="number">12</span>);</span><br><span class="line">  <span class="comment">// 命名构造方法</span></span><br><span class="line">  <span class="keyword">var</span> model1 = Model.withNameAndAge(<span class="string">&#x27;titan&#x27;</span>, <span class="number">12</span>);</span><br><span class="line">  <span class="keyword">var</span> model2 = Model.initJson(&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;jun&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h3><p>几种方式定义的属性都是可变的, 如果定义的属性是<code>final</code>不可重新赋值的又该如何实现</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> name;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> age;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. 这里会有一个错误提示: All final variables must be initialized, but &#x27;age&#x27; and &#x27;name&#x27; are not</span></span><br><span class="line">  Teacher(<span class="built_in">String</span> name, <span class="built_in">int</span> age) &#123;</span><br><span class="line">    <span class="comment">//2. 这里也会有一个错误提示: &#x27;name&#x27; can&#x27;t be used as a setter because it&#x27;s final</span></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>上面第一处错误主要是因为: 在<code>Dart</code>中在执行下面<code>&#123; &#125;</code>中的代码的时候, 表示<code>Teacher</code>对象已经初始化完毕了</li>
<li>所以在执行<code>&#123; &#125;</code>之前, 必须保证<code>name</code>和<code>age</code>被初始化了</li>
<li>而且<code>final</code>修饰的属性是不可被重新赋值的, 所以才会报错</li>
<li>或者也可以使用函数中的命名可选参数处理</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Size</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> width;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> height;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> area;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 命名可选参数</span></span><br><span class="line">  Size(<span class="keyword">this</span>.width, <span class="keyword">this</span>.height, &#123; <span class="keyword">this</span>.area = <span class="number">10</span> &#125;); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>上面通过命名可选参数的形式, 给参数设置默认值也是可以的, 但是不同的是<code>area</code>只能设置具体的数值, 不能设置表达式</li>
<li>初始化列表的形式不但可以设置具体的数值, 也可以设置默认值为表达式的形式</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Size</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> width;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> height;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> area;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 多个属性使用逗号分隔</span></span><br><span class="line">  Size(<span class="built_in">double</span> width, <span class="built_in">double</span> height): </span><br><span class="line">    <span class="keyword">this</span>.width = width,</span><br><span class="line">    <span class="keyword">this</span>.height = height,</span><br><span class="line">    <span class="keyword">this</span>.area = width * height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="重定向构造方法"><a href="#重定向构造方法" class="headerlink" title="重定向构造方法"></a>重定向构造方法</h3><ul>
<li>下面的构造函数中, 我们只能通过传入两个参数来获取一个对象</li>
<li>如果在某些情况下, 希望只通过一个<code>name</code>变量来获取一个对象</li>
<li>这种情况下, 就可以通过在构造方法中去调用另外一个构造方法, 这个时候可以使用重定向构造方法</li>
<li>需要注意的是: 在一个构造函数中，去调用另外一个构造函数, 是在冒号后面使用this调用</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line">  <span class="built_in">int</span> age;</span><br><span class="line"></span><br><span class="line">  Point(<span class="keyword">this</span>.name, <span class="keyword">this</span>.age);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重定向的构造方法</span></span><br><span class="line">  Point.fromName(<span class="built_in">String</span> name): <span class="keyword">this</span>(name, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方法</span></span><br><span class="line"><span class="keyword">var</span> point = Point.fromName(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="built_in">print</span>(point.age);  <span class="comment">// 输出: 0</span></span><br></pre></td></tr></table></figure>


<h3 id="常量构造函数"><a href="#常量构造函数" class="headerlink" title="常量构造函数"></a>常量构造函数</h3><ul>
<li>在某些情况下, 我们希望通过构造函数, 只要传入相同的参数, 那么得到的对象就是同一个</li>
<li>在<code>Dart</code>中判断两个对象是否是同一个的方法是通过函数<code>identical</code>判断, 返回值是一个布尔值</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 普通构造函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line">  <span class="built_in">int</span> age;</span><br><span class="line"></span><br><span class="line">  Person(<span class="keyword">this</span>.name, <span class="keyword">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化列表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Size</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> width;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> height;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> area;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 多个属性使用逗号分隔</span></span><br><span class="line">  Size(<span class="built_in">double</span> width, <span class="built_in">double</span> height): </span><br><span class="line">    <span class="keyword">this</span>.width = width,</span><br><span class="line">    <span class="keyword">this</span>.height = height,</span><br><span class="line">    <span class="keyword">this</span>.area = width * height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="keyword">var</span> p1 = Person(<span class="string">&quot;name&quot;</span>, <span class="number">10</span>);</span><br><span class="line">  <span class="keyword">var</span> p2 = Person(<span class="string">&quot;name&quot;</span>, <span class="number">10</span>);</span><br><span class="line">  <span class="comment">// 判断两个对象是不是同一个</span></span><br><span class="line">  <span class="built_in">print</span>(identical(p1, p2));    <span class="comment">/// <span class="language-markdown">false</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> s1 = Size(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">  <span class="keyword">var</span> s2 = Size(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">  <span class="comment">// 判断两个对象是不是同一个</span></span><br><span class="line">  <span class="built_in">print</span>(identical(s1, s2));    <span class="comment">/// <span class="language-markdown">false</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>很明显上面两种方式初始化的对象都不是同一个</li>
<li>其实在<code>Dart</code>中如果将构造方法前加<code>const</code>进行修饰，那么可以保证相同的参数，创建出来的对象是相同的</li>
<li>这样的构造方法就称之为常量构造方法</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 常量构造方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> name;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> Teacher(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="comment">// 常量构造方法</span></span><br><span class="line">  <span class="comment">// 这里的const不可以省略</span></span><br><span class="line">  <span class="keyword">var</span> t1 = <span class="keyword">const</span> Teacher(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> t2 = <span class="keyword">const</span> Teacher(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">  <span class="built_in">print</span>(identical(t1, t2));    <span class="comment">/// <span class="language-markdown">true</span></span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 这里的const可以省略</span></span><br><span class="line">  <span class="keyword">const</span> t3 = Teacher(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> t4 = Teacher(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">  <span class="built_in">print</span>(identical(t3, t4));    <span class="comment">/// <span class="language-markdown">true</span></span></span><br><span class="line">  <span class="built_in">print</span>(identical(t1, t4));    <span class="comment">/// <span class="language-markdown">true</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>常量构造方法有一些注意点:</p>
<ul>
<li>拥有常量构造方法的类中，所有的成员变量必须是<code>final</code>修饰的.</li>
<li>为了可以通过常量构造方法，创建出相同的对象，不再使用<code>new</code>关键字，而是使用<code>const</code>关键字</li>
<li>如果是将结果赋值给<code>const</code>修饰的标识符时，<code>const</code>可以省略.</li>
</ul>
<h3 id="工厂构造方法"><a href="#工厂构造方法" class="headerlink" title="工厂构造方法"></a>工厂构造方法</h3><ul>
<li>在<code>Dart</code>提供了<code>factory</code>关键字, 用于通过工厂去获取对象</li>
<li>普通的构造函数, 会默认返回创建出来的对象, 不需要我们手动<code>return</code></li>
<li>工厂构造方法, 需要手动返回一个对象</li>
<li>同样和上面一样的目的, 只要传入相同的参数, 那么得到的对象就是同一个, 下面通过工厂构造函数的方式实现</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> p1 = Person.fromName(<span class="string">&quot;titan&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> p2 = Person.fromName(<span class="string">&quot;titan&quot;</span>);</span><br><span class="line">  <span class="built_in">print</span>(identical(p1, p2)); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于缓存创建的对象, 避免大量的创建和销毁对象</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, Person&gt; _cache = &lt;<span class="built_in">String</span>, Person&gt;&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">factory</span> Person.fromName(<span class="built_in">String</span> name) &#123;</span><br><span class="line">    <span class="keyword">if</span> (_cache.containsKey(name)) &#123;</span><br><span class="line">      <span class="keyword">return</span> _cache[name];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> p = Person(name);</span><br><span class="line">      _cache[name] = p;</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Person(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><h3 id="setter和getter"><a href="#setter和getter" class="headerlink" title="setter和getter"></a>setter和getter</h3><ul>
<li><code>Dart</code>中类定义的属性默认是可以直接被外界访问的</li>
<li><code>Dart</code>中也存在<code>setter</code>和<code>getter</code>方法, 用于监听累的属性被访问的过程</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">var</span> people = People(<span class="string">&#x27;top&#x27;</span>);</span><br><span class="line">  people.setName = <span class="string">&#x27;top&#x27;</span>;</span><br><span class="line">  <span class="built_in">print</span>(people.getName);</span><br><span class="line">  <span class="built_in">print</span>(people.name);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> person = Person(<span class="string">&#x27;titan&#x27;</span>);</span><br><span class="line">  person.setName = <span class="string">&#x27;jun&#x27;</span>;</span><br><span class="line">  <span class="built_in">print</span>(person.getName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// setter</span></span><br><span class="line">  <span class="keyword">set</span> setName(<span class="built_in">String</span> value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// getter</span></span><br><span class="line">  <span class="built_in">String</span> <span class="keyword">get</span> getName &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;titanjun&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  People(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>上面<code>setName</code>和<code>getName</code>是自定义的, 你也可以命名为<code>setterName</code>和<code>getterName</code>等</li>
<li>还有就是上述两个方法不是系统自动生成的, 是需要我们手动添加的</li>
<li>简单的方式也可以使用箭头函数</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// setter</span></span><br><span class="line">  <span class="keyword">set</span> setName(<span class="built_in">String</span> value) =&gt; <span class="keyword">this</span>.name = value;</span><br><span class="line">  <span class="comment">// getter</span></span><br><span class="line">  <span class="built_in">String</span> <span class="keyword">get</span> getName =&gt; <span class="string">&#x27;titanjun&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  Person(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="类的继承-1"><a href="#类的继承-1" class="headerlink" title="类的继承"></a>类的继承</h3><ul>
<li>在<code>Dart</code>中同样支持类的继承, 继承使用<code>extends</code>关键字，子类中使用<code>super</code>来访问父类</li>
<li>父类中除了构造方法外, 所有的成员变量和方法都会被继承</li>
<li>子类可以拥有自己的成员变量, 并且可以对父类的方法进行重写</li>
<li>子类中可以调用父类的构造方法，对某些属性进行初始化：<ul>
<li>子类的构造方法在执行前，将隐含调用父类的无参默认构造方法（没有参数且与类同名的构造方法）</li>
<li>如果父类没有无参默认构造方法，则子类的构造方法必须在初始化列表中通过<code>super</code>显式调用父类的某个构造方法</li>
</ul>
</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line"></span><br><span class="line">  People(<span class="keyword">this</span>.name);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> eat() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;people -- eat&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> age;</span><br><span class="line"></span><br><span class="line">  Person(<span class="built_in">String</span> name, <span class="built_in">int</span> age): <span class="keyword">this</span>.age = age, <span class="keyword">super</span>(name);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> eat() &#123;</span><br><span class="line">    <span class="comment">// 这里的super, 看个人需求是否调用</span></span><br><span class="line">    <span class="keyword">super</span>.eat();</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Person -- eat&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="keyword">var</span> people = People(<span class="string">&#x27;name&#x27;</span>);</span><br><span class="line">  people.eat();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> person = Person(<span class="string">&quot;top&quot;</span>, <span class="number">10</span>);</span><br><span class="line">  person.eat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><ul>
<li>在<code>Dart</code>中抽象类是使用<code>abstract</code>声明的类</li>
<li>在<code>Dart</code>中没有具体实现的方法(没有方法体)，就是抽象方法</li>
<li>抽象方法，必须存在于抽象类中, 抽象类不能实例化</li>
<li>抽象类中的抽象方法必须被子类实现, 抽象类中的已经被实现方法, 可以不被子类重写</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Size</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> width;</span><br><span class="line">  <span class="built_in">int</span> height;</span><br><span class="line"></span><br><span class="line">  Size(<span class="keyword">this</span>.width, <span class="keyword">this</span>.height);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> getSize();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">int</span> getArea() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.width * <span class="keyword">this</span>.height;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Area</span> <span class="keyword">extends</span> <span class="title">Size</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> getSize() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;width = <span class="subst">$width</span>, height = <span class="subst">$height</span>&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Area(<span class="built_in">int</span> width, <span class="built_in">int</span> height): <span class="keyword">super</span>(width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="comment">// 实例化Size会报错: Abstract classes can&#x27;t be instantiated</span></span><br><span class="line">  <span class="comment">// var size = Size(20, 2);</span></span><br><span class="line">  <span class="keyword">var</span> area = Area(<span class="number">10</span>, <span class="number">2</span>);</span><br><span class="line">  area.getArea();</span><br><span class="line">  <span class="built_in">print</span>(area.getArea());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="类成员和方法"><a href="#类成员和方法" class="headerlink" title="类成员和方法"></a>类成员和方法</h3><p>在<code>Dart</code>中我们使用<code>static</code>关键字来定义类成员和类方法</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main() &#123;</span><br><span class="line"> <span class="keyword">var</span> person = Person();</span><br><span class="line"> <span class="built_in">print</span>(person.firstName);</span><br><span class="line"> person.<span class="keyword">hide</span>();</span><br><span class="line"></span><br><span class="line"> <span class="built_in">print</span>(Person.lastName);</span><br><span class="line"> Person.<span class="keyword">show</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">String</span> firstName = <span class="string">&#x27;top&#x27;</span>;</span><br><span class="line">  <span class="comment">// 不能使用this调用静态属性</span></span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">String</span> lastName = <span class="string">&#x27;titanjun&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> <span class="keyword">hide</span>() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;titanjun&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 静态方法</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">show</span>() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;https://www.<span class="subst">$lastName</span>.top&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h2><p>在<code>Dart</code>中只有单继承, 是不支持多继承的, 但是我们却可以通过其他方式间接实现多继承问题</p>
<h3 id="隐式接口"><a href="#隐式接口" class="headerlink" title="隐式接口"></a>隐式接口</h3><ul>
<li><code>Dart</code>中的接口比较特殊, 没有一个专门的关键字来声明接口, 默认情况下所有的类都是隐式接口</li>
<li>默认情况下，定义的每个类都相当于默认也声明了一个接口，可以由其他的类来实现</li>
<li>在<code>Dart</code>开发中，我们通常将用于给别人实现的类声明为抽象类</li>
<li>当将一个类能够做接口使用时, 那么实现这个接口的类, 必须实现这个接口中的所有方法</li>
<li>在<code>Dart</code>中通过<code>implements</code>来实现多继承问题, 但是必须实现这个接口中的所有方法, 而且在方法的实现中不能调用<code>super</code>方法</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> eat();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> student() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;student&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> run() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;runner&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Woman</span>, <span class="title">Man</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> eat() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;eat&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> student() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;student--student&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> run() &#123;</span><br><span class="line">    <span class="comment">// 这里不能调用super方法</span></span><br><span class="line">    <span class="comment">// super.run(); </span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;run&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="keyword">var</span> stu = Student();</span><br><span class="line">  stu.eat();</span><br><span class="line">  stu.run();</span><br><span class="line">  stu.student();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="Mixin混入"><a href="#Mixin混入" class="headerlink" title="Mixin混入"></a>Mixin混入</h3><ul>
<li>在通过<code>implements</code>实现某个类时，类中所有的方法都必须被重新实现(无论这个类原来是否已经实现过该方法)</li>
<li>但是某些情况下，一个类可能希望直接复用之前类的原有实现方案</li>
<li>Dart提供了另外一种方案: Mixin混入的方式<ul>
<li>除了可以通过<code>class</code>定义类之外，也可以通过<code>mixin</code>关键字来定义一个类。</li>
<li>只是通过<code>mixin</code>定义的类用于被其他类混入使用，通过<code>with</code>关键字来进行混入</li>
</ul>
</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mixin</span> Runner &#123;</span><br><span class="line">  run() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;在奔跑&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mixin</span> Flyer &#123;</span><br><span class="line">  fly() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;在飞翔&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里可以对原方法不做任何实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span> <span class="title">with</span> <span class="title">Runner</span>, <span class="title">Flyer</span> </span>&#123;  &#125;</span><br><span class="line"></span><br><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="keyword">var</span> bird = Bird();</span><br><span class="line">  bird.run();</span><br><span class="line">  bird.fly();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://mp.weixin.qq.com/s/xdSYvqSYOXTOCeb89C1uvg">Flutter之搞定Dart二</a>: coderwhy老师的公众号知识</li>
<li><a href="https://dart.dev/guides/language/language-tour#classes">Dart官网语法介绍-英文版</a></li>
<li><a href="http://www.shutongye.com/dartapi/dart-core/Map-class.html">Dart语言中文社区</a></li>
</ul>
<hr>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
        <tag>Dart</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter开发之Dart的数据类型01</title>
    <url>/post/d6a5aafa.html</url>
    <content><![CDATA[<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/flutter/dart-logo.png?x-oss-process=style/titanjun" alt="dart-logo"></p>
<span id="more"></span>



<ul>
<li>这几篇文章都是在学习<code>Dart</code>过程中所记录的学习笔记, 都是一些基础知识, 几乎没什么技术含量, 主要是方便后期使用的时候方便查阅</li>
<li>我写的<a href="https://www.titanjun.top/categories/Flutter%E7%AC%94%E8%AE%B0/">Flutter和Dart语法系列相关的文章</a>, 有兴趣的可参考随便看看</li>
</ul>
<h2 id="Dart数据类型"><a href="#Dart数据类型" class="headerlink" title="Dart数据类型"></a>Dart数据类型</h2><p><code>Dart</code>内置的数据类型中, 支持以下几种数据类型</p>
<ul>
<li><code>numbers</code>(数字)</li>
<li><code>strings</code>(字符串)</li>
<li><code>booleans</code>(布尔)</li>
<li><code>lists</code> (也被称之为 <code>arrays</code>)</li>
<li><code>maps</code></li>
<li><code>runes</code> (用于在字符串中表示<code>Unicode</code>字符)</li>
<li><code>symbols</code></li>
</ul>
<p>上面的数据类型可以直接使用字面量初始化</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;this is a string&#x27;</span> ;</span><br><span class="line"><span class="keyword">var</span> isStr = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure>

<p>也可以使用构造函数初始化, 由于<code>Dart</code>中每个变量引用的都是一个对象 – 一个类的实例, 一些内置的类型具有自己的构造函数</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以使用 Map()构造函数来创建一个 map，就像这样 </span></span><br><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br></pre></td></tr></table></figure>


<blockquote>
<p><code>Dart</code>中<code>Numbers</code>支持两种类型的数字：</p>
</blockquote>
<ul>
<li><code>int</code>: 整数值，其取值通常位于<code>-2^53</code>和<code>2^53</code>之间, 差不多<code>9*10^16</code>, 也就是支持16位数字</li>
<li><code>double</code>: <code>64-bit</code> (双精度) 浮点数，符合<code>IEEE 754</code>标准</li>
</ul>
<h2 id="int"><a href="#int" class="headerlink" title="int"></a>int</h2><ul>
<li>其取值通常位于<code>-2^53</code>和<code>2^53</code>之间</li>
<li>也就是-9,007,199,254,740,992和9,007,199,254,740,992之间</li>
<li>实际在编译中则是超过19位则会报错</li>
<li>更多可参考<a href="https://github.com/dart-lang/sdk/issues/1533">问题 1533</a>了解更多信息</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如下定义则会报错, 定义的int星变量需要在9,223,372,036,854,775,807 or less than -9,223,372,036,854,775,808之间</span></span><br><span class="line"><span class="keyword">var</span> bil = <span class="number">12345678901234567890</span>;</span><br></pre></td></tr></table></figure>

<p>一些常用的判断属性</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m1 = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否为负数, 大于0即为false</span></span><br><span class="line"><span class="built_in">print</span>(m1.isNegative);</span><br><span class="line"><span class="built_in">print</span>(<span class="number">0.</span>isNegative);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否是有限的</span></span><br><span class="line"><span class="built_in">print</span>(b32.isFinite);</span><br><span class="line"><span class="built_in">print</span>(m1.isFinite);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否是无穷大或者无穷小</span></span><br><span class="line"><span class="built_in">print</span>(m1.isInfinite);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否为偶数</span></span><br><span class="line"><span class="built_in">print</span>(m1.isEven);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否为奇数</span></span><br><span class="line"><span class="built_in">print</span>(m1.isOdd);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否是NaN值</span></span><br><span class="line"><span class="built_in">print</span>(m1.isNaN);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据的符号，-1.0:值小于0、+1.0:值大于0、-0.0/0.0/NaN:值是其本身</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">21.</span>sign);  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">-23.</span>sign); <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">0.</span>sign);   <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">-0.</span>sign);  <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p><code>int</code>数字类型中常用的函数</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m3 = <span class="number">24</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取绝对值</span></span><br><span class="line"><span class="built_in">print</span>(m3.abs());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转成字符串</span></span><br><span class="line"><span class="built_in">print</span>(m3.toString());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 幂次求模; m3的4次幂, 在对3求模</span></span><br><span class="line"><span class="built_in">print</span>(m3.modPow(<span class="number">4</span>, <span class="number">3</span>)); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回m3和16的最大公约数</span></span><br><span class="line"><span class="built_in">print</span>(m3.gcd(<span class="number">16</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回m3除以5的余数</span></span><br><span class="line"><span class="built_in">print</span>(m3.remainder(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转成double</span></span><br><span class="line"><span class="built_in">print</span>(m3.toDouble());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较大小, 0:相同、1:大于、-1:小于</span></span><br><span class="line"><span class="built_in">print</span>(m3.compareTo(<span class="number">30</span>));</span><br></pre></td></tr></table></figure>



<h2 id="double"><a href="#double" class="headerlink" title="double"></a>double</h2><p>下面是定义<code>double</code>的一些方式：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> y = <span class="number">1.1</span>;</span><br><span class="line"><span class="keyword">var</span> exponents = <span class="number">1.42e5</span>;</span><br></pre></td></tr></table></figure>

<p><code>double</code>类型相关的属性使用</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 是否是NaN值</span></span><br><span class="line"><span class="built_in">print</span>(d0.isNaN);</span><br><span class="line"><span class="comment">// 是否是无穷大或者无穷小</span></span><br><span class="line"><span class="built_in">print</span>(d0.isInfinite);</span><br><span class="line"><span class="comment">// 是否是有限的</span></span><br><span class="line"><span class="built_in">print</span>(d0.isFinite);</span><br><span class="line"><span class="comment">// 是否为负数, 大于0即为false</span></span><br><span class="line"><span class="built_in">print</span>(d0.isNegative);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据代码单元生成的哈希码</span></span><br><span class="line"><span class="built_in">print</span>(d0.hashCode);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据的符号，-1.0:值小于0、+1.0:值大于0、-0.0/0.0/NaN:值是其本身</span></span><br><span class="line"><span class="built_in">print</span>(d0.sign);</span><br><span class="line"><span class="built_in">print</span>(<span class="number">-1.23</span>.sign);</span><br><span class="line"><span class="built_in">print</span>(<span class="number">0.0</span>.sign);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回运行时的类型</span></span><br><span class="line"><span class="built_in">print</span>(d0.runtimeType);  <span class="comment">// double</span></span><br></pre></td></tr></table></figure>

<p><code>double</code>类型相关方法的使用</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 转成字符串</span></span><br><span class="line"><span class="built_in">print</span>(d0.toString());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取整数, 小数点舍去</span></span><br><span class="line"><span class="built_in">print</span>(d0.toInt());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较大小, 0:相同、1:大于、-1:小于</span></span><br><span class="line"><span class="built_in">print</span>(d0.compareTo(<span class="number">30</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取绝对值</span></span><br><span class="line"><span class="built_in">print</span>(d0.abs());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 四舍五入</span></span><br><span class="line"><span class="built_in">print</span>(d0.round()); <span class="comment">// 13</span></span><br><span class="line"><span class="comment">// 向上取整</span></span><br><span class="line"><span class="built_in">print</span>(d0.ceil());  <span class="comment">// 14</span></span><br><span class="line"><span class="comment">// 向下取整</span></span><br><span class="line"><span class="built_in">print</span>(d0.floor()); <span class="comment">// 13</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出的double类型, 相当于d0.round().toDouble()</span></span><br><span class="line"><span class="built_in">print</span>(d0.roundToDouble()); <span class="comment">// 13.0</span></span><br><span class="line"><span class="built_in">print</span>(d0.ceilToDouble());  <span class="comment">// 14.0</span></span><br><span class="line"><span class="built_in">print</span>(d0.floorToDouble()); <span class="comment">// 13.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 保留指定的小数位数(四舍五入), 不足补0, 字符串返回</span></span><br><span class="line"><span class="built_in">print</span>(d0.toStringAsFixed(<span class="number">2</span>)); <span class="comment">// 13.10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 保留变量的位数(小数点前后的总位数), 不足补0, 多余的四舍五入</span></span><br><span class="line"><span class="built_in">print</span>(d0.toStringAsPrecision(<span class="number">10</span>));  <span class="comment">// 13.09870000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="language-markdown">/<span class="strong">**  toStringAsExponential</span></span></span></span><br><span class="line"><span class="strong"><span class="language-markdown"><span class="comment"> <span class="emphasis">*     1.toStringAsExponential();       // 1e+0</span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="language-markdown"><span class="comment"> *</span>     1.toStringAsExponential(3);      // 1.000e+0</span></span></span></span><br><span class="line"><span class="strong"><span class="language-markdown"><span class="comment"> <span class="emphasis">*     123456.toStringAsExponential();  // 1.23456e+5</span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="language-markdown"><span class="comment"> *</span>     123456.toStringAsExponential(3); // 1.235e+5</span></span></span></span><br><span class="line"><span class="strong"><span class="language-markdown"><span class="comment"> <span class="emphasis">*     123.toStringAsExponential(0);    // 1e+2</span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="language-markdown"><span class="comment"> *</span>/</span></span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="language-markdown"><span class="strong">/**</span> toStringAsPrecision</span></span></span><br><span class="line"><span class="language-markdown"><span class="comment"><span class="bullet"> *</span>     1.toStringAsPrecision(2);       // 1.0</span></span></span><br><span class="line"><span class="language-markdown"><span class="comment"><span class="bullet"> *</span>     1e15.toStringAsPrecision(3);    // 1.00e+15</span></span></span><br><span class="line"><span class="language-markdown"><span class="comment"><span class="bullet"> *</span>     1234567.toStringAsPrecision(3); // 1.23e+6</span></span></span><br><span class="line"><span class="language-markdown"><span class="comment"><span class="bullet"> *</span>     1234567.toStringAsPrecision(9); // 1234567.00</span></span></span><br><span class="line"><span class="language-markdown"><span class="comment"><span class="bullet"> *</span>     12345678901234567890.toStringAsPrecision(20); // 12345678901234567168</span></span></span><br><span class="line"><span class="language-markdown"><span class="comment"><span class="bullet"> *</span>     12345678901234567890.toStringAsPrecision(14); // 1.2345678901235e+19</span></span></span><br><span class="line"><span class="language-markdown"><span class="comment"><span class="bullet"> *</span>     0.00000012345.toStringAsPrecision(15); // 1.23450000000000e-7</span></span></span><br><span class="line"><span class="language-markdown"><span class="comment"><span class="bullet"> *</span>     0.0000012345.toStringAsPrecision(15);  // 0.00000123450000000000</span></span></span><br><span class="line"><span class="language-markdown"><span class="comment"> <span class="emphasis">*/</span></span></span></span><br></pre></td></tr></table></figure>


<h2 id="Booleans"><a href="#Booleans" class="headerlink" title="Booleans"></a>Booleans</h2><ul>
<li>为了代表布尔值，<code>Dart</code>有一个名字为<code>bool</code>的类型。 </li>
<li>只有两个对象是布尔类型的：<code>true</code>和 <code>false</code> 所创建的对象， 这两个对象也都是编译时常量</li>
<li>当<code>Dart</code>需要一个布尔值的时候，只有<code>true</code>对象才被认为是<code>true</code>, 所有其他的值都是<code>flase</code>; 像 1、 <code>&quot;aString&quot;</code>、 以及<code>someObject</code>等值都被认为是<code>false</code></li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (m) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;是一个布尔值&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;不是一个布尔值&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在<code>Dart</code>中上面判断语句是合法的代码</li>
<li>但是在<code>Dart</code>检查模式运行，上面的代码将会抛出一个异常，表示<code>m</code>变量不是一个布尔值</li>
<li>所以不建议这么使用上述方法进行判断</li>
</ul>
<h2 id="Strings"><a href="#Strings" class="headerlink" title="Strings"></a>Strings</h2><p><code>Dart</code>字符串是<code>UTF-16</code>编码的字符序列, 可以使用单引号或者双引号来创建字符串：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">&#x27;Single quotes work well for string literals.&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="string">&quot;Double quotes work just as well.&quot;</span>;</span><br><span class="line"><span class="comment">// 单引号里面有单引号(双引号里面有双引号)时, 必须使用反斜\杠转义</span></span><br><span class="line"><span class="keyword">var</span> s3 = <span class="string">&#x27;It\&#x27;s easy to escape the string delimiter.&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> s4 = <span class="string">&quot;It&#x27;s even easier to use the other delimiter.&quot;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="字符串的拼接"><a href="#字符串的拼接" class="headerlink" title="字符串的拼接"></a>字符串的拼接</h3><p>直接把相邻字符串写在一起，就可以连接字符串了</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> string = <span class="string">&#x27;name&#x27;</span><span class="string">&#x27;+&#x27;</span><span class="string">&#x27;age&#x27;</span></span><br></pre></td></tr></table></figure>

<p>用+把相邻字符串连接起来</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> string1 = <span class="string">&#x27;name&#x27;</span> + <span class="string">&#x27;+&#x27;</span> + <span class="string">&#x27;age&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="引用变量"><a href="#引用变量" class="headerlink" title="引用变量"></a>引用变量</h3><ul>
<li>在<code>Dart</code>中使用<code>$</code>符号引用变量或者表达式</li>
<li>表达式引用方式: <code>$&#123;表达式&#125;</code>, 如果表达式是一个变量则<code>&#123;&#125;</code>可以省略</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> num1 = <span class="number">12</span>;</span><br><span class="line"><span class="comment">// 引用表达式</span></span><br><span class="line"><span class="keyword">const</span> ageStr0 = <span class="string">&#x27;age = <span class="subst">$num1</span>&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> ageStr1 = <span class="string">&#x27;age = <span class="subst">$&#123;num1&#125;</span> is my age&#x27;</span>;</span><br><span class="line"><span class="comment">// 引用表达式</span></span><br><span class="line"><span class="keyword">const</span> ageStr2 = <span class="string">&#x27;age = <span class="subst">$&#123;num1 * num1&#125;</span>&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a>多行字符串</h3><p>使用单引号或双引号的三引号</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> line1 = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    道路千万条，安全第一条，</span></span><br><span class="line"><span class="string">    行车不规范，亲人两行泪</span></span><br><span class="line"><span class="string">  &#x27;&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> line2 = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    道路千万条，安全第一条，</span></span><br><span class="line"><span class="string">    行车不规范，亲人两行泪</span></span><br><span class="line"><span class="string">  &quot;&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="转义符号"><a href="#转义符号" class="headerlink" title="转义符号"></a>转义符号</h3><p>声明<code>raw字符串(前缀为r)</code>，在字符串前加字符<code>r</code>，或者在<code>\</code>前面再加一个<code>\</code>，可以避免<code>\</code>的转义作用，在正则表达式里特别有用</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 转义字符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">r&#x27;转义字符, \n&#x27;</span>);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;转义字符, \\n&#x27;</span>);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;转义字符, \n&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="属性介绍"><a href="#属性介绍" class="headerlink" title="属性介绍"></a>属性介绍</h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> string0 = <span class="string">&#x27;https://www.titanjun.top/&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可根据索引获取字符串的每一个字符</span></span><br><span class="line"><span class="built_in">print</span>(string0[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串是否是空的</span></span><br><span class="line"><span class="built_in">print</span>(string0.isEmpty);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>.isEmpty); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 字符串是否不是空的</span></span><br><span class="line"><span class="built_in">print</span>(string0.isNotEmpty);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>.isNotEmpty);  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回字符串Unicode代码的可迭代对象</span></span><br><span class="line"><span class="built_in">print</span>(string0.runes);</span><br><span class="line"><span class="comment">// 返回字符串的UTF-16代码单元列表</span></span><br><span class="line"><span class="built_in">print</span>(string0.codeUnits);</span><br><span class="line"><span class="comment">// 返回根据代码单元生成的哈希码</span></span><br><span class="line"><span class="built_in">print</span>(string0.hashCode);</span><br><span class="line"><span class="comment">// 字符串的长度</span></span><br><span class="line"><span class="built_in">print</span>(string0.length); </span><br><span class="line"><span class="comment">// 返回对象运行时的类型</span></span><br><span class="line"><span class="built_in">print</span>(string0.runtimeType);  <span class="comment">// String</span></span><br></pre></td></tr></table></figure>

<h3 id="方法介绍"><a href="#方法介绍" class="headerlink" title="方法介绍"></a>方法介绍</h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> string0 = <span class="string">&#x27;https://www.titanjun.top/&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串比较</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;titan&#x27;</span>.compareTo(<span class="string">&#x27;jun&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 大小写转换</span></span><br><span class="line"><span class="built_in">print</span>(string0.toUpperCase());</span><br><span class="line"><span class="built_in">print</span>(string0.toLowerCase());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 截取字符串(开头索引和结尾索引)</span></span><br><span class="line"><span class="built_in">print</span>(string0.substring(<span class="number">0</span>, <span class="number">5</span>)); <span class="comment">// https</span></span><br><span class="line"><span class="comment">// 只有开头索引, 默认截取到最后</span></span><br><span class="line"><span class="built_in">print</span>(string0.substring(<span class="number">12</span>));  <span class="comment">// titanjun.top/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 拆分字符串</span></span><br><span class="line"><span class="built_in">print</span>(string0.split(<span class="string">&#x27;.&#x27;</span>));  <span class="comment">// [https://www, titanjun, top/]</span></span><br><span class="line"><span class="built_in">print</span>(string0.split(<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">r&quot;t&quot;</span>)));  <span class="comment">// [h, , ps://www., i, anjun., op/]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 去掉字符串里面的tab空格和换行符</span></span><br><span class="line"><span class="keyword">const</span> string1 = <span class="string">&#x27;\t\ttitanjun top\n&#x27;</span>;</span><br><span class="line"><span class="built_in">print</span>(string1.trim());</span><br><span class="line"><span class="comment">// 去掉字符串开头的tab空格和换行符</span></span><br><span class="line"><span class="built_in">print</span>(string1.trimLeft());</span><br><span class="line"><span class="comment">// 去掉字符串结尾的tab空格和换行符</span></span><br><span class="line"><span class="built_in">print</span>(string1.trimRight());</span><br></pre></td></tr></table></figure>

<h4 id="endsWith"><a href="#endsWith" class="headerlink" title="endsWith"></a>endsWith</h4><p>判断字符串是否以某字符(字符串)结尾, 参数不接受正则表达式</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str1 = <span class="string">&#x27;titanjun.top&#x27;</span>;</span><br><span class="line"><span class="built_in">print</span>(str1.endsWith(<span class="string">&#x27;p&#x27;</span>));  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">print</span>(str1.endsWith(<span class="string">&#x27;/&#x27;</span>));  <span class="comment">//false</span></span><br><span class="line"><span class="built_in">print</span>(str1.endsWith(<span class="string">&#x27;top&#x27;</span>));  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h4 id="startsWith"><a href="#startsWith" class="headerlink" title="startsWith"></a>startsWith</h4><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bool</span> startsWith(<span class="built_in">Pattern</span> pattern, [<span class="built_in">int</span> index = <span class="number">0</span>]);</span><br></pre></td></tr></table></figure>

<p>判断字符串是否以某字符(字符串)开头, 参数接受正则表达式</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str1 = <span class="string">&#x27;titanjun.top&#x27;</span>;</span><br><span class="line"><span class="built_in">print</span>(str1.startsWith(<span class="string">&#x27;h&#x27;</span>));  <span class="comment">//false</span></span><br><span class="line"><span class="built_in">print</span>(str1.startsWith(<span class="string">&#x27;tit&#x27;</span>)); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">print</span>(str1.startsWith(<span class="string">&#x27;it&#x27;</span>, <span class="number">1</span>)); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">print</span>(str1.startsWith(<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">r&#x27;[A-Z][a-z]&#x27;</span>), <span class="number">1</span>)); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h4 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h4><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> indexOf(<span class="built_in">Pattern</span> pattern, [<span class="built_in">int</span> start]);</span><br></pre></td></tr></table></figure>

<ul>
<li>根据指定的字符(字符串)获取其在原字符串中第一次出现的索引值, 顺序是从左到右</li>
<li>可以从指定的索引初开始, 默认从0开始</li>
<li>如果原字符串中没有需要查找的字符(字符串), 则返回值为: -1</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str2 = <span class="string">&#x27;https://www.titanjun.top/&#x27;</span>;</span><br><span class="line"><span class="built_in">print</span>(str2.indexOf(<span class="string">&#x27;titan&#x27;</span>)); <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">print</span>(str2.indexOf(<span class="string">&#x27;t&#x27;</span>, <span class="number">5</span>));  <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">print</span>(str2.indexOf(<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">r&#x27;[a-z]&#x27;</span>))); <span class="comment">//0</span></span><br><span class="line"><span class="comment">// 如果没有改字符, 则会输出-1</span></span><br><span class="line"><span class="built_in">print</span>(str2.indexOf(<span class="string">&#x27;ppp&#x27;</span>));  <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>

<h4 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="lastIndexOf"></a>lastIndexOf</h4><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> lastIndexOf(<span class="built_in">Pattern</span> pattern, [<span class="built_in">int</span> start]);</span><br></pre></td></tr></table></figure>

<p>效果和<code>indexOf</code>一样, 不同点则是: <code>indexOf</code>的顺序是从左到右, <code>lastIndexOf</code>是从右到左</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str2 = <span class="string">&#x27;https://www.titanjun.top/&#x27;</span>;</span><br><span class="line"><span class="built_in">print</span>(str2.lastIndexOf(<span class="string">&#x27;t&#x27;</span>, <span class="number">20</span>));  <span class="comment">//14</span></span><br><span class="line"><span class="built_in">print</span>(str2.indexOf(<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">r&#x27;[a-z]&#x27;</span>))); <span class="comment">//0</span></span><br><span class="line"><span class="comment">// 如果没有改字符, 则会输出-1</span></span><br><span class="line"><span class="built_in">print</span>(str2.indexOf(<span class="string">&#x27;ppp&#x27;</span>));  <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>

<h4 id="补占位符"><a href="#补占位符" class="headerlink" title="补占位符"></a>补占位符</h4><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span> padLeft(<span class="built_in">int</span> width, [<span class="built_in">String</span> padding = <span class="string">&#x27; &#x27;</span>]);</span><br><span class="line"><span class="built_in">String</span> padRight(<span class="built_in">int</span> width, [<span class="built_in">String</span> padding = <span class="string">&#x27; &#x27;</span>]);</span><br></pre></td></tr></table></figure>

<ul>
<li>在字符串前后补占位符</li>
<li>参数一: 想要得到的字符串的位数</li>
<li>参数二: 位数不足时, 补充的字符</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str3 = <span class="string">&#x27;12&#x27;</span>;</span><br><span class="line"><span class="built_in">print</span>(str3.padLeft(<span class="number">2</span>, <span class="string">&#x27;0&#x27;</span>)); <span class="comment">//12</span></span><br><span class="line"><span class="built_in">print</span>(str3.padRight(<span class="number">3</span>, <span class="string">&#x27;0&#x27;</span>)); <span class="comment">// 120</span></span><br></pre></td></tr></table></figure>

<h4 id="contains"><a href="#contains" class="headerlink" title="contains"></a>contains</h4><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bool</span> contains(<span class="built_in">Pattern</span> other, [<span class="built_in">int</span> startIndex = <span class="number">0</span>]);</span><br></pre></td></tr></table></figure>

<ul>
<li>判断字符串中是否包含某字符</li>
<li>判断指定索引处的字符是否是某字符</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bool</span> contains(<span class="built_in">Pattern</span> other, [<span class="built_in">int</span> startIndex = <span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;Dart strings&#x27;</span>;</span><br><span class="line"><span class="built_in">print</span>(str.contains(<span class="string">&#x27;D&#x27;</span>));</span><br><span class="line"><span class="built_in">print</span>(str.contains(<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">r&#x27;[A-Z]&#x27;</span>)));</span><br><span class="line"><span class="built_in">print</span>(str.contains(<span class="string">&#x27;D&#x27;</span>, <span class="number">0</span>));</span><br><span class="line"><span class="built_in">print</span>(str.contains(<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">r&#x27;[A-Z]&#x27;</span>), <span class="number">0</span>));</span><br></pre></td></tr></table></figure>

<h4 id="替换字符"><a href="#替换字符" class="headerlink" title="替换字符"></a>替换字符</h4><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只能替换一次, 参数三为开始的索引值, 默认0</span></span><br><span class="line"><span class="built_in">String</span> replaceFirst(<span class="built_in">Pattern</span> from, <span class="built_in">String</span> to, [<span class="built_in">int</span> startIndex = <span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 替换所有符合条件的字符(字符串)</span></span><br><span class="line"><span class="built_in">String</span> replaceAll(<span class="built_in">Pattern</span> from, <span class="built_in">String</span> replace);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 替换某一区间的字符</span></span><br><span class="line"><span class="built_in">String</span> replaceRange(<span class="built_in">int</span> start, <span class="built_in">int</span> end, <span class="built_in">String</span> replacement);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例如下:</span></span><br><span class="line"><span class="comment">// 替换字符串</span></span><br><span class="line">  <span class="keyword">const</span> str4 = <span class="string">&#x27;titanjun12--0123&#x27;</span>;</span><br><span class="line">  <span class="built_in">print</span>(str4.replaceFirst(<span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;T&#x27;</span>));  <span class="comment">// Titanjun12--0123</span></span><br><span class="line">  <span class="built_in">print</span>(str4.replaceFirst(<span class="string">&#x27;12&#x27;</span>, <span class="string">&#x27;21&#x27;</span>, <span class="number">10</span>));   <span class="comment">//titanjun12--0213</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 全部替换</span></span><br><span class="line">  <span class="built_in">print</span>(str4.replaceAll(<span class="string">&#x27;12&#x27;</span>, <span class="string">&#x27;21&#x27;</span>));  <span class="comment">//titanjun21--0213</span></span><br><span class="line">  <span class="built_in">print</span>(str4.replaceAll(<span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;T&#x27;</span>));  <span class="comment">//TiTanjun12--0123</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 区间替换</span></span><br><span class="line">  <span class="built_in">print</span>(str4.replaceRange(<span class="number">0</span>, <span class="number">5</span>, <span class="string">&#x27;top&#x27;</span>));  <span class="comment">//topjun12--0123</span></span><br></pre></td></tr></table></figure>

<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>在<code>Dart</code>中<code>List</code>对象就是其他语言中的数组</p>
<h3 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个指定长度的List, 不能添加/删除元素</span></span><br><span class="line"><span class="built_in">List</span>([<span class="built_in">int</span> length]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过指定长度创建一个固定长度的List，并使用fill初始化每个位置的值, 不能添加/删除元素</span></span><br><span class="line"><span class="built_in">List</span>.filled(<span class="built_in">int</span> length, E fill, &#123;<span class="built_in">bool</span> growable: <span class="keyword">false</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个包含所有elements的List, </span></span><br><span class="line"><span class="comment">//当growable为true（默认）时，构造函数返回一个可增长的List。 否则，它返回一个固定长度的List</span></span><br><span class="line"><span class="built_in">List</span>.from(<span class="built_in">Iterable</span> elements, &#123;<span class="built_in">bool</span> growable: <span class="keyword">true</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成一个包含所有值的List</span></span><br><span class="line"><span class="comment">//除非growable为true(默认)，否则创建的List是固定长度的</span></span><br><span class="line"><span class="built_in">List</span>.generate(<span class="built_in">int</span> length, E generator(<span class="built_in">int</span> index), &#123;<span class="built_in">bool</span> growable: <span class="keyword">true</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个包含所有elements的，不能改变它的长度或元素</span></span><br><span class="line"><span class="built_in">List</span>.unmodifiable(<span class="built_in">Iterable</span> elements)</span><br></pre></td></tr></table></figure>

<h4 id="List-1"><a href="#List-1" class="headerlink" title="List"></a>List</h4><ul>
<li>如果设置了参数<code>length</code>(<code>length</code>不能为负数或<code>null</code>)，那么创建的<code>List</code>是固定长度的</li>
<li>元素可修改, 元素个数不可修改, 不能删除和增加元素</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> l1 = <span class="keyword">new</span> <span class="built_in">List</span>(<span class="number">3</span>);  <span class="comment">//[null, null, null]</span></span><br><span class="line"><span class="built_in">print</span>(l1.length);  <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面这种写法会报错</span></span><br><span class="line">l1.length = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>如果未设置参数<code>length</code>，那么<code>List</code>的长度是0，并且是可增长的</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这两种方式一样</span></span><br><span class="line"><span class="keyword">var</span> l10 = <span class="keyword">new</span> <span class="built_in">List</span>();</span><br><span class="line"><span class="keyword">var</span> l11 = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 都是可行的</span></span><br><span class="line">l10.length = <span class="number">3</span>;</span><br><span class="line">l10.add(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>当使用指定长度创建一个可增长的<code>List</code>时，仅仅在刚创建后分配长度</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">List</span> growableList = <span class="keyword">new</span> <span class="built_in">List</span>()..length = <span class="number">500</span>;</span><br></pre></td></tr></table></figure>

<h4 id="filled"><a href="#filled" class="headerlink" title="filled"></a>filled</h4><ul>
<li>通过指定长度创建一个固定长度的<code>List</code>，并初始化每个位置的值</li>
<li>所有的元素都是相同的<code>fill</code>值。 如果指定的值是一个可变对象，那么<code>List</code>中所有的元素都是相同的对象，并且是可修改的</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> l2 = <span class="keyword">new</span> <span class="built_in">List</span>.filled(<span class="number">3</span>, <span class="string">&#x27;l&#x27;</span>);  <span class="comment">//[l, l, l]</span></span><br><span class="line"><span class="keyword">var</span> l3 = <span class="keyword">new</span> <span class="built_in">List</span>.filled(<span class="number">2</span>, []);   <span class="comment">// [[], []]</span></span><br><span class="line">l3[<span class="number">0</span>].add(<span class="number">12</span>);   </span><br><span class="line"><span class="built_in">print</span>(l3);      <span class="comment">// [[12], [12]]</span></span><br></pre></td></tr></table></figure>

<h4 id="from"><a href="#from" class="headerlink" title="from"></a>from</h4><ul>
<li>创建一个包含所有<code>elements</code>的<code>List</code></li>
<li><code>elements</code>的<code>Iterator</code>规定了元素的顺序。</li>
<li>当<code>growable</code>为<code>true</code>（默认）时，构造函数返回一个可增长的<code>List</code>。 否则，它返回一个固定长度的<code>List</code></li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> l5 = <span class="keyword">new</span> <span class="built_in">List</span>.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</span><br><span class="line">l5.add(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">print</span>(l5);   <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的add方法会报错</span></span><br><span class="line"><span class="keyword">var</span> l5 = <span class="keyword">new</span> <span class="built_in">List</span>.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], growable: <span class="keyword">false</span>);</span><br><span class="line">l5.add(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<h4 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h4><ul>
<li>生成一个包含所有值的<code>List</code>, 根据索引值创建元素</li>
<li><code>growable</code>为<code>false</code>时，创建的<code>List</code>是固定长度的</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> l4 = <span class="keyword">new</span> <span class="built_in">List</span>.generate(<span class="number">3</span>, (<span class="built_in">int</span> i) =&gt; i * i);</span><br><span class="line">l4.add(<span class="number">14</span>);</span><br><span class="line"><span class="built_in">print</span>(l4);</span><br><span class="line"><span class="comment">// [0, 1, 4, 14]</span></span><br></pre></td></tr></table></figure>

<h4 id="unmodifiable"><a href="#unmodifiable" class="headerlink" title="unmodifiable"></a>unmodifiable</h4><ul>
<li>创建一个包含所有<code>elements</code>的，不可修改的<code>List</code></li>
<li>不可修改的<code>List</code>不能改变它的长度或元素</li>
<li>如果元素本身是不可改变的，那么由此产生的<code>List</code>也是不可改变的</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> l6 = <span class="keyword">new</span> <span class="built_in">List</span>.unmodifiable([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</span><br></pre></td></tr></table></figure>


<h3 id="List属性"><a href="#List属性" class="headerlink" title="List属性"></a>List属性</h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="comment">// 数组的第一个和最后一个元素</span></span><br><span class="line"><span class="built_in">print</span>(arr1.first);  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">print</span>(arr1.last);   <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断数组是否为空</span></span><br><span class="line"><span class="built_in">print</span>(arr1.isNotEmpty);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">print</span>(arr1.isEmpty);     <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组长度, 元素个数</span></span><br><span class="line"><span class="built_in">print</span>(arr1.length);  <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 倒序返回List</span></span><br><span class="line"><span class="built_in">print</span>(arr1.reversed);  <span class="comment">// [4, 3, 2, 1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回Iterator，被允许迭代Iterable的所有元素</span></span><br><span class="line"><span class="built_in">print</span>(arr1.iterator);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象的运行时类型</span></span><br><span class="line"><span class="built_in">print</span>(arr1.runtimeType);   <span class="comment">// List&lt;int&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取对象的哈希值</span></span><br><span class="line"><span class="built_in">print</span>(arr1.hashCode);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据索引获取元素</span></span><br><span class="line"><span class="built_in">print</span>(arr1[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据索引修改元素</span></span><br><span class="line">arr1[<span class="number">1</span>] = <span class="number">11</span>;</span><br><span class="line"><span class="built_in">print</span>(arr1);</span><br></pre></td></tr></table></figure>

<h3 id="List方法"><a href="#List方法" class="headerlink" title="List方法"></a>List方法</h3><h4 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h4><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加元素</span></span><br><span class="line">arr1.add(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一个数组</span></span><br><span class="line">arr1.addAll([<span class="number">10</span>, <span class="number">12</span>]);</span><br></pre></td></tr></table></figure>

<h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr2 = [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>, <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;four&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否包含某元素</span></span><br><span class="line"><span class="built_in">print</span>(arr2.contains(<span class="string">&#x27;one&#x27;</span>));  <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 判断数组是否有满足条件的元素</span></span><br><span class="line"><span class="built_in">print</span>(arr2.any((item) =&gt; item.length &gt; <span class="number">4</span>));  <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 判断数组是否所有元素都满足条件</span></span><br><span class="line"><span class="built_in">print</span>(arr2.every((item) =&gt; item.length &gt; <span class="number">4</span>));  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 转化为Map类型, 索引作为Key值，对应的元素作为Value</span></span><br><span class="line"><span class="built_in">print</span>(arr2.asMap());  <span class="comment">// &#123;0: one, 1: two, 2: three, 3: one, 4: four&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//随机打乱List中的元素</span></span><br><span class="line">arr2.shuffle();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过索引获取元素, 等价于arr2[3]</span></span><br><span class="line"><span class="built_in">print</span>(arr2.elementAt(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取元素对应的索引值, 默认从索引0开始</span></span><br><span class="line"><span class="built_in">print</span>(arr2.indexOf(<span class="string">&#x27;one&#x27;</span>));  <span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 从第2个索引开始查找</span></span><br><span class="line"><span class="built_in">print</span>(arr2.indexOf(<span class="string">&#x27;one&#x27;</span>, <span class="number">2</span>));  <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 如果找不到, 返回-1</span></span><br><span class="line"><span class="built_in">print</span>(arr2.indexOf(<span class="string">&#x27;five&#x27;</span>));  <span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取元素对应的索引值, 从后往前找</span></span><br><span class="line"><span class="built_in">print</span>(arr2.lastIndexOf(<span class="string">&#x27;one&#x27;</span>));</span><br><span class="line"><span class="built_in">print</span>(arr2.lastIndexOf(<span class="string">&#x27;one&#x27;</span>, <span class="number">3</span>));</span><br><span class="line"><span class="built_in">print</span>(arr2.lastIndexOf(<span class="string">&#x27;five&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回满足条件的第一个元素</span></span><br><span class="line"><span class="built_in">print</span>(arr3.firstWhere((item) =&gt; item == <span class="string">&#x27;one&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找符合条件的元素, 如果有且仅有一个符合条件的元素, 则返回该元素</span></span><br><span class="line"><span class="comment">// 如果没有匹配到元素，或匹配到多个元素, 则会抛出异常</span></span><br><span class="line"><span class="built_in">print</span>(arr2.singleWhere((item) =&gt; item.length == <span class="number">5</span>));  <span class="comment">//three</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回除了最初的count个元素外的所有元素</span></span><br><span class="line">arr2 = [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>, <span class="string">&#x27;four&#x27;</span>];</span><br><span class="line"><span class="built_in">print</span>(arr2.skip(<span class="number">2</span>)); <span class="comment">// (three, four)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回所有不符合该条件的元素</span></span><br><span class="line"><span class="built_in">print</span>(arr2.skipWhile((item) =&gt; item.length == <span class="number">3</span>));  <span class="comment">//(three, four)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个新的List，包含从start（包括）到end（不包括）的对象, 原数组不变</span></span><br><span class="line"><span class="built_in">print</span>(arr2.sublist(<span class="number">1</span>, <span class="number">3</span>));</span><br><span class="line"><span class="comment">// 不指定end, 默认到数组结尾</span></span><br><span class="line"><span class="built_in">print</span>(arr2.sublist(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取某一区间的元素, 返回一个数组</span></span><br><span class="line"><span class="built_in">print</span>(arr2.getRange(<span class="number">1</span>, <span class="number">3</span>));    <span class="comment">// [&#x27;two&#x27;, &#x27;three&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组拼接成字符串</span></span><br><span class="line"><span class="built_in">print</span>(arr2.join());  <span class="comment">//onetwothreefour</span></span><br><span class="line"><span class="built_in">print</span>(arr2.join(<span class="string">&#x27;-&#x27;</span>));  <span class="comment">//one-two-three-four</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回数组最初的count个元素</span></span><br><span class="line"><span class="built_in">print</span>(arr2.take(<span class="number">2</span>));</span><br><span class="line"><span class="comment">// 返回数组符合条件的元素, 直到条件值为false停止过滤</span></span><br><span class="line">arr2 = [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>, <span class="string">&#x27;four&#x27;</span>, <span class="string">&#x27;ten&#x27;</span>];</span><br><span class="line"><span class="built_in">print</span>(arr2.takeWhile((item) =&gt; item.length == <span class="number">3</span>));  <span class="comment">//(one, two)</span></span><br></pre></td></tr></table></figure>

<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr2 = [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>, <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;four&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除指定的元素</span></span><br><span class="line"><span class="comment">// 如果有该元素, 返回true</span></span><br><span class="line"><span class="built_in">print</span>(arr2.remove(<span class="string">&#x27;two&#x27;</span>));  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">print</span>(arr2);   <span class="comment">// [one, three, one, four]</span></span><br><span class="line"><span class="comment">// 如果没有该元素, 返回false</span></span><br><span class="line"><span class="built_in">print</span>(arr2.remove(<span class="string">&#x27;five&#x27;</span>));  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据索引删除, 返回被删除的元素值</span></span><br><span class="line"><span class="built_in">print</span>(arr2.removeAt(<span class="number">1</span>));  <span class="comment">// three</span></span><br><span class="line"><span class="built_in">print</span>(arr2);   <span class="comment">// [one, one, four]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除最后一个元素, 返回该元素值</span></span><br><span class="line"><span class="built_in">print</span>(arr2.removeLast());  <span class="comment">// four</span></span><br><span class="line"><span class="built_in">print</span>(arr2); <span class="comment">// [one, one]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除一个区间的元素, 含左不含右[start, end)</span></span><br><span class="line">arr2.addAll([<span class="string">&#x27;six&#x27;</span>, <span class="string">&#x27;seven&#x27;</span>, <span class="string">&#x27;eight&#x27;</span>]);</span><br><span class="line">arr2.removeRange(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">print</span>(arr2);  <span class="comment">// [one, seven, eight]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除所有符合条件的元素</span></span><br><span class="line">arr2.removeWhere((item) =&gt; item.length == <span class="number">3</span>);</span><br><span class="line"><span class="built_in">print</span>(arr2);  <span class="comment">// [seven, eight]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除List中所有不满足条件的元素</span></span><br><span class="line">arr2.retainWhere((item) =&gt; item.length &gt; <span class="number">3</span>);</span><br><span class="line"><span class="built_in">print</span>(arr2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除所有的元素</span></span><br><span class="line">arr1.clear();</span><br><span class="line"><span class="built_in">print</span>(arr1);  <span class="comment">// []</span></span><br></pre></td></tr></table></figure>

<h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr3 = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="comment">// 在某处插入元素</span></span><br><span class="line">arr3.insert(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line"><span class="built_in">print</span>(arr3); <span class="comment">//[1, 10, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入一个数组</span></span><br><span class="line">arr3.insertAll(<span class="number">2</span>, [<span class="number">12</span>, <span class="number">32</span>]);</span><br><span class="line"><span class="built_in">print</span>(arr3);</span><br></pre></td></tr></table></figure>

<h4 id="重要方法"><a href="#重要方法" class="headerlink" title="重要方法"></a>重要方法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//过滤</span><br><span class="line">Iterable&lt;E&gt; where(bool test(E element)) =&gt; new WhereIterable&lt;E&gt;(this, test);</span><br><span class="line"></span><br><span class="line">// 映射</span><br><span class="line">Iterable&lt;T&gt; map&lt;T&gt;(T f(E e)) =&gt; new MappedIterable&lt;E, T&gt;(this, f);</span><br><span class="line"></span><br><span class="line">// 排序</span><br><span class="line">void sort([int compare(E a, E b)]);</span><br><span class="line"></span><br><span class="line">// 迭代计算, initialValue: 初始值, combine: 计算函数</span><br><span class="line">T fold&lt;T&gt;(T initialValue, T combine(T previousValue, E element))</span><br><span class="line"></span><br><span class="line">// 迭代计算, 初始值即为第一个元素的值, combine: 计算函数</span><br><span class="line">E reduce(E combine(E value, E element))</span><br><span class="line"></span><br><span class="line">// 对集合的每个元素，按迭代顺序执行函数操作</span><br><span class="line">void forEach(void f(E element))</span><br><span class="line"></span><br><span class="line">// 将Iterable的每个元素扩展为0个或多个元素</span><br><span class="line">Iterable expand(Iterable f(E element))</span><br></pre></td></tr></table></figure>

<p>下面看一下每一个函数的具体使用和介绍</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr2 = [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>, <span class="string">&#x27;four&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 过滤操作, 返回所有符合条件的元素</span></span><br><span class="line"><span class="built_in">print</span>(arr2.where((item) =&gt; item.length == <span class="number">3</span>));  <span class="comment">//(one, two, ten)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 映射一个新的数组, 参数是一个函数</span></span><br><span class="line"><span class="keyword">var</span> array = arr2.map((item) &#123;</span><br><span class="line">  <span class="keyword">return</span> item + <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">print</span>(array.toList());  <span class="comment">// [one-, ten-, two-, four-, three-]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 排序, 默认从小到大</span></span><br><span class="line">arr2.sort();</span><br><span class="line"><span class="built_in">print</span>(arr2);  <span class="comment">//[four, one, ten, three, two]</span></span><br><span class="line"><span class="comment">// 设置条件进行排序</span></span><br><span class="line">arr2.sort((item1, item2) &#123;</span><br><span class="line">  <span class="comment">// 如果两个比较的结果为0, 那么排序后返回的结果可能不同</span></span><br><span class="line">  <span class="keyword">return</span> item1.length.compareTo(item2.length);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">print</span>(arr2);  <span class="comment">//[one, ten, two, four, three]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代计算, initialValue: 初始值, combine: 计算函数</span></span><br><span class="line"><span class="keyword">var</span> arr4 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="comment">// 设置初始值</span></span><br><span class="line"><span class="keyword">var</span> result1 = arr4.fold(<span class="number">10</span>, (prev, value) =&gt; prev + value);  <span class="comment">//20</span></span><br><span class="line"><span class="keyword">var</span> result2 = arr4.fold(<span class="number">2</span>, (prev, value) =&gt; prev * value);  <span class="comment">//48</span></span><br><span class="line"><span class="comment">// 初始值即为第一个元素的值, 可迭代对象至少要有一个元素。 如果它只有一个元素，则元素直接返回</span></span><br><span class="line"><span class="keyword">var</span> result3 = arr4.reduce((value, element) =&gt; value * element);  <span class="comment">// 24</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对每一个元素进行操作</span></span><br><span class="line">arr2.forEach((item) &#123;</span><br><span class="line">  <span class="built_in">print</span>(item);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// expand, 以对每个元素调用f函数后生成的元素，按迭代的顺序，返回新的Iterable</span></span><br><span class="line"><span class="keyword">var</span> pairs = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]];</span><br><span class="line"><span class="keyword">var</span> flattened = pairs.expand((pair) =&gt; pair).toList();</span><br><span class="line"><span class="built_in">print</span>(flattened); <span class="comment">// =&gt; [1, 2, 3, 4];</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> input = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> duplicated = input.expand((i) =&gt; [i, i]).toList();</span><br><span class="line"><span class="built_in">print</span>(duplicated); <span class="comment">// =&gt; [1, 1, 2, 2, 3, 3]</span></span><br></pre></td></tr></table></figure>


<blockquote>
<p>由于篇幅太长了, 剩下的一些数据类型下篇文章在继续研究记录吧</p>
</blockquote>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul>
<li><a href="http://dart.goodev.org/guides/language/language-tour">Dart官网语法介绍-中文版</a></li>
<li><a href="https://www.dartlang.org/guides/language/language-tour">Dart官网语法介绍-英文版</a></li>
<li><a href="http://www.shutongye.com/dartapi/dart-core/List-class.html">Dart语言中文社区</a></li>
</ul>
<hr>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
        <tag>Dart</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter开发之Dart的数据类型02</title>
    <url>/post/4facfb40.html</url>
    <content><![CDATA[<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/flutter/dart-logo.png?x-oss-process=style/titanjun" alt="dart-logo"></p>
<span id="more"></span>



<ul>
<li>这几篇文章都是在学习<code>Dart</code>过程中所记录的学习笔记, 都是一些基础知识, 几乎没什么技术含量, 主要是方便后期使用的时候方便查阅</li>
<li>之前的一篇文章已经介绍了一部分的数据类型<a href="https://www.titanjun.top/2019/02/20/Flutter%E5%BC%80%E5%8F%91%E4%B9%8BDart%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B01/">Flutter开发之Dart的数据类型01</a>, 这里主要记录剩下的一些常用的数据类型</li>
<li>我写的<a href="https://www.titanjun.top/categories/Flutter%E7%AC%94%E8%AE%B0/">Flutter和Dart语法系列相关的文章</a>, 有兴趣的可参考随便看看</li>
</ul>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><ul>
<li><code>key-value</code>键值对（可以使用相关联的<code>key</code>检索<code>value</code>值）的集合, 即传说中的字典</li>
<li><code>Map</code>中<code>key</code>的数量是有限的，每个<code>key</code>正好有一个相关的<code>value</code></li>
<li><code>Map</code>、以及它的键和值，都是可以迭代的, 迭代的顺序由<code>Map</code>不同的类型定义<ul>
<li><a href="http://www.shutongye.com/dartapi/dart-collection/HashMap-class.html"><code>HashMap</code></a>是无序的，这意味着它迭代的顺序是不确定的</li>
<li><a href="http://www.shutongye.com/dartapi/dart-collection/LinkedHashMap-class.html"><code>LinkedHashMap</code></a>按<code>key</code>的插入顺序进行迭代</li>
<li><a href="http://www.shutongye.com/dartapi/dart-collection/SplayTreeMap-class.html"><code>SplayTreeMap</code></a>按<code>key</code>的排序顺序进行迭代</li>
</ul>
</li>
<li>当<code>Map</code>的一个操作正在执行的时候，通常不允许修改<code>Map</code>（添加或删除<code>key</code>）</li>
</ul>
<h3 id="创建Map"><a href="#创建Map" class="headerlink" title="创建Map"></a>创建Map</h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Map</span>()</span><br><span class="line"><span class="comment">// 创建一个Map实例，默认实现是LinkedHashMap。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Map</span>.from(<span class="built_in">Map</span> other)</span><br><span class="line"><span class="comment">// 创建一个LinkedHashMap实例，包含other的所有键值对。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Map</span>.fromIterable(<span class="built_in">Iterable</span> iterable, &#123;K key(element), V value(element)&#125;)</span><br><span class="line"><span class="comment">// 创建一个Map实例，其中Key和Value由iterable的元素计算得到。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Map</span>.fromIterables(<span class="built_in">Iterable</span>&lt;K&gt; keys, <span class="built_in">Iterable</span>&lt;V&gt; values)</span><br><span class="line"><span class="comment">// 将指定的keys和values关联，创建一个Map实例。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Map</span>.identity()</span><br><span class="line"><span class="comment">// 使用默认实现LinkedHashMap创建一个严格的Map。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Map</span>.unmodifiable(<span class="built_in">Map</span> other)</span><br><span class="line"><span class="comment">// 创建一个不可修改、基于哈希值的Map，包含other所有的项</span></span><br></pre></td></tr></table></figure>

<p>每一种创建方式的具体使用</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个Map实例, 插入顺序进行排列</span></span><br><span class="line"><span class="keyword">var</span> dic = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="built_in">print</span>(dic);  <span class="comment">// &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据一个Map创建一个新的Map, 插入顺序进行排列</span></span><br><span class="line"><span class="keyword">var</span> dic1 = <span class="keyword">new</span> <span class="built_in">Map</span>.from(&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;titan&#x27;</span>&#125;);</span><br><span class="line"><span class="built_in">print</span>(dic1);  <span class="comment">// &#123;name: titan&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据List创建Map, 插入顺序进行排列</span></span><br><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// 使用默认方式, key和value都是数组对应的元素</span></span><br><span class="line"><span class="keyword">var</span> dic2 = <span class="keyword">new</span> <span class="built_in">Map</span>.fromIterable(list);</span><br><span class="line"><span class="built_in">print</span>(dic2);  <span class="comment">// &#123;1: 1, 2: 2, 3: 3&#125;</span></span><br><span class="line"><span class="comment">// 设置key和value的值</span></span><br><span class="line"><span class="keyword">var</span> dic3 = <span class="keyword">new</span> <span class="built_in">Map</span>.fromIterable(list, key: (item) =&gt; item.toString(), value: (item) =&gt; item * item);</span><br><span class="line"><span class="built_in">print</span>(dic3);  <span class="comment">// &#123;1: 1, 2: 4, 3: 9&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个数组映射一个字典, 插入顺序进行排列</span></span><br><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; keys = [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> values = [<span class="string">&#x27;jun&#x27;</span>, <span class="number">20</span>];</span><br><span class="line"><span class="comment">// 如果有相同的key值, 后面的值会覆盖前面的值</span></span><br><span class="line"><span class="keyword">var</span> dic4 = <span class="keyword">new</span> <span class="built_in">Map</span>.fromIterables(keys, values);</span><br><span class="line"><span class="built_in">print</span>(dic4);  <span class="comment">// &#123;name: jun, age: 20&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个空的Map, Map允许null作为key</span></span><br><span class="line"><span class="keyword">var</span> dic5 = <span class="keyword">new</span> <span class="built_in">Map</span>.identity();</span><br><span class="line"><span class="built_in">print</span>(dic5);  <span class="comment">//&#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个不可修改、基于哈希值的Map</span></span><br><span class="line"><span class="keyword">var</span> dic6 = <span class="keyword">new</span> <span class="built_in">Map</span>.unmodifiable(&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;titan&#x27;</span>&#125;);</span><br><span class="line"><span class="built_in">print</span>(dic6);</span><br></pre></td></tr></table></figure>

<h3 id="相关属性"><a href="#相关属性" class="headerlink" title="相关属性"></a>相关属性</h3><p><code>Map</code>中相关属性和一些常用属性的操作如下:</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> map1 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;titan&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>&#125;;</span><br><span class="line"><span class="comment">// 哈希值</span></span><br><span class="line"><span class="built_in">print</span>(map1.hashCode); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行时类型</span></span><br><span class="line"><span class="built_in">print</span>(map1.runtimeType);  <span class="comment">//_InternalLinkedHashMap&lt;String, Object&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否为空, null不能判断, 会报错</span></span><br><span class="line"><span class="built_in">print</span>(map1.isEmpty);  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否不为空</span></span><br><span class="line"><span class="built_in">print</span>(map1.isNotEmpty);  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 键值对个数</span></span><br><span class="line"><span class="built_in">print</span>(map1.length);   <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有的key值, 返回Iterable&lt;K&gt;类型</span></span><br><span class="line"><span class="built_in">print</span>(map1.keys.toList());  <span class="comment">// [name, age]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有的value值, 返回Iterable&lt;K&gt;类型</span></span><br><span class="line"><span class="built_in">print</span>(map1.values.toList());   <span class="comment">// [titan, 20]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据key取值</span></span><br><span class="line"><span class="built_in">print</span>(map1[<span class="string">&#x27;name&#x27;</span>] ?? <span class="string">&#x27;&#x27;</span>);   <span class="comment">// titan</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据key赋值</span></span><br><span class="line">map1[<span class="string">&#x27;age&#x27;</span>] = <span class="number">30</span>;</span><br><span class="line"><span class="built_in">print</span>(map1);   <span class="comment">// &#123;name: titan, age: 30&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> map2 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;titan&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一个map</span></span><br><span class="line">map2.addAll(&#123;<span class="string">&#x27;blog&#x27;</span>: <span class="string">&#x27;titanjun&#x27;</span>&#125;);</span><br><span class="line"><span class="built_in">print</span>(map2);</span><br><span class="line"><span class="comment">// &#123;name: titan, age: 20, blog: titanjun&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否包含指定的key</span></span><br><span class="line"><span class="built_in">print</span>(map2.containsKey(<span class="string">&#x27;age&#x27;</span>));  <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否包含指定的value</span></span><br><span class="line"><span class="built_in">print</span>(map2.containsValue(<span class="string">&#x27;titan&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作每个键值对</span></span><br><span class="line">map2.forEach((key, value) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;key = <span class="subst">$key</span>, value = <span class="subst">$value</span>&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找key对应的value，或添加一个新的值为key.length的value</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;king&#x27;</span>]) &#123;</span><br><span class="line">  <span class="comment">// 函数的返回值为查找到的对应的value值</span></span><br><span class="line">  <span class="built_in">print</span>(map2.putIfAbsent(key, () =&gt; key.length));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(map2);</span><br><span class="line"><span class="comment">// &#123;name: titan, age: 20, blog: titanjun, king: 4&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 转成字符串</span></span><br><span class="line"><span class="built_in">print</span>(map2.toString());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除键值对, 返回删除key对应的value值, 没有则返回null</span></span><br><span class="line"><span class="built_in">print</span>(map2.remove(<span class="string">&#x27;blog&#x27;</span>));  <span class="comment">//titanjun</span></span><br><span class="line"><span class="built_in">print</span>(map2.remove(<span class="string">&#x27;coder&#x27;</span>));  <span class="comment">//null</span></span><br><span class="line"><span class="built_in">print</span>(map2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除所有的键值对</span></span><br><span class="line">map2.clear();</span><br><span class="line"><span class="built_in">print</span>(map2);  <span class="comment">//&#123;&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="Iterable"><a href="#Iterable" class="headerlink" title="Iterable"></a>Iterable</h2><ul>
<li>按顺序访问的值或元素的集合, <code>List</code>集合也是继承于<code>Iterable</code></li>
<li><code>List</code>和<code>Set</code>也是<code>Iterable</code>，<code>dart:collection</code>库中同样有很多</li>
<li>部分<code>Iterable</code>集合可以被修改   <ul>
<li>向<code>List</code>或<code>Set</code>添加元素将改变对象所有包含的元素。 </li>
<li>向Map添加新的<code>Key</code>会改变所有<code>Map.keys</code>的元素。 </li>
<li>在集合改变后，创建的迭代器将提供新的所有元素，并且可能会保持目前元素的顺序, 也可能不会</li>
</ul>
</li>
</ul>
<h3 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建空的可迭代对象</span></span><br><span class="line"><span class="keyword">var</span> ite = <span class="built_in">Iterable</span>.empty();</span><br><span class="line"><span class="built_in">print</span>(ite);   <span class="comment">// ()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个Iterable，通过序列来动态生成元素</span></span><br><span class="line"><span class="keyword">var</span> ite1 = <span class="built_in">Iterable</span>.generate(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">print</span>(ite1);  <span class="comment">// (0, 1, 2, 3, 4)</span></span><br></pre></td></tr></table></figure>

<p>至于<code>Iterable</code>的所有属性和函数的介绍和使用, 在上篇文章<a href="https://www.titanjun.top/2019/02/20/Flutter%E5%BC%80%E5%8F%91%E4%B9%8BDart%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B01/#List">Flutter开发之Dart的数据类型01</a>中的<code>List</code>模块中已经详细介绍了, 因为<code>List</code>是继承于<code>Iterable</code>的, 所以<code>Iterable</code>有的属性和方法<code>List</code>中都有</p>
<h2 id="Runes"><a href="#Runes" class="headerlink" title="Runes"></a>Runes</h2><ul>
<li>在<code>Dart</code>中，<code>Runes</code>代表字符串的<code>UTF-32</code>字符集, 另一种<code>Strings</code></li>
<li><code>Unicode</code>为每一个字符、标点符号、表情符号等都定义了 一个唯一的数值</li>
<li>由于<code>Dart</code>字符串是<code>UTF-16</code>的字符序列，所以在字符串中表达32的字符序列就需要新的语法了</li>
<li>通常使用<code>\uXXXX</code>的方式来表示, 这里的<code>XXXX</code>是4个16进制的数, 如，心形符号<code>(♥)</code>是<code>\u2665</code></li>
<li>对于非4个数值的情况，把编码值放到大括号中即可, 如，笑脸<code>emoji</code> (😆) 是<code>\u&#123;1f600&#125;</code></li>
<li><code>String</code>类有一些属性可以提取<code>rune</code>信息<ul>
<li><code>codeUnitAt</code>和<code>codeUnit</code>属性返回16为字符</li>
<li>使用<code>runes</code>属性来获取字符串的<code>runes</code>信息</li>
</ul>
</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> clapping = <span class="string">&#x27;\u&#123;1f44f&#125;&#x27;</span>;</span><br><span class="line"><span class="built_in">print</span>(clapping);  <span class="comment">// 👏</span></span><br><span class="line"><span class="built_in">print</span>(clapping.codeUnits);  <span class="comment">// [55357, 56399]</span></span><br><span class="line"><span class="built_in">print</span>(clapping.runes.toList());  <span class="comment">// [128079]</span></span><br></pre></td></tr></table></figure>

<h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据字符串创建</span></span><br><span class="line">Runes runes = <span class="keyword">new</span> Runes(<span class="string">&#x27;\u2665, \u&#123;1f605&#125;, \u&#123;1f60e&#125;&#x27;</span>);</span><br><span class="line"><span class="built_in">print</span>(runes);</span><br><span class="line"><span class="comment">// (9829, 44, 32, 128517, 44, 32, 128526)</span></span><br><span class="line"><span class="comment">// 输出特殊字符的字符串</span></span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">new</span> <span class="built_in">String</span>.fromCharCodes(runes));</span><br><span class="line"><span class="comment">// ♥, 😅, 😎</span></span><br></pre></td></tr></table></figure>

<p>由于<code>Runes</code>也是继承于<code>Iterable</code>, 所以<code>Runes</code>中的属性和方法的使用也和<code>Iterable</code>一样, 详情参考<a href="http://www.shutongye.com/dartapi/dart-core/Runes-class.html">Runes</a>和<a href="https://www.titanjun.top/2019/02/20/Flutter%E5%BC%80%E5%8F%91%E4%B9%8BDart%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B01/#List">Flutter开发之Dart的数据类型01</a>中的介绍</p>
<h2 id="Symbols"><a href="#Symbols" class="headerlink" title="Symbols"></a>Symbols</h2><ul>
<li>一个<code>Symbol</code>对象代表<code>Dart</code>程序中声明的操作符或者标识符</li>
<li>也许不会用到<code>Symbol</code>，但是该功能对于通过名字来引用标识符的情况 是非常有价值的，特别是混淆后的代码，标识符的名字被混淆了，但是<code>Symbol</code>的名字不会改变</li>
<li>使用<code>Symbol</code>字面量来获取标识符的<code>symbol</code>对象，也就是在标识符前面添加一个 <code>#</code> 符号</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取symbol 对象</span></span><br><span class="line"><span class="keyword">var</span> sym1 = <span class="built_in">Symbol</span>(<span class="string">&#x27;name&#x27;</span>);</span><br><span class="line"><span class="built_in">print</span>(sym1);   <span class="comment">// Symbol(&quot;name&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// #号创建</span></span><br><span class="line"><span class="keyword">var</span> sym2 = #titan;</span><br><span class="line"><span class="built_in">print</span>(sym2);   <span class="comment">// Symbol(&quot;titan&quot;)</span></span><br></pre></td></tr></table></figure>

<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><ul>
<li>对象的集合，其中每个对象只能出现一次, <code>List</code>中一个对象可以出现多次</li>
<li>迭代Set中的元素时，某些时候有可能是无序的，也有可能是有序的。例如：<ul>
<li><code>HashSet</code>是无序的，这意味着它迭代的顺序是不确定的</li>
<li><code>LinkedHashSet</code>按元素的插入顺序进行迭代</li>
<li><code>SplayTreeSet</code>按排序顺序迭代元素</li>
</ul>
</li>
<li><code>Set</code>除创建方式和<code>List</code>不同, 其他属性和方法基本一样</li>
</ul>
<h3 id="创建Set"><a href="#创建Set" class="headerlink" title="创建Set"></a>创建Set</h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个空的Set。</span></span><br><span class="line"><span class="keyword">var</span> set1 = <span class="built_in">Set</span>();</span><br><span class="line"><span class="built_in">print</span>(set1);   <span class="comment">// &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个包含所有elements的Set</span></span><br><span class="line"><span class="keyword">var</span> set2 = <span class="built_in">Set</span>.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="built_in">print</span>(set2);   <span class="comment">// &#123;1, 2, 3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个空的，元素严格相等的Set</span></span><br><span class="line"><span class="keyword">var</span> set3 = <span class="built_in">Set</span>.identity();</span><br><span class="line"><span class="built_in">print</span>(set3);   <span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// set2 = &#123;1, 2, 3&#125;</span></span><br><span class="line"><span class="comment">//返回一个新的Set，它是this和other的交集</span></span><br><span class="line"><span class="keyword">var</span> set4 = <span class="built_in">Set</span>.from([<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>]);</span><br><span class="line"><span class="built_in">print</span>(set2.intersection(set4));  <span class="comment">//&#123;2, 3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个新的Set，它包含this和other的所有元素（并集）</span></span><br><span class="line"><span class="built_in">print</span>(set2.union(set4));  <span class="comment">// &#123;1, 2, 3, 5, 6&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查Set中是否包含object, 有则返回该object, 没有则返回null</span></span><br><span class="line"><span class="built_in">print</span>(set4.lookup(<span class="number">5</span>));   <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">print</span>(set4.lookup(<span class="number">21</span>));  <span class="comment">// null</span></span><br></pre></td></tr></table></figure>

<p>其他更多属性参考<a href="http://www.shutongye.com/dartapi/dart-core/Set-class.html">Set<E></a>和<a href="https://www.titanjun.top/2019/02/20/Flutter%E5%BC%80%E5%8F%91%E4%B9%8BDart%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B01/#List">Flutter开发之Dart的数据类型01</a>中的介绍</p>
<h2 id="Duration"><a href="#Duration" class="headerlink" title="Duration"></a>Duration</h2><ul>
<li><code>Duration</code>表示从一个时间点到另一个时间点的时间差</li>
<li>如果是一个较晚的时间点和一个较早的时间点，<code>Duration</code>可能是负数</li>
</ul>
<h3 id="创建Duration"><a href="#创建Duration" class="headerlink" title="创建Duration"></a>创建Duration</h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 唯一的构造函数创建Duration对象</span></span><br><span class="line"><span class="built_in">Duration</span>(&#123;<span class="built_in">int</span> days: <span class="number">0</span>, <span class="built_in">int</span> hours: <span class="number">0</span>, <span class="built_in">int</span> minutes: <span class="number">0</span>, <span class="built_in">int</span> seconds: <span class="number">0</span>, <span class="built_in">int</span> milliseconds: <span class="number">0</span>, <span class="built_in">int</span> microseconds: <span class="number">0</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以使用其中的一个或者几个参数创建</span></span><br><span class="line"><span class="comment">// 只是用其中的一个参数</span></span><br><span class="line"><span class="built_in">Duration</span> ration = <span class="built_in">Duration</span>(days: <span class="number">1</span>);</span><br><span class="line"><span class="built_in">print</span>(ration);  <span class="comment">//24:00:00.000000</span></span><br><span class="line"><span class="built_in">Duration</span> ration1 = <span class="built_in">Duration</span>(hours: <span class="number">10</span>);</span><br><span class="line"><span class="built_in">print</span>(ration1);  <span class="comment">//10:00:00.000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只是用其中的两个参数</span></span><br><span class="line"><span class="built_in">Duration</span> ration2 = <span class="built_in">Duration</span>(days: <span class="number">1</span>, hours: <span class="number">3</span>);</span><br><span class="line"><span class="built_in">print</span>(ration2);  <span class="comment">//27:00:00.000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用所有的参数</span></span><br><span class="line"><span class="built_in">Duration</span> ration3 = <span class="built_in">Duration</span>(days: <span class="number">2</span>, hours: <span class="number">2</span>, minutes: <span class="number">23</span>, seconds: <span class="number">34</span>, milliseconds: <span class="number">56</span>, microseconds: <span class="number">89</span>);</span><br><span class="line"><span class="built_in">print</span>(ration3);  <span class="comment">//50:23:34.056089</span></span><br></pre></td></tr></table></figure>

<h3 id="相关运算"><a href="#相关运算" class="headerlink" title="相关运算"></a>相关运算</h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Duration</span> time1 = <span class="built_in">Duration</span>(days: <span class="number">1</span>, hours: <span class="number">1</span>, minutes: <span class="number">1</span>, seconds: <span class="number">1</span>, milliseconds: <span class="number">1</span>, microseconds: <span class="number">1</span>);</span><br><span class="line"><span class="built_in">Duration</span> time2 = <span class="built_in">Duration</span>(days: <span class="number">2</span>, hours: <span class="number">2</span>, minutes: <span class="number">2</span>, seconds: <span class="number">2</span>, milliseconds: <span class="number">2</span>, microseconds: <span class="number">2</span>);</span><br><span class="line"><span class="built_in">print</span>(time1);  <span class="comment">//25:01:01.001001</span></span><br><span class="line"><span class="built_in">print</span>(time2);  <span class="comment">//50:02:02.002002</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加</span></span><br><span class="line"><span class="built_in">print</span>(time1 + time2);  <span class="comment">//75:03:03.003003</span></span><br><span class="line"><span class="comment">// 减</span></span><br><span class="line"><span class="built_in">print</span>(time1 - time2);  <span class="comment">//-25:01:01.001001</span></span><br><span class="line"><span class="comment">// 乘</span></span><br><span class="line"><span class="built_in">print</span>(time1 * <span class="number">2</span>);    <span class="comment">//50:02:02.002002</span></span><br><span class="line"><span class="comment">// 除(取整)</span></span><br><span class="line"><span class="built_in">print</span>(time2 ~/ <span class="number">3</span>);  <span class="comment">//16:40:40.667334</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较</span></span><br><span class="line"><span class="built_in">print</span>(time1 &gt; time2);  <span class="comment">//false</span></span><br><span class="line"><span class="built_in">print</span>(time1 &gt;= time2);  <span class="comment">//false</span></span><br><span class="line"><span class="built_in">print</span>(time1 == time2);  <span class="comment">//false</span></span><br><span class="line"><span class="built_in">print</span>(time1 &lt; time2);  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">print</span>(time1 &lt;= time2); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 取相反值</span></span><br><span class="line"><span class="built_in">print</span>(-time1);  <span class="comment">//-25:01:01.001001</span></span><br><span class="line"><span class="built_in">print</span>(-(time1 - time2));  <span class="comment">//25:01:01.001001</span></span><br></pre></td></tr></table></figure>

<h3 id="相关函数-1"><a href="#相关函数-1" class="headerlink" title="相关函数"></a>相关函数</h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Duration</span> time3 = -<span class="built_in">Duration</span>(days: <span class="number">1</span>, hours: <span class="number">1</span>, minutes: <span class="number">1</span>, seconds: <span class="number">1</span>, milliseconds: <span class="number">1</span>, microseconds: <span class="number">1</span>);</span><br><span class="line"><span class="built_in">print</span>(time3);  <span class="comment">//-25:01:01.001001</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 取绝对值</span></span><br><span class="line"><span class="built_in">print</span>(time3.abs());  <span class="comment">//25:01:01.001001</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较, 返回值, 0: 相等, -1: time1 &lt; time2, 1: time1 &gt; time2</span></span><br><span class="line"><span class="built_in">print</span>(time1.compareTo(time2));  <span class="comment">//-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串形式</span></span><br><span class="line"><span class="built_in">print</span>(time1.toString());</span><br></pre></td></tr></table></figure>


<h2 id="DateTime"><a href="#DateTime" class="headerlink" title="DateTime"></a>DateTime</h2><ul>
<li>表示一个时间点</li>
<li>通过构造函数或解析格式化的字符串创建<code>DateTime</code>对象，并且符合<code>ISO 8601</code>标准的子集，小时是24小时制，范围在0-23之间</li>
<li><code>DateTime</code>对象创建之后，将是固定不变的, 不可被修改</li>
<li><code>DateTime</code>对象默认使用的是本地时区，除非显示地指定<code>UTC</code>时区</li>
</ul>
<h3 id="创建时间点"><a href="#创建时间点" class="headerlink" title="创建时间点"></a>创建时间点</h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当前时间</span></span><br><span class="line"><span class="keyword">var</span> date1 = <span class="keyword">new</span> <span class="built_in">DateTime</span>.now();</span><br><span class="line"><span class="built_in">print</span>(date1);  <span class="comment">//2019-02-23 16:43:15.505305</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造一个指定为本地时区的DateTime</span></span><br><span class="line"><span class="comment">//DateTime(int year, [int month = 1, int day = 1, int hour = 0, int minute = 0, int second = 0, int millisecond = 0, int microsecond = 0])</span></span><br><span class="line"><span class="keyword">var</span> date2 = <span class="keyword">new</span> <span class="built_in">DateTime</span>(<span class="number">2018</span>, <span class="number">10</span>, <span class="number">3</span>, <span class="number">12</span>, <span class="number">23</span>, <span class="number">34</span>, <span class="number">562</span>, <span class="number">1002</span>);</span><br><span class="line"><span class="built_in">print</span>(date2);  <span class="comment">//2018-10-03 12:23:34.563002</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用微秒创建</span></span><br><span class="line"><span class="keyword">var</span> date3 = <span class="keyword">new</span> <span class="built_in">DateTime</span>.fromMicrosecondsSinceEpoch(<span class="number">1000222</span>);</span><br><span class="line"><span class="comment">// isUtc: true: UTC时区, 默认false</span></span><br><span class="line"><span class="keyword">var</span> date31 =  <span class="keyword">new</span> <span class="built_in">DateTime</span>.fromMicrosecondsSinceEpoch(<span class="number">1000222</span>, isUtc: <span class="keyword">true</span>);</span><br><span class="line"><span class="built_in">print</span>(date3);  <span class="comment">//1970-01-01 08:00:01.000222</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用毫秒创建</span></span><br><span class="line"><span class="keyword">var</span> date4 = <span class="keyword">new</span> <span class="built_in">DateTime</span>.fromMillisecondsSinceEpoch(<span class="number">1000222</span>);</span><br><span class="line"><span class="comment">// isUtc: true: UTC时区, 默认false</span></span><br><span class="line"><span class="keyword">var</span> date41 = <span class="keyword">new</span> <span class="built_in">DateTime</span>.fromMillisecondsSinceEpoch(<span class="number">1000222</span>, isUtc: <span class="keyword">true</span>);</span><br><span class="line"><span class="built_in">print</span>(date4);  <span class="comment">//1970-01-01 08:16:40.222</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定为UTC时区的时间</span></span><br><span class="line"><span class="keyword">var</span> date5 = <span class="keyword">new</span> <span class="built_in">DateTime</span>.utc(<span class="number">1969</span>, <span class="number">7</span>, <span class="number">20</span>, <span class="number">20</span>, <span class="number">18</span>, <span class="number">04</span>);</span><br><span class="line"><span class="built_in">print</span>(date5);  <span class="comment">//1969-07-20 20:18:04.000Z</span></span><br></pre></td></tr></table></figure>

<h3 id="parse"><a href="#parse" class="headerlink" title="parse"></a>parse</h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">DateTime</span> parse(<span class="built_in">String</span> formattedString)</span><br></pre></td></tr></table></figure>

<ul>
<li>基于时间字符串, 创建<code>DateTime</code></li>
<li>如果输入的字符串无法解析，将抛出异常</li>
<li>当前接受的字符串为：<ul>
<li>日期：一个有正负号之分的4-6位数的年份，2位数的月份，2位数的号数<ul>
<li>年、月、日相互间可选-进行分割</li>
<li>例如：”19700101”，”-0004-12-24”，”81030-04-01”</li>
</ul>
</li>
<li>时间部分为可选项，从日期处以<code>T</code>或一个空格分开<ul>
<li>对于时间部分，包括2位数的小时，然后2位数的分钟值可选，然后2位数的秒钟值可选， 然后 <code>.</code> 加1-6位数的秒数可选</li>
<li>分和秒可以用<code>:</code>分隔</li>
<li>如：”12”，”12:30:24.124”，”123010.50”</li>
</ul>
</li>
<li>时区偏移量为可选项，可能用空格与之前的部分分隔开<ul>
<li>时区是<code>z</code>或<code>Z</code>，或者是一个有正负之分的2位数的小时部分，和可选的2位数的分钟部分</li>
<li>符号必须是<code>+</code>或<code>-</code>，并且不能省略</li>
<li>分钟和小时可能用<code>:</code>分隔</li>
</ul>
</li>
</ul>
</li>
<li>接受的字符串例子：<ul>
<li><code>&quot;2012-02-27 13:27:00&quot;</code></li>
<li><code>&quot;2012-02-27 13:27:00.123456z&quot;</code></li>
<li><code>&quot;20120227 13:27:00&quot;</code></li>
<li><code>&quot;20120227T132700&quot;</code></li>
<li><code>&quot;20120227&quot;</code></li>
<li><code>&quot;+20120227&quot;</code></li>
<li><code>&quot;2012-02-27T14Z&quot;</code></li>
<li><code>&quot;2012-02-27T14+00:00&quot;</code></li>
<li><code>&quot;-123450101 00:00:00 Z&quot;</code>：年份为-12345</li>
<li><code>&quot;2002-02-27T14:00:00-0500&quot;</code>: 与<code>&quot;2002-02-27T19:00:00Z&quot;</code>相同</li>
</ul>
</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 格式化时间字符串</span></span><br><span class="line"><span class="keyword">var</span> date6 = <span class="built_in">DateTime</span>.parse(<span class="string">&quot;2012-02-27 13:27:00&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> date7 = <span class="built_in">DateTime</span>.parse(<span class="string">&#x27;20120227T132700&#x27;</span>);</span><br><span class="line"><span class="built_in">print</span>(date6);  <span class="comment">// 2012-02-27 13:27:00.000</span></span><br><span class="line"><span class="built_in">print</span>(date7);  <span class="comment">// 2012-02-27 13:27:00.000</span></span><br></pre></td></tr></table></figure>

<h3 id="属性值"><a href="#属性值" class="headerlink" title="属性值"></a>属性值</h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> time = <span class="built_in">DateTime</span>.parse(<span class="string">&quot;2019-02-25 13:27:04&quot;</span>);</span><br><span class="line"><span class="comment">// 获取年-月-日-周几</span></span><br><span class="line"><span class="built_in">print</span>(time.year);   <span class="comment">//2019</span></span><br><span class="line"><span class="built_in">print</span>(time.month);  <span class="comment">//2</span></span><br><span class="line"><span class="built_in">print</span>(time.day);    <span class="comment">//25</span></span><br><span class="line"><span class="built_in">print</span>(time.weekday);<span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取时-分-秒-毫秒-微秒</span></span><br><span class="line"><span class="built_in">print</span>(time.hour);       <span class="comment">//13</span></span><br><span class="line"><span class="built_in">print</span>(time.minute);     <span class="comment">//27</span></span><br><span class="line"><span class="built_in">print</span>(time.second);     <span class="comment">//4</span></span><br><span class="line"><span class="built_in">print</span>(time.millisecond);<span class="comment">//0</span></span><br><span class="line"><span class="built_in">print</span>(time.microsecond);<span class="comment">//0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 是不是utc时区</span></span><br><span class="line"><span class="built_in">print</span>(time.isUtc);</span><br><span class="line"></span><br><span class="line"><span class="comment">//1970-01-01T00:00:00Z (UTC)开始经过的微秒数</span></span><br><span class="line"><span class="built_in">print</span>(time.microsecondsSinceEpoch);</span><br><span class="line"></span><br><span class="line"><span class="comment">//1970-01-01T00:00:00Z (UTC)开始经过的毫秒数</span></span><br><span class="line"><span class="built_in">print</span>(time.millisecondsSinceEpoch);</span><br><span class="line"></span><br><span class="line"><span class="comment">//平台提供的时区名称</span></span><br><span class="line"><span class="built_in">print</span>(time.timeZoneName);</span><br><span class="line"></span><br><span class="line"><span class="comment">//时区偏移量，即本地时间和UTC之间的时间差</span></span><br><span class="line"><span class="built_in">print</span>(time.timeZoneOffset);</span><br></pre></td></tr></table></figure>

<h3 id="相关函数-2"><a href="#相关函数-2" class="headerlink" title="相关函数"></a>相关函数</h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取当前时间</span></span><br><span class="line"><span class="built_in">DateTime</span> today = <span class="keyword">new</span> <span class="built_in">DateTime</span>.now();</span><br><span class="line"><span class="built_in">print</span>(today);  <span class="comment">//2019-02-28 11:18:16.198088</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//加上duration，返回一个新的DateTime实例</span></span><br><span class="line"><span class="built_in">DateTime</span> newDay = today.add(<span class="keyword">new</span> <span class="built_in">Duration</span>(days: <span class="number">60</span>));</span><br><span class="line"><span class="built_in">print</span>(newDay);  <span class="comment">//2019-04-29 11:18:16.198088</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//减去duration，返回一个新的DateTime实例</span></span><br><span class="line"><span class="built_in">DateTime</span> newDay1 = today.subtract(<span class="keyword">new</span> <span class="built_in">Duration</span>(days: <span class="number">60</span>));</span><br><span class="line"><span class="built_in">print</span>(newDay1);  <span class="comment">//2018-12-30 11:25:31.741382</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较两个时间值的大小, 0: 相等, -1: 前值&lt;后值, 1: 前值&gt;后值</span></span><br><span class="line"><span class="keyword">var</span> isCom = today.compareTo(newDay);</span><br><span class="line"><span class="built_in">print</span>(isCom);  <span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算两个时间的差值</span></span><br><span class="line"><span class="built_in">Duration</span> duration = today.difference(newDay);</span><br><span class="line"><span class="built_in">print</span>(duration);  <span class="comment">//-1440:00:00.000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较两个时间</span></span><br><span class="line"><span class="built_in">print</span>(today.isAfter(newDay));  <span class="comment">// false</span></span><br><span class="line"><span class="built_in">print</span>(today.isBefore(newDay)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较是否是同一时刻</span></span><br><span class="line"><span class="built_in">print</span>(today.isAtSameMomentAs(newDay));  <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回此DateTime在本地时区的值</span></span><br><span class="line"><span class="built_in">print</span>(today.toLocal());  <span class="comment">//2019-02-28 11:30:51.713069</span></span><br></pre></td></tr></table></figure>


<hr>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul>
<li><a href="http://dart.goodev.org/guides/language/language-tour">Dart官网语法介绍-中文版</a></li>
<li><a href="https://www.dartlang.org/guides/language/language-tour">Dart官网语法介绍-英文版</a></li>
<li><a href="http://www.shutongye.com/dartapi/dart-core/Map-class.html">Dart语言中文社区</a></li>
</ul>
<hr>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
        <tag>Dart</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter之基础Widget</title>
    <url>/post/ebbecb82.html</url>
    <content><![CDATA[<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/flutter/widget_base.png?x-oss-process=style/titanjun" alt="Flutter"></p>
<span id="more"></span>


<ul>
<li><a href="https://www.titanjun.top/categories/Flutter%E7%AC%94%E8%AE%B0/">Flutter和Dart系列文章</a></li>
<li><a href="https://github.com/CoderTitan/Flutter_Widget">项目GitHub地址</a></li>
<li><code>Flutter</code>作为一种全新的响应式，跨平台，高性能, 完全免费、开源的移动开发框架</li>
<li><code>Widget</code>是<code>Flutter</code>开发中的主要组成部分, 是<code>Flutter</code>的基础, <code>Flutter</code>的核心设计思想便是: 一切皆<code>Widget</code></li>
<li><code>Flutter</code>中的<code>widget</code>的概念更广泛，它不仅可以表示<code>UI</code>元素，也可以表示一些功能性的组件如：用于手势检测的 <code>GestureDetector</code> <code>widget</code>、用于应用主题数据传递的<code>Theme</code>等等</li>
</ul>
<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/flutter/WidgetWork.png?x-oss-process=style/titanjun" alt="Flutter框架"></p>
<h2 id="Widget与Element"><a href="#Widget与Element" class="headerlink" title="Widget与Element"></a>Widget与Element</h2><ul>
<li><code>Widget</code>实际上就是<code>Element</code>的配置数据, <code>Widget</code>的功能是描述一个UI元素的一个配置数据, 而真正的UI渲染是由<code>Element</code>构成</li>
<li>由于<code>Element</code>是通过<code>Widget</code>生成，所以它们之间有对应关系，所以在大多数场景，我们可以宽泛地认为<code>Widget</code>就是指UI控件或UI渲染</li>
<li>一个<code>Widget</code>对象可以对应多个<code>Element</code>对象。这很好理解，根据同一份配置（<code>Widget</code>），可以创建多个实例（<code>Element</code>）</li>
</ul>
<h3 id="Widget类的声明"><a href="#Widget类的声明" class="headerlink" title="Widget类的声明"></a><code>Widget</code>类的声明</h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="meta">@immutable</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Widget</span> <span class="keyword">extends</span> <span class="title">DiagnosticableTree</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="language-markdown">Initializes [key] for subclasses.</span></span></span><br><span class="line">  <span class="keyword">const</span> Widget(&#123; <span class="keyword">this</span>.key &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">See also the discussions at [Key] and [GlobalKey].</span></span></span><br><span class="line">  <span class="keyword">final</span> Key key;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">multiple times.</span></span></span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  <span class="built_in">Element</span> createElement();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">A short, textual description of this widget.</span></span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">String</span> toStringShort() &#123;</span><br><span class="line">    <span class="keyword">return</span> key == <span class="keyword">null</span> ? <span class="string">&#x27;<span class="subst">$runtimeType</span>&#x27;</span> : <span class="string">&#x27;<span class="subst">$runtimeType</span>-<span class="subst">$key</span>&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> debugFillProperties(DiagnosticPropertiesBuilder properties) &#123;</span><br><span class="line">    <span class="keyword">super</span>.debugFillProperties(properties);</span><br><span class="line">    properties.defaultDiagnosticsTreeStyle = DiagnosticsTreeStyle.dense;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">bool</span> canUpdate(Widget oldWidget, Widget newWidget) &#123;</span><br><span class="line">    <span class="keyword">return</span> oldWidget.runtimeType == newWidget.runtimeType</span><br><span class="line">        &amp;&amp; oldWidget.key == newWidget.key;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Widget</code>类继承自<code>DiagnosticableTree</code>，主要作用是提供调试信息。</li>
<li><code>Key</code>: 这个<code>key</code>属性类似于<code>React/Vue</code>中的<code>key</code>，主要的作用是决定是否在下一次<code>build</code>时复用旧的<code>widget</code>，决定的条件在<code>canUpdate()</code>方法中</li>
<li><code>createElement()</code>：正如前文所述<code>一个Widget可以对应多个Element</code>；<code>Flutter Framework</code>在构建UI时，会先调用此方法生成对应节点的<code>Element</code>对象。此方法是<code>Flutter Framework</code>隐式调用的，在我们开发过程中基本不会调用到。</li>
<li><code>debugFillProperties</code> 复写父类的方法，主要是设置<code>DiagnosticableTree</code>的一些特性。</li>
<li><code>canUpdate</code>是一个静态方法，它主要用于在<code>Widget</code>树重新<code>build</code>时复用旧的<code>widget</code><ul>
<li>具体来说就是：是否用新的<code>Widget</code>对象去更新旧UI上所对应的<code>Element</code>对象的配置；</li>
<li>通过其源码我们可以看到，只要<code>newWidget</code>与<code>oldWidget</code>的<code>runtimeType</code>和<code>key</code>同时相等时就会用<code>newWidget</code>去更新<code>Element</code>对象的配置，否则就会创建新的<code>Element</code></li>
</ul>
</li>
</ul>
<h3 id="StatelessWidget和StatefulWidget的区别"><a href="#StatelessWidget和StatefulWidget的区别" class="headerlink" title="StatelessWidget和StatefulWidget的区别"></a>StatelessWidget和StatefulWidget的区别</h3><ul>
<li><code>StatelessWidget</code>是状态不可变的<code>widget</code>, 初始状态设置以后就不可再变化, 如果需要变化需要重新创建; <code>StatefulWidget</code>可以保存自己的状态</li>
<li>在<code>Flutter</code>中通过引入<code>State</code>来保存状态, 当<code>State</code>的状态改变时，能重新构建本节点以及孩子的<code>Widget</code>树来进行UI变化</li>
<li>如果需要主动改变<code>State</code>的状态，需要通过<code>setState()</code>方法进行触发，单纯改变数据是不会引发UI改变的</li>
<li>下面介绍部分的<code>Widget</code>组件</li>
</ul>
<h2 id="Text"><a href="#Text" class="headerlink" title="Text"></a>Text</h2><p>UI上面文字的展示基本上都要靠<code>Text</code>组件来完成</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 两种构造函数</span></span><br><span class="line"><span class="comment">// 显示普通的文本</span></span><br><span class="line"> <span class="keyword">const</span> Text(<span class="keyword">this</span>.data, &#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="keyword">this</span>.style,</span><br><span class="line">    <span class="keyword">this</span>.textAlign,</span><br><span class="line">    <span class="keyword">this</span>.textDirection,</span><br><span class="line">    <span class="keyword">this</span>.locale,</span><br><span class="line">    <span class="keyword">this</span>.softWrap,</span><br><span class="line">    <span class="keyword">this</span>.overflow,</span><br><span class="line">    <span class="keyword">this</span>.textScaleFactor,</span><br><span class="line">    <span class="keyword">this</span>.maxLines,</span><br><span class="line">    <span class="keyword">this</span>.semanticsLabel,</span><br><span class="line">  &#125;) : <span class="keyword">assert</span>(data != <span class="keyword">null</span>),</span><br><span class="line">       textSpan = <span class="keyword">null</span>,</span><br><span class="line">       <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">段落式文本,可以给文本中的每个textSpan设置其样式</span></span></span><br><span class="line">  <span class="keyword">const</span> Text.rich(<span class="keyword">this</span>.textSpan, &#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="keyword">this</span>.style,</span><br><span class="line">    <span class="keyword">this</span>.textAlign,</span><br><span class="line">    <span class="keyword">this</span>.textDirection,</span><br><span class="line">    <span class="keyword">this</span>.locale,</span><br><span class="line">    <span class="keyword">this</span>.softWrap,</span><br><span class="line">    <span class="keyword">this</span>.overflow,</span><br><span class="line">    <span class="keyword">this</span>.textScaleFactor,</span><br><span class="line">    <span class="keyword">this</span>.maxLines,</span><br><span class="line">    <span class="keyword">this</span>.semanticsLabel,</span><br><span class="line">  &#125;): <span class="keyword">assert</span>(textSpan != <span class="keyword">null</span>),</span><br><span class="line">      data = <span class="keyword">null</span>,</span><br><span class="line">      <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="参数介绍"><a href="#参数介绍" class="headerlink" title="参数介绍"></a>参数介绍</h3><h4 id="data"><a href="#data" class="headerlink" title="data"></a>data</h4><p>文本的内容</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Text(<span class="string">&#x27;titanjun&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="style"><a href="#style" class="headerlink" title="style"></a>style</h4><p>文本的样式</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">const</span> TextStyle(&#123;</span><br><span class="line">    <span class="keyword">this</span>.inherit = <span class="keyword">true</span>,</span><br><span class="line">    <span class="keyword">this</span>.color,</span><br><span class="line">    <span class="keyword">this</span>.fontSize,</span><br><span class="line">    <span class="keyword">this</span>.fontWeight,</span><br><span class="line">    <span class="keyword">this</span>.fontStyle,</span><br><span class="line">    <span class="keyword">this</span>.letterSpacing,</span><br><span class="line">    <span class="keyword">this</span>.wordSpacing,</span><br><span class="line">    <span class="keyword">this</span>.textBaseline,</span><br><span class="line">    <span class="keyword">this</span>.height,</span><br><span class="line">    <span class="keyword">this</span>.locale,</span><br><span class="line">    <span class="keyword">this</span>.foreground,</span><br><span class="line">    <span class="keyword">this</span>.background,</span><br><span class="line">    <span class="keyword">this</span>.shadows,</span><br><span class="line">    <span class="keyword">this</span>.decoration,</span><br><span class="line">    <span class="keyword">this</span>.decorationColor,</span><br><span class="line">    <span class="keyword">this</span>.decorationStyle,</span><br><span class="line">    <span class="keyword">this</span>.debugLabel,</span><br><span class="line">    <span class="built_in">String</span> fontFamily,</span><br><span class="line">    <span class="built_in">String</span> package,</span><br><span class="line">  &#125;) : fontFamily = package == <span class="keyword">null</span> ? fontFamily : <span class="string">&#x27;packages/<span class="subst">$package</span>/<span class="subst">$fontFamily</span>&#x27;</span>,</span><br><span class="line">       <span class="keyword">assert</span>(inherit != <span class="keyword">null</span>),</span><br><span class="line">       <span class="keyword">assert</span>(color == <span class="keyword">null</span> || foreground == <span class="keyword">null</span>, _kColorForegroundWarning);</span><br><span class="line">       </span><br><span class="line"><span class="comment">// 相关属性介绍</span></span><br><span class="line"><span class="number">1.</span> inherit: 为<span class="keyword">false</span>时不显示</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> color: 字体颜色</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> fontSize: 字体大小, 默认是<span class="number">14.0</span></span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> fontWeight: 字体的粗体, FontWeight.w500</span><br><span class="line">  </span><br><span class="line"><span class="number">5.</span> fontStyle: 字体的样式</span><br><span class="line">    normal正常 italic 斜体</span><br><span class="line"></span><br><span class="line"><span class="number">6.</span> letterSpacing: 字符间距</span><br><span class="line"></span><br><span class="line"><span class="number">7.</span> wordSpacing: 单词间距</span><br><span class="line"></span><br><span class="line"><span class="number">8.</span> textBaseline</span><br><span class="line">    alphabetic：用于对齐字母字符底部的水平线</span><br><span class="line">    ideographic：用于对齐表意字符的水平线</span><br><span class="line">    </span><br><span class="line"><span class="number">9.</span> height: 用在Text控件上的时候，会乘以fontSize做为行高,</span><br><span class="line"></span><br><span class="line"><span class="number">10.</span> locale: 国际化</span><br><span class="line"></span><br><span class="line"><span class="number">11.</span> foreground: 用paint来渲染text，也可以用他来改变字体颜色等</span><br><span class="line"></span><br><span class="line"><span class="number">12.</span> background: 背景颜色</span><br><span class="line"></span><br><span class="line"><span class="number">13.</span> decoration: </span><br><span class="line">    下划线 underline、 删除线 lineThrough、上划线 overline，默认是无 none</span><br><span class="line">    </span><br><span class="line"><span class="number">14.</span> decorationStyle: decoration线的样式</span><br><span class="line">    solid: 直线, <span class="built_in">double</span>: 两条线, dotted: 短虚线, dashed: 长虚线, wavy: 波浪线</span><br><span class="line"></span><br><span class="line"><span class="number">15.</span> decorationColor: decoration线的颜色</span><br><span class="line"></span><br><span class="line"><span class="number">16.</span> debugLabel: 文本样式的描述, 该属性只在调试中维护</span><br><span class="line"></span><br><span class="line"><span class="number">17.</span> fontFamily和package（自定义字体的时候用的到，后面再详解）</span><br></pre></td></tr></table></figure>

<p>使用样式示例</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">style: TextStyle(</span><br><span class="line">    inherit: <span class="keyword">true</span>,</span><br><span class="line">    color: Colors.red,</span><br><span class="line">    fontSize: <span class="number">50</span>,</span><br><span class="line">    fontWeight: FontWeight.bold,</span><br><span class="line">    fontStyle: FontStyle.italic,</span><br><span class="line">    letterSpacing: <span class="number">2</span>,</span><br><span class="line">    wordSpacing: <span class="number">5</span>,</span><br><span class="line">    textBaseline: TextBaseline.alphabetic,</span><br><span class="line">    height: <span class="number">2</span>,</span><br><span class="line">    locale: Locale(<span class="string">&#x27;CH&#x27;</span>),</span><br><span class="line">    decoration: TextDecoration.lineThrough,</span><br><span class="line">    decorationColor: Colors.blue,</span><br><span class="line">    decorationStyle: TextDecorationStyle.wavy,</span><br><span class="line">),</span><br></pre></td></tr></table></figure>

<h4 id="textAlign"><a href="#textAlign" class="headerlink" title="textAlign"></a>textAlign</h4><p>文本显示方向</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">left: 居左显示</span><br><span class="line">center: 居中显示</span><br><span class="line">right: 居右显示</span><br><span class="line">justify: 文本的拉伸行，其末尾用软换行符填充宽度</span><br><span class="line">start: 对齐容器前缘的文本。</span><br><span class="line">    对于从左到右的文本([TextDirection.ltr])，这是左边缘。</span><br><span class="line">    对于从右到左的文本([TextDirection.rtl])，这是右边缘。</span><br><span class="line">end: 对齐容器尾部边缘的文本。</span><br><span class="line">    对于从左到右的文本([TextDirection.ltr])，这是右边缘。</span><br><span class="line">    对于从右到左的文本([TextDirection.rtl])，这是左边缘。</span><br></pre></td></tr></table></figure>

<h4 id="textDirection"><a href="#textDirection" class="headerlink" title="textDirection"></a>textDirection</h4><p>和上述<code>TextAlign.start和TextAlign.end</code>一样</p>
<h4 id="softWrap"><a href="#softWrap" class="headerlink" title="softWrap"></a>softWrap</h4><p>文本是否能换行,bool类型</p>
<h4 id="overflow"><a href="#overflow" class="headerlink" title="overflow"></a>overflow</h4><p>用来指定超出文本的表示方式，是截断文本啊还是用三个点显示等</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ellipsis: ...形式显示</span><br><span class="line">clip: 直接截断</span><br><span class="line">fade: 效果和clip一样</span><br></pre></td></tr></table></figure>

<h4 id="maxLines"><a href="#maxLines" class="headerlink" title="maxLines"></a>maxLines</h4><p>用来指定文本最多显示多少行</p>
<h4 id="textScaleFactor"><a href="#textScaleFactor" class="headerlink" title="textScaleFactor"></a>textScaleFactor</h4><p>文本字体的缩放倍数，如：1.5则在默认字体上变成1.5倍大小字体，0.5则是0.5倍</p>
<h3 id="Text构造函数"><a href="#Text构造函数" class="headerlink" title="Text构造函数"></a>Text构造函数</h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">child: Text(</span><br><span class="line">      <span class="comment">// 需要显示的文字</span></span><br><span class="line">      <span class="string">&#x27;titanjun.top&#x27;</span> * <span class="number">3</span>,</span><br><span class="line">      textAlign: TextAlign.left,</span><br><span class="line">      textDirection: TextDirection.ltr,</span><br><span class="line">      locale: Locale(<span class="string">&#x27;CH&#x27;</span>),</span><br><span class="line">      maxLines: <span class="number">1</span>,</span><br><span class="line">      overflow: TextOverflow.fade,</span><br><span class="line">      style: TextStyle(</span><br><span class="line">          inherit: <span class="keyword">true</span>,</span><br><span class="line">          color: Colors.red,</span><br><span class="line">          fontSize: <span class="number">50</span>,</span><br><span class="line">          fontWeight: FontWeight.bold,</span><br><span class="line">          fontStyle: FontStyle.italic,</span><br><span class="line">          letterSpacing: <span class="number">2</span>,</span><br><span class="line">          wordSpacing: <span class="number">5</span>,</span><br><span class="line">          textBaseline: TextBaseline.alphabetic,</span><br><span class="line">          height: <span class="number">2</span>,</span><br><span class="line">          locale: Locale(<span class="string">&#x27;CH&#x27;</span>),</span><br><span class="line">          decoration: TextDecoration.lineThrough,</span><br><span class="line">          decorationColor: Colors.blue,</span><br><span class="line">          decorationStyle: TextDecorationStyle.wavy,</span><br><span class="line">      ),</span><br><span class="line">  ),</span><br></pre></td></tr></table></figure>


<h3 id="Text-rich构造函数"><a href="#Text-rich构造函数" class="headerlink" title="Text.rich构造函数"></a>Text.rich构造函数</h3><p>这个构造函数和<code>iOS</code>中用到的富文本类似</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">child: Text.rich(</span><br><span class="line">    TextSpan(</span><br><span class="line">      text: <span class="string">&#x27;博客地址: &#x27;</span>,</span><br><span class="line">      children: [</span><br><span class="line">        TextSpan(</span><br><span class="line">          text: <span class="string">&#x27;https://&#x27;</span>,</span><br><span class="line">          style: TextStyle(color: Colors.red)</span><br><span class="line">        ),</span><br><span class="line">        TextSpan(</span><br><span class="line">          text: <span class="string">&#x27;titanjun.top&#x27;</span>,</span><br><span class="line">          style: TextStyle(color: Colors.blue),</span><br><span class="line">        ),</span><br><span class="line">        TextSpan(</span><br><span class="line">          text: <span class="string">&#x27;欢迎访问&#x27;</span>,</span><br><span class="line">          style: TextStyle(color: Colors.orange)</span><br><span class="line">        ),</span><br><span class="line">      ]</span><br><span class="line">    ),</span><br><span class="line">),</span><br></pre></td></tr></table></figure>


<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/flutter/text_rich.png" alt="Text.rich"></p>
<p>其中<code>TextSpan</code>的构造函数如下</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> TextSpan(&#123;</span><br><span class="line">    <span class="keyword">this</span>.style,</span><br><span class="line">    <span class="keyword">this</span>.text,</span><br><span class="line">    <span class="comment">// 接受List&lt;TextSpan&gt;类型的数组</span></span><br><span class="line">    <span class="keyword">this</span>.children,</span><br><span class="line">    <span class="comment">// 文本的手势操作, 后面说这个</span></span><br><span class="line">    <span class="keyword">this</span>.recognizer,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h2><ul>
<li>一个用于展示图片的组件。支持 JPEG、PNG、GIF、Animated GIF、WebP、Animated WebP、BMP 和 WBMP 等格式</li>
<li><code>Image</code>共有五种构造函数</li>
</ul>
<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/flutter/ImageProvider.png" alt="image"></p>
<h3 id="Image-1"><a href="#Image-1" class="headerlink" title="Image()"></a>Image()</h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Image(&#123;</span><br><span class="line">  Key key,</span><br><span class="line">  <span class="comment">// 一个图片对象ImageProvider, 可设置NetworkImage(), FileImage(), MemoryImage()三种对象</span></span><br><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.image,</span><br><span class="line">  <span class="comment">// 图片的描述, String</span></span><br><span class="line">  <span class="keyword">this</span>.semanticLabel,</span><br><span class="line">  <span class="keyword">this</span>.excludeFromSemantics = <span class="keyword">false</span>,</span><br><span class="line">  <span class="comment">// 图片的宽度, double</span></span><br><span class="line">  <span class="keyword">this</span>.width,</span><br><span class="line">  <span class="comment">// 图片的高度, double</span></span><br><span class="line">  <span class="keyword">this</span>.height,</span><br><span class="line">  <span class="comment">// 图像的颜色, 用于和图片混合的颜色, 结合colorBlendMode使用</span></span><br><span class="line">  <span class="keyword">this</span>.color,</span><br><span class="line">  <span class="comment">// 颜色和图片混合的状态, BlendMode</span></span><br><span class="line">  <span class="keyword">this</span>.colorBlendMode,</span><br><span class="line">  <span class="comment">// 图像在布局中分配的空间, BoxFit</span></span><br><span class="line">  <span class="keyword">this</span>.fit,</span><br><span class="line">  <span class="comment">// 图像边界内对齐图像, Alignment</span></span><br><span class="line">  <span class="keyword">this</span>.alignment = Alignment.center,</span><br><span class="line">  <span class="comment">// 未充分填充容器时,是否重复显示图片</span></span><br><span class="line">  <span class="keyword">this</span>.repeat = ImageRepeat.noRepeat,</span><br><span class="line">  <span class="comment">// 九片图像的中心切点, Rect</span></span><br><span class="line">  <span class="keyword">this</span>.centerSlice,</span><br><span class="line">  <span class="comment">// 是否在图像的方向上绘制图像 TextDirection</span></span><br><span class="line">  <span class="keyword">this</span>.matchTextDirection = <span class="keyword">false</span>,</span><br><span class="line">  <span class="comment">// 当图像提供者发生变化时，是继续显示旧图像（true）还是暂时不显示（false）</span></span><br><span class="line">  <span class="keyword">this</span>.gaplessPlayback = <span class="keyword">false</span>,</span><br><span class="line">  <span class="comment">// 设置图片的过滤质量</span></span><br><span class="line">  <span class="keyword">this</span>.filterQuality = FilterQuality.low,</span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure>

<h4 id="部分属性详解"><a href="#部分属性详解" class="headerlink" title="部分属性详解"></a>部分属性详解</h4><h5 id="width、height："><a href="#width、height：" class="headerlink" title="width、height："></a>width、height：</h5><ul>
<li>用于设置图片的宽、高，当不指定宽高时，图片会根据当前父容器的限制，尽可能的显示其原始大小</li>
<li>如果只设置<code>width</code>、<code>height</code>的其中一个，那么另一个属性默认会按比例缩放</li>
<li>但可以通过下面介绍的fit属性来指定适应规则</li>
</ul>
<h5 id="fit"><a href="#fit" class="headerlink" title="fit"></a>fit</h5><p>图像在布局中分配的空间, <code>BoxFit</code>枚举值</p>
<ul>
<li><code>fill</code>: 填充满容器空间, 图片会被拉伸</li>
<li><code>contain</code>: 以容器的大小等比例缩放图片</li>
<li><code>cover</code>: 填充整个容器, 图片会被剪切</li>
<li><code>fitWidth</code>: 以容器的宽度, 等比例缩放图片</li>
<li><code>fitHeight</code>: 以容器的高度, 等比例的缩放图片</li>
<li><code>none</code>: 以图片的实际大小显示</li>
<li><code>scaleDown</code>: 居中显示, 图片不会拉伸, 以宽高中最小的尺寸为标准</li>
</ul>
<h5 id="alignment"><a href="#alignment" class="headerlink" title="alignment"></a>alignment</h5><p>图像边界内对齐图像, <code>Alignment</code>类, 不是枚举值</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">定义方式为垂直方向-水平方向</span></span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> Alignment topLeft = Alignment(<span class="number">-1.0</span>, <span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> Alignment topCenter = Alignment(<span class="number">0.0</span>, <span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> Alignment topRight = Alignment(<span class="number">1.0</span>, <span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> Alignment centerLeft = Alignment(<span class="number">-1.0</span>, <span class="number">0.0</span>);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> Alignment center = Alignment(<span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> Alignment centerRight = Alignment(<span class="number">1.0</span>, <span class="number">0.0</span>);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> Alignment bottomLeft = Alignment(<span class="number">-1.0</span>, <span class="number">1.0</span>);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> Alignment bottomCenter = Alignment(<span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> Alignment bottomRight = Alignment(<span class="number">1.0</span>, <span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">使用方式</span></span></span><br><span class="line">alignment: Alignment.topLeft,</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">alignment: Alignment(<span class="number">0.0</span>, <span class="number">1.0</span>)</span><br></pre></td></tr></table></figure>


<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Image(</span><br><span class="line">  image: NetworkImage(<span class="string">&#x27;https://titanjun.oss-cn-hangzhou.aliyuncs.com/flutter/flutter.jpeg?x-oss-process=style/titanjun&#x27;</span>),</span><br><span class="line">  fit: BoxFit.scaleDown,</span><br><span class="line">  alignment: Alignment.topLeft,</span><br><span class="line">),</span><br></pre></td></tr></table></figure>

<h5 id="color和-colorBlendMode"><a href="#color和-colorBlendMode" class="headerlink" title="color和 colorBlendMode"></a>color和 colorBlendMode</h5><p>在图片绘制时可以对每一个像素进行颜色混合处理，<code>color</code>指定混合色，而<code>colorBlendMode</code>指定混合模式；</p>
<h5 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a>repeat</h5><p>当图片本身大小小于显示空间时，指定图片的重复规则</p>
<h3 id="FadeInImage"><a href="#FadeInImage" class="headerlink" title="FadeInImage"></a>FadeInImage</h3><p>可以用于添加占位图</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FadeInImage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> FadeInImage(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="comment">// 占位图片, 默认本地图片</span></span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.placeholder,</span><br><span class="line">    <span class="keyword">this</span>.placeholderErrorBuilder,</span><br><span class="line">    <span class="comment">// 网络图片</span></span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.image,</span><br><span class="line">    <span class="keyword">this</span>.imageErrorBuilder,</span><br><span class="line">    <span class="keyword">this</span>.excludeFromSemantics = <span class="keyword">false</span>,</span><br><span class="line">    <span class="keyword">this</span>.imageSemanticLabel,</span><br><span class="line">    <span class="keyword">this</span>.fadeOutDuration = <span class="keyword">const</span> <span class="built_in">Duration</span>(milliseconds: <span class="number">300</span>),</span><br><span class="line">    <span class="keyword">this</span>.fadeOutCurve = Curves.easeOut,</span><br><span class="line">    <span class="keyword">this</span>.fadeInDuration = <span class="keyword">const</span> <span class="built_in">Duration</span>(milliseconds: <span class="number">700</span>),</span><br><span class="line">    <span class="keyword">this</span>.fadeInCurve = Curves.easeIn,</span><br><span class="line">    <span class="keyword">this</span>.width,</span><br><span class="line">    <span class="keyword">this</span>.height,</span><br><span class="line">    <span class="keyword">this</span>.fit,</span><br><span class="line">    <span class="keyword">this</span>.alignment = Alignment.center,</span><br><span class="line">    <span class="keyword">this</span>.repeat = ImageRepeat.noRepeat,</span><br><span class="line">    <span class="keyword">this</span>.matchTextDirection = <span class="keyword">false</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ImageProvider"><a href="#ImageProvider" class="headerlink" title="ImageProvider"></a>ImageProvider</h3><p>用于显示图片的抽象类, 不能直接使用, 需要使用其子类</p>
<p>用于显示网络图片</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用于显示网络图片</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">NetworkImage</span> <span class="keyword">extends</span> <span class="title">ImageProvider</span>&lt;<span class="title">NetworkImage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="language-markdown">抽象类不能直接使用, 但是可以使用它的工厂构造函数</span></span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">factory</span> NetworkImage(<span class="built_in">String</span> url, &#123; <span class="built_in">double</span> scale, <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; headers &#125;) = network_image.NetworkImage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于加载图片文件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileImage</span> <span class="keyword">extends</span> <span class="title">ImageProvider</span>&lt;<span class="title">FileImage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="language-markdown">常量构造方法</span></span></span><br><span class="line">  <span class="keyword">const</span> FileImage(<span class="keyword">this</span>.file, &#123; <span class="keyword">this</span>.scale = <span class="number">1.0</span> &#125;)</span><br><span class="line">    : <span class="keyword">assert</span>(file != <span class="keyword">null</span>),</span><br><span class="line">      <span class="keyword">assert</span>(scale != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于加载内存中的图片</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MemoryImage</span> <span class="keyword">extends</span> <span class="title">ImageProvider</span>&lt;<span class="title">MemoryImage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="language-markdown">常量构造方法</span></span></span><br><span class="line">  <span class="keyword">const</span> MemoryImage(<span class="keyword">this</span>.bytes, &#123; <span class="keyword">this</span>.scale = <span class="number">1.0</span> &#125;)</span><br><span class="line">    : <span class="keyword">assert</span>(bytes != <span class="keyword">null</span>),</span><br><span class="line">      <span class="keyword">assert</span>(scale != <span class="keyword">null</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于显示本地图片</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AssetImage</span> <span class="keyword">extends</span> <span class="title">AssetBundleImageProvider</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="language-markdown">常量构造方法</span></span></span><br><span class="line">  <span class="keyword">const</span> AssetImage(</span><br><span class="line">    <span class="keyword">this</span>.assetName, &#123;</span><br><span class="line">    <span class="keyword">this</span>.bundle,</span><br><span class="line">    <span class="keyword">this</span>.package,</span><br><span class="line">  &#125;) : <span class="keyword">assert</span>(assetName != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h3 id="Image-network"><a href="#Image-network" class="headerlink" title="Image.network"></a>Image.network</h3><p>用于显示网络图片</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Image.network(</span><br><span class="line">  <span class="string">&#x27;https://titanjun.oss-cn-hangzhou.aliyuncs.com/flutter/catimage.jpg&#x27;</span>,</span><br><span class="line">  width: <span class="number">100</span>,</span><br><span class="line">  height: <span class="number">100</span>,</span><br><span class="line">  fit: BoxFit.scaleDown,</span><br><span class="line">  alignment: Alignment.center,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>网络请求<code>Image</code>是最常见的操作, 这里重点说明两个点</p>
<h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><ul>
<li><code>ImageCache</code>是<code>ImageProvider</code>默认使用的图片缓存。<code>ImageCache</code>使用的是<code>LRU</code>的算法</li>
<li>默认可以存储1000张图片。如果觉得缓存太大，可以通过设置<code>ImageCache</code>的<code>maximumSize</code>属性来控制缓存图片的数量。</li>
<li>也可以通过设置<code>maximumSizeBytes</code>来控制缓存的大小（默认缓存大小10MB）</li>
</ul>
<h4 id="CDN优化"><a href="#CDN优化" class="headerlink" title="CDN优化"></a>CDN优化</h4><p>如果想要使用<code>cdn</code>优化，可以通过<code>url</code>增加后缀的方式实现。默认实现中没有这个点，但是考虑到<code>cdn</code>优化的可观收益，建议大家利用好这个优化</p>
<h3 id="Image-asset"><a href="#Image-asset" class="headerlink" title="Image.asset"></a>Image.asset</h3><ul>
<li><code>Flutter</code>应用程序可以包含代码和 <code>assets</code>（有时称为资源）</li>
<li><code>asset</code>是打包到程序安装包中的，可在运行时访问</li>
<li>常见类型的<code>asset</code>包括静态数据（例如JSON文件），配置文件，图标和图片（JPEG，WebP，GIF，动画WebP &#x2F; GIF，PNG，BMP和WBMP）</li>
<li><code>Flutter</code>使用<code>pubspec.yaml</code>文件（位于项目根目录），来识别应用程序所需的<code>asset</code></li>
</ul>
<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/flutter/image_assets.png" alt="image"></p>
<div class="note warning"><p>注意事项</p></div>

<ul>
<li>图片所在的文件夹<code>images</code>和<code>pubspec.yaml</code>需要在同一目录下, 否则<code>pubspec.yaml</code>文件中, 设置资源路径的时候要对应修改</li>
<li><code>images</code>图片文件夹中<code>2.0x和3.0x</code>图片要分别创建两个文件夹, 并把2倍和3倍图分别放在不同的文件夹中, 切文件的名字不要在带<code>@2x和@3x</code>字样</li>
</ul>
<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/flutter/image_assets1.png" alt="image"></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Image.asset(</span><br><span class="line">  <span class="string">&#x27;images/home.png&#x27;</span>,</span><br><span class="line">  width: <span class="number">100</span>,</span><br><span class="line">  height: <span class="number">100</span>,</span><br><span class="line">  fit: BoxFit.scaleDown,</span><br><span class="line">  alignment: Alignment.center,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="Image-file"><a href="#Image-file" class="headerlink" title="Image.file"></a>Image.file</h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Image.file(File file, &#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="built_in">double</span> scale = <span class="number">1.0</span>,</span><br><span class="line">    <span class="keyword">this</span>.semanticLabel,</span><br><span class="line">    <span class="keyword">this</span>.excludeFromSemantics = <span class="keyword">false</span>,</span><br><span class="line">    <span class="keyword">this</span>.width,</span><br><span class="line">    <span class="keyword">this</span>.height,</span><br><span class="line">    <span class="keyword">this</span>.color,</span><br><span class="line">    <span class="keyword">this</span>.colorBlendMode,</span><br><span class="line">    <span class="keyword">this</span>.fit,</span><br><span class="line">    <span class="keyword">this</span>.alignment = Alignment.center,</span><br><span class="line">    <span class="keyword">this</span>.repeat = ImageRepeat.noRepeat,</span><br><span class="line">    <span class="keyword">this</span>.centerSlice,</span><br><span class="line">    <span class="keyword">this</span>.matchTextDirection = <span class="keyword">false</span>,</span><br><span class="line">    <span class="keyword">this</span>.gaplessPlayback = <span class="keyword">false</span>,</span><br><span class="line">    <span class="keyword">this</span>.filterQuality = FilterQuality.low,</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>


<ul>
<li>主要解析file参数，其他与<code>Image()</code>构造的参数一致！</li>
<li><code>file</code>: 对文件系统上的文件的引用。</li>
<li><a href="https://docs.flutter.io/flutter/dart-io/File-class.html">File</a> 实例是一个对象，它包含可以在其上执行操作的路径</li>
</ul>
<h3 id="Image-memory"><a href="#Image-memory" class="headerlink" title="Image.memory"></a>Image.memory</h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Image.memory(Uint8List bytes, &#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="built_in">double</span> scale = <span class="number">1.0</span>,</span><br><span class="line">    <span class="keyword">this</span>.semanticLabel,</span><br><span class="line">    <span class="keyword">this</span>.excludeFromSemantics = <span class="keyword">false</span>,</span><br><span class="line">    <span class="keyword">this</span>.width,</span><br><span class="line">    <span class="keyword">this</span>.height,</span><br><span class="line">    <span class="keyword">this</span>.color,</span><br><span class="line">    <span class="keyword">this</span>.colorBlendMode,</span><br><span class="line">    <span class="keyword">this</span>.fit,</span><br><span class="line">    <span class="keyword">this</span>.alignment = Alignment.center,</span><br><span class="line">    <span class="keyword">this</span>.repeat = ImageRepeat.noRepeat,</span><br><span class="line">    <span class="keyword">this</span>.centerSlice,</span><br><span class="line">    <span class="keyword">this</span>.matchTextDirection = <span class="keyword">false</span>,</span><br><span class="line">    <span class="keyword">this</span>.gaplessPlayback = <span class="keyword">false</span>,</span><br><span class="line">    <span class="keyword">this</span>.filterQuality = FilterQuality.low,</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>加载<code>Uint8List</code>资源图片</li>
<li>主要解析<code>bytes</code>参数，其他与<code>Image()</code>构造的参数一致！</li>
</ul>
<h2 id="Icon"><a href="#Icon" class="headerlink" title="Icon"></a>Icon</h2><ul>
<li><code>Flutter</code>中，<code>Icon</code>是类似于<code>web</code>开发中一样使用<code>iconfont</code>(字体图标)，它是将图标做成字体文件，然后通过指定不同的字符而显示不同的图片</li>
<li>在字体文件中，每一个字符都对应一个位码，而每一个位码对应一个显示字形，不同的字体就是指字形不同，即字符对应的字形是不同的</li>
<li>而在<code>iconfont</code>中，只是将位码对应的字形做成了图标，所以不同的字符最终就会渲染成不同的图标。</li>
<li>在<code>Flutter</code>中<code>iconfont</code>相较于图片的优势如下:<ul>
<li>体积小：可以减小安装包大小。</li>
<li>矢量的：<code>iconfont</code>都是矢量图标，放大不会影响其清晰度。</li>
<li>可以应用文本样式：可以像文本一样改变字体图标的颜色、大小对齐等。</li>
<li>可以通过<code>TextSpan</code>和文本混用。</li>
</ul>
</li>
</ul>
<h3 id="使用Material-Design字体图标"><a href="#使用Material-Design字体图标" class="headerlink" title="使用Material Design字体图标"></a>使用Material Design字体图标</h3><p><code>Flutter</code>默认包含了一套<code>Material Design</code>的字体图标，在<code>pubspec.yaml</code>文件中的配置如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">flutter:</span></span><br><span class="line">  <span class="attr">uses-material-design:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<div class="note warning"><p>如果设置成false, 则图片效果如下, 图片颜色为自己设置的颜色</p></div>

<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/flutter/icon_false.png" alt="image"></p>
<ul>
<li><code>Material Design</code>所有图标可以在其官网查看：<a href="https://material.io/tools/icons/">https://material.io/tools/icons/</a></li>
<li><code>Material Design</code>所有图标对应的字符编码可在<a href="https://github.com/google/material-design-icons/blob/master/iconfont/codepoints">material-design-icons</a>中搜索查找</li>
</ul>
<h3 id="在Text中使用"><a href="#在Text中使用" class="headerlink" title="在Text中使用"></a>在Text中使用</h3><p>下面看一个在<code>Text</code>中使用<code>iconfont</code>的示例</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span> iconStr = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="comment">// accessible: &amp;#xE914; or 0xE914 or E914</span></span><br><span class="line">iconStr += <span class="string">&quot;\uE914&quot;</span>;</span><br><span class="line"><span class="comment">// error: &amp;#xE000; or 0xE000 or E000</span></span><br><span class="line">iconStr += <span class="string">&quot; \uE000&quot;</span>;</span><br><span class="line"><span class="comment">// fingerprint: &amp;#xE90D; or 0xE90D or E90D</span></span><br><span class="line">iconStr += <span class="string">&quot; \uE90D&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Text(iconStr,</span><br><span class="line">  style: TextStyle(</span><br><span class="line">    fontFamily: <span class="string">&quot;MaterialIcons&quot;</span>,</span><br><span class="line">    fontSize: <span class="number">80.0</span>,</span><br><span class="line">    color: Colors.green</span><br><span class="line">  ),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>上述代码的运行效果如下</p>
<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/flutter/icon_image.png" alt="image"></p>
<blockquote>
<p>任何一个图片我们都可以使用<code>Text</code>文本进行展示, 但是这需要我们提供每一个图标的字符码点, 可在<a href="https://github.com/google/material-design-icons/blob/master/iconfont/codepoints">material-design-icons</a>中搜索查找, 而且并不能固定指定图片的大小, 只能设置字体的大小, 这并对开发者不友好</p>
</blockquote>
<h3 id="Icon介绍"><a href="#Icon介绍" class="headerlink" title="Icon介绍"></a>Icon介绍</h3><p><code>Flutter</code>封装了一个<code>Icon</code>来专门显示字体图标，上面的例子也可以用如下方式实现</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Row(</span><br><span class="line">  mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">  children: &lt;Widget&gt;[</span><br><span class="line">    Icon(Icons.accessible, color: Colors.green, size: <span class="number">80</span>),</span><br><span class="line">    Icon(Icons.error, color: Colors.green, size: <span class="number">80</span>),</span><br><span class="line">    Icon(Icons.fingerprint, color: Colors.green, size: <span class="number">80</span>),</span><br><span class="line">  ],</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><code>Icons</code>类中包含了所有<code>Material Design</code>图标的<code>IconData</code>静态变量定义, …..我大概算了一下, <code>Icons</code>中大概一共定义了984中图标</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// icon的构造函数</span></span><br><span class="line"><span class="keyword">const</span> Icon(<span class="keyword">this</span>.icon, &#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="comment">// double, 设置图片的大小, 同事设置宽高</span></span><br><span class="line">    <span class="keyword">this</span>.size,</span><br><span class="line">    <span class="comment">// Color, 设置图片的颜色</span></span><br><span class="line">    <span class="keyword">this</span>.color,</span><br><span class="line">    <span class="comment">// String, 图标的语义标签</span></span><br><span class="line">    <span class="keyword">this</span>.semanticLabel,</span><br><span class="line">    <span class="comment">// TextDirection, 从左/右开始排列</span></span><br><span class="line">    <span class="keyword">this</span>.textDirection,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


<h3 id="圆形图片"><a href="#圆形图片" class="headerlink" title="圆形图片"></a>圆形图片</h3><p>在<code>Flutter</code>中实现圆角效果也是使用一些<code>Widget</code>来实现的</p>
<h4 id="CircleAvatar"><a href="#CircleAvatar" class="headerlink" title="CircleAvatar"></a>CircleAvatar</h4><p><code>CircleAvatar</code>可以实现圆角头像，也可以添加一个子<code>Widget</code></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircleAvatar</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="language-markdown">Creates a circle that represents a user.</span></span></span><br><span class="line">  <span class="keyword">const</span> CircleAvatar(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="keyword">this</span>.child, <span class="comment">// 子Widget</span></span><br><span class="line">    <span class="keyword">this</span>.backgroundColor, <span class="comment">// 背景颜色</span></span><br><span class="line">    <span class="keyword">this</span>.backgroundImage, <span class="comment">// 背景图像</span></span><br><span class="line">    <span class="keyword">this</span>.foregroundColor, <span class="comment">// 前景颜色</span></span><br><span class="line">    <span class="keyword">this</span>.radius, <span class="comment">// 半径</span></span><br><span class="line">    <span class="keyword">this</span>.minRadius, <span class="comment">// 最小半径</span></span><br><span class="line">    <span class="keyword">this</span>.maxRadius, <span class="comment">// 最大半径</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单使用实现一个圆形头像：</p>
<ul>
<li>这里我们使用的是<code>NetworkImage</code>，因为<code>backgroundImage</code>要求我们传入一个<code>ImageProvider</code>；</li>
<li>这里我还在里面添加了一个文字，但是我在文字外层包裹了一个<code>Container</code>；</li>
<li>这里<code>Container</code>的作用是为了可以控制文字在其中的位置调整</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeContent</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Center(</span><br><span class="line">      child: CircleAvatar(</span><br><span class="line">        radius: <span class="number">100</span>,</span><br><span class="line">        backgroundImage: NetworkImage(<span class="string">&quot;https://tva1.sinaimg.cn/large/006y8mN6gy1g7aa03bmfpj3069069mx8.jpg&quot;</span>),</span><br><span class="line">        child: Container(</span><br><span class="line">          alignment: Alignment(<span class="number">0</span>, <span class="number">.5</span>),</span><br><span class="line">          width: <span class="number">200</span>,</span><br><span class="line">          height: <span class="number">200</span>,</span><br><span class="line">          child: Text(<span class="string">&quot;圣诞节&quot;</span>)</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="ClipOval"><a href="#ClipOval" class="headerlink" title="ClipOval"></a>ClipOval</h4><p><code>ClipOval</code>也可以实现圆角头像，而且通常是在只有头像时使用</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClipOval</span> <span class="keyword">extends</span> <span class="title">SingleChildRenderObjectWidget</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// </span></span><br><span class="line">  <span class="keyword">const</span> ClipOval(&#123;</span><br><span class="line">      Key key, </span><br><span class="line">      <span class="keyword">this</span>.clipper, </span><br><span class="line">      <span class="keyword">this</span>.clipBehavior = Clip.antiAlias, </span><br><span class="line">      Widget child</span><br><span class="line">  &#125;): <span class="keyword">assert</span>(clipBehavior != <span class="keyword">null</span>),</span><br><span class="line">        <span class="keyword">super</span>(key: key, child: child);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单使用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeContent</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Center(</span><br><span class="line">      child: ClipOval(</span><br><span class="line">        child: Image.network(</span><br><span class="line">          <span class="string">&quot;https://tva1.sinaimg.cn/large/006y8mN6gy1g7aa03bmfpj3069069mx8.jpg&quot;</span>,</span><br><span class="line">          width: <span class="number">200</span>,</span><br><span class="line">          height: <span class="number">200</span>,</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="BoxDecoration"><a href="#BoxDecoration" class="headerlink" title="BoxDecoration"></a>BoxDecoration</h4><p>通过<code>Container</code>和<code>Container</code>实现</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CirCleImage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> CirCleImage(&#123;Key key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      child: Container(</span><br><span class="line">        decoration: BoxDecoration(</span><br><span class="line">          <span class="comment">// 设置不同大小可实现不同的圆角, 设置图片大小的一半就是圆形图片</span></span><br><span class="line">          borderRadius: BorderRadius.all(Radius.circular(<span class="number">50</span>))</span><br><span class="line">        ),</span><br><span class="line">        clipBehavior: Clip.antiAlias,</span><br><span class="line">        child: Image.network(</span><br><span class="line">          <span class="string">&#x27;https://titanjun.oss-cn-hangzhou.aliyuncs.com/flutter/flutter_scroll.png&#x27;</span>,</span><br><span class="line">          width: <span class="number">100</span>,</span><br><span class="line">          height: <span class="number">100</span>,</span><br><span class="line">          fit: BoxFit.fitHeight,</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="图片圆角"><a href="#图片圆角" class="headerlink" title="图片圆角"></a>图片圆角</h3><h4 id="ClipRRect"><a href="#ClipRRect" class="headerlink" title="ClipRRect"></a>ClipRRect</h4><p><code>ClipRRect</code>用于实现圆角效果，可以设置圆角的大小。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeContent</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Center(</span><br><span class="line">      child: ClipRRect(</span><br><span class="line">        borderRadius: BorderRadius.circular(<span class="number">10</span>),</span><br><span class="line">        child: Image.network(</span><br><span class="line">          <span class="string">&#x27;https://titanjun.oss-cn-hangzhou.aliyuncs.com/flutter/flutter_scroll.png&#x27;</span>,</span><br><span class="line">          width: <span class="number">200</span>,</span><br><span class="line">          height: <span class="number">200</span>,</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h2><ul>
<li><code>Flutter</code>提供了<code>RaisedButton</code>、<code>FlatButton</code>、<code>OutlineButton</code>和<code>IconButton</code>四种按钮, 除了<code>IconButton</code>之外都是继承自<code>MaterialButton</code></li>
<li>所有<code>Material</code>库中的按钮都有如下相同点：<ul>
<li>按下时都会有“水波动画”。</li>
<li>有一个<code>onPressed</code>属性来设置点击回调，当按钮按下时会执行该回调，如果不提供该回调则按钮会处于禁用状态，禁用状态不响应用户点击</li>
</ul>
</li>
</ul>
<h3 id="MaterialButton"><a href="#MaterialButton" class="headerlink" title="MaterialButton"></a>MaterialButton</h3><p><code>MaterialButton</code>是除<code>IconButton</code>按钮之外的其他按钮的父类, 下面介绍一下各属性的使用</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MaterialButton(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="comment">// 点击事件</span></span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.onPressed,</span><br><span class="line">    <span class="comment">// 高亮状态变化回调，参数：是否高亮，按下时高亮，抬起不高亮</span></span><br><span class="line">    <span class="keyword">this</span>.onHighlightChanged,</span><br><span class="line">    <span class="comment">// 字体的主体</span></span><br><span class="line">    <span class="keyword">this</span>.textTheme,</span><br><span class="line">    <span class="comment">// 按钮文字颜色</span></span><br><span class="line">    <span class="keyword">this</span>.textColor,</span><br><span class="line">    <span class="comment">// 禁用状态下按钮字体颜色</span></span><br><span class="line">    <span class="keyword">this</span>.disabledTextColor,</span><br><span class="line">    <span class="comment">// 按钮背景颜色</span></span><br><span class="line">    <span class="keyword">this</span>.color,</span><br><span class="line">    <span class="comment">// 禁用状态下背景颜色</span></span><br><span class="line">    <span class="keyword">this</span>.disabledColor,</span><br><span class="line">    <span class="comment">// 高亮状态(按下时的背景颜色)</span></span><br><span class="line">    <span class="keyword">this</span>.highlightColor,</span><br><span class="line">    <span class="comment">// 按钮的水波纹的颜色</span></span><br><span class="line">    <span class="keyword">this</span>.splashColor,</span><br><span class="line">    <span class="comment">// 字体亮度</span></span><br><span class="line">    <span class="keyword">this</span>.colorBrightness,</span><br><span class="line">    <span class="comment">// 按钮底部阴影效果的偏移量, double</span></span><br><span class="line">    <span class="keyword">this</span>.elevation,</span><br><span class="line">    <span class="comment">// 高亮状态下, 按钮底部阴影效果的偏移量, double</span></span><br><span class="line">    <span class="keyword">this</span>.highlightElevation,</span><br><span class="line">    <span class="comment">// 禁用状态下, 按钮底部阴影效果的偏移量, double</span></span><br><span class="line">    <span class="keyword">this</span>.disabledElevation,</span><br><span class="line">    <span class="comment">// 内边距</span></span><br><span class="line">    <span class="keyword">this</span>.padding,</span><br><span class="line">    <span class="comment">// 按钮的形状</span></span><br><span class="line">    <span class="keyword">this</span>.shape,</span><br><span class="line">    <span class="keyword">this</span>.clipBehavior = Clip.none,</span><br><span class="line">    <span class="keyword">this</span>.materialTapTargetSize,</span><br><span class="line">    <span class="keyword">this</span>.animationDuration,</span><br><span class="line">    <span class="comment">// 按钮的最小宽度</span></span><br><span class="line">    <span class="keyword">this</span>.minWidth,</span><br><span class="line">    <span class="comment">// 按钮的高度</span></span><br><span class="line">    <span class="keyword">this</span>.height,</span><br><span class="line">    <span class="comment">// 子widget</span></span><br><span class="line">    <span class="keyword">this</span>.child,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="onPressed"><a href="#onPressed" class="headerlink" title="onPressed"></a>onPressed</h4><p>按钮触发时触发的函数，如果不设置此属性<code>Button</code>为不可用状态</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">onPressed: () =&gt; <span class="built_in">print</span>(<span class="string">&#x27;被点击了&#x27;</span>),</span><br></pre></td></tr></table></figure>

<h4 id="textTheme"><a href="#textTheme" class="headerlink" title="textTheme"></a>textTheme</h4><p>按钮字体的主题, 在<code>onPressed</code>不为空的时候才有效果</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">三个取值</span></span></span><br><span class="line">ButtonTextTheme.normal</span><br><span class="line">ButtonTextTheme.accent</span><br><span class="line">ButtonTextTheme.primary</span><br></pre></td></tr></table></figure>

<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/flutter/button_theme.png" alt="image"></p>
<h4 id="colorBrightness"><a href="#colorBrightness" class="headerlink" title="colorBrightness"></a>colorBrightness</h4><p>设置按钮的字体亮度, 取值分别是<code>Brightness.light</code>和<code>Brightness.darks</code></p>
<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/flutter/button_.png" alt="image"></p>
<h4 id="padding"><a href="#padding" class="headerlink" title="padding"></a>padding</h4><p>内边距，其接收值的类型是<code>EdgeInsetsGeometry</code>类型的，<code>EdgeInsetsGeometry</code>是一个抽象类, 只能使用其子类<code>EdgeInsets</code>来实现</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">padding: EdgeInsets.all(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<h4 id="shape"><a href="#shape" class="headerlink" title="shape"></a>shape</h4><ul>
<li>设置按钮的形状，其接收值是<code>ShapeBorder</code>类型，<code>ShapeBorder</code>也是一个抽象类</li>
<li><code>ShapeBorder</code>的子类中比较常用的几个如下所示<ul>
<li><code>BeveledRectangleBorder</code> 带斜角的长方形边框</li>
<li><code>CircleBorder</code> 圆形边框</li>
<li><code>RoundedRectangleBorder</code> 圆角矩形</li>
<li><code>StadiumBorder</code> 两端是半圆的边框</li>
</ul>
</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 带斜角的长方形边框</span></span><br><span class="line"><span class="keyword">const</span> BeveledRectangleBorder(&#123;</span><br><span class="line">    <span class="comment">// 边框的样式 </span></span><br><span class="line">    <span class="keyword">this</span>.side = BorderSide.none,</span><br><span class="line">    <span class="comment">// 圆角大小</span></span><br><span class="line">    <span class="keyword">this</span>.borderRadius = BorderRadius.zero,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 圆形边框</span></span><br><span class="line"><span class="keyword">const</span> CircleBorder(&#123; </span><br><span class="line">    <span class="keyword">this</span>.side = BorderSide.none </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 圆角矩形</span></span><br><span class="line"><span class="keyword">const</span> RoundedRectangleBorder(&#123;</span><br><span class="line">    <span class="keyword">this</span>.side = BorderSide.none,</span><br><span class="line">    <span class="keyword">this</span>.borderRadius = BorderRadius.zero,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两端是半圆的边框</span></span><br><span class="line"><span class="keyword">const</span> StadiumBorder(&#123; </span><br><span class="line">    <span class="keyword">this</span>.side = BorderSide.none </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 边框样式的设置</span></span><br><span class="line"><span class="keyword">const</span> BorderSide(&#123;</span><br><span class="line">    <span class="comment">// 边框颜色, 默认黑色 </span></span><br><span class="line">    <span class="keyword">this</span>.color = <span class="keyword">const</span> Color(<span class="number">0xFF000000</span>),</span><br><span class="line">    <span class="comment">// 边框宽度, 默认1.0</span></span><br><span class="line">    <span class="keyword">this</span>.width = <span class="number">1.0</span>,</span><br><span class="line">    <span class="comment">// 边框样式, solid: 实线边框(默认值), none: 不显示边框</span></span><br><span class="line">    <span class="keyword">this</span>.style = BorderStyle.solid,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>下面就来看一下<code>shape</code>的配置和使用, 设置默认状态(即所有的边框样式和圆角都是默认值)的效果如下</p>
<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/flutter/button_shape1.png" alt="image"></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">children: &lt;Widget&gt;[</span><br><span class="line">  <span class="comment">// BeveledRectangleBorder</span></span><br><span class="line">  RaisedButton(</span><br><span class="line">    child: Text(<span class="string">&#x27;BeveledRectangleBorder&#x27;</span>),</span><br><span class="line">    onPressed: () =&gt; <span class="built_in">print</span>(<span class="string">&#x27;RaisedButton&#x27;</span>),</span><br><span class="line">    shape: BeveledRectangleBorder(</span><br><span class="line">      borderRadius: BorderRadius.all(Radius.circular(<span class="number">10</span>)),</span><br><span class="line">      side: BorderSide(</span><br><span class="line">        color: Colors.red,</span><br><span class="line">        width: <span class="number">2</span>,</span><br><span class="line">        style: BorderStyle.solid</span><br><span class="line">      )</span><br><span class="line">    ),</span><br><span class="line">  ),</span><br><span class="line">  RaisedButton(</span><br><span class="line">    child: Icon(Icons.supervisor_account, color: Colors.green, size: <span class="number">40</span>),</span><br><span class="line">    onPressed: () =&gt; <span class="built_in">print</span>(<span class="string">&#x27;RaisedButton&#x27;</span>),</span><br><span class="line">    padding: EdgeInsets.all(<span class="number">10</span>),</span><br><span class="line">    shape: CircleBorder(</span><br><span class="line">      side: BorderSide(</span><br><span class="line">        color: Colors.red,</span><br><span class="line">        width: <span class="number">2</span>,</span><br><span class="line">        style: BorderStyle.solid</span><br><span class="line">      )</span><br><span class="line">    ),</span><br><span class="line">  ),</span><br><span class="line">  RaisedButton(</span><br><span class="line">    child: Text(<span class="string">&#x27;RoundedRectangleBorder&#x27;</span>),</span><br><span class="line">    onPressed: () =&gt; <span class="built_in">print</span>(<span class="string">&#x27;RaisedButton&#x27;</span>),</span><br><span class="line">    shape: RoundedRectangleBorder(</span><br><span class="line">      borderRadius: BorderRadius.all(Radius.circular(<span class="number">10</span>)),</span><br><span class="line">      side: BorderSide(</span><br><span class="line">        color: Colors.red,</span><br><span class="line">        width: <span class="number">2</span>,</span><br><span class="line">        style: BorderStyle.solid</span><br><span class="line">      )</span><br><span class="line">    ),</span><br><span class="line">  ),</span><br><span class="line">  RaisedButton(</span><br><span class="line">    child: Text(<span class="string">&#x27;StadiumBorder&#x27;</span>),</span><br><span class="line">    onPressed: () =&gt; <span class="built_in">print</span>(<span class="string">&#x27;RaisedButton&#x27;</span>),</span><br><span class="line">    shape: StadiumBorder(</span><br><span class="line">      side: BorderSide(</span><br><span class="line">        color: Colors.red,</span><br><span class="line">        width: <span class="number">2</span>,</span><br><span class="line">        style: BorderStyle.solid</span><br><span class="line">      )</span><br><span class="line">    ),</span><br><span class="line">  ),</span><br><span class="line">],</span><br></pre></td></tr></table></figure>

<p>上述代码是分别设置圆角和边框后的代码, 效果如下</p>
<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/flutter/button_shape2.png" alt="image"></p>
<h3 id="RaisedButton"><a href="#RaisedButton" class="headerlink" title="RaisedButton"></a>RaisedButton</h3><ul>
<li><code>RaisedButton</code>即”漂浮”按钮，它默认带有阴影和灰色背景。按下后阴影会变大</li>
<li><code>RaisedButton</code>继承自<code>MaterialButton</code>, 相关属性和父类一样</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">RaisedButton(</span><br><span class="line">    child: Text(<span class="string">&#x27;RaisedButton&#x27;</span>),</span><br><span class="line">    onPressed: () =&gt; <span class="built_in">print</span>(<span class="string">&#x27;RaisedButton&#x27;</span>),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="FlatButton"><a href="#FlatButton" class="headerlink" title="FlatButton"></a>FlatButton</h3><ul>
<li><code>FlatButton</code>即扁平按钮，默认背景透明并不带阴影。按下后，会有背景色</li>
<li><code>RaisedButton</code>继承自<code>MaterialButton</code>, 相关属性和父类一样</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">FlatButton(</span><br><span class="line">    child: Text(<span class="string">&#x27;FlatButton&#x27;</span>),</span><br><span class="line">    onPressed: () =&gt; <span class="built_in">print</span>(<span class="string">&#x27;FlatButton&#x27;</span>),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>


<h3 id="OutlineButton"><a href="#OutlineButton" class="headerlink" title="OutlineButton"></a>OutlineButton</h3><ul>
<li><code>OutlineButton</code>默认有一个边框，不带阴影且背景透明。按下后，边框颜色会变亮、同时出现背景和阴影(较弱)</li>
<li><code>RaisedButton</code>继承自<code>MaterialButton</code>, 相关属性和父类一样</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">OutlineButton(</span><br><span class="line">    child: Text(<span class="string">&#x27;OutlineButton&#x27;</span>),</span><br><span class="line">    onPressed: () =&gt; <span class="built_in">print</span>(<span class="string">&#x27;OutlineButton&#x27;</span>),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="IconButton"><a href="#IconButton" class="headerlink" title="IconButton"></a>IconButton</h3><p><code>IconButton</code>是一个可点击的Icon，不包括文字，默认没有背景，点击后会出现背景</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 继承自StatelessWidget</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IconButton</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> IconButton(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="comment">// 按钮的大小</span></span><br><span class="line">    <span class="keyword">this</span>.iconSize = <span class="number">24.0</span>,</span><br><span class="line">    <span class="comment">// 内边距</span></span><br><span class="line">    <span class="keyword">this</span>.padding = <span class="keyword">const</span> EdgeInsets.all(<span class="number">8.0</span>),</span><br><span class="line">    <span class="comment">// 按钮中图片的对齐方式</span></span><br><span class="line">    <span class="keyword">this</span>.alignment = Alignment.center,</span><br><span class="line">    <span class="comment">// 图片按钮的图片Icon</span></span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.icon,</span><br><span class="line">    <span class="comment">// 背景色</span></span><br><span class="line">    <span class="keyword">this</span>.color,</span><br><span class="line">    <span class="comment">// 高亮状态下的背景色</span></span><br><span class="line">    <span class="keyword">this</span>.highlightColor,</span><br><span class="line">    <span class="comment">// 按钮按下时, 水波纹的颜色</span></span><br><span class="line">    <span class="keyword">this</span>.splashColor,</span><br><span class="line">    <span class="comment">// 禁用状态下, 按钮的背景色</span></span><br><span class="line">    <span class="keyword">this</span>.disabledColor,</span><br><span class="line">    <span class="comment">// 点击事件</span></span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.onPressed,</span><br><span class="line">    <span class="comment">// String, 描述按钮按下时的描述文本, 需要长按才能出现(黑框显示文本)</span></span><br><span class="line">    <span class="keyword">this</span>.tooltip</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用示例</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">IconButton(</span><br><span class="line">    icon: Icon(Icons.mail_outline, color:Colors.orange, size: <span class="number">40</span>),</span><br><span class="line">    color: Colors.yellow,</span><br><span class="line">    iconSize: <span class="number">100</span>,</span><br><span class="line">    alignment: Alignment.topLeft,</span><br><span class="line">    onPressed: () =&gt; <span class="built_in">print</span>(<span class="string">&#x27;IconButton&#x27;</span>),</span><br><span class="line">    tooltip: <span class="string">&#x27;titanjun.top&#x27;</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="图文按钮"><a href="#图文按钮" class="headerlink" title="图文按钮"></a>图文按钮</h3><p>每一个继承自<code>MaterialButton</code>的按钮<code>Widget</code>都有一个工厂构造函数, 返回一个图片在左, 文字在右的按钮</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">factory</span> RaisedButton.icon(&#123;</span><br><span class="line">    <span class="comment">// 这里包含MaterialButton的所有属性</span></span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">// 图片Widget</span></span><br><span class="line">    <span class="meta">@required</span> Widget icon,</span><br><span class="line">    <span class="comment">// 文字Widget</span></span><br><span class="line">    <span class="meta">@required</span> Widget label,</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">factory</span> FlatButton.icon(&#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="meta">@required</span> Widget icon,</span><br><span class="line">    <span class="meta">@required</span> Widget label,</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">factory</span> OutlineButton.icon(&#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="meta">@required</span> Widget icon,</span><br><span class="line">    <span class="meta">@required</span> Widget label,</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line">RaisedButton.icon(</span><br><span class="line">  label: Text(<span class="string">&#x27;data&#x27;</span>),</span><br><span class="line">  icon: Icon(Icons.mail),</span><br><span class="line">  onPressed: () =&gt; &#123;&#125;,</span><br><span class="line">),</span><br></pre></td></tr></table></figure>


<h2 id="单选开关和复选框"><a href="#单选开关和复选框" class="headerlink" title="单选开关和复选框"></a>单选开关和复选框</h2><ul>
<li><code>Material widgets</code>库中提供了<code>Material</code>风格的单选开关<code>Switch</code>和复选框<code>Checkbox</code>，它们都是继承自<code>StatelessWidget</code></li>
<li>它们本身不会保存当前选择状态，所以一般都是在父<code>widget</code>中管理选中状态</li>
<li>当用户点击<code>Switch</code>或<code>Checkbox</code>时，它们会触发<code>onChanged</code>回调，我们可以在此回调中处理选中状态改变逻辑</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Switch属性</span></span><br><span class="line"><span class="keyword">const</span> Switch(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="comment">// Switch的状态值, true开启, false关闭</span></span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.value,</span><br><span class="line">    <span class="comment">// Switch改变状态所执行的操作</span></span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.onChanged,</span><br><span class="line">    <span class="comment">// 开启状态下选项条的颜色</span></span><br><span class="line">    <span class="keyword">this</span>.activeColor,</span><br><span class="line">    <span class="comment">// 开启状态下圆球的颜色</span></span><br><span class="line">    <span class="keyword">this</span>.activeTrackColor,</span><br><span class="line">    <span class="comment">// 关闭状态下选项条的颜色</span></span><br><span class="line">    <span class="keyword">this</span>.inactiveThumbColor,</span><br><span class="line">    <span class="comment">// 关闭状态下圆球的颜色</span></span><br><span class="line">    <span class="keyword">this</span>.inactiveTrackColor,</span><br><span class="line">    <span class="comment">// 设置开启状态下圆球的图片</span></span><br><span class="line">    <span class="keyword">this</span>.activeThumbImage,</span><br><span class="line">    <span class="comment">// 设置关闭状态下圆球的图片</span></span><br><span class="line">    <span class="keyword">this</span>.inactiveThumbImage,</span><br><span class="line">    <span class="comment">// 设置Switch的尺寸样式, padded: 建议大小48, shrinkWrap: 可能的最小尺寸</span></span><br><span class="line">    <span class="keyword">this</span>.materialTapTargetSize,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Checkbox属性</span></span><br><span class="line"><span class="keyword">const</span> Checkbox(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="comment">// Switch的状态值, true选中, false未选中</span></span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.value,</span><br><span class="line">    <span class="comment">// 如果为 true，那么复选框的值可以是 true，false 或 null</span></span><br><span class="line">    <span class="comment">// 如果为false(默认值), 那么只有true和false两种状态</span></span><br><span class="line">    <span class="keyword">this</span>.tristate = <span class="keyword">false</span>,</span><br><span class="line">    <span class="comment">// 改变状态时执行的函数</span></span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.onChanged,</span><br><span class="line">    <span class="comment">// 选中时的颜色</span></span><br><span class="line">    <span class="keyword">this</span>.activeColor,</span><br><span class="line">    <span class="comment">// 设置Checkbox的尺寸样式, padded: 建议大小48, shrinkWrap: 可能的最小尺寸</span></span><br><span class="line">    <span class="keyword">this</span>.materialTapTargetSize,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>使用代码</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">children: &lt;Widget&gt;[</span><br><span class="line">  Switch(</span><br><span class="line">    value: <span class="keyword">false</span>,</span><br><span class="line">    onChanged: (value) &#123;&#125;,</span><br><span class="line">    activeColor: Colors.red,</span><br><span class="line">    activeTrackColor: Colors.yellow,</span><br><span class="line">    inactiveThumbColor: Colors.blue,</span><br><span class="line">    inactiveTrackColor: Colors.cyan,</span><br><span class="line">    materialTapTargetSize: MaterialTapTargetSize.shrinkWrap</span><br><span class="line">  ),</span><br><span class="line">  Checkbox(</span><br><span class="line">    value: <span class="keyword">true</span>,</span><br><span class="line">    onChanged: (value) &#123; &#125;,</span><br><span class="line">    activeColor: Colors.orange,</span><br><span class="line">    tristate: <span class="keyword">true</span>,</span><br><span class="line">  )</span><br><span class="line">],</span><br></pre></td></tr></table></figure>

<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/flutter/widget_switch.png" alt="image"></p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a href="https://book.flutterchina.club/chapter3/text.html">Flutter中文网</a></li>
<li><a href="https://flutterchina.club/widgets/">Widgets 目录</a></li>
</ul>
<hr>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
        <tag>Widget</tag>
        <tag>Dart</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter开发之Dart语法基础</title>
    <url>/post/aa54e55a.html</url>
    <content><![CDATA[<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/flutter/dart-logo.png?x-oss-process=style/titanjun" alt="dart-logo"></p>
<span id="more"></span>

<ul>
<li><code>Dart</code>是谷歌在 2011 年推出的编程语言，是一种结构化<code>Web</code>编程语言，允许用户通过<code>Chromium</code>中所整合的虚拟机（<code>Dart VM</code>）直接运行<code>Dart</code> 语言编写的程序，免去了单独编译的步骤</li>
<li>以后这些程序将从<code>Dart VM</code>更快的性能与较低的启动延迟中受益</li>
<li><code>Dart</code>从设计之初就为配合现代<code>web</code>整体运作而考虑，开发团队也同时在持续改进<code>Dart</code>向<code>JavaScript</code>转换的快速编译器</li>
<li><code>Dart VM</code>以及现代<code>JavaScript</code>引擎（V8 等）都是<code>Dart</code>语言的首选目标平台</li>
<li><code>Dart</code>语言和<code>Swift</code>语言有很多的相似之处</li>
</ul>
<h2 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h2><p>在学习<code>Dart</code>语言之前, 先了解一些<code>Dart</code>相关的一些概念:</p>
<ul>
<li>在<code>O-Objective</code>中有一切皆对象的说法, 这句话在<code>Dart</code>中同样适用<ul>
<li>所有能够使用变量引用的都是对象， 每个对象都是一个类的实例</li>
<li>在<code>Dart</code>中 甚至连 数字、方法和<code>null</code>都是对象</li>
<li>所有的对象都继承于<code>Object</code>类</li>
</ul>
</li>
<li><code>Dart</code>动态类型语言, 尽量给变量定义一个类型，会更安全，没有显示定义类型的变量在<code>debug</code>模式下会类型会是<code>dynamic</code>(动态的)</li>
<li><code>Dart</code>会在运行之前解析你的所有代码，指定数据类型和编译时的常量，可以提高运行速度</li>
<li><code>Dart</code>中的类和接口是统一的，类即接口，你可以继承一个类，也可以实现一个类（接口），自然也包含了良好的面向对象和并发编程的支持</li>
<li><code>Dart</code>函数<ul>
<li>支持顶级函数 (例如<code>main()</code>)</li>
<li>支持在类中定义函数, 如静态函数和实例函数 </li>
<li>还可以在方法中定义方法（嵌套方法或者局部方法）</li>
</ul>
</li>
<li>类似的，<code>Dart</code>支持顶级变量，以及依赖于类或对象（静态变量和实例变量）变量。实例变量有时被称为域或属性</li>
<li><code>Dart</code>不具备关键字<code>public</code>，<code>protected</code>和<code>private</code>。如果一个标识符以下划线<code>（_）</code>开始，那么它和它的库都是私有的</li>
<li>标识符可以字母或（_）开始，或者是字符加数字的组合开头</li>
</ul>
<blockquote>
<p>以上只是大概说明了一些<code>Dart</code>中的重要概念, 具体的语法使用, 请看下文</p>
</blockquote>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p><code>Dart</code>的注释分为3种：单行注释、多行注释、文档注释</p>
<ul>
<li>单行注释以<code>//</code>开头</li>
<li>多行注释以<code>/*</code>开头，以<code>*/</code>结尾</li>
<li>文档注释以<code>///</code>或者<code>/**</code>开头</li>
</ul>
<h3 id="分号"><a href="#分号" class="headerlink" title="分号;"></a>分号;</h3><ul>
<li>分号用于分隔<code>Dart</code>语句</li>
<li>通常我们在每条可执行的语句结尾添加分号</li>
<li>使用分号的另一用处是在一行中编写多条语句</li>
<li>在<code>Dart</code>中，用分号来结束语句是必须的, 不加分则会报错</li>
</ul>
<h3 id="其他语法"><a href="#其他语法" class="headerlink" title="其他语法"></a>其他语法</h3><ul>
<li>按照<code>Dart</code>的编程规范，使用2个空格来缩进</li>
<li>输出语句使用<code>print(Object)</code></li>
</ul>
<h2 id="变量和常量"><a href="#变量和常量" class="headerlink" title="变量和常量"></a>变量和常量</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>使用<code>var</code>、<code>Object</code>或<code>dynamic</code>关键字声明变量</p>
<h4 id="弱类型变量"><a href="#弱类型变量" class="headerlink" title="弱类型变量"></a>弱类型变量</h4><p><code>var</code>方式声明变量</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 声明变量, 不赋初始值</span></span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line">a = <span class="string">&#x27;titanjun&#x27;</span>;</span><br><span class="line">a = <span class="number">123</span>;</span><br><span class="line">a = <span class="keyword">false</span>;</span><br><span class="line"><span class="built_in">print</span>(a);</span><br><span class="line"><span class="comment">// 在不初始化的前提下, 变量可以赋值任何类型的值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 声明变量, 赋初始值</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&#x27;titanjun.top&#x27;</span>;</span><br><span class="line"><span class="comment">// 变量在有初始化值得情况下, 只能赋值相同类型的值, 否则报错</span></span><br><span class="line"><span class="comment">// b = 123;</span></span><br></pre></td></tr></table></figure>

<p><code>dynamic</code>声明</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dynamic</span> c = <span class="string">&#x27;titannjun&#x27;</span>;</span><br><span class="line">c = <span class="number">123</span>;</span><br><span class="line">c = <span class="keyword">false</span>;</span><br><span class="line"><span class="built_in">print</span>(c);</span><br><span class="line"><span class="comment">// 调用未声明的方法, 不会报错, 运行时报错</span></span><br><span class="line"><span class="comment">// c.test();</span></span><br></pre></td></tr></table></figure>

<p><code>Object</code>方式声明变量</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span> d = <span class="string">&#x27;titanjun&#x27;</span>;</span><br><span class="line">d = <span class="number">123</span>;</span><br><span class="line">d = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">// 调用未声明的方法, 会直接报错</span></span><br><span class="line"><span class="comment">// d.test();</span></span><br></pre></td></tr></table></figure>

<h4 id="强类型变量"><a href="#强类型变量" class="headerlink" title="强类型变量"></a>强类型变量</h4><p>明确指定变量的类型, 声明后，类型被锁定</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span> str = <span class="string">&#x27;titanjun&#x27;</span>;</span><br><span class="line"><span class="built_in">bool</span> isStr = <span class="keyword">true</span>;</span><br><span class="line"><span class="built_in">num</span> number = <span class="number">1234</span>;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>num</code></td>
<td>数字</td>
</tr>
<tr>
<td><code>int</code></td>
<td>整型</td>
</tr>
<tr>
<td><code>double</code></td>
<td>浮点</td>
</tr>
<tr>
<td><code>bool</code></td>
<td>布尔</td>
</tr>
<tr>
<td><code>String</code></td>
<td>字符串</td>
</tr>
<tr>
<td><code>StringBuffer</code></td>
<td>字符串 buffer</td>
</tr>
<tr>
<td><code>DateTime</code></td>
<td>时间日期</td>
</tr>
<tr>
<td><code>Duration</code></td>
<td>时间区间</td>
</tr>
<tr>
<td><code>List</code></td>
<td>列表</td>
</tr>
<tr>
<td><code>Sets</code></td>
<td>无重复队列</td>
</tr>
<tr>
<td><code>Maps</code></td>
<td>kv 容器</td>
</tr>
<tr>
<td><code>enum</code></td>
<td>枚举</td>
</tr>
</tbody></table>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span> a = <span class="string">&#x27;doucafecat&#x27;</span>;</span><br><span class="line"><span class="built_in">int</span> i = <span class="number">123</span>;</span><br><span class="line"><span class="built_in">double</span> d = <span class="number">0.12</span>;</span><br><span class="line"><span class="built_in">bool</span> b = <span class="keyword">true</span>;</span><br><span class="line"><span class="built_in">DateTime</span> dt = <span class="keyword">new</span> <span class="built_in">DateTime</span>.now();</span><br><span class="line"><span class="built_in">List</span> l = [ a, i, d, b, dt];</span><br></pre></td></tr></table></figure>

<h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><p>一切都是<code>Object</code>, 未初始化的变量的初始值为<code>null</code>, 即使是数字也是如此，因为在<code>Dart</code>中数字也是一个对象</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bool</span> isNum;</span><br><span class="line"><span class="built_in">String</span> str2;</span><br><span class="line"><span class="built_in">StringBuffer</span> str3;</span><br><span class="line"><span class="built_in">num</span> num1;</span><br><span class="line"><span class="built_in">print</span>([isNum, str2, str3, num1]);</span><br><span class="line"><span class="comment">// [null, null, null, null]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>可选类型</p>
</blockquote>
<p>在声明变量的时候，你可以选择加上具体的类型：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span> name2 = <span class="string">&#x27;name2&#x27;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>这种方式可以更加清晰的表达你想要定义的变量的类型, 编译器也可以根据该类型为你提供代码补全、提前发现 bug 等功能</li>
<li>注意: 对于局部变量，这里遵守 <a href="http://dart.goodev.org/guides/language/effective-dart/design#type-annotations">代码风格推荐</a> 部分的建议，使用<code>var</code>而不是具体的类型来定义局部变量</li>
</ul>
<h4 id="强弱类型"><a href="#强弱类型" class="headerlink" title="强弱类型"></a>强弱类型</h4><ul>
<li>在写 API 接口的时候，请用<code>强类型</code>，一旦不符合约定，接收数据时能方便排查故障</li>
<li>写个小工具时，可以用<code>弱类型</code>，这样代码写起来很快，类型自动适应</li>
</ul>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><ul>
<li>常量使用<code>final</code>或者<code>const</code></li>
<li>一个<code>final</code>变量只能赋值一次</li>
<li>一个<code>const</code>变量是编译时常量</li>
<li>实例变量可以为<code>final</code>但是不能是<code>const</code></li>
<li><code>final</code>不能和<code>var</code>同用</li>
<li><code>const</code>不能和<code>var</code>同用</li>
</ul>
<h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><p><code>final</code>修饰的变量(即常量2)</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类型声明可以省略</span></span><br><span class="line"><span class="keyword">final</span> age = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="built_in">int</span> age1 = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// final修饰的变量不能重新赋值, 会报错</span></span><br><span class="line">age = <span class="number">20</span>;</span><br><span class="line">age1 = <span class="number">30</span>;</span><br></pre></td></tr></table></figure>

<h4 id="const"><a href="#const" class="headerlink" title="const"></a>const</h4><ul>
<li><code>const</code>变量为编译时常量</li>
<li>如果在类中使用<code>const</code>定义常量，请定义为<code>static const</code></li>
<li>使用<code>const</code>定义的常量, 可以直接给定初始值，也可以使用其他<code>const</code>变量的值来初始化其值</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类型声明可以省略</span></span><br><span class="line"><span class="keyword">const</span> m1 = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">double</span> m2 = <span class="number">23</span>;</span><br><span class="line"><span class="keyword">const</span> m3 = m1 + m2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// final修饰的变量不能重新赋值, 会报错</span></span><br><span class="line">m1 = <span class="number">10</span>;</span><br><span class="line">m2 = <span class="number">1.02</span>;</span><br></pre></td></tr></table></figure>

<h4 id="final和const的区别"><a href="#final和const的区别" class="headerlink" title="final和const的区别"></a>final和const的区别</h4><ol>
<li>需要确定值</li>
</ol>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// final是运行时的时候判断, const是赋值时进行判断</span></span><br><span class="line"><span class="keyword">final</span> time1 = <span class="built_in">DateTime</span>.now();</span><br><span class="line"><span class="comment">// const修饰的常量会报错</span></span><br><span class="line"><span class="keyword">const</span> time2 = <span class="built_in">DateTime</span>.now();</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>不可变性可传递</li>
</ol>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="built_in">List</span> ls = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>];</span><br><span class="line"><span class="comment">// final修饰的数组可以改变元素值</span></span><br><span class="line">ls[<span class="number">1</span>] = <span class="number">44</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">List</span> ls1 = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>];</span><br><span class="line"><span class="comment">// const修饰的数组不可以改变元素值, 运行时报错</span></span><br><span class="line">ls1[<span class="number">1</span>] = <span class="number">44</span>;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>内存中重复创建</li>
</ol>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> arr1 = [<span class="number">11</span> , <span class="number">22</span>];</span><br><span class="line"><span class="keyword">final</span> arr2 = [<span class="number">11</span> , <span class="number">22</span>];</span><br><span class="line"><span class="comment">// 判断是否是相同内存</span></span><br><span class="line"><span class="built_in">print</span>(identical(arr1, arr2));  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const修饰的常量, 在内存中不会重复创建相同的常量</span></span><br><span class="line"><span class="keyword">const</span> ls3 = [<span class="number">11</span> , <span class="number">22</span>];</span><br><span class="line"><span class="keyword">const</span> ls4 = [<span class="number">11</span> , <span class="number">22</span>];</span><br><span class="line"><span class="built_in">print</span>(identical(ls3, ls4));  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><h3 id="算术操作符"><a href="#算术操作符" class="headerlink" title="算术操作符"></a>算术操作符</h3><p><code>Dart</code>支持常用的算术操作符</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>+</code></td>
<td>加号</td>
</tr>
<tr>
<td><code>–</code></td>
<td>减号</td>
</tr>
<tr>
<td><code>-expr</code></td>
<td>负号</td>
</tr>
<tr>
<td><code>*</code></td>
<td>乘号</td>
</tr>
<tr>
<td><code>/</code></td>
<td>除号(值为<code>double</code>类型)</td>
</tr>
<tr>
<td><code>~/</code></td>
<td>除号，但是返回值为整数</td>
</tr>
<tr>
<td><code>%</code></td>
<td>取模</td>
</tr>
</tbody></table>
<p>示例:</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assert</span>(<span class="number">2</span> + <span class="number">3</span> == <span class="number">5</span>);</span><br><span class="line"><span class="keyword">assert</span>(<span class="number">2</span> - <span class="number">3</span> == <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">assert</span>(<span class="number">2</span> * <span class="number">3</span> == <span class="number">6</span>);</span><br><span class="line"><span class="keyword">assert</span>(<span class="number">5</span> / <span class="number">2</span> == <span class="number">2.5</span>);   <span class="comment">// 结果是double类型</span></span><br><span class="line"><span class="keyword">assert</span>(<span class="number">5</span> ~/ <span class="number">2</span> == <span class="number">2</span>);    <span class="comment">// 结果是integer类型 </span></span><br><span class="line"><span class="keyword">assert</span>(<span class="number">5</span> % <span class="number">2</span> == <span class="number">1</span>);     <span class="comment">// 余数</span></span><br></pre></td></tr></table></figure>

<h3 id="自加自减"><a href="#自加自减" class="headerlink" title="自加自减"></a>自加自减</h3><p><code>Dart</code>还支持自加自减操作</p>
<ul>
<li><code>++var</code>: 先自加在使用</li>
<li><code>var++</code>: 先使用在自加</li>
<li><code>--var</code>: 先自减在使用</li>
<li><code>var--</code>: 先使用在自减</li>
</ul>
<p>示例</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">b = a++;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;a = <span class="subst">$a</span>, b = <span class="subst">$b</span>&#x27;</span>); <span class="comment">//a = 1, b = 0</span></span><br><span class="line">b = ++a;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;a = <span class="subst">$a</span>, b = <span class="subst">$b</span>&#x27;</span>); <span class="comment">//a = 2, b = 2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">b = a--;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;a = <span class="subst">$a</span>, b = <span class="subst">$b</span>&#x27;</span>); <span class="comment">//a = 1, b = 2</span></span><br><span class="line">b = --a;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;a = <span class="subst">$a</span>, b = <span class="subst">$b</span>&#x27;</span>); <span class="comment">//a = 0, b = 0</span></span><br></pre></td></tr></table></figure>

<h3 id="关系操作符"><a href="#关系操作符" class="headerlink" title="关系操作符"></a>关系操作符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>==</code></td>
<td>等于</td>
</tr>
<tr>
<td><code>!=</code></td>
<td>不等于</td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>大于</td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>小于</td>
</tr>
<tr>
<td><code>&gt;=</code></td>
<td>大于等于</td>
</tr>
<tr>
<td><code>&lt;=</code></td>
<td>小于等于</td>
</tr>
</tbody></table>
<ul>
<li>要测试两个对象代表的是否为同样的内容，使用 <code>==</code> 操作符</li>
<li>在某些情况下，你需要知道两个对象是否是同一个对象， 使用<code>identical()</code>方法</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">external</span> <span class="built_in">bool</span> identical(<span class="built_in">Object</span> a, <span class="built_in">Object</span> b);</span><br></pre></td></tr></table></figure>

<h3 id="类型判定操作符"><a href="#类型判定操作符" class="headerlink" title="类型判定操作符"></a>类型判定操作符</h3><p>类型判定操作符是在运行时判定对象类型的操作符</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>as</code></td>
<td>类型转换</td>
</tr>
<tr>
<td><code>is</code></td>
<td>如果对象是指定的类型返回 True</td>
</tr>
<tr>
<td><code>is!</code></td>
<td>如果对象是指定的类型返回 False</td>
</tr>
</tbody></table>
<ul>
<li>只有当<code>obj</code>实现了 <code>T</code> 的接口， <code>obj is T</code> 才是<code>true</code>。例如<code>obj is Object</code>总是<code>true</code></li>
<li>使用<code>as</code>操作符把对象转换为特定的类型</li>
<li>可以把<code>as</code>它当做用<code>is</code>判定类型然后调用 所判定对象的函数的缩写形式</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (emp <span class="keyword">is</span> Person) &#123; <span class="comment">// Type check</span></span><br><span class="line">  emp.firstName = <span class="string">&#x27;Bob&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面代码可简化为</span></span><br><span class="line">(emp <span class="keyword">as</span> Person).firstName = <span class="string">&#x27;Bob&#x27;</span>;</span><br></pre></td></tr></table></figure>

<div class="note warning"><p>注意</p></div>

<p>如果<code>emp</code>是<code>null</code>或者不是<code>Person</code>类型，则第一个示例使用<code>is</code>则不会执行条件里面的代码，而第二个情况使用<code>as</code>则会抛出一个异常; 所以在不缺定<code>emp</code>是否为空的情况下, 安全起见, 建议使用第一种方式</p>
<h3 id="赋值操作符"><a href="#赋值操作符" class="headerlink" title="赋值操作符"></a>赋值操作符</h3><table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>=</code></td>
<td><code>–=</code></td>
<td><code>/=</code></td>
<td><code>%=</code></td>
<td><code>&gt;&gt;=</code></td>
<td><code>^=</code></td>
</tr>
<tr>
<td><code>+=</code></td>
<td><code>*=</code></td>
<td><code>~/=</code></td>
<td><code>&lt;&lt;=</code></td>
<td><code>&amp;=</code></td>
<td></td>
</tr>
</tbody></table>
<p>示例:</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 给 a 变量赋值</span></span><br><span class="line">a = value;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 复合赋值操作符</span></span><br><span class="line">a += b;  <span class="comment">// 等价于a = a + b;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 b 是 null，则赋值给 b；</span></span><br><span class="line"><span class="comment">// 如果不是 null，则 b 的值保持不变</span></span><br><span class="line">b ??= value; </span><br><span class="line">     </span><br><span class="line"><span class="comment">// 如下所示:     </span></span><br><span class="line">  <span class="keyword">var</span> s;</span><br><span class="line">  <span class="built_in">print</span>(s);  <span class="comment">// null</span></span><br><span class="line">  <span class="built_in">print</span>(s ?? <span class="string">&#x27;str&#x27;</span>);  <span class="comment">// str</span></span><br><span class="line">  s ??= <span class="string">&#x27;string&#x27;</span>;</span><br><span class="line">  <span class="built_in">print</span>(s);  <span class="comment">// string</span></span><br></pre></td></tr></table></figure>

<h3 id="逻辑操作符"><a href="#逻辑操作符" class="headerlink" title="逻辑操作符"></a>逻辑操作符</h3><p>可以使用逻辑操作符来 操作布尔值：</p>
<ul>
<li><code>!expr</code>: 对表达式结果取反（true 变为 false ，false 变为 true）</li>
<li><code>||</code>: 逻辑 OR</li>
<li><code>&amp;&amp;</code>: 逻辑AND</li>
</ul>
<h3 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">condition ? expr1 : expr2</span><br><span class="line">// 如果 condition 是 true，执行 expr1 (并返回执行的结果)； 否则执行 expr2 并返回其结果</span><br><span class="line"></span><br><span class="line">expr1 ?? expr2</span><br><span class="line">// 如果 expr1 是 non-null，返回其值； 否则执行 expr2 并返回其结果</span><br></pre></td></tr></table></figure>

<p>示例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String toString() =&gt; msg ?? super.toString();</span><br><span class="line"></span><br><span class="line">// 上面的代码等价于</span><br><span class="line">String toString() =&gt; msg == null ? super.toString() : msg;</span><br><span class="line"></span><br><span class="line">// 等价于</span><br><span class="line">String toString() &#123;</span><br><span class="line">  if (msg == null) &#123;</span><br><span class="line">    return super.toString();</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return msg;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="级联操作符"><a href="#级联操作符" class="headerlink" title="级联操作符"></a>级联操作符</h3><p>级联操作符 (<code>..</code>) 可以在同一个对象上 连续调用多个函数以及访问成员变量。 使用级联操作符可以避免创建 临时变量， 并且写出来的代码看起来 更加流畅</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">querySelector</span>(<span class="string">&#x27;#button&#x27;</span>) <span class="comment">// Get an object.</span></span><br><span class="line">  ..text = <span class="string">&#x27;Confirm&#x27;</span>   <span class="comment">// Use its members.</span></span><br><span class="line">  ..classes.add(<span class="string">&#x27;important&#x27;</span>)</span><br><span class="line">  ..onClick.listen((e) =&gt; <span class="built_in">window</span>.alert(<span class="string">&#x27;Confirmed!&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p>第一个方法<code>querySelector()</code>返回了一个<code>selector</code>对象。 后面的级联操作符都是调用这个对象的成员， 并忽略每个操作 所返回的值</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 上面代码等价于</span></span><br><span class="line"><span class="keyword">var</span> button = <span class="built_in">querySelector</span>(<span class="string">&#x27;#button&#x27;</span>);</span><br><span class="line">button.text = <span class="string">&#x27;Confirm&#x27;</span>;</span><br><span class="line">button.classes.add(<span class="string">&#x27;important&#x27;</span>);</span><br><span class="line">button.onClick.listen((e) =&gt; <span class="built_in">window</span>.alert(<span class="string">&#x27;Confirmed!&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p>级联调用也可以嵌套：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> addressBook = (<span class="keyword">new</span> AddressBookBuilder()</span><br><span class="line">      ..name = <span class="string">&#x27;jenny&#x27;</span></span><br><span class="line">      ..email = <span class="string">&#x27;jenny@example.com&#x27;</span></span><br><span class="line">      ..phone = (<span class="keyword">new</span> PhoneNumberBuilder()</span><br><span class="line">            ..number = <span class="string">&#x27;415-555-0100&#x27;</span></span><br><span class="line">            ..label = <span class="string">&#x27;home&#x27;</span>)</span><br><span class="line">          .build())</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>

<div class="note warning"><p>注意</p></div>

<p>严格来说，两个点的级联语法不是一个操作符, 只是一个<code>Dart</code>特殊语法。</p>
<h2 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h2><p>在<code>Dart</code>中可以使用下面的语句来控制<code>Dart</code>代码的流程：</p>
<ul>
<li><code>if-else</code></li>
<li><code>for</code>和<code>for-in</code></li>
<li><code>while</code>和<code>do-while</code></li>
<li><code>switch</code></li>
<li><code>assert</code></li>
<li><code>break</code>和<code>continue</code></li>
<li><code>try-catch</code>和<code>throw</code></li>
</ul>
<h3 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a><code>if-else</code></h3><p><code>Dart</code>支持<code>if</code>语句以及可选的<code>else</code></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (a == <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;a = 0&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;a = 1&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;a = 2&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note warning"><p>注意</p></div>

<p>上述代码中的条件控制语句的结果必须是布尔值</p>
<h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><p>可以使用标准的<code>for</code>循环, <code>List</code>和<code>Set</code>等实现了<code>Iterable</code>接口的类还支持<code>for-in</code>形式的遍历：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// for循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  <span class="built_in">print</span>(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for-in循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  <span class="built_in">print</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="While和do-while"><a href="#While和do-while" class="headerlink" title="While和do-while"></a><code>While</code>和<code>do-while</code></h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// while 循环在执行循环之前先判断条件是否满足：</span></span><br><span class="line"><span class="keyword">while</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;c = <span class="subst">$c</span>&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 而do-while循环是先执行循环代码再判断条件：</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;c = <span class="subst">$c</span>&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">while</span> (c == <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h3 id="Break和continue"><a href="#Break和continue" class="headerlink" title="Break和continue"></a><code>Break</code>和<code>continue</code></h3><p>使用<code>break</code>来终止循环：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (shutDownRequested()) <span class="keyword">break</span>;</span><br><span class="line">  processIncomingRequests();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>continue</code>来开始下一次循环</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; candidates.length; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> candidate = candidates[i];</span><br><span class="line">  <span class="keyword">if</span> (candidate.yearsExperience &lt; <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  candidate.interview();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a><code>Switch</code></h3><ul>
<li><code>Dart</code>中的<code>Switch</code>语句使用 <code>==</code> 比较 <code>integer</code>、<code>string</code>、或者编译时常量</li>
<li>比较的对象必须都是同一个类的实例, 比较适合枚举值</li>
<li>每个非空的<code>case</code>语句都必须有一个<code>break</code>语句</li>
<li>另外还可以通过<code>continue</code>、<code>throw</code>或者<code>return</code>来结束非空<code>case</code>语句</li>
<li>当没有<code>case</code>语句匹配的时候，可以使用<code>default</code>语句来匹配这种默认情况</li>
<li>每个<code>case</code>语句可以有局部变量，局部变量只有在这个语句内可见</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> command = <span class="string">&#x27;OPEN&#x27;</span>;</span><br><span class="line"><span class="keyword">switch</span> (command) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;CLOSED&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;CLOSED&#x27;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;APPROVED&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;APPROVED&#x27;</span>);</span><br><span class="line">    <span class="comment">// break;</span></span><br><span class="line">    <span class="comment">// 这里非空的case, 没有break会报错</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;DENIED&#x27;</span>:</span><br><span class="line">    <span class="comment">// 这里空的case, 可以不要break</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;OPEN&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;OPEN&#x27;</span>);</span><br><span class="line">    <span class="keyword">continue</span> nowClosed;</span><br><span class="line"><span class="comment">//如果你需要实现这种继续到下一个 case 语句中继续执行，则可以 使用 continue 语句跳转到对应的标签（label）处继续执行：</span></span><br><span class="line">nowClosed:</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;PENDING&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;PENDING&#x27;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;default&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Assert"><a href="#Assert" class="headerlink" title="Assert"></a>Assert</h3><ul>
<li>断言: 如果条件表达式结果不满足需要，则可以使用<code>assert</code> 语句中断代码的执行</li>
<li><code>assert</code>方法的参数可以为任何返回布尔值的表达式或者方法。</li>
<li>如果返回的值为<code>true</code>，断言执行通过，执行结束</li>
<li>如果返回值为<code>false</code>，断言执行失败，会抛出一个异常</li>
<li>可在开发过程中, 监测代码是否有问题时使用</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Make sure the variable has a non-null value</span></span><br><span class="line"><span class="keyword">assert</span>(text != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Make sure the value is less than 100</span></span><br><span class="line"><span class="keyword">assert</span>(number &lt; <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Make sure this is an https URL</span></span><br><span class="line"><span class="keyword">assert</span>(urlString.startsWith(<span class="string">&#x27;https&#x27;</span>));</span><br></pre></td></tr></table></figure>

<div class="note warning"><p>注意</p></div>

<p>断言只在开发模式下运行有效，如果在生产模式 运行，则断言不会执行</p>
<blockquote>
<p>这篇文章的简单介绍就到这里了, 下一篇将会记录<code>Dart</code>的基本数据类型</p>
</blockquote>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul>
<li><a href="http://dart.goodev.org/guides/language/language-tour">Dart官网语法介绍-中文版</a></li>
<li><a href="https://www.dartlang.org/guides/language/language-tour">Dart官网语法介绍-英文版</a></li>
</ul>
<hr>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
        <tag>Dart</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter必备开源项目推荐</title>
    <url>/post/60a03ea8.html</url>
    <content><![CDATA[<ul>
<li>这段时间内一直学习<code>Flutter</code>, 自行设计完成了一个实战项目<code>mahua_pet</code></li>
<li>项目中用到了<code>flutter</code>中的大部分的组件, 界面也涉及了很多功能(可能很多地方还有待完善)</li>
<li>项目目前也还是处在开发待完成阶段, 主要内容差不多已经完成</li>
<li>下面是一些UI界面展示, 后面推见一些比较好的开源项目</li>
<li>验证码登录和密码登录都可以登录, 账号: 123 密码: 123</li>
<li><a href="https://github.com/CoderTitan/mahuaPet">GitHub项目地址</a></li>
</ul>
<span id="more"></span>



<h2 id="项目版本信息"><a href="#项目版本信息" class="headerlink" title="项目版本信息"></a>项目版本信息</h2><blockquote>
<p>项目下载完成之后, 请先执行<code>flutter pub get</code>命令</p>
</blockquote>
<h3 id="2020-04-10"><a href="#2020-04-10" class="headerlink" title="2020-04-10"></a>2020-04-10</h3><ul>
<li>项目代码和相关插件已经更新</li>
<li>Flutter 2.0.0 • channel stable</li>
<li>Engine • revision 40441def69</li>
<li>Tools • Dart 2.12.0</li>
</ul>
<h2 id="部分界面展示"><a href="#部分界面展示" class="headerlink" title="部分界面展示"></a>部分界面展示</h2><h3 id="首页"><a href="#首页" class="headerlink" title="首页"></a>首页</h3><p>动态的展示导航栏的显示和隐藏</p>
<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/mahua/home_0.png?x-oss-process=style/titanjun" alt="image"></p>
<h3 id="日历模块"><a href="#日历模块" class="headerlink" title="日历模块"></a>日历模块</h3><p>展示日历的记录, 每日记录生成图片和保存图片</p>
<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/mahua/calendar_0.png?x-oss-process=style/titanjun" alt="image"></p>
<h3 id="发现"><a href="#发现" class="headerlink" title="发现"></a>发现</h3><p>类似朋友圈的内容展示, 图片浏览和保存图片</p>
<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/mahua/find_0.png?x-oss-process=style/titanjun" alt="image"></p>
<p>动态详情模块, 动态的评论和删除评论</p>
<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/mahua/detail_0.png?x-oss-process=style/titanjun" alt="image"></p>
<h3 id="多语言国际化"><a href="#多语言国际化" class="headerlink" title="多语言国际化"></a>多语言国际化</h3><p>部分页面适配了韩语和英语</p>
<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/mahua/language_0.png?x-oss-process=style/titanjun" alt="image"></p>
<h3 id="颜色主题和暗黑模式"><a href="#颜色主题和暗黑模式" class="headerlink" title="颜色主题和暗黑模式"></a>颜色主题和暗黑模式</h3><p>部分页面支持手动的修改项目主题色, 黑色主题(暗黑模式)适配</p>
<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/mahua/theme_0.png?x-oss-process=style/titanjun" alt="image"></p>
<h2 id="用到的插件"><a href="#用到的插件" class="headerlink" title="用到的插件"></a>用到的插件</h2><h3 id="dio"><a href="#dio" class="headerlink" title="dio"></a>dio</h3><blockquote>
<p><a href="https://pub.dartlang.org/packages/dio">https://pub.dartlang.org/packages/dio</a></p>
</blockquote>
<p>Dart社区提供的http请求库，不仅支持常见的网络请求，还支持Restful API、FormData、拦截器、请求取消、Cookie管理、文件上传&#x2F;下载、超时等操作</p>
<h3 id="provider"><a href="#provider" class="headerlink" title="provider"></a>provider</h3><blockquote>
<p><a href="https://pub.dev/packages/provider">https://pub.dev/packages/provider</a></p>
</blockquote>
<p><code>Flutter</code>官方推荐的状态管理插件, <a href="https://flutter.cn/docs/development/data-and-backend/state-mgmt/simple">简单的应用状态管理</a></p>
<h3 id="flutter-redux"><a href="#flutter-redux" class="headerlink" title="flutter_redux"></a>flutter_redux</h3><blockquote>
<p><a href="https://pub.dev/packages/flutter_redux">https://pub.dev/packages/flutter_redux</a></p>
</blockquote>
<p><code>flutter</code>版的<code>redux</code></p>
<h3 id="pull-to-refresh"><a href="#pull-to-refresh" class="headerlink" title="pull_to_refresh"></a>pull_to_refresh</h3><blockquote>
<p><a href="https://pub.dev/packages/pull_to_refresh">https://pub.dev/packages/pull_to_refresh</a></p>
</blockquote>
<p>一个提供上拉加载和下拉刷新的组件,同时支持<code>Android</code>和<code>ios</code></p>
<h3 id="flutter-staggered-grid-view"><a href="#flutter-staggered-grid-view" class="headerlink" title="flutter_staggered_grid_view"></a>flutter_staggered_grid_view</h3><blockquote>
<p><a href="https://pub.dev/packages/flutter_staggered_grid_view">https://pub.dev/packages/flutter_staggered_grid_view</a></p>
</blockquote>
<p>一个支持瀑布流布局, 支持交错和可扩展的网格布局的组件</p>
<h3 id="flutter-easyloading"><a href="#flutter-easyloading" class="headerlink" title="flutter_easyloading"></a>flutter_easyloading</h3><blockquote>
<p><a href="https://pub.dev/packages/flutter_easyloading">https://pub.dev/packages/flutter_easyloading</a></p>
</blockquote>
<p>支持多种样式的toast提示组件, 支持自定义</p>
<h3 id="carousel-slider"><a href="#carousel-slider" class="headerlink" title="carousel_slider"></a>carousel_slider</h3><blockquote>
<p><a href="https://pub.dev/packages/carousel_slider">https://pub.dev/packages/carousel_slider</a></p>
</blockquote>
<p>轮播图组件, 支持缩放切换</p>
<h3 id="table-calendar"><a href="#table-calendar" class="headerlink" title="table_calendar"></a>table_calendar</h3><blockquote>
<p><a href="https://pub.dev/packages/table_calendar">https://pub.dev/packages/table_calendar</a></p>
</blockquote>
<p>日历组件, 可定制性比较高, 支持语言国际化</p>
<h3 id="photo-view"><a href="#photo-view" class="headerlink" title="photo_view"></a>photo_view</h3><blockquote>
<p><a href="https://pub.dev/packages/photo_view">https://pub.dev/packages/photo_view</a></p>
</blockquote>
<p>可定制的图片查看器, 支持手势缩放, 动画展示等</p>
<h3 id="shimmer"><a href="#shimmer" class="headerlink" title="shimmer"></a>shimmer</h3><blockquote>
<p><a href="https://pub.dev/packages/shimmer">https://pub.dev/packages/shimmer</a></p>
</blockquote>
<p>提供闪光效果的组件, 表述不清晰, 看提供效果图</p>
<p><img data-src="https://github.com/hnvn/flutter_shimmer/blob/master/screenshots/loading_list.gif?raw=true" alt="image"><br><img data-src="https://github.com/hnvn/flutter_shimmer/blob/master/screenshots/slide_to_unlock.gif?raw=true" alt="image"></p>
<h3 id="cached-network-image"><a href="#cached-network-image" class="headerlink" title="cached_network_image"></a>cached_network_image</h3><blockquote>
<p><a href="https://pub.dev/packages/cached_network_image">https://pub.dev/packages/cached_network_image</a></p>
</blockquote>
<p>用来加载和缓存网络图像</p>
<h3 id="image-picker"><a href="#image-picker" class="headerlink" title="image_picker"></a>image_picker</h3><blockquote>
<p><a href="https://pub.dev/packages/image_picker">https://pub.dev/packages/image_picker</a></p>
</blockquote>
<p>用于从Android和iOS图像库中选择图像的库，支持使用相机拍摄新照片。</p>
<h3 id="image-gallery-saver"><a href="#image-gallery-saver" class="headerlink" title="image_gallery_saver"></a>image_gallery_saver</h3><blockquote>
<p><a href="https://pub.dev/packages/image_gallery_saver">https://pub.dev/packages/image_gallery_saver</a></p>
</blockquote>
<p>保存视频和图片到手机相册</p>
<h3 id="video-player"><a href="#video-player" class="headerlink" title="video_player"></a>video_player</h3><blockquote>
<p><a href="https://pub.dev/packages/video_player">https://pub.dev/packages/video_player</a></p>
</blockquote>
<p>flutter官方推荐的视频播放组件</p>
<h3 id="permission-handler"><a href="#permission-handler" class="headerlink" title="permission_handler"></a>permission_handler</h3><blockquote>
<p><a href="https://pub.dev/packages/permission_handler">https://pub.dev/packages/permission_handler</a></p>
</blockquote>
<p>用于Android和iOS的相关隐私权限判断</p>
<h3 id="shared-preferences"><a href="#shared-preferences" class="headerlink" title="shared_preferences"></a>shared_preferences</h3><blockquote>
<p><a href="https://pub.dev/packages/shared_preferences">https://pub.dev/packages/shared_preferences</a></p>
</blockquote>
<p>用于基本数据的缓存处理</p>
<h3 id="device-info"><a href="#device-info" class="headerlink" title="device_info"></a>device_info</h3><blockquote>
<p><a href="https://pub.dev/packages/device_info">https://pub.dev/packages/device_info</a></p>
</blockquote>
<p>用于获取用户设备信息</p>
<h3 id="location"><a href="#location" class="headerlink" title="location"></a>location</h3><blockquote>
<p><a href="https://pub.dev/packages/location">https://pub.dev/packages/location</a></p>
</blockquote>
<p>获取定位信息, 可以获取位置更改时的回调</p>
<h2 id="值得推荐的插件"><a href="#值得推荐的插件" class="headerlink" title="值得推荐的插件"></a>值得推荐的插件</h2><h3 id="适配相关"><a href="#适配相关" class="headerlink" title="适配相关"></a>适配相关</h3><h4 id="native-widgets"><a href="#native-widgets" class="headerlink" title="native_widgets"></a>native_widgets</h4><blockquote>
<p><a href="https://pub.dev/packages/native_widgets">https://pub.dev/packages/native_widgets</a></p>
</blockquote>
<p>支持自动根据平台自动使用对应风格组件，Android将使用Material风格，iOS将使用Cupertino风格</p>
<h3 id="日期时间"><a href="#日期时间" class="headerlink" title="日期时间"></a>日期时间</h3><h4 id="flutter-picker"><a href="#flutter-picker" class="headerlink" title="flutter_picker"></a>flutter_picker</h4><blockquote>
<p><a href="https://pub.dev/packages/flutter_picker">https://pub.dev/packages/flutter_picker</a></p>
</blockquote>
<p>一个日期，时间，日期时间，icon，自定义数据的选择器，可以居中弹窗，也可以在底部弹出</p>
<h3 id="MarkDown"><a href="#MarkDown" class="headerlink" title="MarkDown"></a>MarkDown</h3><h4 id="markdown"><a href="#markdown" class="headerlink" title="markdown"></a>markdown</h4><blockquote>
<p><a href="https://pub.dev/packages/markdown">https://pub.dev/packages/markdown</a></p>
</blockquote>
<p>用Dart编写的便携式Markdown库。它可以在客户端和服务器上将Markdown解析为HTML</p>
<h3 id="颜色选择"><a href="#颜色选择" class="headerlink" title="颜色选择"></a>颜色选择</h3><h4 id="flutter-colorpicker"><a href="#flutter-colorpicker" class="headerlink" title="flutter_colorpicker"></a>flutter_colorpicker</h4><blockquote>
<p><a href="https://pub.dev/packages/flutter_colorpicker">https://pub.dev/packages/flutter_colorpicker</a></p>
</blockquote>
<p>一个HSV(HSB)&#x2F;HSL颜色选择器</p>
<h3 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h3><h4 id="crypto"><a href="#crypto" class="headerlink" title="crypto"></a>crypto</h4><blockquote>
<p><a href="https://pub.dev/packages/crypto">https://pub.dev/packages/crypto</a></p>
</blockquote>
<p>crypto算法库支持的算法: </p>
<ul>
<li>SHA-1</li>
<li>SHA-224</li>
<li>SHA-256</li>
<li>SHA-384</li>
<li>SHA-512</li>
<li>MD5</li>
<li>HMAC (i.e. HMAC-MD5, HMAC-SHA1, HMAC-SHA256)</li>
</ul>
<h4 id="pointycastle"><a href="#pointycastle" class="headerlink" title="pointycastle"></a>pointycastle</h4><blockquote>
<p><a href="https://pub.dev/packages/pointycastle">https://pub.dev/packages/pointycastle</a></p>
</blockquote>
<p>用于加密和解密的Dart库, 实现了AES RSA 公私钥加解密等加密算法</p>
<h3 id="解压缩"><a href="#解压缩" class="headerlink" title="解压缩"></a>解压缩</h3><h4 id="archive"><a href="#archive" class="headerlink" title="archive"></a>archive</h4><blockquote>
<p><a href="https://pub.dev/packages/archive">https://pub.dev/packages/archive</a></p>
</blockquote>
<p>为各种存档和压缩格式提供编码器和解码器，如zip，tar，bzip2，gzip和zlib</p>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><h4 id="sqflite"><a href="#sqflite" class="headerlink" title="sqflite"></a>sqflite</h4><blockquote>
<p><a href="https://pub.dev/packages/sqflite">https://pub.dev/packages/sqflite</a></p>
</blockquote>
<p>SQLite的Flutter插件，一个自包含的高可靠性嵌入式SQL数据库引擎</p>
<h3 id="分享统计支付"><a href="#分享统计支付" class="headerlink" title="分享统计支付"></a>分享统计支付</h3><h4 id="share"><a href="#share" class="headerlink" title="share"></a>share</h4><blockquote>
<p><a href="https://pub.dev/packages/share">https://pub.dev/packages/share</a></p>
</blockquote>
<p>支持分享的flutter插件</p>
<h4 id="flutter-umeng-analytics"><a href="#flutter-umeng-analytics" class="headerlink" title="flutter_umeng_analytics"></a>flutter_umeng_analytics</h4><blockquote>
<p><a href="https://pub.dev/packages/flutter_umeng_analytics">https://pub.dev/packages/flutter_umeng_analytics</a></p>
</blockquote>
<p>友盟的分享和统计库</p>
<h4 id="flutter-qq"><a href="#flutter-qq" class="headerlink" title="flutter_qq"></a>flutter_qq</h4><blockquote>
<p><a href="https://pub.dev/packages/flutter_qq">https://pub.dev/packages/flutter_qq</a></p>
</blockquote>
<p>集成了QQ登录、QQ分享、QQ空间分享等功能的库</p>
<h4 id="flutter-wechat"><a href="#flutter-wechat" class="headerlink" title="flutter_wechat"></a>flutter_wechat</h4><blockquote>
<p><a href="https://pub.dev/packages/flutter_wechat">https://pub.dev/packages/flutter_wechat</a></p>
</blockquote>
<p>集成了微信，支持微信登录、分享、支付等功能的库</p>
<h4 id="flutter-alipay"><a href="#flutter-alipay" class="headerlink" title="flutter_alipay"></a>flutter_alipay</h4><blockquote>
<p><a href="https://pub.dev/packages/flutter_alipay">https://pub.dev/packages/flutter_alipay</a></p>
</blockquote>
<p>支付宝支付的功能</p>
<h2 id="学习资料和项目"><a href="#学习资料和项目" class="headerlink" title="学习资料和项目"></a>学习资料和项目</h2><p>推荐一些不错的学习网站和项目学习</p>
<h3 id="awesome-flutter-cn"><a href="#awesome-flutter-cn" class="headerlink" title="awesome-flutter-cn"></a>awesome-flutter-cn</h3><blockquote>
<p><a href="https://github.com/crazycodeboy/awesome-flutter-cn">https://github.com/crazycodeboy/awesome-flutter-cn</a></p>
</blockquote>
<p>一个Flutter的学习资料库, 里面提供了很多的学习资料</p>
<h3 id="flutter-go"><a href="#flutter-go" class="headerlink" title="flutter-go"></a>flutter-go</h3><blockquote>
<p><a href="https://github.com/alibaba/flutter-go">https://github.com/alibaba/flutter-go</a></p>
</blockquote>
<p>由阿里巴巴前端技术团队开发的Flutter 开发者帮助 APP，包含 flutter 常用 140+ 组件的demo 演示与中文文档</p>
<h3 id="Widget整理"><a href="#Widget整理" class="headerlink" title="Widget整理"></a>Widget整理</h3><blockquote>
<p><a href="http://laomengit.com/flutter/widgets/widgets_structure.html">http://laomengit.com/flutter/widgets/widgets_structure.html</a></p>
</blockquote>
<p>整理的330+组件的详细用法，不仅包含UI组件，还包含了功能性的组件</p>
<h3 id="Morec"><a href="#Morec" class="headerlink" title="Morec"></a>Morec</h3><blockquote>
<p><a href="https://github.com/Mayandev/morec">https://github.com/Mayandev/morec</a></p>
</blockquote>
<p>一个非常精美的 Flutter 版电影客户端，利用豆瓣现有的 Api，打造了一个完整的电影展示 App</p>
<h3 id="flutter-hrlweibo"><a href="#flutter-hrlweibo" class="headerlink" title="flutter_hrlweibo"></a>flutter_hrlweibo</h3><blockquote>
<p><a href="https://github.com/huangruiLearn/flutter_hrlweibo">https://github.com/huangruiLearn/flutter_hrlweibo</a></p>
</blockquote>
<p>仿微博最新版本,还原微博80%的界面,总共涉及到了几十个界面和接口,用到了flutter中的大部分组件</p>
<h3 id="flutter-netease-music"><a href="#flutter-netease-music" class="headerlink" title="flutter-netease-music"></a>flutter-netease-music</h3><blockquote>
<p><a href="https://github.com/boyan01/flutter-netease-music">https://github.com/boyan01/flutter-netease-music</a></p>
</blockquote>
<p>仿网易云音乐，完成大部分功能的APP</p>
<h3 id="flutter-shuqi"><a href="#flutter-shuqi" class="headerlink" title="flutter_shuqi"></a>flutter_shuqi</h3><blockquote>
<p><a href="https://github.com/huanxsd/flutter_shuqi">https://github.com/huanxsd/flutter_shuqi</a></p>
</blockquote>
<p>一个用Flutter写的书旗小说客户端, 所有功能都是用Dart写的，iOS和Android的代码复用率达到了100%</p>
<h3 id="gsy-github-app-flutter"><a href="#gsy-github-app-flutter" class="headerlink" title="gsy_github_app_flutter"></a>gsy_github_app_flutter</h3><blockquote>
<p><a href="https://github.com/CarGuo/GSYGithubAPP">https://github.com/CarGuo/GSYGithubAPP</a></p>
</blockquote>
<p>一款跨平台的开源Github客户端App，项目涉及各种常用控件、网络、数据库、设计模式、主题切换、多语言、Redux等</p>
<hr>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
        <tag>Dart</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter的安装和配置</title>
    <url>/post/8fbde7fa.html</url>
    <content><![CDATA[<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/flutter/flutter.jpeg?x-oss-process=style/titanjun" alt="Flutter"></p>
<span id="more"></span>


<ul>
<li><code>Flutter</code>是谷歌的移动<code>UI</code>框架，可以快速在<code>iOS</code>和<code>Android</code>上构建高质量的原生用户界面, 并且是未来新操作系统<a href="https://baike.baidu.com/item/Fuchsia/19900570">Fuchsia</a>的默认开发套件</li>
<li>在全世界，<code>Flutter</code>正在被越来越多的开发者和组织使用，并且<code>Flutter</code>是完全免费、开源的—-<a href="https://flutterchina.club/">Flutter中文网</a></li>
<li><code>Flutter</code>同时支持<code>Windows</code>、<code>Linux</code>和<code>MacOS</code>操作系统作为开发环境，并且在<code>Android Studio</code>和<code>VS Code</code>两个<code>IDE</code>上都提供了全功能的支持</li>
<li><code>Flutter</code>以<code>Dart</code>语言为开发语言(之后的文章会介绍)</li>
</ul>
<h2 id="跨平台框架"><a href="#跨平台框架" class="headerlink" title="跨平台框架"></a>跨平台框架</h2><ul>
<li>在<code>Flutter</code>诞生之前，已经有许多跨平台<code>UI</code>框架的方案，比如基<code>于WebView</code>的<code>Cordova</code>、<code>AppCan</code>等，还有使用<code>HTML+JavaScript</code>渲染成原生控件的<code>React Native</code>、<code>Weex</code>等(虽然我只用过<code>React Native</code>)</li>
<li>基于<code>WebView</code>的框架<ul>
<li>优点很明显，它们几乎可以完全继承现代<code>Web</code>开发的所有成果（丰富得多的控件库、满足各种需求的页面框架、完全的动态化、自动化测试工具等等），当然也包括<code>Web</code>开发人员，不需要太多的学习和迁移成本就可以开发一个<code>App</code></li>
<li>缺点也很致命, 在对体验和性能有较高要求的情况下, <code>WebView</code>的渲染效率和<code>JavaScript</code>执行性能太差。再加上<code>Android</code>各个系统版本和设备厂商的定制，很难保证所在所有设备上都能提供一致的体验</li>
</ul>
</li>
<li><code>React Native</code>一类的框架<ul>
<li>将最终渲染工作交还给了系统，虽然同样使用类<code>HTML+JS</code>的<code>UI</code>构建逻辑，但是最终会生成对应的自定义原生控件，以充分利用原生控件相对于<code>WebView</code>的较高的绘制效率</li>
<li>同时这种策略也将框架本身和<code>App</code>开发者绑在了系统的控件上，不仅框架本身需要处理大量平台相关的逻辑，随着系统版本变化和<code>API</code>的变化，开发者可能也需要处理不同平台的差异，甚至有些特性只能在部分平台上实现，这样框架的跨平台特性就会大打折扣</li>
</ul>
</li>
<li><code>Flutter</code>框架<ul>
<li><code>Flutter</code>则开辟了一种全新的思路，从头到尾重写一套跨平台的<code>UI</code>框架，包括<code>UI</code>控件、渲染逻辑甚至开发语言</li>
<li><code>Flutter</code>使用自己的高性能渲染引擎来绘制<code>widget</code>, <code>Flutter</code>使用<code>C</code>、<code>C ++</code>、<code>Dart</code>和<code>Skia</code>（2D渲染引擎）构建</li>
<li>在<code>iOS</code>上，<code>Flutter</code>引擎的<code>C/C ++</code>代码使用<code>LLVM</code>编译，任何<code>Dart</code>代码都是<code>AOT</code>编译为本地代码的，<code>Flutter</code>应用程序使用本机指令集运行（不涉及解释器）</li>
<li>而在<code>Android</code>下，<code>Flutter</code>引擎的<code>C/C ++</code>代码是用<code>Android</code>的<code>NDK</code>编译的，任何<code>Dart</code>代码都是<code>AOT</code>编译成本地代码的，<code>Flutter</code>应用程序依然使用本机指令集运行（不涉及解释器）</li>
</ul>
</li>
</ul>
<h2 id="Flutter安装"><a href="#Flutter安装" class="headerlink" title="Flutter安装"></a><code>Flutter</code>安装</h2><ul>
<li>可参考官网的<a href="https://flutterchina.club/get-started/install/">安装Flutter</a>, 支持<code>Windows</code>、<code>Linux</code>和<code>MacOS</code>操作系统</li>
<li>我使用的系统是<code>MacOS</code>操作系统</li>
</ul>
<h3 id="系统要求"><a href="#系统要求" class="headerlink" title="系统要求"></a>系统要求</h3><p>要安装并运行<code>Flutter</code>，您的开发环境必须满足以下最低要求:</p>
<ul>
<li>操作系统: macOS (64-bit)</li>
<li>磁盘空间: 700 MB (不包括<code>Xcode</code>或<code>Android Studio</code>的磁盘空间）.</li>
<li>工具: <code>Flutter</code>依赖下面这些命令行工具.<ul>
<li><code>bash</code>, <code>mkdir</code>, <code>rm</code>, <code>git</code>, <code>curl</code>, <code>unzip</code>, <code>which</code></li>
</ul>
</li>
</ul>
<h3 id="获取Flutter-SDK"><a href="#获取Flutter-SDK" class="headerlink" title="获取Flutter SDK"></a>获取<code>Flutter SDK</code></h3><h4 id="下载SDK"><a href="#下载SDK" class="headerlink" title="下载SDK"></a>下载SDK</h4><ul>
<li>去<code>Flutter</code>官网下载其最新可用的安装包，<a href="https://flutter.io/docs/development/tools/sdk/archive?tab=macos#macos">转到下载页</a></li>
<li>注意，<code>Flutter</code>的渠道版本会不停变动，请以<code>Flutter</code>官网为准</li>
<li>另外，在中国大陆地区，要想正常获取安装包列表或下载安装包，可能需要翻墙，读者也可以去<code>Flutter github</code>项目下去下载安装包，<a href="https://github.com/flutter/flutter/releases">转到下载页</a></li>
</ul>
<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/flutter/flutter_SDK.png?x-oss-process=style/titanjun" alt="Flutter_SDK"></p>
<h4 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h4><ul>
<li>解压SDK并把解压好的文件全部放在你想要放置的位置, 建议和其他开发语言的SDK放置在一起, 比如<code>~/Library/Flutter</code></li>
<li>为了方便后续使用，需要将项目根目录下<code>bin</code>路径加入环境变量<code>PATH</code>中<ul>
<li>编辑器打开<code>~/.bash_profile</code>文件, 添加如下</li>
</ul>
</li>
</ul>
<figure class="highlight rb"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Flutter 相关配置</span></span><br><span class="line"><span class="comment"># xxx是你自己的Flutter文件夹路径</span></span><br><span class="line">export <span class="variable constant_">PATH</span>=<span class="regexp">/xxx/</span>Flutter/<span class="symbol">bin:</span>$<span class="variable constant_">PATH</span></span><br></pre></td></tr></table></figure>

<p>由于在国内访问<code>Flutter</code>有时可能会受到限制，<code>Flutter</code>官方为中国开发者搭建了临时镜像，大家可以将如下环境变量加入到用户环境变量中：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">export <span class="variable constant_">PUB_HOSTED_URL</span>=<span class="symbol">https:</span>/<span class="regexp">/pub.flutter-io.cn</span></span><br><span class="line"><span class="regexp">export FLUTTER_STORAGE_BASE_URL=https:/</span><span class="regexp">/storage.flutter-io.cn</span></span><br></pre></td></tr></table></figure>

<div class="note warning"><p>注意</p></div>

<p>此镜像为临时镜像，并不能保证一直可用，读者可以参考详情请参考 <a href="https://github.com/flutter/flutter/wiki/Using-Flutter-in-China">Using Flutter in China</a> 以获得有关镜像服务器的最新动态</p>
<div class="note info"><p>保存文件, 并更新当前配置</p></div>


<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行命令</span></span><br><span class="line">source ~<span class="regexp">/.bash_profile</span></span><br></pre></td></tr></table></figure>

<div class="note success"><p>验证`flutter/bin`目录是否在你的PATH中</p></div>


<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行下面命令</span></span><br><span class="line">echo $<span class="variable constant_">PATH</span></span><br></pre></td></tr></table></figure>

<p>如果安装成功, 会输出类似<code>/xxx/Flutter/bin</code>的路径</p>
<h3 id="安装开发工具"><a href="#安装开发工具" class="headerlink" title="安装开发工具"></a>安装开发工具</h3><h4 id="安装Android-Studio"><a href="#安装Android-Studio" class="headerlink" title="安装Android Studio"></a>安装Android Studio</h4><ul>
<li>下载并安装<a href="http://www.android-studio.org/">Android Studio</a></li>
<li>启动<code>Android Studio</code>，然后执行<code>Android Studio</code>安装向导, 这将安装最新的<code>Android SDK</code>，<code>Android SDK</code>平台工具和<code>Android SDK</code>构建工具, 这是<code>Flutter</code>开发<code>Android</code>应用时所必备的</li>
<li>安装完成后, 配置一个需要的<code>Android</code>模拟器</li>
</ul>
<h4 id="安装Xcode"><a href="#安装Xcode" class="headerlink" title="安装Xcode"></a>安装Xcode</h4><p>在<code>App Store</code>搜索最新版本<code>Xcode</code>下载安装即可</p>
<h4 id="VSCode"><a href="#VSCode" class="headerlink" title="VSCode"></a>VSCode</h4><p>开发<code>IDE</code>，直接去<a href="https://code.visualstudio.com/">官网下载</a>安装即可</p>
<h3 id="环境配置检测"><a href="#环境配置检测" class="headerlink" title="环境配置检测"></a>环境配置检测</h3><p>通过<code>flutter doctor</code>命令来执行<code>Flutter</code>的安装程序了，经过一段时间的下载和安装，<code>Flutter</code>会输出安装结果(时间可能会比较久)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ flutter doctor</span><br><span class="line">Doctor summary (to see all details, run flutter doctor -v):</span><br><span class="line">[✓] Flutter (Channel beta, v0.5.1, on Mac OS X 10.13.5 17F77, locale en-NZ)</span><br><span class="line">[!] Android toolchain - develop for Android devices (Android SDK 26.0.2)</span><br><span class="line">    ! Some Android licenses not accepted.  To resolve this, run: flutter doctor --android-licenses</span><br><span class="line">[!] iOS toolchain - develop for iOS devices (Xcode 9.4.1)</span><br><span class="line">    ✗ Missing Xcode dependency: Python module &quot;six&quot;.</span><br><span class="line">    Install via &#x27;pip install six&#x27; or &#x27;sudo easy_install six&#x27;.</span><br><span class="line">    ✗ libimobiledevice and ideviceinstaller are not installed. To install, run:</span><br><span class="line">        brew install --HEAD libimobiledevice</span><br><span class="line">        brew install ideviceinstaller</span><br><span class="line">    ✗ ios-deploy not installed. To install:</span><br><span class="line">        brew install ios-deploy</span><br><span class="line">    ✗ CocoaPods not installed.</span><br><span class="line">        CocoaPods is used to retrieve the iOS platform side&#x27;s plugin code that responds to your plugin usage on the Dart side.</span><br><span class="line">        Without resolving iOS dependencies with CocoaPods, plugins will not work on iOS.</span><br><span class="line">        For more info, see https://flutter.io/platform-plugins</span><br><span class="line">    To install:</span><br><span class="line">        brew install cocoapods</span><br><span class="line">        pod setup</span><br><span class="line">[✓] Android Studio</span><br><span class="line">    ✗ Flutter plugin not installed; this adds Flutter specific functionality.</span><br><span class="line">    ✗ Dart plugin not installed; this adds Dart specific functionality.</span><br><span class="line">[✓] Android Studio (version 3.0)</span><br><span class="line">    ✗ Flutter plugin not installed; this adds Flutter specific functionality.</span><br><span class="line">    ✗ Dart plugin not installed; this adds Dart specific functionality.</span><br><span class="line">[!] IntelliJ IDEA Ultimate Edition (version 2017.1.1)</span><br><span class="line">    ✗ Flutter plugin not installed; this adds Flutter specific functionality.</span><br><span class="line">    ✗ Dart plugin not installed; this adds Dart specific functionality.</span><br><span class="line">[!] VS Code (version 1.24.1)</span><br><span class="line">[!] Connected devices</span><br><span class="line">    ! No devices available</span><br><span class="line"></span><br><span class="line">! Doctor found issues in 5 categories.</span><br></pre></td></tr></table></figure>

<ul>
<li>其中前面有<code>[✓]</code>标识的是已经安装成功的</li>
<li><code>[!]</code>标识是需要安装或者更新的</li>
<li>下面介绍需要安装的编辑器及其配置</li>
</ul>
<h2 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h2><p>运行<code>flutter doctor</code>命令可看到相关信息</p>
<ul>
<li><code>Flutter</code>的版本和信息</li>
<li><code>Flutter</code>运行所需的<code>Android</code>工具链，有些许可证没有接受，输入提示命令，输入<code>y</code>确认</li>
<li><code>Flutter</code>运行所需的<code>iOS</code>工具链不满足</li>
<li><code>AS</code>、<code>IDEA</code>的<code>Flutter</code>插件没有安装，所以需要安装，因此需要配置<code>AS</code>或<code>IDEA</code></li>
<li>有可用的连接设备</li>
</ul>
<h3 id="Android-Studio"><a href="#Android-Studio" class="headerlink" title="Android Studio"></a><code>Android Studio</code></h3><ul>
<li>打开插件选择项<code>Preferences &gt; Plugins</code></li>
<li>选择<code>Browse repositories</code>，搜索<code>Flutter</code>插件并安装(同时自动安装<code>Dart</code>插件)</li>
<li>插件安装完成后, 重启<code>Android Studio</code>后插件生效</li>
</ul>
<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/flutter/android_flutter.png?x-oss-process=style/titanjun" alt="android_flutter"></p>
<p>这时候在命令行运行<code>flutter doctor</code>，可以看到<code>Android Studio</code>已经好了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[✓] Android Studio (version 3.2)</span><br></pre></td></tr></table></figure>

<h3 id="iOS配置"><a href="#iOS配置" class="headerlink" title="iOS配置"></a>iOS配置</h3><ul>
<li>在进行<code>iOS</code>配置之前, 首先需要安装<code>CocoaPods</code>, 可自行百度</li>
<li>安装<code>CocoaPods</code>后, 在执行<code>flutter doctor</code>命令, 可能会出现如下问题</li>
<li>此时在终端中依次执行出现的命令即可</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">[!] iOS toolchain - develop <span class="keyword">for</span> iOS devices</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可能出现的命令, 若出现, 依次执行出现的命令即可, 未出现的可不执行</span></span><br><span class="line"><span class="variable">$ </span>brew install --<span class="variable constant_">HEAD</span> usbmuxd</span><br><span class="line"><span class="variable">$ </span>brew link usbmuxd</span><br><span class="line"><span class="variable">$ </span>brew install --<span class="variable constant_">HEAD</span> libimobiledevice</span><br><span class="line"><span class="variable">$ </span>brew install ideviceinstaller ios-deploy cocoapods</span><br><span class="line"><span class="variable">$ </span>pod setup</span><br></pre></td></tr></table></figure>

<p>这时候在命令行运行<code>flutter doctor</code>，可以看到<code>iOS</code>相关配置也好了</p>
<h3 id="VSCode插件"><a href="#VSCode插件" class="headerlink" title="VSCode插件"></a>VSCode插件</h3><p>在扩展中搜索<code>Flutter</code>和<code>Dart</code>安装后, 重载即可</p>
<h3 id="配置完成"><a href="#配置完成" class="headerlink" title="配置完成"></a>配置完成</h3><p>此刻, 在运行<code>flutter doctor</code>命令, 应该就没有问题了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Doctor summary (to see all details, run flutter doctor -v):</span><br><span class="line">[✓] Flutter (Channel stable, v1.0.0, on Mac OS X 10.14.3 18D109, locale</span><br><span class="line">    zh-Hans-CN)</span><br><span class="line">[✓] Android toolchain - develop for Android devices (Android SDK 28.0.3)</span><br><span class="line">[✓] iOS toolchain - develop for iOS devices (Xcode 10.1)</span><br><span class="line">[✓] Android Studio (version 3.0)</span><br><span class="line">[✓] VS Code (version 1.30.2)</span><br><span class="line">[✓] Connected device (1 available)</span><br><span class="line"></span><br><span class="line">• No issues found!</span><br></pre></td></tr></table></figure>


<h2 id="创建Flutter应用"><a href="#创建Flutter应用" class="headerlink" title="创建Flutter应用"></a>创建Flutter应用</h2><h3 id="CSCode创建"><a href="#CSCode创建" class="headerlink" title="CSCode创建"></a>CSCode创建</h3><p>中文版: <code>vscode</code> -&gt; 查看 -&gt; 命令面板 -&gt; <code>Flutter: new project</code> -&gt; 输入项目名称</p>
<div class="note warning"><p>注意</p></div>

<p>项目名称不支持大写字母</p>
<h3 id="Android-Studio创建"><a href="#Android-Studio创建" class="headerlink" title="Android Studio创建"></a>Android Studio创建</h3><p>打开<code>Android studio</code>就可以看见<code>Flutter</code>工程模板如下</p>
<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/flutter/android_create_flutter.png" alt="android_create_flutte"></p>
<h3 id="命令创建"><a href="#命令创建" class="headerlink" title="命令创建"></a>命令创建</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flutter create helloflutter</span><br></pre></td></tr></table></figure>

<p>这里创建了一个名为<code>helloflutter</code>的<code>Dart package</code></p>
<div class="note info"><p>参数介绍</p></div>

<ul>
<li>要创建插件包，请使用<code>--template=plugin</code>参数执行<code>flutter create</code></li>
<li>使用<code>--org</code>选项指定您的组织，并使用反向域名表示法。该值用于生成的<code>Android</code>和<code>iOS</code>代码中的各种包和包标识符。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flutter create --org com.example --template=plugin helloflutter</span><br></pre></td></tr></table></figure>

<ul>
<li>默认情况下，插件项目针对<code>iOS</code>代码使用<code>Objective-C</code>，<code>Android</code>代码使用<code>Java</code>。</li>
<li>如果您更喜欢<code>Swift</code>或<code>Kotlin</code>，则可以使用<code>-i</code>或<code>-a</code> 为<code>iOS</code>或<code>Android</code>指定语言。例如：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flutter create --template=plugin -i swift -a kotlin helloflutter</span><br></pre></td></tr></table></figure>

<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul>
<li><a href="http://blog.itpub.net/31077337/viewspace-2199818/">Flutter的原理及美团的实践</a></li>
<li><a href="https://flutterchina.club/">Flutter中文网</a></li>
</ul>
<blockquote>
<p>初识<code>Flutter</code>, 总结的可能也不准确, 不足之处还望海涵, 后续会继续优化相关文章</p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
        <tag>Dart</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML5基本介绍</title>
    <url>/post/7334fb9a.html</url>
    <content><![CDATA[<h2 id="一-网页固定格式"><a href="#一-网页固定格式" class="headerlink" title="一.网页固定格式"></a>一.网页固定格式</h2><h3 id="1-编写网页的步骤"><a href="#1-编写网页的步骤" class="headerlink" title="1.编写网页的步骤:"></a>1.编写网页的步骤:</h3><ul>
<li>新建一个文本文档</li>
<li>利用记事本打开</li>
<li>编写THML代码</li>
<li>保存并且修改纯文本文档的扩展名为.html</li>
<li>利用浏览器打开编写好的文件</li>
</ul>
<span id="more"></span>

<h2 id="一-网页固定格式-1"><a href="#一-网页固定格式-1" class="headerlink" title="一.网页固定格式"></a>一.网页固定格式</h2><h3 id="1-编写网页的步骤-1"><a href="#1-编写网页的步骤-1" class="headerlink" title="1.编写网页的步骤:"></a>1.编写网页的步骤:</h3><ul>
<li>新建一个文本文档</li>
<li>利用记事本打开</li>
<li>编写THML代码</li>
<li>保存并且修改纯文本文档的扩展名为.html</li>
<li>利用浏览器打开编写好的文件</li>
</ul>
<blockquote>
<p>一款强大的编辑软件  <a href="http://www.sdifen.com/?s=webstorm+&submit=%E6%90%9C%E7%B4%A2">Webstorm</a>或者 <a href="http://www.pc6.com/mac/112553.html">WebStorm</a></p>
</blockquote>
<h4 id="1-1-WebStorm常见快捷键"><a href="#1-1-WebStorm常见快捷键" class="headerlink" title="1.1 WebStorm常见快捷键"></a>1.1 WebStorm常见快捷键</h4><ul>
<li><p>如何在<code>WebStorm</code>中利用快捷键创建一个新的<code>.html</code>的文件</p>
<ul>
<li>同时按下键盘上的<code>Ctrl + Alt + Insert</code></li>
</ul>
</li>
<li><p>如何在<code>WebStorm</code>中让光标移动到当前行的末尾</p>
<ul>
<li>按下键盘上的<code>End</code>键即可</li>
</ul>
</li>
<li><p>如何在<code>WebStorm</code>中让光标移动到当前行的最前面</p>
<ul>
<li>按下键盘上的<code>Home</code>键即可</li>
</ul>
</li>
<li><p>如何在<code>WebStorm</code>中让光标在多行中闪烁</p>
<ul>
<li>按住键盘上的Alt键不放, 然后再按住鼠标的左键不放, 然后再拖动鼠标即可</li>
</ul>
</li>
<li><p>如何在<code>WebStorm</code>中快速的复制光标所在的那一行</p>
<ul>
<li>按下键盘上的<code>Ctrl + D</code></li>
</ul>
</li>
<li><p>如何在<code>WebStorm</code>中快速的删除光标所在的那一行</p>
<ul>
<li>按下键盘上的<code>Ctrl + X</code></li>
</ul>
</li>
<li><p>如何在<code>WebStorm</code>中让标签包裹一段内容, 也就是自动在一段内容前后加上标签</p>
<ul>
<li>按下键盘上的<code>Ctrl + Alt + T</code>, 然后按下回车, 然后输入对应的标签即可</li>
</ul>
</li>
</ul>
<h3 id="2-网页基本结构"><a href="#2-网页基本结构" class="headerlink" title="2.网页基本结构"></a>2.网页基本结构</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;音视频测试&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>通过观察我们发现, HTML基本结构中所有的标签都是成对出现的, 这些成对出现的标签中有一个带&#x2F;有一个不带&#x2F;, 那么这些不带&#x2F;的标签我们称之为开始标签, 这些带&#x2F;的我们称之为结束标签</li>
</ul>
<h2 id="二-网页标签"><a href="#二-网页标签" class="headerlink" title="二.网页标签"></a>二.网页标签</h2><h3 id="1-HTML标签"><a href="#1-HTML标签" class="headerlink" title="1.HTML标签"></a>1.HTML标签</h3><ul>
<li>作用: 用于告诉浏览器这是一个网页, 也就是说告诉浏览器我是一个HTML文档<blockquote>
<p>注意点: 其它所有的标签都必须写在html标签里面, 也就是写在html开始标签和结束标签中间</p>
</blockquote>
</li>
</ul>
<h3 id="2-head标签"><a href="#2-head标签" class="headerlink" title="2.head标签"></a>2.head标签</h3><ul>
<li>作用:<br>用于给网站添加一些配置信息</li>
<li>例如:<ul>
<li>指定网站的标题 &#x2F; 指定网站的小图片</li>
<li>添加网站的SEO相关的信息(指定网站的关键字&#x2F;指定网站的描述信息)</li>
<li>外挂一些外部的css&#x2F;js文件</li>
<li>添加一些浏览器适配相关的内容<blockquote>
<p>注意点:<br>一般情况下, 写在head标签内部的内容都不会显示给用户查看, 也就是说一般情况下写在head标签内部的内容我们都看不到</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="3-title标签"><a href="#3-title标签" class="headerlink" title="3.title标签"></a>3.title标签</h3><ul>
<li>作用:<br>专门用于指定网站的标题, 并且这个指定的标题将来还会作为用户保存网站的默认标题<blockquote>
<p>注意点:<br>title标签必须写在head标签里面</p>
</blockquote>
</li>
</ul>
<h3 id="4-body标签"><a href="#4-body标签" class="headerlink" title="4.body标签"></a>4.body标签</h3><ul>
<li>作用:<br>专门用于定义HTML文档中需要显示给用户查看的内容(文字&#x2F;图片&#x2F;音频&#x2F;视频)<blockquote>
<p>注意点:<br>虽然说有时候你可能将内容写到了别的地方在网页中也能看到, 但是千万不要这么干, 一定要将需要显示的内容写在body中<br>一对html标签中(一个html开始标签和一个html结束标签)只能有一对body标签</p>
</blockquote>
</li>
</ul>
<h3 id="5-meta标签"><a href="#5-meta标签" class="headerlink" title="5.meta标签"></a>5.meta标签</h3><ul>
<li>作用 : 在编写网页的时候指定字符集,可避免出现乱码现象</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">&lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br></pre></td></tr></table></figure>
<h4 id="GBK-GB2312-和UTF-8区别"><a href="#GBK-GB2312-和UTF-8区别" class="headerlink" title="GBK(GB2312)和UTF-8区别"></a>GBK(GB2312)和UTF-8区别</h4><ul>
<li>GBK(GB2312)里面存储的字符比较少, 仅仅存储了汉字和一些常用外文<br>体积比较小</li>
<li>UTF-8里面存储的世界上所有的文字,提交比较大<blockquote>
<h4 id="个人推荐-所有一律都写UTF-8"><a href="#个人推荐-所有一律都写UTF-8" class="headerlink" title="个人推荐:所有一律都写UTF-8"></a>个人推荐:所有一律都写UTF-8</h4></blockquote>
</li>
</ul>
<h2 id="3-HTML标签分类"><a href="#3-HTML标签分类" class="headerlink" title="3.HTML标签分类"></a>3.HTML标签分类</h2><h3 id="1-单标签"><a href="#1-单标签" class="headerlink" title="1.单标签"></a>1.单标签</h3><ul>
<li>只有开始标签没有结束标签, 也就是由一个&lt;&gt;组成的</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">&lt;meta charset=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>
<h3 id="2-双标签"><a href="#2-双标签" class="headerlink" title="2.双标签"></a>2.双标签</h3><p> 有开始标签和结束标签, 也就是由一个&lt;&gt;和一个&lt;&#x2F;&gt;组成的</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h2 id="4-HTML标签关系分类"><a href="#4-HTML标签关系分类" class="headerlink" title="4.HTML标签关系分类"></a>4.HTML标签关系分类</h2><h3 id="1-并列关系-兄弟-x2F-平级"><a href="#1-并列关系-兄弟-x2F-平级" class="headerlink" title="1.并列关系(兄弟&#x2F;平级)"></a>1.并列关系(兄弟&#x2F;平级)</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<h3 id="2-嵌套关系-父子-x2F-上下级"><a href="#2-嵌套关系-父子-x2F-上下级" class="headerlink" title="2.嵌套关系(父子&#x2F;上下级)"></a>2.嵌套关系(父子&#x2F;上下级)</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">      &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span><br><span class="line">      &lt;title&gt;音视频测试&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<blockquote>
<ul>
<li><h3 id="对HTML5语言有兴趣的同学-给大家极力推荐-江哥的视频HTML5-跨平台开发-只是不知道会不会继续更新"><a href="#对HTML5语言有兴趣的同学-给大家极力推荐-江哥的视频HTML5-跨平台开发-只是不知道会不会继续更新" class="headerlink" title="对HTML5语言有兴趣的同学,给大家极力推荐:江哥的视频HTML5 + 跨平台开发,只是不知道会不会继续更新"></a>对HTML5语言有兴趣的同学,给大家极力推荐:江哥的视频<a href="http://study.163.com/course/introduction.htm?courseId=1003864040">HTML5 + 跨平台开发</a>,只是不知道会不会继续更新</h3></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML5学习笔记之基础标签</title>
    <url>/post/7ab2d054.html</url>
    <content><![CDATA[<p>HTML5学习笔记之基础标签</p>
<span id="more"></span>

<h2 id="列表标签"><a href="#列表标签" class="headerlink" title="列表标签"></a>列表标签</h2><h3 id="无序列表-unordered-list"><a href="#无序列表-unordered-list" class="headerlink" title="无序列表(unordered list)"></a>无序列表(unordered list)</h3><ul>
<li>无序 : 没有先后之分</li>
<li>给一堆内容添加无序列表语义(一个没有先后顺序整体), 列表中的条目是不分先后</li>
<li>ul应用场景:<ul>
<li>导航条</li>
<li>商品列表等</li>
<li>新闻列表</li>
</ul>
</li>
</ul>
<h4 id="格式"><a href="#格式" class="headerlink" title="格式:"></a>格式:</h4><ul>
<li>li 英文是 list item, 翻译为列表项</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">    &lt;h4&gt;中国城市列举(CN)&lt;/h4&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;北京&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;上海&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;广州&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;杭州&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-6170aa7da4bd362f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20170614_4.png"></p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h4><ul>
<li>ul是一个组标签, 一定是一坨一坨的出现, 也就是说li标签不能单独存在, 必须包裹在ul里面</li>
<li>由于ul和li是一个整体, 所以ul里面不推荐包裹其它标签, 永远记住ul里面最好只写li标签</li>
<li>虽然ul中推荐只能写li标签, 但是li标签是一个容器标签, li标签中可以添加任意标签, 甚至可以添加ul标签</li>
<li>其实ul还有一个type属性, 可以修改先导符号的样式, 取值有disc、square、circle几种</li>
</ul>
<table>
<thead>
<tr>
<th>取值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>disc</td>
<td>项目符号显示为实体圆心,默认值</td>
</tr>
<tr>
<td>square</td>
<td>项目符号显示为实体方心</td>
</tr>
<tr>
<td>circle</td>
<td>项目符号显示为空心圆</td>
</tr>
</tbody></table>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span>课程安排<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">        上午</span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>HTML5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>CSS<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">        下午</span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>OC<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>Swift<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-3e921651c9eb3c47.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20170614_5.png"></p>
<h3 id="有序列表-ordered-list"><a href="#有序列表-ordered-list" class="headerlink" title="有序列表(ordered list)"></a>有序列表(ordered list)</h3><ul>
<li>作用: 给一堆内容添加有序列表语义(一个有顺序整体), 列表中的条目有先后之分</li>
<li>ol应用场景:<ul>
<li>xxx排行榜</li>
<li>其实ol应用场景并不多, 因为能用ol做的用ul都能做</li>
<li>ul的常见属性start、type属性, 可以修改先导符号的样式和序号</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>取值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>使用数字作为项目符号</td>
</tr>
<tr>
<td>A&#x2F;a</td>
<td>使用大写&#x2F;小写字母作为项目符号</td>
</tr>
<tr>
<td>I&#x2F;i</td>
<td>使用大写&#x2F;小写罗马数字作为项目符号</td>
</tr>
</tbody></table>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span>中国房价排行榜<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>上海<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>杭州<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>广州<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>深圳<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-13f9b32478195bac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20170614_6.png"></p>
<h3 id="定义列表-definition-list"><a href="#定义列表-definition-list" class="headerlink" title="定义列表(definition list)"></a>定义列表(definition list)</h3><ul>
<li>给一堆内容添加列表语义, 通过dt罗列出列表的条目, 然后再通过dd给每个条目进行相应的描述</li>
<li>dl应用场景:<ul>
<li>网站底部相关信息</li>
<li>但凡看到一堆内容都是用于描述某一个内容的时候就要想到dl</li>
</ul>
</li>
</ul>
<h4 id="格式-1"><a href="#格式-1" class="headerlink" title="格式:"></a>格式:</h4><ul>
<li>dt英文definition title, 翻译为定义标题</li>
<li>dd英文definition description, 翻译为定义描述信息</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">&lt;dl&gt;</span><br><span class="line">    &lt;dt&gt;北京&lt;/dt&gt;</span><br><span class="line">    &lt;dd&gt;国家的首都&lt;/dd&gt;</span><br><span class="line">    &lt;dt&gt;杭州&lt;/dt&gt;</span><br><span class="line">    &lt;dd&gt;坑爹,房价上涨最快的地方&lt;/dd&gt;</span><br><span class="line">&lt;/dl&gt;</span><br><span class="line"></span><br><span class="line">![Snip20170614_7.png](http:<span class="comment">//upload-images.jianshu.io/upload_images/4122543-2d304b7b5f58b8c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span></span><br></pre></td></tr></table></figure>


<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-4429f20791990a71.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20170614_9.png"></p>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项:"></a>注意事项:</h4><ul>
<li>dl是一个<code>组标签</code>, 一定是一坨一坨的出现, 也就是说<code>dt</code>和<code>dd</code>标签不能单独存在, 必须包裹在<code>dl</code>里面</li>
<li>由于<code>dl</code>和<code>dt</code>、<code>dd</code>是一个整体, 所以<code>dl</code>里面不推荐包裹其它标签</li>
<li><code>dd</code>和<code>dt</code>和<code>li</code>标签一样是容器标签, 里面可以添加任意标签</li>
<li>定义列表非常灵活, 可以给一个<code>dt</code>配置多个<code>dd</code>, 但是最好不要出现多个<code>dt</code>对应一个<code>dd</code>, <code>dd</code>的语义是描述离它最近的一个<code>dt</code>, 所以其它<code>dt</code>相当于没有描述, 而定义列表存在的意义就是既可以列出每一个条目又可以对每一个条目进行描述</li>
<li>定义列表非常灵活, 可以将多个<code>dt+dd</code>组合拆分为多个<code>dl</code></li>
</ul>
<h3 id="列表对比"><a href="#列表对比" class="headerlink" title="列表对比"></a>列表对比</h3><table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
<th>项目符号</th>
</tr>
</thead>
<tbody><tr>
<td>无序列表</td>
<td>以<code>&lt;ul&gt;</code>标签来实现, 以<code>&lt;li&gt;</code>标签表示列表项</td>
<td>通过type属性设置项目符号: disc（默认）、square和circle</td>
</tr>
<tr>
<td>有序列表</td>
<td>以<code>&lt;ol&gt;</code>标签来实现, 以<code>&lt;li&gt;</code>标签表示列表项</td>
<td>通过type属性设置项目顺序: 1(数字，默认)、A(大写字母)、a(小写字母)、I(大写罗马数字)和i(小写罗马数字)</td>
</tr>
<tr>
<td>定义列表</td>
<td>以<code>&lt;dl&gt;</code>标签是实现, 以<code>&lt;dt&gt;</code>标签定义列表项, 以<code>&lt;dd&gt;</code>标签定义内容</td>
<td>无项目符号和显示顺序</td>
</tr>
</tbody></table>
<h2 id="H-x2F-P-x2F-Hr-x2F-br标签"><a href="#H-x2F-P-x2F-Hr-x2F-br标签" class="headerlink" title="H&#x2F;P&#x2F;Hr&#x2F;br标签"></a>H&#x2F;P&#x2F;Hr&#x2F;br标签</h2><h3 id="H系列标签"><a href="#H系列标签" class="headerlink" title="H系列标签"></a>H系列标签</h3><ul>
<li>用于给文本添加标题语义(Header 1~Header 6)</li>
<li>格式: <code>&lt;h1&gt;xxxxxx&lt;/h1&gt;</code></li>
<li>注意点:<ul>
<li>H标签是用来给文本添加标题语义的, 而不是用来修改文本的样式的</li>
<li>H标签一共有6个, 从H1~H6, 最多就只能到6, 超过6则无效</li>
<li>被H系列标签包裹的内容会独占一行</li>
<li>在H系列的标签中, H1最大, H6最小</li>
<li>在企业开发中, 一定要慎用H系列的标签, 特别是H1标签. 在企业开发中一般情况下一个界面中只能出现一个H1标签(和SEO有关)</li>
</ul>
</li>
</ul>
<h3 id="P标签-Paragraph"><a href="#P标签-Paragraph" class="headerlink" title="P标签(Paragraph)"></a>P标签(Paragraph)</h3><ul>
<li>告诉浏览器哪些文字是一个段落</li>
<li>格式: <code>&lt;p&gt;xxxxxxxx&lt;/p&gt;</code></li>
<li>在浏览器中会单独占一行</li>
</ul>
<h3 id="Hr标签-Horizontal-Rule"><a href="#Hr标签-Horizontal-Rule" class="headerlink" title="Hr标签(Horizontal Rule)"></a>Hr标签(Horizontal Rule)</h3><ul>
<li>在浏览器上显示一条分割线</li>
<li>格式: <code>&lt;hr /&gt;</code></li>
<li>注意点:<ul>
<li>在浏览器中会单独占一行</li>
<li>通过我的观察发现HR标签可以写&#x2F;也可以不写<ul>
<li>如果不写&#x2F;那么就是按照HTML的规范来编写</li>
<li>如果写上&#x2F;那么就是按照XHTML的规范来编写.</li>
</ul>
</li>
<li>由于hr标签是用来修改样式的, 所以不推荐使用. 今后开发中添加水平线一般都使用CSS盒子来做</li>
</ul>
</li>
</ul>
<h3 id="br标签-Break"><a href="#br标签-Break" class="headerlink" title="br标签(Break)"></a>br标签(Break)</h3><ul>
<li>作用: 让内容换行</li>
<li>格式: <code>&lt;br/&gt;</code></li>
<li>注意点:<ul>
<li>br的意思是不另起一个段落进行换行, 而网页中99.99%需要换行时都是因为另起了一个段落, 所以应该用p来做</li>
</ul>
</li>
</ul>
<h3 id="字体样式标签"><a href="#字体样式标签" class="headerlink" title="字体样式标签"></a>字体样式标签</h3><ul>
<li>加粗：<code>&lt;strong&gt;…&lt;/strong&gt;</code>、<code>&lt;b&gt;..&lt;/b&gt;</code></li>
<li>斜体：<code>&lt;em&gt;…&lt;/em&gt;</code>、<code>&lt;i&gt;&lt;/i&gt;</code></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">strong</span>&gt;</span>徐志摩人物简介<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">em</span>&gt;</span>1910<span class="tag">&lt;/<span class="name">em</span>&gt;</span>年入杭州学堂<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">em</span>&gt;</span>1918<span class="tag">&lt;/<span class="name">em</span>&gt;</span>年赴美国克拉大学学习银行学<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="注释和特殊符号"><a href="#注释和特殊符号" class="headerlink" title="注释和特殊符号"></a>注释和特殊符号</h3><table>
<thead>
<tr>
<th>特殊符号</th>
<th>字符实体</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>空格</td>
<td><code>&amp;nbsp;</code></td>
<td><code>&lt;a href=&quot;#&quot;&gt;百度&lt;/a&gt;&amp;nbsp; &amp;nbsp;&lt;a href=&quot;#&quot;&gt;新浪&lt;/a&gt;</code></td>
</tr>
<tr>
<td>大于号(&gt;)</td>
<td><code>&amp;gt;</code></td>
<td>如果时间<code>&amp;gt;</code>晚上6点，就坐车回家</td>
</tr>
<tr>
<td>小于号(&lt;)</td>
<td><code>&amp;lt;</code></td>
<td>如果时间<code>&amp;lt;</code>早上7点，就走路去上学</td>
</tr>
<tr>
<td>引号(“)</td>
<td><code>&amp;quot;</code></td>
<td>W3C规范中，HTML的属性值必须用成对的<code>&amp;quot;</code>引起来</td>
</tr>
<tr>
<td>版权符号©</td>
<td><code>&amp;copy;</code></td>
<td><code>&amp;copy;</code> 2003-2013</td>
</tr>
</tbody></table>
<h3 id="HTML注释-Annotation"><a href="#HTML注释-Annotation" class="headerlink" title="HTML注释(Annotation)"></a>HTML注释(Annotation)</h3><h4 id="什么是注释"><a href="#什么是注释" class="headerlink" title="什么是注释"></a>什么是注释</h4><ul>
<li>注释格式: <code>&lt;!--被注释的内容--&gt;</code></li>
<li>注意点:<ul>
<li>被注释的内容不会在浏览器中显示, 注释是写给我们自己看的<ul>
<li>注释不能嵌套使用</li>
</ul>
</li>
</ul>
</li>
<li>快捷键: <code>ctrl + /</code></li>
</ul>
<p><code>&lt;!--&lt;!--被注释的内容--&gt;--&gt;</code></p>
<h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">&lt;h1&gt;标题<span class="number">1</span>&lt;/h1&gt;</span><br><span class="line">&lt;h2&gt;标题<span class="number">2</span>&lt;/h2&gt;</span><br><span class="line">&lt;h3&gt;标题<span class="number">3</span>&lt;/h3&gt;</span><br><span class="line">&lt;h4&gt;标题<span class="number">4</span>&lt;/h4&gt;</span><br><span class="line">&lt;h5&gt;标题<span class="number">5</span>&lt;/h5&gt;</span><br><span class="line">&lt;h6&gt;标题<span class="number">6</span>&lt;/h6&gt;</span><br><span class="line">&lt;h7&gt;我是假的,标题<span class="number">7</span>&lt;/h7&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--我是注释--&gt;</span><br><span class="line">&lt;hr /&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;告诉浏览器哪些文字是一个段落&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--下面是分割线--&gt;</span><br><span class="line">&lt;hr /&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-1ebb54835bf8f28b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20170614_10.png"></p>
<h2 id="img标签-image"><a href="#img标签-image" class="headerlink" title="img标签(image)"></a>img标签(image)</h2><ul>
<li>作用: 在网页上插入一张图片</li>
<li>格式: <code>![image](http://note.youdao.com/favicon.ico)</code></li>
<li>标签的属性<ul>
<li>写在标签中K&#x3D;”V”这种格式的文本我们称之为标签属性</li>
</ul>
</li>
<li>常见的图像格式<ul>
<li>JPG: Internet上被广泛支持，采用的是有损压缩，会造成图像失真，压缩之后体积小，且比较清晰，适合在网页中应用</li>
<li>GIF: 网页中使用最广泛、最普遍的，不仅支持透明色还支持动画，因此在网页中使用非常广泛</li>
<li>PNG: 兼有GIF和JPG的优势，同时具备GIF文件不具备的特性，唯一遗憾的是,PNG是一种新兴的图像格式，存在部分旧版本浏览器不支持的问题</li>
<li>BMP: Windows操作系统中使用的比较多，不支持文件压缩，也不适用与web页面</li>
</ul>
</li>
</ul>
<h3 id="属性介绍"><a href="#属性介绍" class="headerlink" title="属性介绍"></a>属性介绍</h3><table>
<thead>
<tr>
<th>属性名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>src(source)</td>
<td>告诉浏览器需要插入的图片路径, 以便于浏览器到该路径下找到需要插入的图片</td>
</tr>
<tr>
<td>alt(alternate)</td>
<td>规定图像的替代文本, 只有在src指定的路径下找不到图片,才会显示alt指定的文本</td>
</tr>
<tr>
<td>title</td>
<td>悬停文本(介绍这张图片, 只有在鼠标移动到图片上时才会显示)</td>
</tr>
<tr>
<td>height</td>
<td>设置图片显示的高度</td>
</tr>
<tr>
<td>width</td>
<td>设置图片显示的宽度</td>
</tr>
</tbody></table>
<h3 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h3><p>img标签添加的图片默认不是占一整行空间<br>如果想让图片等比拉伸,只写高度或者宽度即可</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">&lt;!--图片标签--&gt;</span><br><span class="line">![](http:<span class="comment">//note.youdao.com/favicon.ico)</span></span><br><span class="line">![有道云笔记](http:<span class="comment">//note.youdao.com/favicon.ico)</span></span><br><span class="line">![有道云笔记](http:<span class="comment">//note.youdao.com/favicon.ico)</span></span><br><span class="line">![有道云笔记](http:<span class="comment">//note.youdao.com/favicon.ico)</span></span><br><span class="line">![有道云笔记](http:<span class="comment">//note.youdao.com/favicon.ico)</span></span><br><span class="line">![有道云笔记](http:<span class="comment">//note.youdao.com/favicon.ico)</span></span><br><span class="line">&lt;img src=<span class="string">&quot;&quot;</span> alt=<span class="string">&quot;找不到图片&quot;</span>&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-9ff009b644bc64cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20170614_12.png"></p>
<h2 id="a标签-anchor"><a href="#a标签-anchor" class="headerlink" title="a标签(anchor)"></a>a标签(anchor)</h2><ul>
<li>页面间链接<ul>
<li>从一个页面链接到另外一个页面</li>
</ul>
</li>
<li>锚链接<ul>
<li>从A页面的甲位置跳转到A页面的乙位置</li>
<li>从A页面的甲位置跳转到B页面的乙位置</li>
<li>在目标标签中设置id属性&#x3D;值，链接处href&#x3D;”[路径]#值”</li>
<li>设置<a name=”值”>目标处</a>，在链接处链接处href&#x3D;”[路径]#值”</li>
</ul>
</li>
<li>注意事项:<ul>
<li>在a标签之间一定要写上文字, 如果没有, 那么在页面上找不到这个标签<br>a标签也叫做超级链接或超链接</li>
</ul>
</li>
<li>格式:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;目标窗口位置&quot;&gt;链接文本或图像&lt;/a&gt;</span><br></pre></td></tr></table></figure>



<h3 id="a标签的属性"><a href="#a标签的属性" class="headerlink" title="a标签的属性"></a>a标签的属性</h3><table>
<thead>
<tr>
<th>属性名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>href(hypertext reference)</td>
<td>指定跳转的目标地址</td>
</tr>
<tr>
<td>target</td>
<td>告诉浏览器是否保留原始界面, _blank保留, _self不保留</td>
</tr>
<tr>
<td>title</td>
<td>悬停文本(介绍这个链接, 只有在鼠标移动到超链接上时才会显示)</td>
</tr>
</tbody></table>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">&lt;!--a标签--&gt;</span><br><span class="line">&lt;a href=<span class="string">&quot;http://www.jianshu.com/u/5bd5e9ed569e&quot;</span>&gt;我的简书&lt;/a&gt;</span><br><span class="line">&lt;a href=<span class="string">&quot;http://www.jianshu.com/u/5bd5e9ed569e&quot;</span> title=<span class="string">&quot;我的简书&quot;</span>&gt;我的简书&lt;/a&gt;</span><br><span class="line">&lt;a href=<span class="string">&quot;http://www.jianshu.com/u/5bd5e9ed569e&quot;</span> title=<span class="string">&quot;我的简书&quot;</span> target=<span class="string">&quot;_blank&quot;</span>&gt;我的简书&lt;/a&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-b60bbd6bcf56af2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20170614_13.png"></p>
<h3 id="base标签和a标签结合使用"><a href="#base标签和a标签结合使用" class="headerlink" title="base标签和a标签结合使用"></a>base标签和a标签结合使用</h3><ul>
<li>如果每个a标签都想在新页面中打开,那么逐个设置a标签的<code>target</code>属性比较麻烦, 这时我们可以使用base和a标签结合的方式,一次性设置有a标签都在新页面中打开<ul>
<li>格式: <code>&lt;base target=&quot;_blank&quot; /&gt;</code></li>
</ul>
</li>
<li>注意事项:<ul>
<li><code>base</code>必须嵌套在<code>head</code>标签里面</li>
<li>如果标签上指定了<code>target</code>,<code>base</code>中也指定了<code>target</code>,那么会按照标签上指定的来执行</li>
</ul>
</li>
</ul>
<h3 id="a标签其它用法"><a href="#a标签其它用法" class="headerlink" title="a标签其它用法"></a>a标签其它用法</h3><ul>
<li>假链接(本质是跳转到当前页面)<ul>
<li>格式<code>&lt;a href=&quot;#&quot;&gt;我的简书&lt;/a&gt;</code></li>
<li>格式<code>&lt;a href=&quot;javascript:&quot;&gt;我的简书&lt;/a&gt;</code><ul>
<li>跳转到当前页面指定位置(锚点链接)</li>
<li>1.格式<code>&lt;a href=&quot;#location&quot;&gt;</code>跳转到指定位置<code>&lt;/a&gt;</code></li>
<li>2.在页面的指定位置给任意标签添加一个id属性<ul>
<li>例如 <code>&lt;p id=&quot;location&quot;&gt;</code>这个是目标<code>&lt;/p&gt;</code></li>
</ul>
</li>
</ul>
</li>
<li>跳转到指定页面的指定位置<ul>
<li>格式: <code>&lt;a href=&quot;01-锚点链接.html#location&quot;&gt;跳转到指定位置&lt;/a&gt;</code></li>
<li>只需要在01-锚点链接.html页面添加一个id位置即可</li>
</ul>
</li>
<li>下载(极力不推荐使用)<ul>
<li>例如<code>&lt;a href=&quot;girl.zip&quot;&gt;</code>下载福利资源<code>&lt;a/&gt;</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>对HTML5语言有兴趣的同学,给大家极力推荐:江哥的视频<a href="http://study.163.com/course/introduction.htm?courseId=1003864040">HTML5 + 跨平台开发</a>,只是不知道会不会继续更新</p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML5学习笔记之表单标签</title>
    <url>/post/8930c83.html</url>
    <content><![CDATA[<p><img data-src="http://upload-images.jianshu.io/upload_images/647982-9f6f2cfcfdf04c42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<span id="more"></span>


<ul>
<li>作用: 用于收集用户信息, 让用户填写、选择相关信息</li>
<li>注意事项:<ul>
<li>所有的表单内容，都要写在form标签里面<br>form标签中有两个比较重要的属性action和method</li>
</ul>
</li>
<li>格式:</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">&lt;form&gt;</span><br><span class="line">    所有的表单内容，都要写在form标签里面</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>


<h2 id="input标签"><a href="#input标签" class="headerlink" title="input标签"></a>input标签</h2><blockquote>
<p>如果说td是表格最核心的标签, 那么input就是表单最核心的标签. nput标签有一个type属性, 这个属性有很多类型的取值, 取值的不同就决定了input标签的功能和外观不同</p>
</blockquote>
<h3 id="明文输入框"><a href="#明文输入框" class="headerlink" title="明文输入框"></a>明文输入框</h3><ul>
<li>作用: 用户可以在输入框内输入内容</li>
<li>账号: <code>&lt;input type=&quot;text&quot;/&gt;</code></li>
<li>暗文输入框<ul>
<li>作用: 用户可以在输入框内输入内容</li>
<li>密码: <code>&lt;input type=&quot;password&quot;/&gt;</code></li>
</ul>
</li>
<li>给输入框设置默认值<ul>
<li>账号: <code>&lt;input type=&quot;text&quot;  value=&quot;tqj&quot;/&gt;</code></li>
<li>密码: <code>&lt;input type=&quot;password&quot; value=&quot;0929&quot;/&gt;</code></li>
</ul>
</li>
<li>规定输入字段中的字符的最大长度<ul>
<li>账号: <code>&lt;input type=&quot;text&quot; name=&quot;fullname&quot; maxlength=&quot;8&quot; /&gt;</code></li>
</ul>
</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--明文输入框--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>账号: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--暗文输入框--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>密码: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--p标签换行--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>账号: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;tqj&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>密码: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0929&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>最大长度: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">maxlength</span>=<span class="string">&quot;5&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-39cbc042f6cfbdb1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20170615_22.png"></p>
<h3 id="选框"><a href="#选框" class="headerlink" title="选框"></a>选框</h3><ul>
<li>单选框(radio)<ul>
<li>作用: 用户只能从众多选项中选择其中一个</li>
<li>单选按钮，天生是不互斥的，如果想互斥，必须要有相同的name属性</li>
</ul>
</li>
<li>多选框(checkbox)<ul>
<li>作用: 用户只能从众多选项中选择多个</li>
<li>复选框，最好也是有相同的name（虽然他不需要互斥，但是也要有相同的name）</li>
</ul>
</li>
<li>label标签<ul>
<li>作用: label标签不会向用户呈现任何特殊效果。不过，它为鼠标用户改进了可用性</li>
<li>注意事项: 表单元素要有一个id，然后label标签就有一个for属性，for属性和id相同就表示绑定了</li>
<li>所有表单元素都可以通过label绑定</li>
</ul>
</li>
<li>示例代码</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--单选框--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--checked属性,为默认值--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;sex&quot;</span>&gt;</span>性别: <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">checked</span> /&gt;</span> <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;sex&quot;</span>&gt;</span>男<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> /&gt;</span> <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;sex&quot;</span>&gt;</span>女<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> /&gt;</span> <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;sex&quot;</span>&gt;</span>妖<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--多选框--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;课程&quot;</span>&gt;</span>课程: <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;课程&quot;</span> <span class="attr">checked</span> /&gt;</span> <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;课程&quot;</span>&gt;</span>HTML5 <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;课程&quot;</span> <span class="attr">checked</span> /&gt;</span> <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;课程&quot;</span>&gt;</span>Swift <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;课程&quot;</span> /&gt;</span> <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;课程&quot;</span>&gt;</span>OC <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;课程&quot;</span> /&gt;</span> <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;课程&quot;</span>&gt;</span>CSS <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-141c73672aca00ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20170615_1.png"></p>
<h3 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h3><h4 id="普通按钮"><a href="#普通按钮" class="headerlink" title="普通按钮"></a>普通按钮</h4><p> 作用: 定义可点击按钮（多数情况下，用于通过 JavaScript 启动脚本）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;button&quot; value=&quot;点我丫&quot; /&gt;</span><br></pre></td></tr></table></figure>


<h4 id="图片按钮"><a href="#图片按钮" class="headerlink" title="图片按钮"></a>图片按钮</h4><p> 作用:定义图像形式的提交按钮</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;image&quot; src=&quot;1.png&quot; /&gt;</span><br></pre></td></tr></table></figure>

<h4 id="还原按钮"><a href="#还原按钮" class="headerlink" title="还原按钮"></a>还原按钮</h4><p> 作用: 定义还原按钮。还原按钮会清除表单中的所有数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;reset&quot; /&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意事项:<br>这个按钮不需要写value自动就有“还原”文字<br>reset只对form表单中表单项有效果</p>
</blockquote>
<h4 id="提交按钮"><a href="#提交按钮" class="headerlink" title="提交按钮"></a>提交按钮</h4><p> 作用:定义提交按钮。提交按钮会把表单数据发送到action属性指定的页面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;submit&quot; /&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意事项:<ul>
<li>这个按钮不需要写value自动就有“提交”文字</li>
<li>要想通过submit提交数据到服务器, 被提交的表单项都必须设置name属性</li>
<li>默认明文传输(GET)不安全, 可以将method属性设置为POST改为非明文传输(学到Ajax再理解)</li>
</ul>
</li>
</ul>
<h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--按钮--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--普通按钮--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;点我有奖&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--图片按钮--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;image&quot;</span> <span class="attr">src</span>=<span class="string">&quot;http://note.youdao.com/favicon.ico&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--还原按钮--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--提交按钮--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-df3952d22685cb6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20170615_3.png"></p>
<h3 id="隐藏域"><a href="#隐藏域" class="headerlink" title="隐藏域"></a>隐藏域</h3><ul>
<li>作用: 定义隐藏的输入字段</li>
<li>暂时不用掌握, 在Ajax中对数据的CRUD操作有非常大的作用</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;hidden&quot;&gt;</span><br></pre></td></tr></table></figure>




<h3 id="取色器和日期选择器"><a href="#取色器和日期选择器" class="headerlink" title="取色器和日期选择器"></a>取色器和日期选择器</h3><ul>
<li>取色器: <code>&lt;input type=&quot;color&quot;&gt;</code></li>
<li>日期选色器: <code>&lt;input type=&quot;date&quot;&gt;</code></li>
<li>HTML5中input类型增加了很多type类型, 例如color、date但是都不兼容, 后面讲到浏览器兼容时会重点讲解</li>
<li>亲测,在Mac电脑的Safari浏览器不兼容,只能用谷歌浏览器</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--取色器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span>颜色: <span class="tag">&lt;/<span class="name">label</span>&gt;</span> <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;color&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--换行--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--日期选色器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span>时间: <span class="tag">&lt;/<span class="name">label</span>&gt;</span> <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;date&quot;</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-af39ca426f317aec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20170615_5.png"></p>
<h3 id="数据列表"><a href="#数据列表" class="headerlink" title="数据列表"></a>数据列表</h3><ul>
<li>作用: 给输入框绑定待选项</li>
<li>格式:</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">datalist&gt;</span><br><span class="line">  &lt;option&gt;待选项内容&lt;/option&gt;</span><br><span class="line">&lt;/datalist&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>如何给输入框绑定待选列表<ul>
<li>搞一个输入框</li>
<li>搞一个datalist列表</li>
<li>给datalist列表标签添加一个id</li>
<li>给输入框添加一个list属性,将datalist的id对应的值赋值给list属性即可</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--数据列表--&gt;</span></span><br><span class="line">请选择车型: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">list</span>=<span class="string">&quot;cars&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">datalist</span> <span class="attr">id</span>=<span class="string">&quot;cars&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>奔驰<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>宝马<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>奥迪<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>别克<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>奔腾<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>奔跑<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">datalist</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-5e9e1c3b75a16426.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20170615_6.png"></p>
<p> 当输入某一个字符时,会自动根据datalist列表查询,并显示对应的列表,如图:</p>
<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-4973010e14b7d6c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20170615_7.png"></p>
<h2 id="多行文本框-文本域"><a href="#多行文本框-文本域" class="headerlink" title="多行文本框(文本域)"></a>多行文本框(文本域)</h2><ul>
<li><p>作用: textarea标签用于在表单中定义多行的文本输入控件</p>
<ul>
<li>cols属性表示columns“列”, 规定文本区内的可见宽度</li>
<li>rows属性表示rows“行”, 规定文本区内的可见高度</li>
</ul>
</li>
<li><p>格式:<br><code>&lt;textarea cols=&quot;30&quot; rows=&quot;10&quot;&gt;</code>默认<code>&lt;/textarea&gt;</code></p>
</li>
<li><p>注意点:</p>
<ul>
<li>可以通过cols和rows来指定输入框的宽度和高度</li>
<li>默认情况下输入框是可以手动拉伸的</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--禁止手动拉伸--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">textarea</span>&#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">resize</span>: none;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="下拉列表"><a href="#下拉列表" class="headerlink" title="下拉列表"></a>下拉列表</h2><ul>
<li>作用: select标签和ul、ol、dl一样，都是组标签. 用于创建表单中的待选列表<ul>
<li>和radio、checkbox一样select也可以设置默认值, 通过selected属性设置(本身默认是第一个选项)</li>
</ul>
</li>
<li>给下拉列表添加分组</li>
<li>示例代码</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--给下拉表添加分组--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optgroup</span> <span class="attr">label</span>=<span class="string">&quot;杭州市&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span>&gt;</span>江干区<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span>&gt;</span>西湖区<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span>&gt;</span>滨江区<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span>&gt;</span>下城区<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">optgroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optgroup</span> <span class="attr">label</span>=<span class="string">&quot;烟台市&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span>&gt;</span>莱山区<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span>&gt;</span>芝罘区<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">optgroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">selected</span>&gt;</span>北京市<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-c9638bcbcf8e60f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20170615_8.png"></p>
<blockquote>
<p>对HTML5语言有兴趣的同学,给大家极力推荐:江哥的视频<a href="http://study.163.com/course/introduction.htm?courseId=1003864040">HTML5 + 跨平台开发</a>,只是不知道会不会继续更新</p>
</blockquote>
]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML5学习笔记之表格标签</title>
    <url>/post/9483b8e.html</url>
    <content><![CDATA[<p><img data-src="http://upload-images.jianshu.io/upload_images/647982-151e7c132c68a833.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<span id="more"></span>


<h3 id="作用"><a href="#作用" class="headerlink" title="作用:"></a>作用:</h3><ul>
<li>以表格形式将数据显示出来, 当数据量非常大的时候, 表格这种展现形式被认为是最为清晰的一种展现形式</li>
</ul>
<h3 id="格式"><a href="#格式" class="headerlink" title="格式:"></a>格式:</h3><ul>
<li>table定义表格</li>
<li>tr定义行</li>
<li>td定义单元格</li>
</ul>
<h3 id="表格中的属性"><a href="#表格中的属性" class="headerlink" title="表格中的属性"></a>表格中的属性</h3><ul>
<li><code>border</code>: 默认情况下表格的边框宽度为0看不到, 通过border属性给表格指定边框宽度</li>
<li><code>width</code>: 默认情况下表格的宽度是由内容自动计算出来的, 可以通过width属性指定表格的宽度</li>
<li><code>height</code>:默认情况下表格的高度是由内容自动计算出来的, 可以通过height属性指定表格的高度</li>
<li><code>cellspacing</code>: 外边距. 默认情况下单元格之间有2个像素的间隙, 可以通过cellpadding指定表格之间的间隙</li>
<li><code>cellpadding</code>: 内边距. 默认情况下单元格边缘距离内容有1个像素的内边距, 可以通过cellpadding属性指定单元格边缘和内容之间的内边距</li>
<li><code>align</code>: 规定表格相对周围元素的对齐方式, 它的取值有center、left、right<ul>
<li>给table设置align属性, 是让表格在浏览器中居左&#x2F;居右&#x2F;居中</li>
<li>给tr设置align属性, 是让当前行中所有内容居左&#x2F;居右&#x2F;居中</li>
<li>给td设置align属性,是让当前单元格中所有内容居左&#x2F;居右&#x2F;居中</li>
<li>该属性仅仅作为了解, 企业开发中用css代替, 因为HTML仅仅用于说明语义</li>
<li>如果td中设置了align属性, tr中也设置了align属性, 那么单元格中的内容会按照td中设置的来对齐</li>
</ul>
</li>
<li><code>valign</code>: 规定表格相对周围元素的对齐方式, 它的取值有center、left、right<ul>
<li>给table设置valign属性, 无效<br>给tr设置valign属性, 是让当前行中所有内容居上&#x2F;居中&#x2F;居下</li>
<li>给td设置valign属性,是让当前单元格中所有内容居上&#x2F;居中&#x2F;居下</li>
<li>如果td中设置了valign属性, tr中也设置了valign属性, 那么单元格中的内容会按照td中设置的来对齐</li>
</ul>
</li>
<li><code>bgcolor</code>:规定表格的背景颜色<ul>
<li>给table设置bgcolor属性, 是给整个表格设置背景颜色</li>
<li>给tr设置bgcolor属性, 是给当前行设置背景颜色</li>
<li>给td设置bgcolor属性, 是给当前单元格设置背景颜色</li>
<li>该属性仅仅作为了解, 企业开发中用css代替, 因为HTML仅仅用于说明语义</li>
</ul>
</li>
</ul>
<h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">&lt;!--表格标签--&gt;</span><br><span class="line">&lt;!--先定义一个表格, 然后通过tr告诉浏览器这个表格中一共有多少行, 然后再通过td告诉浏览器这一行中一共有多少个元素(一共有多少列)--&gt;</span><br><span class="line">&lt;table border=<span class="string">&quot;1&quot;</span> width=<span class="string">&quot;500&quot;</span> cellpadding=<span class="string">&quot;5&quot;</span> cellspacing=<span class="string">&quot;10&quot;</span>&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="展示样式"><a href="#展示样式" class="headerlink" title="展示样式"></a>展示样式</h4><p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-cac6e5756352e691.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20170614_17.png"></p>
<h3 id="表格中的其它标签"><a href="#表格中的其它标签" class="headerlink" title="表格中的其它标签"></a>表格中的其它标签</h3><ul>
<li>表单中有两种类型的单元格, 一种是标准单元格td, 一种是表头单元格th</li>
<li>th标签: 给每一列设置标题, 单元格中的内容会自动加粗，居中</li>
<li>caption标签:给整个表格设置标题<ul>
<li>一定要嵌套在talbe标签内部才有效</li>
</ul>
</li>
</ul>
<h4 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">&lt;table bgcolor=<span class="string">&quot;#5f9ea0&quot;</span> cellspacing=<span class="string">&quot;1px&quot;</span> width=<span class="string">&quot;1000&quot;</span> align=<span class="string">&quot;center&quot;</span>&gt;</span><br><span class="line">    &lt;caption&gt;</span><br><span class="line">        &lt;h2&gt;这周代码量排行榜&lt;/h2&gt;</span><br><span class="line">    &lt;/caption&gt;</span><br><span class="line">    &lt;tr bgcolor=<span class="string">&quot;#8a2be2&quot;</span>&gt;</span><br><span class="line">        &lt;th&gt;排名&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;关键词&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;趋势&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;今日搜索&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;最近一天&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;最近一天相关链接&lt;/th&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;tr bgcolor=<span class="string">&quot;#f0ffff&quot;</span> align=<span class="string">&quot;center&quot;</span>&gt;</span><br><span class="line">        &lt;td&gt;<span class="number">1</span>&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;穷爸爸富爸爸&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;上涨&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;<span class="number">456</span>&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;<span class="number">234214</span>&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;</span><br><span class="line">            &lt;a href=<span class="string">&quot;#&quot;</span>&gt;贴吧&lt;/a&gt;</span><br><span class="line">            &lt;a href=<span class="string">&quot;#&quot;</span>&gt;百度&lt;/a&gt;</span><br><span class="line">            &lt;a href=<span class="string">&quot;#&quot;</span>&gt;杭州&lt;/a&gt;</span><br><span class="line">        &lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;tr bgcolor=<span class="string">&quot;#f0ffff&quot;</span> align=<span class="string">&quot;center&quot;</span>&gt;</span><br><span class="line">        &lt;td&gt;<span class="number">2</span>&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;穷爸爸富爸爸&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;上涨&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;<span class="number">234</span>&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;<span class="number">3423542</span>&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;</span><br><span class="line">            &lt;a href=<span class="string">&quot;#&quot;</span>&gt;贴吧&lt;/a&gt;</span><br><span class="line">            &lt;a href=<span class="string">&quot;#&quot;</span>&gt;百度&lt;/a&gt;</span><br><span class="line">            &lt;a href=<span class="string">&quot;#&quot;</span>&gt;杭州&lt;/a&gt;</span><br><span class="line">        &lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br></pre></td></tr></table></figure>
<h4 id="展示样式-1"><a href="#展示样式-1" class="headerlink" title="展示样式"></a>展示样式</h4><p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-70f5e09e43e7df60.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20170615_19.png"></p>
<h3 id="表格的结构"><a href="#表格的结构" class="headerlink" title="表格的结构"></a>表格的结构</h3><ul>
<li>thead标签:用来存放当前列的表头, 如果没有加css页面默认将表头中的高度设置变小</li>
<li>tbody标签:一般用来存放页面中的主体数据, 如果不写会自动加上</li>
<li>tfoot标签:用来存放表格的页脚（脚注或表注), 如果没有加css页面默认将表头中的高度设置变小, 一般不会出现</li>
</ul>
<h4 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">&lt;table bgcolor=<span class="string">&quot;#7fffd4&quot;</span> width=<span class="string">&quot;800&quot;</span> cellspacing=<span class="string">&quot;2&quot;</span> align=<span class="string">&quot;center&quot;</span>&gt;</span><br><span class="line">    &lt;caption&gt;我是表格标题&lt;/caption&gt;</span><br><span class="line">    &lt;thead&gt;</span><br><span class="line">    &lt;tr align=<span class="string">&quot;center&quot;</span>&gt;</span><br><span class="line">        &lt;th&gt;每一列的标题&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;每一列的标题&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;每一列的标题&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;每一列的标题&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;每一列的标题&lt;/th&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;/thead&gt;</span><br><span class="line">    &lt;tbody&gt;</span><br><span class="line">    &lt;tr align=<span class="string">&quot;center&quot;</span>&gt;</span><br><span class="line">        &lt;td&gt;数据&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;数据&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;数据&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;数据&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;数据&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;/tbody&gt;</span><br><span class="line">    &lt;tfoot&gt;</span><br><span class="line">    &lt;tr align=<span class="string">&quot;center&quot;</span>&gt;</span><br><span class="line">        &lt;td&gt;数据&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;数据&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;数据&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;数据&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;数据&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;/tfoot&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure>

<h4 id="展示样式-2"><a href="#展示样式-2" class="headerlink" title="展示样式"></a>展示样式</h4><p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-00a3d46f21a7cce7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20170615_20.png"></p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>表格结构的意义主要是用于SEO, 便于搜索引擎指定哪部分的内容是需要抓取的重要内容, 一般情况下搜索引擎会优先抓取tbody中的内容</li>
<li>由于有一部分浏览器对talbe的这种结构支持不是很好, 所以在企业开发中一般都不用严格的按照这种结构来编写</li>
</ul>
<blockquote>
<p>对HTML5语言有兴趣的同学,给大家极力推荐:江哥的视频<a href="http://study.163.com/course/introduction.htm?courseId=1003864040">HTML5 + 跨平台开发</a>,只是不知道会不会继续更新</p>
</blockquote>
]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客不蒜子统计不显示</title>
    <url>/post/641ca9b6.html</url>
    <content><![CDATA[<p><img data-src="http://titanjun.oss-cn-hangzhou.aliyuncs.com/hexo-next/busuanzi.png" alt="image"></p>
<span id="more"></span>

<ul>
<li>10月份开始引用不蒜子作为静态网站的博客的统计功能都无法显示了, 刚开始还以为是自己的博客修改了什么文件所致, 随之查看了好多其他博客, 发现好多类似的网站统计都不显示了</li>
<li>随后上<a href="http://ibruce.info/2015/04/04/busuanzi/">不蒜子的官网</a>看了一下，才知道，原来不蒜子的域名更改了，导致<code>script</code>引用不了，从而无法进行统计</li>
<li>下面是不蒜子官网的公告</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">！！！！2018年9月 - 重要提示 ！！！！</span><br><span class="line">大家好，因七牛强制过期原有的『dn-lbstatics.qbox.me』域名（预计2018年10月初），与客服沟通数次无果，即使我提出为此付费也不行，只能更换域名到『busuanzi.ibruce.info』！因我是最早的一批七牛用户，为七牛至少带来了数百个邀请用户，很痛心，很无奈！</span><br><span class="line">各位继续使用不蒜子提供的服务，只需把原有的：</span><br><span class="line">&lt;script async src=&quot;//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">域名改一下即可：</span><br><span class="line">&lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">只需要修改该js域名，其他均未改变。若有疑问，可以加入不蒜子交流QQ群：`419260983`，对您带来的不便，非常抱歉！！！还是那句话，不蒜子不会中断服务！！！！</span><br></pre></td></tr></table></figure>


<p>所以想要继续使用不蒜子功能，只需修改对应的不蒜子域名即可</p>
<div class="note success"><p>所需修改文件地址</p></div>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">…/next/layout/_third-party/analytics/busuanzi-counter.swig</span><br></pre></td></tr></table></figure>

<p>原代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script <span class="keyword">async</span> src=<span class="string">&quot;//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>修改后代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script <span class="keyword">async</span> src=<span class="string">&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>


<p>我的博客: <a href="https://www.titanjun.top/">https://www.titanjun.top/</a></p>
]]></content>
      <categories>
        <category>Hexo博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML5学习笔记之音视频标签</title>
    <url>/post/d95c95af.html</url>
    <content><![CDATA[<p><img data-src="http://upload-images.jianshu.io/upload_images/647982-0d0c0be17835a633.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<span id="more"></span>


<h2 id="video标签"><a href="#video标签" class="headerlink" title="video标签"></a>video标签</h2><h3 id="作用-播放视频"><a href="#作用-播放视频" class="headerlink" title="作用: 播放视频"></a>作用: 播放视频</h3><h3 id="video标签格式1"><a href="#video标签格式1" class="headerlink" title="video标签格式1:"></a>video标签格式1:</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="video标签的属性"><a href="#video标签的属性" class="headerlink" title="video标签的属性"></a>video标签的属性</h4><ul>
<li>src: 告诉video标签需要播放的视频地址</li>
<li>autoplay: 告诉video标签是否需要自动播放视频</li>
<li>controls:告诉video标签是否需要显示控制条</li>
<li>poster: 告诉video标签视频没有播放之前显示的占位图片</li>
<li>loop: 告诉video标签循环播放视频. 一般用于做广告视频</li>
<li>preload: 告诉video标签预加载视频, 但是需要注意preload和autoplay相冲, 如果设置了autoplay属性, 那么preload属性就会失效</li>
<li>muted:告诉video标签视频静音</li>
<li>width&#x2F;height: 和img标签中的一模一样</li>
</ul>
<h3 id="video标签格式2"><a href="#video标签格式2" class="headerlink" title="video标签格式2"></a>video标签格式2</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;&quot;</span> <span class="attr">type</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;&quot;</span> <span class="attr">type</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure>


<ul>
<li>第二种格式存在的意义<ul>
<li>由于视频数据非常非常的重要, 所以五大浏览器厂商都不愿意支持别人的视频格式, 所以导致了没有一种视频格式是所有浏览器都支持的这个时候W3C为了解决这个问题, 所以推出了第二个video标签的格式</li>
<li>video标签的第二种格式存在的意义就是为了解决浏览器适配问题. video 元素支持三种视频格式, 我们可以把这三种格式都通过source标签指定给video标签, 那么以后当浏览器播放视频时它就会从这三种中选择一种自己支持的格式来播放</li>
</ul>
</li>
<li>注意点:<ul>
<li>当前通过video标签的第二种格式虽然能够指定所有浏览器都支持的视频格式, 但是想让所有浏览器都通过video标签播放视频还有一个前提条件, 就是浏览器必须支持HTML5标签, 否则同样无法播放</li>
<li>在过去的一些浏览器是不支持HTML5标签的, 所以为了让过去的一些浏览器也能够通过video标签来播放视频, 那么我们以后可以通过一个JS的框架叫做html5media来实现</li>
</ul>
</li>
</ul>
<h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">&lt;video width=<span class="string">&quot;200&quot;</span> height=<span class="string">&quot;100&quot;</span> poster=<span class="string">&quot;http://www.youname.com/images/first.png&quot;</span> autoplay=<span class="string">&quot;autoplay&quot;</span> preload=<span class="string">&quot;none&quot;</span> controls=<span class="string">&quot;controls&quot;</span>&gt;</span><br><span class="line">    &lt;!--楚乔传,好像是第<span class="number">4</span>集--&gt;</span><br><span class="line">    &lt;source src=<span class="string">&quot;https://v.qq.com/x/cover/dhzimk1qzznf301/t0024jjys1q.html?ptag=baidu.aladdin.tv&quot;</span> &gt;</span><br><span class="line">    &lt;source src=<span class="string">&quot;http://www.youname.com/images/first.ogg&quot;</span> /&gt;</span><br><span class="line">&lt;/video&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="audio标签"><a href="#audio标签" class="headerlink" title="audio标签"></a>audio标签</h2><ul>
<li>作用: 播放音频</li>
<li>注意点:<ul>
<li>audio标签的使用和video标签的使用基本一样</li>
<li>video中能够使用的属性在audio标签中大部分都能够使用, 并且功能都一样</li>
<li>只不过有3个属性不能用,<code>height/width/poster</code></li>
</ul>
</li>
<li>格式:</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">audio</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;&quot;</span> <span class="attr">type</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="三-详情和概要标签"><a href="#三-详情和概要标签" class="headerlink" title="三.详情和概要标签"></a>三.详情和概要标签</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用:"></a>作用:</h3><ul>
<li>利用summary标签来描述概要信息, 利用details标签来描述详情信息</li>
<li>默认情况下是折叠展示, 想看见详情必须点击</li>
</ul>
<h3 id="格式"><a href="#格式" class="headerlink" title="格式:"></a>格式:</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">details</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">summary</span>&gt;</span>概要信息<span class="tag">&lt;/<span class="name">summary</span>&gt;</span></span><br><span class="line">    详情信息</span><br><span class="line"><span class="tag">&lt;/<span class="name">details</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--详情和概要标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">details</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">summary</span>&gt;</span>概要信息<span class="tag">&lt;/<span class="name">summary</span>&gt;</span></span><br><span class="line">    这里是详情: 是假的呢举案说法南石道街开发病那都是独守空房技能速度加快非农数据的看法山东矿机第三方看似简单妇女节看电视呢房间看电视开始的减肥纳斯达克今年初vdsfw的看法今年圣诞节开放男</span><br><span class="line"><span class="tag">&lt;/<span class="name">details</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-3bd310e521eed10e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20170615_9.png"></p>
<h2 id="marquee标签"><a href="#marquee标签" class="headerlink" title="marquee标签"></a>marquee标签</h2><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用:"></a>作用:</h3><p>跑马灯效果</p>
<h3 id="格式-1"><a href="#格式-1" class="headerlink" title="格式:"></a>格式:</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">marquee</span>&gt;</span>内容<span class="tag">&lt;/<span class="name">marquee</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="属性"><a href="#属性" class="headerlink" title="属性:"></a>属性:</h3><ul>
<li>direction: 设置滚动方向 left&#x2F;right&#x2F;up&#x2F;down</li>
<li>scrollamount: 设置滚动速度, 值越大就越快</li>
<li>loop: 设置滚动次数, 默认是-1, 也就是无限滚动</li>
<li>behavior: 设置滚动类型 slide滚动到边界就停止, alternate滚动到边界就弹回</li>
</ul>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点:"></a>注意点:</h3><blockquote>
<p>marquee标签不是W3C推荐的标签, 在W3C官方文档中也无法查询这个标签, 但是各大浏览器对这个标签的支持非常好</p>
</blockquote>
<h3 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--跑马灯-marquee标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">marquee</span> <span class="attr">direction</span>=<span class="string">&quot;left&quot;</span> <span class="attr">scrollamount</span>=<span class="string">&quot;5&quot;</span>&gt;</span>跑马灯<span class="tag">&lt;/<span class="name">marquee</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">marquee</span> <span class="attr">direction</span>=<span class="string">&quot;right&quot;</span> <span class="attr">scrollamount</span>=<span class="string">&quot;3&quot;</span>&gt;</span>marquee<span class="tag">&lt;/<span class="name">marquee</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">marquee</span> <span class="attr">direction</span>=<span class="string">&quot;up&quot;</span> <span class="attr">scrollamount</span>=<span class="string">&quot;1&quot;</span>&gt;</span>标签<span class="tag">&lt;/<span class="name">marquee</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">marquee</span> <span class="attr">direction</span>=<span class="string">&quot;down&quot;</span> <span class="attr">scrollamount</span>=<span class="string">&quot;1&quot;</span>&gt;</span>down<span class="tag">&lt;/<span class="name">marquee</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-6bc10b374b5e362e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20170615_10.png"></p>
<blockquote>
<p>注: 实际的效果中,这三个是一直在滚动的,只是图片看不到效果,自己亲自实践感受下吧!</p>
</blockquote>
<h2 id="HTML中被废弃的标签"><a href="#HTML中被废弃的标签" class="headerlink" title="HTML中被废弃的标签"></a>HTML中被废弃的标签</h2><blockquote>
<p>由于HTML现在只负责语义而不负责样式.但是HTML一开始有一部分标签连样式也包揽了, 所以这部分标签都被废弃了</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">b、u、i、s </span><br><span class="line">- 以上标签自己带有样式, 有浓厚的样式作用, 今后一般都只作为CSS钩子使用</span><br><span class="line">- 原则: 不到万不得已,切记不要使用如上标签. 大家可以到BAT的网站查看源代码, 几乎看不到以上标签</span><br></pre></td></tr></table></figure>

<ul>
<li>b(Bold)作用: 将文本字体加粗<ul>
<li>格式:<code>&lt;b&gt;将文本字体加粗&lt;/b&gt;</code></li>
</ul>
</li>
<li>u(Underlined)作用: 为文本添加下划线<ul>
<li>格式: <code>&lt;u&gt;为文本添加下划线&lt;/u&gt;</code></li>
</ul>
</li>
<li>i(Italic)作用: 显示斜体文本效果<ul>
<li>格式: <code>&lt;i&gt;显示斜体文本效果&lt;/i&gt;</code></li>
</ul>
</li>
<li>s(Strikethrough)作用: 为文本添加删除线<ul>
<li>格式: <code>&lt;s&gt;为文本添加删除线&lt;/s&gt;</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>为了弥补 b、u、i、s标签的不足, W3C又推出了一组新的标签, 这些标签在显示上看似和buis没什么区别, 但是在语义上却有重大区别</p>
</blockquote>
<ul>
<li>strong作用: 着重内容<ul>
<li>格式:<code>&lt;strong&gt;着重内容&lt;/strong&gt;</code></li>
</ul>
</li>
<li>ins(Inserted)作用: 新插入的文本<ul>
<li>格式:<code>&lt;ins&gt;新插入的文本&lt;/ins&gt;</code></li>
</ul>
</li>
<li>em(Emphasized)作用:强调内容<ul>
<li>格式:<code>&lt;em&gt;强调内容&lt;/em&gt;</code></li>
</ul>
</li>
<li>del(Deleted)作用: 已删除的文本<ul>
<li>格式:<code>&lt;del&gt;已删除的文本&lt;/del&gt;</code></li>
</ul>
</li>
</ul>
<p> 示例代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--新增标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">strong</span>&gt;</span>着重内容<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ins</span>&gt;</span>新插入的内容<span class="tag">&lt;/<span class="name">ins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">em</span>&gt;</span>强调的内容<span class="tag">&lt;/<span class="name">em</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">del</span>&gt;</span>已经删除的内容<span class="tag">&lt;/<span class="name">del</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-595238b7fcc8c71f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20170615_11.png"></p>
<blockquote>
<p>对HTML5语言有兴趣的同学,给大家极力推荐:江哥的视频<a href="http://study.163.com/course/introduction.htm?courseId=1003864040">HTML5 + 跨平台开发</a>,只是不知道会不会继续更新</p>
</blockquote>
]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客多台电脑设备同步管理</title>
    <url>/post/3ac2f657.html</url>
    <content><![CDATA[<ul>
<li>最近一直在折腾Hexo博客, 玩的可谓是不亦乐乎啊; 这里就整理一下之前遗留的一些问题和一些个性化配置</li>
<li>如有遇到搭建个人博客时遇到的问题, 这里可参考我的之前的两篇相关博客<ul>
<li><a href="https://titanjun.top/post/ab9cc174.html">基于GitHub和Hexo搭建个人博客</a></li>
<li><a href="https://titanjun.top/post/9eda55ce.html">NexT主题配置个性化设置</a></li>
</ul>
</li>
</ul>
<span id="more"></span>

<h2 id="个性化配置"><a href="#个性化配置" class="headerlink" title="个性化配置"></a>个性化配置</h2><h3 id="返回顶部按钮显示滚动进度"><a href="#返回顶部按钮显示滚动进度" class="headerlink" title="返回顶部按钮显示滚动进度"></a>返回顶部按钮显示滚动进度</h3><ul>
<li>打开主题配置文件 <code>~themes/next/_config.yml</code> 找到<code>sidebar</code>字段</li>
<li>把<code>scrollpercent</code>的属性改为<code>true</code>即可, 如下:</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">sidebar:</span><br><span class="line"># Sidebar Position - 侧栏位置（只对Pisces | Gemini两种风格有效）</span><br><span class="line">  position: left        <span class="comment">//靠左放置</span></span><br><span class="line">  <span class="meta">#position: right      <span class="comment">//靠右放置</span></span></span><br><span class="line"></span><br><span class="line"># Sidebar Display - 侧栏显示时机（只对Muse | Mist两种风格有效）</span><br><span class="line">  <span class="meta">#display: post        <span class="comment">//默认行为，在文章页面（拥有目录列表）时显示</span></span></span><br><span class="line">  display: always       <span class="comment">//在所有页面中都显示</span></span><br><span class="line">  <span class="meta">#display: hide        <span class="comment">//在所有页面中都隐藏（可以手动展开）</span></span></span><br><span class="line">  <span class="meta">#display: remove      <span class="comment">//完全移除</span></span></span><br><span class="line"></span><br><span class="line">  offset: <span class="number">12</span>            <span class="comment">//文章间距（只对Pisces | Gemini两种风格有效）</span></span><br><span class="line"></span><br><span class="line">  b2t: <span class="literal">false</span>            <span class="comment">//返回顶部按钮（只对Pisces | Gemini两种风格有效）</span></span><br><span class="line"></span><br><span class="line">  scrollpercent: <span class="literal">true</span>   <span class="comment">//返回顶部按钮的百分比</span></span><br></pre></td></tr></table></figure>

<h2 id="多设备管理博客"><a href="#多设备管理博客" class="headerlink" title="多设备管理博客"></a>多设备管理博客</h2><p>正常情况下, 我们博客的相关配置信息都是在本地的, 并未上传服务器, 这样当我们想在其他设备, 比如公司的电脑或者原电脑重装了系统, 那么我们便无法再维护我们的博客了</p>
<h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><ul>
<li>首先你需要在电脑上配置相关环境<ul>
<li>安装<code>Node.js</code></li>
<li>安装<code>git</code></li>
<li>安装<code>hexo</code></li>
</ul>
</li>
<li>具体安装方式, 可参考这里<a href="https://titanjun.top/post/ab9cc174.html">基于GitHub和Hexo搭建个人博客</a></li>
</ul>
<h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><ul>
<li><code>hexo</code>生成的静态博客文件都是上传到<code>GitHub</code>上的, 且默认放在<code>master</code>分支上, 而一些相关的配置文件都在本地</li>
<li><code>hexo</code>的源文件（部署环境文件）可以都放在<code>hexo</code>分支上（可以新创建一个<code>hexo</code>分支），换新电脑时，直接<code>git clone hexo</code>分支</li>
</ul>
<h4 id="对username-github-io仓库新建hexo分支"><a href="#对username-github-io仓库新建hexo分支" class="headerlink" title="对username.github.io仓库新建hexo分支"></a>对<code>username.github.io</code>仓库新建<code>hexo</code>分支</h4><p>在<code>Github</code>的<code>username.github.io</code>仓库上新建一个<code>hexo</code>(分支名字可自定义)分支, 在下图箭头位置输入分支名字,回车即可创建成功</p>
<p><img data-src="https://upload-images.jianshu.io/upload_images/4122543-a8884eab55430542.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt="GitHub新建分支.png"></p>
<h4 id="设置默认分支"><a href="#设置默认分支" class="headerlink" title="设置默认分支"></a>设置默认分支</h4><p>切换到该<code>hexo</code>分支，并在该仓库<code>-&gt;Settings-&gt;Branches-&gt;Default branch</code>中将默认分支设为<code>hexo</code>，<code>save</code>保存</p>
<p><img data-src="https://upload-images.jianshu.io/upload_images/4122543-61af6e01e50d7837.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt="Snip20180412_1.png"></p>
<h3 id="配置文件上传导Github"><a href="#配置文件上传导Github" class="headerlink" title="配置文件上传导Github"></a>配置文件上传导<code>Github</code></h3><p>该步骤需要在搭建博客的电脑上操作(博客配置文件和主题配置文件所在的电脑上操作)</p>
<h4 id="克隆hexo分支"><a href="#克隆hexo分支" class="headerlink" title="克隆hexo分支"></a>克隆<code>hexo</code>分支</h4><ul>
<li>将上述新建的<code>hexo</code>分支克隆到本地, 在终端中<code>cd</code>进入该<code>username.github.io</code>文件目录</li>
<li>在当前目录使用<code>Git Bash</code>执行<code>git branch</code>命令查看当前所在分支，应为新建的分支<code>hexo</code></li>
<li>如果用<code>Sourcetree</code>软件管理代码的话, 克隆到本地的项目可能没有<code>username.github.io</code>层级, 所有文件都在根目录下, 操作上都不影响, 只需要记住操作要在文件的根目录下即可</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">*hexo</span><br></pre></td></tr></table></figure>

<h4 id="上传部署文件"><a href="#上传部署文件" class="headerlink" title="上传部署文件"></a>上传部署文件</h4><ul>
<li>先将本地博客的部署文件（<code>Hexo</code>目录下的全部文件）全部拷贝进<code>username.github.io</code>文件目录中去</li>
<li>然后安装要用到的一些插件, 有的可能不需要, 但都安装了貌似没有任何影响</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-index --save</span><br><span class="line">npm install hexo-generator-archive --save</span><br><span class="line">npm install hexo-generator-category --save</span><br><span class="line">npm install hexo-generator-tag --save</span><br><span class="line">npm install hexo-server --save</span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">npm install hexo-deployer-heroku --save</span><br><span class="line">npm install hexo-deployer-rsync --save</span><br><span class="line">npm install hexo-deployer-openshift --save</span><br><span class="line">npm install hexo-renderer-marked@<span class="number">0.2</span> --save</span><br><span class="line">npm install hexo-renderer-stylus@<span class="number">0.2</span> --save</span><br><span class="line">npm install hexo-generator-feed@<span class="number">1</span> --save</span><br><span class="line">npm install hexo-generator-sitemap@<span class="number">1</span> --save</span><br><span class="line">npm install hexo-generator-search --save</span><br><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>

<ul>
<li>最后就是讲所有的文件都提交到<code>hexo</code>分支</li>
<li>提交时考虑以下注意事项<ul>
<li>将themes目录以内中的主题的.git目录删除（如果有），因为一个git仓库中不能包含另一个git仓库，否则提交主题文件夹会失败</li>
<li>后期需要更新主题时在另一个地方<code>git clone</code>下来该主题的最新版本，然后将内容拷到当前主题目录即可</li>
</ul>
</li>
<li>最后用终端或者管理工具将所有文件提交到<code>hexo</code>分支 <blockquote>
<p><code>master</code>分支和<code>hexo</code>分支各自保存着一个版本，<code>master</code>分支用于保存博客静态资源，提供博客页面供人访问；<code>hexo</code>分支用于备份博客部署文件，供自己维护更新，两者在一个<code>GitHub</code>仓库内也不会有任何冲突</p>
</blockquote>
</li>
</ul>
<h3 id="同步到其他电脑"><a href="#同步到其他电脑" class="headerlink" title="同步到其他电脑"></a>同步到其他电脑</h3><ul>
<li>将新电脑的生成的<code>ssh key</code>添加到<code>GitHub</code>账户上<ul>
<li><code>ssh key</code>的配置方式可参考<a href="https://www.titanjun.top/2018/03/08/%E5%9F%BA%E4%BA%8EGitHub%E5%92%8CHexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/">基于GitHub和Hexo搭建个人博客</a></li>
</ul>
</li>
<li>在新电脑上克隆<code>username.github.io</code>仓库的<code>hexo</code>分支到本地，此时本地<code>git</code>仓库处于<code>hexo</code>分支</li>
<li>切换到<code>username.github.io</code>目录，执行<code>npm install</code>(由于仓库有一个<code>.gitignore</code>文件，里面默认是忽略掉 <code>node_modules</code>文件夹的，也就是说仓库的<code>hexo</code>分支并没有存储该目录，所以需要<code>install</code>下)<ul>
<li>如果<code>node_modules</code>文件没有丢失, 可不执行该操作</li>
</ul>
</li>
<li>到这里了就可以开始在自己的电脑上写博客了！</li>
<li>需要注意的是每次更新博客之后, 都要把相关修改上传到<code>hexo</code>分支</li>
<li>每次换电脑更新博客的时候, 在修改之前最好也要<code>git pull</code>拉取一下最新的更新</li>
</ul>
<blockquote>
<p>说到这里所有的相关问题基本也都解决了</p>
</blockquote>
]]></content>
      <categories>
        <category>Hexo博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript基本语法01</title>
    <url>/post/e1be9692.html</url>
    <content><![CDATA[<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/javascript/javascropt.jpeg" alt="JavaScript"></p>
<span id="more"></span>





<ul>
<li><code>JavaScript</code>是一种属于网络的脚本语言,已经被广泛用于Web应用开发,常用来为网页添加各式各样的动态功能,为用户提供更流畅美观的浏览效果</li>
<li>通常<code>JavaScript</code>脚本是通过嵌入在<code>HTML</code>中来实现自身的功能的<ul>
<li><code>JavaScript</code>是一种解释性脚本语言（代码不进行预编译）</li>
<li>主要用来向<code>HTML</code>（标准通用标记语言下的一个应用）页面添加交互行为 </li>
<li>可以直接嵌入<code>HTML</code>页面，但写成单独的js文件有利于结构和行为的分离 </li>
<li>跨平台特性，在绝大多数浏览器的支持下，可以在多种平台下运行（如<code>Windows</code>、<code>Linux</code>、<code>Mac</code>、<code>Android</code>、<code>iOS</code>等）。</li>
</ul>
</li>
<li><code>Javascript</code>脚本语言同其他语言一样，有它自身的基本数据类型，表达式和算术运算符及程序的基本程序框架</li>
</ul>
<h2 id="Javascript数据类型"><a href="#Javascript数据类型" class="headerlink" title="Javascript数据类型"></a><code>Javascript</code>数据类型</h2><ul>
<li><p>基本数据类型</p>
<ul>
<li>1、数字(Number)：包括浮点数与整数</li>
<li>2、字符串(String)：包括由任意数量字符组成的序列</li>
<li>3、布尔值(Boolean)：包括true和false</li>
<li>4、<code>Undefined</code>：当我们试图访问一个不存在的变量时，就会得到一个特殊的值<code>undefined</code>。除此之外，使用已定义却未赋值的变量也会如此，以为js会自动将变量在初始化之前的值设定为<code>undefined</code>。而<code>Undefined</code>类型的值只有一个，那就是undefined</li>
<li>5、<code>Null</code>：只包含一个值的特殊数据类型。所谓的<code>null</code>值，通常是没有值或空值，不代表任何东西。<code>null</code>与<code>undefined</code>最大的不同在于，被赋予<code>null</code>的变量通常被认为是已经定义了的，只不过它不代表任何东西。</li>
<li>6、<code>Symbol</code>: 是 ES6 引入了一种新的原始数据类型，表示独一无二的值</li>
</ul>
</li>
<li><p>引用数据类型</p>
<ul>
<li>对象(Object)、</li>
<li>数组(Array)、</li>
<li>函数(Function)</li>
</ul>
</li>
</ul>
<h2 id="JavaScript语法"><a href="#JavaScript语法" class="headerlink" title="JavaScript语法"></a>JavaScript语法</h2><h3 id="JavaScript输出"><a href="#JavaScript输出" class="headerlink" title="JavaScript输出"></a>JavaScript输出</h3><ul>
<li><code>JavaScript</code>可以通过不同的方式来输出数据：<ul>
<li>使用 <code>window.alert()</code> 弹出警告框。</li>
<li>使用 <code>document.write()</code> 方法将内容写到 HTML 文档中。</li>
<li>使用 <code>innerHTML</code> 写入到 HTML 元素。</li>
<li>使用 <code>console.log()</code> 写入到浏览器的控制台。</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 使用 window.alert()</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 弹出警告框来显示数据</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="title function_">alert</span>(<span class="number">5</span> + <span class="number">6</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 写到 HTML 文档</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="title class_">Date</span>());</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 操作 HTML 元素</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 使用 &quot;id&quot; 属性来标识 HTML 元素，并 innerHTML 来获取或插入元素内容</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;demo&quot;</span>).<span class="property">innerHTML</span> = <span class="string">&quot;段落已修改。&quot;</span>;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 在控制台打印数据</span></span></span><br><span class="line"><span class="language-javascript">    a = <span class="number">5</span>;</span></span><br><span class="line"><span class="language-javascript">    b = <span class="number">6</span>;</span></span><br><span class="line"><span class="language-javascript">    c = a + b;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(c);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h3 id="JavaScript注释"><a href="#JavaScript注释" class="headerlink" title="JavaScript注释"></a><code>JavaScript</code>注释</h3><ul>
<li><code>JavaScript</code>不会执行注释中的代码</li>
<li><code>JavaScript</code>中的注释语句和<code>iOS</code>中的一样<ul>
<li>单行注释以 <code>//</code> 开头</li>
<li>多行注释以 <code>/*</code> 开始，以 <code>*/</code> 结尾</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是单行注释</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">这是多行注释</span></span><br><span class="line"><span class="comment">代码不会执行</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="分号"><a href="#分号" class="headerlink" title="分号;"></a>分号<code>;</code></h3><ul>
<li>分号用于分隔 JavaScript 语句。</li>
<li>通常我们在每条可执行的语句结尾添加分号。</li>
<li>使用分号的另一用处是在一行中编写多条语句</li>
<li>也可能看到不带有分号的案例, 在<code>JavaScript</code>中，用分号来结束语句是可选的, 不加分号亦可</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 有分号的情况</span></span><br><span class="line"><span class="keyword">var</span> num1 = <span class="number">5</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不加分号的情况</span></span><br><span class="line"><span class="keyword">var</span> num1 = <span class="number">5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num1)</span><br></pre></td></tr></table></figure>


<h2 id="数字Number"><a href="#数字Number" class="headerlink" title="数字Number"></a>数字<code>Number</code></h2><ul>
<li><code>JavaScript</code>中不区分整数值和浮点数值，所有数字均用浮点数值表示</li>
<li>JS采用<code>IEEE754</code>标准定义的64位浮点格式表示数字，这意味着它能表示的最大值是±1.7976031348623157×10308，最小值是±5×10-324</li>
<li>按照JS中的数字格式，能够表示的整数范围是-9007199254740992<del>9007199254740992（即 -253</del>253）</li>
<li>需要注意的是，JS中实际的操作（比如数组索引，位操作符）则是基于32位整数。</li>
</ul>
<h3 id="类型操作符typeof"><a href="#类型操作符typeof" class="headerlink" title="类型操作符typeof"></a>类型操作符<code>typeof</code></h3><p>当以下num定义后没有任何赋值的情况下num的类型是<code>Undefined</code>，值为<code>undefined</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义了一个名为num的变量</span></span><br><span class="line"><span class="keyword">var</span> num;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印变量num的值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num);  <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//打印变量的数据类型</span></span><br><span class="line"><span class="comment">//查看类型操作符typeof</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> num);  <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<h3 id="进制数"><a href="#进制数" class="headerlink" title="进制数"></a>进制数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//八进制数以0开头</span></span><br><span class="line">num1 = <span class="number">0377</span>;</span><br><span class="line"><span class="comment">//打印出的是八进制0377的十进制形式</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//十六进制数以0x开头</span></span><br><span class="line">num1 = <span class="number">0xff</span>;</span><br><span class="line"><span class="comment">//打印出的是十六进制0xff的十进制形式</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num1);</span><br></pre></td></tr></table></figure>

<h3 id="特殊值"><a href="#特殊值" class="headerlink" title="特殊值"></a>特殊值</h3><ul>
<li><code>Infinity</code>：代表的是超出js处理范围的数值，但它依然是一个数字<ul>
<li>任何数除以0结果为<code>Infinity</code></li>
<li><code>Infinity</code>与其他任何操作数执行任何算术运算的结果也是<code>Infinity</code></li>
</ul>
</li>
<li><code>NaN</code>：表示不是数字，但事实上它依然属于数字类型，只不过是一种特殊的数字罢了<ul>
<li>如果我们在算术运算中使用了不恰当的操作数，导致运算失败，就会得到<code>NaN</code></li>
<li><code>NaN</code>具有传染性，只要算术运算中存在一个<code>NaN</code>，整个运算就会失败</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">num1 = <span class="number">1e308</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num1); <span class="comment">//1e+308</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//超出表示范围</span></span><br><span class="line">num1 = <span class="number">1e309</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num1);  <span class="comment">//Infinity</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//任何数除以0结果为Infinity</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">10</span> / <span class="number">0</span>);  <span class="comment">//Infinity</span></span><br><span class="line"><span class="comment">//Infinity与其他任何操作数执行任何算术运算的结果也是Infinity</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num1 * <span class="number">2</span>);  <span class="comment">//Infinity</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//正负Infinity相加的结果？</span></span><br><span class="line"><span class="comment">//结果为NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Infinity</span> + (-<span class="title class_">Infinity</span>));  <span class="comment">//NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="title class_">NaN</span>);  <span class="comment">//number</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果我们在算术运算中使用了不恰当的操作数，导致运算失败，就会得到NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">10</span> * <span class="string">&#x27;f&#x27;</span>);  <span class="comment">//NaN</span></span><br><span class="line"><span class="comment">//NaN具有传染性，只要算术运算中存在一个NaN，整个运算就会失败</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span> + <span class="number">2</span> + <span class="title class_">NaN</span>);  <span class="comment">//NaN</span></span><br></pre></td></tr></table></figure>


<h3 id="Math运算"><a href="#Math运算" class="headerlink" title="Math运算"></a><code>Math</code>运算</h3><p><code>JavaScript</code>用<code>Math</code>对象实现复杂的运算</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>,<span class="number">3</span>)   <span class="comment">//8；2的3次幂</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">round</span>(<span class="number">.6</span>)  <span class="comment">//1.0；四舍五入</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">ceil</span>(<span class="number">.6</span>)   <span class="comment">//1.0；向上取整</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="number">.6</span>)  <span class="comment">//0.0；向下取整</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">abs</span>(-<span class="number">5</span>)    <span class="comment">//5；求绝对值</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">max</span>(x,y,z) <span class="comment">//返回最大值</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">min</span>(x,y,z) <span class="comment">//返回最小值</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">random</span>()   <span class="comment">//生成一个大于等于0小于1.0的伪随机数</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="property">PI</span>         <span class="comment">//π；圆周率</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="property">E</span>          <span class="comment">//e；自然对数的底数</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">sqrt</span>(<span class="number">3</span>)    <span class="comment">//3的平方根</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">3</span>,<span class="number">1</span>/<span class="number">3</span>) <span class="comment">//3的立方根</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">sin</span>(<span class="number">0</span>)     <span class="comment">//三角函数。Math.cos(),Math.tan(),Math.sin(30/180*Math.PI)</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">log</span>(<span class="number">10</span>)    <span class="comment">//10的自然对数</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">log</span>(<span class="number">100</span>)/<span class="title class_">Math</span>.<span class="property">LN10</span> <span class="comment">//以10为底100的对数</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">log</span>(<span class="number">512</span>)/<span class="title class_">Math</span>.<span class="property">LN2</span> <span class="comment">//以2为底512的对数</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">exp</span>(<span class="number">3</span>)     <span class="comment">//e的3次幂</span></span><br></pre></td></tr></table></figure>



<h2 id="JavaScript布尔"><a href="#JavaScript布尔" class="headerlink" title="JavaScript布尔"></a>JavaScript布尔</h2><p>在<code>JavaScript</code>中有布尔值和<code>falsy</code>值和<code>truthy</code>值</p>
<ul>
<li>布尔（逻辑）只能有两个值：<code>true</code> 或 <code>false</code></li>
<li>所有的<code>Falsy</code>值，当进行逻辑判断时均为<code>false</code></li>
<li>除<code>Falsy</code>值之外的所有的值均为<code>Truthy</code>，当进行逻辑判断时均为<code>true</code><ul>
<li><code>Infinity</code>、空数组、”0”都是<code>Truthy</code>值</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> br = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> br2 = <span class="literal">false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(br);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> br);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Falsy值包括：</span></span><br><span class="line"><span class="comment"> * 1、数字:0</span></span><br><span class="line"><span class="comment"> * 2、数字:NaN</span></span><br><span class="line"><span class="comment"> * 3、空字符串:&quot;&quot;</span></span><br><span class="line"><span class="comment"> * 4、布尔值:false</span></span><br><span class="line"><span class="comment"> * 5、undefined</span></span><br><span class="line"><span class="comment"> * 6、null</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="判断函数"><a href="#判断函数" class="headerlink" title="判断函数"></a>判断函数</h3><ul>
<li><code>isNaN(info)</code>  判断值是否是NaN，如果<code>info===NaN</code>则返回<code>true</code>，否则返回<code>false</code></li>
<li><code>isFinite()</code>检测是否是一个既非<code>Infinity</code>也非<code>NaN</code>的数字</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// isNaN函数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">isNaN</span>(<span class="title class_">NaN</span>));<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">isNaN</span>(<span class="built_in">parseInt</span>(<span class="string">&quot;abc&quot;</span>)));<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">isNaN</span>(<span class="number">123</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 	isFinite函数	</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">isFinite</span>(<span class="title class_">Infinity</span>));<span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">isFinite</span>(-<span class="title class_">Infinity</span>));<span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">isFinite</span>(<span class="title class_">NaN</span>));<span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">isFinite</span>(<span class="number">123</span>));<span class="comment">//true</span></span><br></pre></td></tr></table></figure>


<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>js中一对双引号或单引号之间的任何都会被视为一个字符串</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;https://titanjun.top&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> arr = <span class="string">&quot;/&quot;</span>;</span><br><span class="line"><span class="comment">//两个字符串相加，相当于拼接</span></span><br><span class="line"><span class="keyword">var</span> ret = str + arr;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ret);</span><br><span class="line"></span><br><span class="line"><span class="comment">//数字+字符串:将数字转换成字符串后相加拼接</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line">ret = str + num;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ret);</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串</span></span><br><span class="line"><span class="keyword">var</span> jsString = <span class="string">&quot;Hello,JavaScript&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> jsString)  <span class="comment">// string</span></span><br><span class="line"><span class="comment">//字符串长度</span></span><br><span class="line"><span class="keyword">var</span> s0 = jsString.<span class="property">length</span>;  <span class="comment">//16,</span></span><br><span class="line"><span class="comment">// 第一个字符</span></span><br><span class="line"><span class="keyword">var</span> s1 = jsString.<span class="title function_">charAt</span>(<span class="number">0</span>) ; <span class="comment">//&quot;H&quot;,</span></span><br><span class="line"><span class="comment">// 最后一个字符</span></span><br><span class="line"><span class="keyword">var</span> s2 = jsString.<span class="title function_">charAt</span>(s0 - <span class="number">1</span>)  <span class="comment">//&quot;t&quot;,</span></span><br><span class="line"><span class="comment">//第2~4个字符</span></span><br><span class="line"><span class="keyword">var</span> s3 = jsString.<span class="title function_">substring</span>(<span class="number">1</span>, <span class="number">4</span>) <span class="comment">//&quot;ell&quot;,</span></span><br><span class="line"><span class="comment">//第2~4个字符</span></span><br><span class="line"><span class="keyword">var</span> s4 = jsString.<span class="title function_">slice</span>(<span class="number">1</span>, <span class="number">4</span>)  <span class="comment">//&quot;ell&quot;</span></span><br><span class="line"><span class="comment">// 最后三个字符</span></span><br><span class="line"><span class="keyword">var</span> s5 = jsString.<span class="title function_">slice</span>(-<span class="number">3</span>)  <span class="comment">//&quot;ipt&quot;</span></span><br><span class="line"><span class="comment">// 字符&quot;a&quot;首次出现的位置</span></span><br><span class="line"><span class="keyword">var</span> s6 = jsString.<span class="title function_">indexOf</span>(<span class="string">&quot;a&quot;</span>)  <span class="comment">//7</span></span><br><span class="line"><span class="comment">// 字符&quot;a&quot;最后一次出现的位置</span></span><br><span class="line"><span class="keyword">var</span> s7 = jsString.<span class="title function_">lastIndexOf</span>(<span class="string">&quot;a&quot;</span>)  <span class="comment">//9</span></span><br><span class="line"><span class="comment">// 字符&quot;a&quot;第二次出现的位置</span></span><br><span class="line"><span class="keyword">var</span> s8 = jsString.<span class="title function_">indexOf</span>(<span class="string">&quot;a&quot;</span>, <span class="number">2</span>)  <span class="comment">//7</span></span><br><span class="line"><span class="comment">// 字符串分割成数组</span></span><br><span class="line"><span class="keyword">var</span> s9 = jsString.<span class="title function_">split</span>(<span class="string">&quot;,&quot;</span>)    <span class="comment">//[&quot;Hello&quot;, &quot;JavaScript&quot;]</span></span><br><span class="line"><span class="comment">// 全文字符替换</span></span><br><span class="line"><span class="keyword">var</span> s10 = jsString.<span class="title function_">replace</span>(<span class="string">&quot;e&quot;</span>, <span class="string">&quot;E&quot;</span>)  <span class="comment">//&quot;HEllo,JavaScript&quot;</span></span><br><span class="line"><span class="comment">// 全文转换为大写</span></span><br><span class="line"><span class="keyword">var</span> s11 = jsString.<span class="title function_">toUpperCase</span>()  <span class="comment">//&quot;HELLO,JAVASCRIPT&quot;</span></span><br><span class="line"><span class="comment">// 全文转换成小写</span></span><br><span class="line"><span class="keyword">var</span> s12 = jsString.<span class="title function_">toLowerCase</span>()  <span class="comment">//&quot;hello,javascript&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试输出结果</span></span><br><span class="line"><span class="keyword">var</span> sArr = [s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; sArr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(sArr[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="日期Date"><a href="#日期Date" class="headerlink" title="日期Date"></a>日期Date</h2><ul>
<li>日期对象用于处理日期和时间</li>
<li>格林尼治时间(GTM):是英国郊区皇家格林尼治天文台的时间，因为地球自转的原因，不同经度上的时间是不相同的，格林尼治天文台是经度为0的地方。世界上发生的重大时间都是以格林尼治时间时间为标准的。</li>
<li>世界协调时间(UTC):世界时间。1970年1月1日0点。</li>
<li><code>ECMAScript</code>中的<code>Date</code>类型是在早期<code>Java</code>中的<code>java.util.Date</code>类的基础上构建的。为此<code>Date</code>类型使用自UTC1970年1月1日午夜（零时）开始经过的毫秒数保存时间的。该Date类型保存的日期能够精确到1970年1月1日之前和之后的285616年</li>
</ul>
<h3 id="创建Date"><a href="#创建Date" class="headerlink" title="创建Date"></a>创建Date</h3><p>创建时间使用构造函数法, <code>new Date()</code>, 不论<code>Date()</code>是否带参数，返回的都是当前时间</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、构造函数法--不传参数</span></span><br><span class="line"><span class="keyword">var</span> date1 = <span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> date1) <span class="comment">//Object类型</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、参数是一个表示时间的字符串</span></span><br><span class="line"><span class="comment">//格式：month day, year hours:minutes:seconds</span></span><br><span class="line"><span class="comment">//如果省略了小时、分钟、秒数，这些会被设置为0</span></span><br><span class="line"><span class="keyword">var</span> date2 = <span class="title class_">Date</span>(<span class="string">&quot;2016-09-18&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> date2) <span class="comment">//String类型</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 参数是毫秒数</span></span><br><span class="line"><span class="comment">//返回中国标准时间</span></span><br><span class="line"><span class="keyword">var</span> date3 = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">1000</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date3)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 参数是(年,月,日,时,分,秒,毫秒)</span></span><br><span class="line"><span class="comment">//注意：年和月必须写，且月从0开始，日期从1开始</span></span><br><span class="line"><span class="keyword">var</span> date4 = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2016</span>,<span class="number">09</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">1000</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date4)</span><br></pre></td></tr></table></figure>

<h3 id="Date对象方法"><a href="#Date对象方法" class="headerlink" title="Date对象方法"></a>Date对象方法</h3><h4 id="获取时间"><a href="#获取时间" class="headerlink" title="获取时间"></a>获取时间</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取年份</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date.<span class="title function_">getFullYear</span>());</span><br><span class="line"><span class="comment">//获取月份，注意0表示1月，依次类推</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date.<span class="title function_">getMonth</span>());</span><br><span class="line"><span class="comment">//获取日期</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date.<span class="title function_">getDate</span>());</span><br><span class="line"><span class="comment">//获取星期</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date.<span class="title function_">getDay</span>());</span><br><span class="line"><span class="comment">//获取小时</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date.<span class="title function_">getHours</span>());</span><br><span class="line"><span class="comment">//获取分钟</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date.<span class="title function_">getMinutes</span>());</span><br><span class="line"><span class="comment">//获取秒数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date.<span class="title function_">getSeconds</span>());</span><br><span class="line"><span class="comment">//获取毫秒数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date.<span class="title function_">getMilliseconds</span>());</span><br><span class="line"><span class="comment">//获取日期对象所表示的日期距离1970-01-01的毫秒数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date.<span class="title function_">getTime</span>());</span><br></pre></td></tr></table></figure>


<h4 id="设置时间"><a href="#设置时间" class="headerlink" title="设置时间"></a>设置时间</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置年份</span></span><br><span class="line">date.<span class="title function_">setFullYear</span>(<span class="number">2015</span>);</span><br><span class="line"><span class="comment">//设置月份</span></span><br><span class="line"><span class="comment">//注意：传入的月份大于11，则年份增加</span></span><br><span class="line">date.<span class="title function_">setMonth</span>(<span class="number">8</span>);</span><br><span class="line"><span class="comment">//设置日期</span></span><br><span class="line"><span class="comment">//注意：如果传入的日期超过了该月应有的天数则会增加月份</span></span><br><span class="line">date.<span class="title function_">setDate</span>(<span class="number">29</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：星期一般不用设置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置小时</span></span><br><span class="line"><span class="comment">//注意：如果传入的值超过23则增加日期</span></span><br><span class="line">date.<span class="title function_">setHours</span>(<span class="number">13</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置分钟</span></span><br><span class="line"><span class="comment">//注意：如果传入的值超过了59则增加小时数</span></span><br><span class="line">date.<span class="title function_">setMinutes</span>(<span class="number">56</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置秒数</span></span><br><span class="line"><span class="comment">//注意：传入的值超过59会增加分钟数</span></span><br><span class="line">date.<span class="title function_">setSeconds</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置毫秒数</span></span><br><span class="line"><span class="comment">//注意：传入的值超过999会增加秒数</span></span><br><span class="line">date.<span class="title function_">setMilliseconds</span>(<span class="number">888</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date)</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置距离1970-01-01的毫秒数</span></span><br><span class="line">date.<span class="title function_">setTime</span>(<span class="number">1308484904898</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date);</span><br></pre></td></tr></table></figure>


<h4 id="Date转换格式"><a href="#Date转换格式" class="headerlink" title="Date转换格式"></a>Date转换格式</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//转换成字符串</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date.<span class="title function_">toString</span>())</span><br><span class="line"><span class="comment">//日期部分转换为字符串</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date.<span class="title function_">toDateString</span>())</span><br><span class="line"><span class="comment">//把时间部分转换为字符串</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date.<span class="title function_">toTimeString</span>())</span><br><span class="line"><span class="comment">//包含年月日时分秒</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date.<span class="title function_">toLocaleString</span>());</span><br><span class="line"><span class="comment">//包含年月日</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date.<span class="title function_">toLocaleDateString</span>());</span><br><span class="line"><span class="comment">//包含时分秒</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date.<span class="title function_">toLocaleTimeString</span>());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用 ISO 标准返回字符串的日期格式</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date.<span class="title function_">toISOString</span>())</span><br><span class="line"><span class="comment">//JSON 数据格式返回日期字符串</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date.<span class="title function_">toJSON</span>())</span><br><span class="line"><span class="comment">//根据世界时，把 Date 对象转换为字符串</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date.<span class="title function_">toUTCString</span>())</span><br></pre></td></tr></table></figure>

<h4 id="parse"><a href="#parse" class="headerlink" title="parse"></a>parse</h4><p>返回某日期距离1970年1月1日0点的毫秒数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Date.parse(dateString)</span></span><br><span class="line"><span class="comment">//参数：日期字符串  格式：2016-05-08  2015/05/08 12:00:00</span></span><br><span class="line"><span class="comment">//返回该日期距离1970年1月1日0点的毫秒数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Date</span>.<span class="title function_">parse</span>(<span class="string">&quot;2018-10-10&quot;</span>));</span><br></pre></td></tr></table></figure>


<h4 id="Date间运算"><a href="#Date间运算" class="headerlink" title="Date间运算"></a>Date间运算</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> date1 = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&quot;2018-10-10 10:10:10&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> date2 = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&quot;2018-10-10 10:10:12&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//两个日期对象之间相差的毫秒数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date2 - date1) <span class="comment">// 2000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回两个日期字符串拼接后的字符串</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date2 + date1)  <span class="comment">// Mon Oct 10 2016 10:10:12 GMT+0800 (CST)Mon Oct 10 2016 10:10:10 GMT+0800 (CST)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> (date2 + date1))  <span class="comment">//string</span></span><br></pre></td></tr></table></figure>



<h2 id="数组Array"><a href="#数组Array" class="headerlink" title="数组Array"></a>数组Array</h2><ul>
<li>数组是值的有序集合</li>
<li><code>JavaScript</code>数组事务类型的:数组元素可以使任何类型, 同一数组中的不同元素也可以是不同类型</li>
<li>数组的元素也可以是对象或者其他数组</li>
<li><code>JavaScript</code>数组可能是稀疏的: 数组元素的索引不一定是连续的,之间可能有空缺</li>
<li>稀疏数组的<code>length</code>比任何元素的索引都要大</li>
<li><code>JavaScript</code>中的数组可以存储多个不同类型的数据</li>
</ul>
<h3 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h3><h4 id="直接量创建"><a href="#直接量创建" class="headerlink" title="直接量创建"></a>直接量创建</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字面量表示法</span></span><br><span class="line"><span class="comment">//1.1: 简单数组</span></span><br><span class="line"><span class="keyword">var</span> empty = [];   <span class="comment">//空数组</span></span><br><span class="line"><span class="keyword">var</span> pram = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>]  <span class="comment">//有三个数值的数组</span></span><br><span class="line"><span class="keyword">var</span> misc = [<span class="number">1.1</span>, <span class="literal">true</span>, <span class="string">&quot;a&quot;</span>] <span class="comment">//三个不同元素的数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.2: 数组中的直接量不一定是常量,也可能是表达式</span></span><br><span class="line"><span class="keyword">var</span> base = <span class="number">1024</span></span><br><span class="line"><span class="keyword">var</span> baseArr = [base, base + <span class="number">1</span>, base + <span class="number">2</span>, base + <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.3: 包含对象或数组</span></span><br><span class="line"><span class="keyword">var</span> array3 = [[<span class="number">1</span>, &#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;], [<span class="number">2</span>, &#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">4</span>&#125;]]</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.4: 忽略中间量中的某个值,省略的元素将被赋予undefined</span></span><br><span class="line"><span class="keyword">var</span> undef1 = [<span class="number">1</span>, ,<span class="number">3</span>] <span class="comment">//三个元素,中间的为undefined</span></span><br><span class="line"><span class="keyword">var</span> undef2 = [, ,] <span class="comment">//2个元素都是undefined</span></span><br><span class="line"><span class="comment">//注: 数组直接量的语法允许游客选的结尾的逗号,故[, ,]只有2个元素</span></span><br></pre></td></tr></table></figure>

<h4 id="Array-创建"><a href="#Array-创建" class="headerlink" title="Array()创建"></a>Array()创建</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="comment">// 空数组</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="title class_">Array</span>()</span><br><span class="line"><span class="comment">//指定数组长度</span></span><br><span class="line"><span class="keyword">var</span> a1 = <span class="keyword">new</span>  <span class="title class_">Array</span>(<span class="number">10</span>)</span><br><span class="line"><span class="comment">//显示创建</span></span><br><span class="line"><span class="keyword">var</span> a2 = <span class="keyword">new</span>  <span class="title class_">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">&quot;a&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//3. 读写数组元素</span></span><br><span class="line"><span class="comment">//注: 1.数组是对象的特殊形式,故JavaScript的数组不存在越界报错的情况,只会取到undefined</span></span><br><span class="line"><span class="keyword">var</span> value = a2[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 数组的长度</span></span><br><span class="line"><span class="comment">//length属性为可读可写</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="keyword">var</span> arrLength = arr.<span class="property">length</span>  <span class="comment">//6</span></span><br><span class="line">arr.<span class="property">length</span> = <span class="number">4</span>   <span class="comment">//数组变为[1, 2, 3, 4]</span></span><br><span class="line">arr.<span class="property">length</span> = <span class="number">0</span>  <span class="comment">// 删除所有元素,为[]</span></span><br><span class="line">arr.<span class="property">length</span> = <span class="number">5</span>  <span class="comment">// 长度为5,但是没有元素,相当于new Array(5)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//5. 数组元素的添加和删除</span></span><br><span class="line"><span class="comment">//5.1: 索引值添加</span></span><br><span class="line"><span class="keyword">var</span> a0 = []</span><br><span class="line">a0[<span class="number">0</span>] = <span class="number">3</span></span><br><span class="line">a0[<span class="number">1</span>] = <span class="string">&quot;one&quot;</span></span><br><span class="line"><span class="comment">//a0为[3, &quot;one&quot;]</span></span><br></pre></td></tr></table></figure>

<h3 id="数组的方法"><a href="#数组的方法" class="headerlink" title="数组的方法"></a>数组的方法</h3><p>主要介绍<code>ECMAScript</code>中的方法</p>
<h4 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h4><ul>
<li>0.不改变原数组</li>
<li>1.将数组所有的元素都转化成字符串,并连接在一起,返回生成后的字符串(如不指定分隔符默认使用逗号)</li>
<li>2.join是String.split()的逆向操作</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr0 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">var</span> join1 = arr0.<span class="title function_">join</span>() <span class="comment">// &quot;1,2,3,4&quot;</span></span><br><span class="line"><span class="keyword">var</span> join2 = arr0.<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>) <span class="comment">//&quot;1234&quot;</span></span><br><span class="line"><span class="keyword">var</span> join3 = arr0.<span class="title function_">join</span>(<span class="string">&quot;-&quot;</span>)  <span class="comment">//&quot;1-2-3-4&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(join1,join2,join3)</span><br></pre></td></tr></table></figure>


<h4 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h4><ul>
<li>0.改变原数组</li>
<li>1.将数组中的元素颠倒顺序*&#x2F;</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr0.<span class="title function_">reverse</span>()  <span class="comment">//现在arr0为[4, 3, 2, 1]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr0)</span><br></pre></td></tr></table></figure>


<h4 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h4><ul>
<li>0.改变原数组</li>
<li>1.不带参数时,以字母表顺序排序</li>
<li>2.如果数组包含undefined,则会被排到数组的末尾</li>
<li>3.字母排序区分大小写,A &lt; a</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="string">&quot;tian&quot;</span>, <span class="string">&quot;quan&quot;</span>, <span class="string">&quot;jun&quot;</span>)</span><br><span class="line">arr1.<span class="title function_">sort</span>() <span class="comment">//arr1 = [&quot;jun&quot;, &quot;quan&quot;, &quot;tian&quot;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1)</span><br><span class="line"></span><br><span class="line"><span class="comment">//条件比较</span></span><br><span class="line"><span class="keyword">var</span>  arr2 = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="string">&quot;ant&quot;</span>, <span class="string">&quot;Bug&quot;</span>, <span class="string">&quot;cat&quot;</span>, <span class="string">&quot;Dog&quot;</span>)</span><br><span class="line">arr2.<span class="title function_">sort</span>()  <span class="comment">//[&quot;Bug&quot;, &quot;Dog&quot;, &quot;ant&quot;, &quot;cat&quot;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr2)</span><br><span class="line"></span><br><span class="line"><span class="comment">//不区分大小写排序</span></span><br><span class="line">arr2.<span class="title function_">sort</span>(<span class="keyword">function</span> (<span class="params">s, t</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> a = s.<span class="title function_">toLowerCase</span>()</span><br><span class="line">    <span class="keyword">var</span> b = t.<span class="title function_">toLowerCase</span>()</span><br><span class="line">    <span class="keyword">if</span> (a &lt; b) <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> (a &gt; b) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr2)</span><br><span class="line"><span class="comment">//[&quot;ant&quot;, &quot;Bug&quot;, &quot;cat&quot;, &quot;Dog&quot;]</span></span><br></pre></td></tr></table></figure>


<h4 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h4><p>创建并返回一个新数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//0.不改变原数组</span></span><br><span class="line"><span class="keyword">var</span> arr4 = [<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">var</span> concat1 = arr4.<span class="title function_">concat</span>() <span class="comment">//[0, 2, 3]</span></span><br><span class="line"><span class="keyword">var</span> concat2 = arr4.<span class="title function_">concat</span>(<span class="number">1</span>, <span class="number">4</span>)  <span class="comment">//[0, 2, 3, 1, 4]</span></span><br><span class="line"><span class="keyword">var</span> concat3 = arr4.<span class="title function_">concat</span>([<span class="number">1</span>, <span class="number">4</span>]) <span class="comment">//[0, 2, 3, 1, 4]</span></span><br><span class="line"><span class="keyword">var</span> concat4 = arr4.<span class="title function_">concat</span>([<span class="number">1</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]) <span class="comment">//[0, 2, 3, 1, 4, 5, 6]</span></span><br><span class="line"><span class="keyword">var</span> concat5 = arr4.<span class="title function_">concat</span>(<span class="number">1</span>, [<span class="number">4</span>, [<span class="number">5</span>, <span class="number">6</span>]]) <span class="comment">//[0, 2, 3, 1, 4, [5, 6]]</span></span><br><span class="line"><span class="keyword">var</span> concatArr = [concat1, concat2, concat3, concat4, concat5]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(concatArr)</span><br></pre></td></tr></table></figure>

<h4 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h4><ul>
<li>注意:</li>
<li>1.返回数组的部分数组</li>
<li>2.不改变原数组</li>
<li>3.两个参数,分别表示始末位置,含左不含右</li>
<li>4.1表示第一个元素,-1表示倒数第一个元素</li>
<li>5.只有一个参数,默认以此参数开始,到最后一个元素结束</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr3 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">var</span> slice1 = arr3.<span class="title function_">slice</span>(<span class="number">0</span>,<span class="number">2</span>) <span class="comment">//[1, 2]</span></span><br><span class="line"><span class="keyword">var</span> slice2 = arr3.<span class="title function_">slice</span>(<span class="number">3</span>) <span class="comment">//[4, 5]</span></span><br><span class="line"><span class="keyword">var</span> slice3 = arr3.<span class="title function_">slice</span>(<span class="number">1</span>,-<span class="number">2</span>) <span class="comment">//[2, 3]</span></span><br><span class="line"><span class="keyword">var</span> slice4 = arr3.<span class="title function_">slice</span>(-<span class="number">3</span>,-<span class="number">2</span>)  <span class="comment">//[3]</span></span><br><span class="line"><span class="keyword">var</span> sliceArr = [slice1, slice2, slice3, slice4]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sliceArr)</span><br></pre></td></tr></table></figure>

<h4 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h4><ul>
<li>1.在数组中插入或删除元素的通用方法</li>
<li>2.会修改原数组,会改变数组的索引值</li>
<li>3.两个参数,参数一:起始位置;参数二:处理元素的个数(可省略)</li>
<li>4.若省略第二个参数,默认从起始位置到最后</li>
<li>5.如果没有元素就返回空数组</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"><span class="keyword">var</span> splice1 = m.<span class="title function_">splice</span>(<span class="number">4</span>)  <span class="comment">//返回[5, 6, 7], m 是[1, 2, 3, 4]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m)</span><br><span class="line"><span class="keyword">var</span> splice2 = m.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">//返回[2, 3], m 是[1, 4]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m)</span><br><span class="line"><span class="keyword">var</span> splice3 = m.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">1</span>) <span class="comment">//返回[4], m 是[1]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m)</span><br><span class="line"><span class="keyword">var</span> spliceArr = [splice1, splice2, splice3]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(spliceArr)</span><br></pre></td></tr></table></figure>


<h4 id="push和pop"><a href="#push和pop" class="headerlink" title="push和pop"></a>push和pop</h4><ul>
<li>方法将数组当成栈使用</li>
<li>1.push方法在尾部添加一个或者多个元素,返回新的数组长度</li>
<li>2.pop删除数组的最后一个元素,减小数组的长度,返回删除的值</li>
<li>3.改变原数组的值和长度</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m0 = []</span><br><span class="line"><span class="keyword">var</span> pp1 = m0.<span class="title function_">push</span>(<span class="number">1</span>, <span class="number">2</span>)  <span class="comment">//[1, 2], 返回2</span></span><br><span class="line"><span class="keyword">var</span> pp2 = m0.<span class="title function_">pop</span>()       <span class="comment">//[1], 返回2</span></span><br><span class="line"><span class="keyword">var</span> pp3 = m0.<span class="title function_">push</span>(<span class="number">3</span>, <span class="number">4</span>)  <span class="comment">//[1, 3, 4], 返回3</span></span><br><span class="line"><span class="keyword">var</span> pp4 = m0.<span class="title function_">pop</span>()       <span class="comment">//[1, 3],  返回4</span></span><br><span class="line"><span class="keyword">var</span> pp5 = m0.<span class="title function_">push</span>([<span class="number">9</span>,<span class="number">0</span>]) <span class="comment">//[1, 3, [9, 0]], 返回3</span></span><br><span class="line"><span class="keyword">var</span> pp6 = m0.<span class="title function_">pop</span>()       <span class="comment">//[1, 3], 返回[9, 0]</span></span><br><span class="line"><span class="keyword">var</span> pp7 = m0.<span class="title function_">pop</span>()       <span class="comment">//[1], 返回3</span></span><br><span class="line"><span class="keyword">var</span> ppArr = [pp1, pp2, pp3, pp4, pp5, pp6, pp7]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ppArr)</span><br></pre></td></tr></table></figure>

<h4 id="unshift和shift"><a href="#unshift和shift" class="headerlink" title="unshift和shift"></a>unshift和shift</h4><ul>
<li>1.unshift在头部添加一个或者多个元素,返回长度</li>
<li>2.shift删除数组的第一个元素,返回删除的元素</li>
<li>3.改变原数组,改变原数组的索引</li>
<li>4.unshift插入多个元素时,试一次性插入的</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sh = []</span><br><span class="line"><span class="keyword">var</span> sh1 = sh.<span class="title function_">unshift</span>(<span class="number">1</span>)  <span class="comment">//sh: [1], 返回: 1</span></span><br><span class="line"><span class="keyword">var</span> sh2 = sh.<span class="title function_">unshift</span>(<span class="number">22</span>) <span class="comment">//sh: [1, 22], 返回: 2</span></span><br><span class="line"><span class="keyword">var</span> sh3 = sh.<span class="title function_">shift</span>()     <span class="comment">//sh: [22], 返回: 22</span></span><br><span class="line"><span class="keyword">var</span> sh4 = sh.<span class="title function_">unshift</span>(<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]) <span class="comment">//sh: [3, [4, 5], 1], 返回:  3</span></span><br><span class="line"><span class="keyword">var</span> sh5 = sh.<span class="title function_">shift</span>()      <span class="comment">//sh: [[4, 5], 1], 返回: 3</span></span><br><span class="line"><span class="keyword">var</span> sh6 = sh.<span class="title function_">shift</span>()      <span class="comment">//sh: [1], 返回: [4, 5]</span></span><br><span class="line"><span class="keyword">var</span> shiftArr = [sh1, sh2, sh3, sh4, sh5, sh6]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(shiftArr)</span><br><span class="line"><span class="comment">//注: unshift插入多个元素时,试一次性插入的,例如:</span></span><br><span class="line">sh.<span class="title function_">unshift</span>(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="comment">// 结果: [3, 4]</span></span><br><span class="line">sh.<span class="title function_">unshift</span>(<span class="number">3</span>)</span><br><span class="line">sh.<span class="title function_">unshift</span>(<span class="number">4</span>)</span><br><span class="line"><span class="comment">//结果: [4, 3]</span></span><br></pre></td></tr></table></figure>

<h4 id="toString和toLocalString"><a href="#toString和toLocalString" class="headerlink" title="toString和toLocalString"></a>toString和toLocalString</h4><ul>
<li>1.toString()将数组元素转化成字符串后,用都好链接输出</li>
<li>2.toString()和join()不加参数的返回的值是一样的</li>
<li>3.toLocalString()是toString()的本地化版本</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str0 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">toString</span>() <span class="comment">//返回: &quot;1,2,3&quot;</span></span><br><span class="line"><span class="keyword">var</span> str1 = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>].<span class="title function_">toString</span>()  <span class="comment">//返回: &quot;a,b,c&quot;</span></span><br><span class="line"><span class="keyword">var</span> str2 = [<span class="number">1</span>, [<span class="number">2</span>, <span class="string">&quot;c&quot;</span>]].<span class="title function_">toString</span>()  <span class="comment">//返回: &quot;1,2,c&quot;</span></span><br><span class="line"><span class="keyword">var</span> str3 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">toLocaleString</span>()  <span class="comment">//返回: &quot;1,2,3&quot;</span></span><br><span class="line"><span class="keyword">var</span> strArr = [str0, str1, str2, str3, str4]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(strArr)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="ECMAScript5"><a href="#ECMAScript5" class="headerlink" title="ECMAScript5"></a><code>ECMAScript5</code></h3><ul>
<li>1.<code>ECMAScript5</code>定义了九个新的数组方法</li>
<li>2.大多数<code>ECMAScript5</code>数组方法的第一个参数是一个函数</li>
<li>2.第二个参数是可选的,如果有,则调用的函数被看作是第二个参数的方法</li>
<li>3.也就是说在调用函数时,传递进去的第二个参数作为它的this关键字的值来使用</li>
<li>4.<code>ECMAScript5</code>中的数组方法不会修改他们调用的原始数组</li>
<li>5.传递给这些方法的函数是可以改变这些数组的</li>
</ul>
<h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h4><ul>
<li>1.方法从头到尾遍历数组,为每个元素调用指定的函数</li>
<li>2.forEach使用三个参数调用该函数:数组元素,元素索引, 数组本身</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="comment">//求和</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">data1.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">    sum += value</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//15</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//每个元素本身自加1</span></span><br><span class="line">data1.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">value, i, arr</span>) &#123;</span><br><span class="line">    arr[i] = value + <span class="number">1</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//[2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>

<h4 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h4><ul>
<li>1.返回一个新数组,不改变原数组</li>
<li>2.原数组若是稀疏数组,返回也是稀疏数组</li>
<li>3.具有相同的长度,相同的缺失元素</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr2 = data1.<span class="title function_">map</span>(<span class="keyword">function</span> (<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x * x</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// [4, 9, 16, 25, 36]</span></span><br></pre></td></tr></table></figure>

<h4 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h4><p>逻辑判定,过滤数组</p>
<ul>
<li>1.返回原数组的一个子集</li>
<li>2.返回原数组符合条件的元素,组成新数组</li>
<li>3.会将稀疏数组压缩,返回的是稠密数组</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr3 = data1.<span class="title function_">filter</span>(<span class="keyword">function</span> (<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; <span class="number">3</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//[4, 5, 6]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">var</span> arr4 = data2.<span class="title function_">filter</span>(<span class="keyword">function</span> (<span class="params">i</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> i % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//[2, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data3 = [<span class="number">1</span>, <span class="number">2</span>, , , <span class="literal">null</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">var</span> arr5 = data3.<span class="title function_">filter</span>(<span class="keyword">function</span> (<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x !== <span class="literal">undefined</span> &amp;&amp; x != <span class="literal">null</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr5)</span><br><span class="line"><span class="comment">//[1, 2, 5]</span></span><br></pre></td></tr></table></figure>

<h4 id="every和some"><a href="#every和some" class="headerlink" title="every和some"></a>every和some</h4><p>数组的逻辑判定</p>
<ul>
<li>1.对数组元素应用指定的函数进行判定</li>
<li>2.返回trur或者false</li>
<li>2.every()都为true返回true,否则返回false</li>
<li>3.some()都为false,返回false;有一个为true,返回true</li>
<li>4.一旦该方法确定了返回值,就会停止遍历数组</li>
<li>5.空数组,every()返回true,some()返回false</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data4 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">var</span> sum1 = data4.<span class="title function_">every</span>(<span class="keyword">function</span> (<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x &lt; <span class="number">10</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//sum1 = true</span></span><br><span class="line"><span class="keyword">var</span> sum2 = data4.<span class="title function_">every</span>(<span class="keyword">function</span> (<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x % <span class="number">2</span> === <span class="number">0</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//sum2 = false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum3 = data4.<span class="title function_">some</span>(<span class="keyword">function</span> (<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x % <span class="number">2</span> === <span class="number">0</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//sum3 = true</span></span><br><span class="line"><span class="keyword">var</span> sum4 = data4.<span class="title function_">some</span>(<span class="built_in">isNaN</span>)</span><br><span class="line"><span class="comment">//sum4 = false, data4不包含非整数值元素</span></span><br></pre></td></tr></table></figure>

<h4 id="reduce和reduceRigh"><a href="#reduce和reduceRigh" class="headerlink" title="reduce和reduceRigh"></a>reduce和reduceRigh</h4><ul>
<li>作用: 将数组元素进行组合生成单个值</li>
<li>1.reduce()需要两个参数;参数一:执行操作的函数;参数二:传递给函数的初始值</li>
<li>2.reduceRight()是倒叙操作,功能与reduce相同</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data5 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">var</span> sn0 = data5.<span class="title function_">reduce</span>(<span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="comment">//15</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sn1 = data5.<span class="title function_">reduce</span>(<span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x * y</span><br><span class="line">&#125;, <span class="number">1</span>)</span><br><span class="line"><span class="comment">//120</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sn2 = data5.<span class="title function_">reduce</span>(<span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; y ? x : y</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


<h4 id="indexOf和lastIndexOf"><a href="#indexOf和lastIndexOf" class="headerlink" title="indexOf和lastIndexOf"></a>indexOf和lastIndexOf</h4><ul>
<li>1.搜索整个数组中具有给定值的元素,返回找到的第一个元素的索引,如果没有找到就返回-1</li>
<li>2.indexOf(),从前向后搜索,lastIndexOf()从后向前搜索</li>
<li>3.参数一:元素值; 参数二: 搜索的起始位置(可省略,默认从头开始)</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data6 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line"><span class="keyword">var</span> index1 = data6.<span class="title function_">indexOf</span>(<span class="number">1</span>) <span class="comment">//1, data6[1] = 1</span></span><br><span class="line"><span class="keyword">var</span> index2 = data6.<span class="title function_">indexOf</span>(<span class="number">3</span>) <span class="comment">//-1, 没有值为3的元素</span></span><br><span class="line"><span class="keyword">var</span> index3 = data6.<span class="title function_">lastIndexOf</span>(<span class="number">1</span>) <span class="comment">//3, data6[3] = 1</span></span><br><span class="line"><span class="keyword">var</span> index4 = data6.<span class="title function_">indexOf</span>(<span class="number">2</span>, <span class="number">1</span>)<span class="comment">//2, data6[2] = 2</span></span><br><span class="line"><span class="keyword">var</span> index5 = data6.<span class="title function_">lastIndexOf</span>(<span class="number">2</span>, -<span class="number">1</span>)<span class="comment">//2, data6[2] = 2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="判定一个位置对象是否为数组"><a href="#判定一个位置对象是否为数组" class="headerlink" title="判定一个位置对象是否为数组"></a>判定一个位置对象是否为数组</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="comment">// var isA = data.isArray()</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="title function_">isArray</span>())</span><br></pre></td></tr></table></figure>


<h2 id="类型间的转换"><a href="#类型间的转换" class="headerlink" title="类型间的转换"></a>类型间的转换</h2><h3 id="Number"><a href="#Number" class="headerlink" title="Number()"></a>Number()</h3><p>将其他类型数据转成Number类型数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、Null--&gt;Number</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(<span class="literal">null</span>));<span class="comment">//0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、Undefined--&gt;Number</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(<span class="literal">undefined</span>));<span class="comment">//NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3、Boolean--&gt;Number</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(<span class="literal">true</span>));<span class="comment">//1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(<span class="literal">false</span>));<span class="comment">//0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4、String--&gt;Number</span></span><br><span class="line"><span class="comment">//如果字符串中只有数字、小数点、(最前面空格 正负号)则转换成对应的十进制数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(<span class="string">&quot;123&quot;</span>));<span class="comment">//123</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(<span class="string">&quot;12.3&quot;</span>));<span class="comment">//12.3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(<span class="string">&quot;+123&quot;</span>));<span class="comment">//123</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(<span class="string">&quot;-123&quot;</span>));<span class="comment">//-123</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(<span class="string">&quot;   123&quot;</span>));<span class="comment">//123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是一个空字符串，结果是0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(<span class="string">&quot;&quot;</span>));<span class="comment">//0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(<span class="string">&quot;   &quot;</span>));<span class="comment">//0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果字符串中含有非数字，非正负号，转换失败，结果NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(<span class="string">&quot;123abc&quot;</span>));<span class="comment">//NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(<span class="string">&quot;123+456&quot;</span>));<span class="comment">//NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(<span class="string">&quot;abc&quot;</span>));<span class="comment">//NaN</span></span><br></pre></td></tr></table></figure>

<h3 id="parseInt"><a href="#parseInt" class="headerlink" title="parseInt()"></a>parseInt()</h3><ul>
<li>会试图将其收到的任何输入值(通常是字符串）转成整数类型，如果转换失败就返回NaN。</li>
<li>转换规则：如果第一个非空白字符(空格、换行、tab)是数字或者正负号则开始转换，直到碰到第一个非数字字符停止转换。如果第一个非空白字符不是数字或者正负号，转换失败，结果是NaN.</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;-----parseInt------&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseInt</span>(<span class="string">&quot;123&quot;</span>));<span class="comment">//123</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseInt</span>(<span class="string">&quot;+123&quot;</span>));<span class="comment">//123</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseInt</span>(<span class="string">&quot;-123&quot;</span>));<span class="comment">//-123</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseInt</span>(<span class="string">&quot;  123&quot;</span>));<span class="comment">//123</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseInt</span>(<span class="string">&quot;12a3&quot;</span>));<span class="comment">//12</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseInt</span>(<span class="string">&quot;12.3&quot;</span>));<span class="comment">//12</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseInt</span>(<span class="string">&quot;12 3&quot;</span>));<span class="comment">//12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseInt</span>(<span class="string">&quot;true&quot;</span>)); <span class="comment">//NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseInt</span>(<span class="string">&quot;  .123&quot;</span>)); <span class="comment">//NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseInt</span>(<span class="string">&quot;+-123&quot;</span>)); <span class="comment">//NaN</span></span><br></pre></td></tr></table></figure>


<h3 id="parseFloat"><a href="#parseFloat" class="headerlink" title="parseFloat()"></a>parseFloat()</h3><ul>
<li>会试图将其收到的任何输入值(通常是字符串）转成浮点数类型，如果转换失败就返回NaN。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="built_in">parseFloat</span>(<span class="string">&quot;   2.5a&quot;</span>) );<span class="comment">//2.5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="built_in">parseFloat</span>(<span class="string">&quot;  .56&quot;</span>) ); <span class="comment">//0.56</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="built_in">parseFloat</span>(<span class="string">&quot;  -.23&quot;</span>)); <span class="comment">//- 0.23</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="built_in">parseFloat</span>(<span class="string">&quot;   +.23 + .1&quot;</span>) );<span class="comment">//0.23</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="built_in">parseFloat</span>(<span class="string">&quot;  3.14.956&quot;</span>) ); <span class="comment">//3.14</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="built_in">parseFloat</span>(<span class="string">&quot;a3.14&quot;</span>) ); <span class="comment">//NaN</span></span><br></pre></td></tr></table></figure>

<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>其它基本类型转换成String类型</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Null--&gt;String</span></span><br><span class="line"><span class="keyword">var</span> str0 = <span class="string">&quot;titan&quot;</span> + <span class="literal">null</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> str0); <span class="comment">//string</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str0); <span class="comment">//titannull</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Undefined--&gt;String</span></span><br><span class="line"><span class="keyword">var</span> str1 = <span class="string">&quot;jun&quot;</span> + <span class="literal">undefined</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> str1); <span class="comment">//string</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str1); <span class="comment">//junundefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Boolean--&gt;String</span></span><br><span class="line"><span class="keyword">var</span> str2 = <span class="literal">true</span>.<span class="title function_">toString</span>(); <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> str2);<span class="comment">//string</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str2);<span class="comment">//&quot;true&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">false</span>.<span class="title function_">toString</span>());<span class="comment">//&quot;false&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Number--&gt;String</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> str3 = num.<span class="title function_">toString</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> str3);<span class="comment">//string</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str3);<span class="comment">//&quot;10&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean()"></a>Boolean()</h3><ul>
<li>其它基本类型转换成<code>Boolean</code>类型</li>
<li>绝大部分值在转换为布尔类型时都为<code>true</code>，但以下6中<code>falsy</code>值除外</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、&quot;&quot;</span></span><br><span class="line"><span class="comment"> * 2、null</span></span><br><span class="line"><span class="comment"> * 3、undefined</span></span><br><span class="line"><span class="comment"> * 4、0</span></span><br><span class="line"><span class="comment"> * 5、NaN</span></span><br><span class="line"><span class="comment"> * 6、false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Boolean</span>(<span class="string">&quot;&quot;</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Boolean</span>(<span class="literal">null</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Boolean</span>(<span class="literal">undefined</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Boolean</span>(<span class="number">0</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Boolean</span>(<span class="title class_">NaN</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Boolean</span>(<span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 都输出false</span></span><br></pre></td></tr></table></figure>


<hr>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript基本语法03</title>
    <url>/post/fb0f7be.html</url>
    <content><![CDATA[<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/javascript/javascropt.jpeg" alt="JavaScript"></p>
<span id="more"></span>

<ul>
<li>书接上文<a href="https://www.titanjun.top/categories/JavaScript%E7%AC%94%E8%AE%B0/">JavaScript基本语法</a>, 记录了<code>JavaScript</code>的记录了相关数据类型和函数等相关语法</li>
<li>这里主要记录浏览器对象模型(<code>BOM</code>), <code>window</code>对象和文档对象模型(<code>DOM</code>)</li>
</ul>
<h2 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h2><ul>
<li><code>BOM</code>:浏览器对象模型（<code>Browser Object Model</code>)，是一个用于访问浏览器和计算机屏幕的对象集合。我们可以通过全局对象<code>window</code>来访问这些对象。</li>
<li>所有浏览器都支持<code>window</code>对象, 它表示浏览器窗口</li>
<li>所有<code>JavaScript</code>全局对象、函数以及变量均自动成为<code>window</code>对象的成员</li>
<li>全局变量是<code>window</code>对象的属性</li>
<li>全局函数是<code>window</code>对象的方法</li>
</ul>
<h3 id="Window"><a href="#Window" class="headerlink" title="Window"></a>Window</h3><ul>
<li><code>window.document</code>: 是一个BOM对象，表示的是当前所载入的文档(即页面)，但它的方法和属性同时也属于DOM对象所涵盖的范围</li>
<li><code>window.frames</code>: 是当前页面中所有框架的集合</li>
<li><code>window.navigator</code>: 用于反应浏览器及其功能信息的对象</li>
<li><code>window.screen</code>: 提供浏览器以外的环境信息</li>
<li><code>window.location</code>: 用于获得当前页面的地址 (URL)，并把浏览器重定向到新的页面</li>
<li><code>window.history</code>: 获取浏览器的历史记录</li>
<li>以上对象在编写时可以一般不使用<code>window</code>这个前缀</li>
</ul>
<h4 id="Screen"><a href="#Screen" class="headerlink" title="Screen"></a>Screen</h4><p><code>Screen</code>中的相关属性的使用如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 提供浏览器以外的环境信息</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">screen</span>)</span><br><span class="line"><span class="comment">// 输出: Screen &#123; availWidth: 2560, availHeight: 1417, width: 2560, height: 1440, colorDepth: 24, pixelDepth: 24, top: 0, left: 0, availTop: 23, availLeft: 0 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回屏幕的宽度，以像素计，减去界面特性，比如窗口任务栏</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(screen.<span class="property">availWidth</span>)</span><br><span class="line"><span class="comment">// 输出: 2560</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回访问者屏幕的高度，以像素计，减去界面特性，比如窗口任务栏</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(screen.<span class="property">availHeight</span>)</span><br><span class="line"><span class="comment">// 输出: 1417</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回总宽度 * 高度</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(screen.<span class="property">width</span> + <span class="string">&quot;*&quot;</span> + screen.<span class="property">height</span>)</span><br><span class="line"><span class="comment">// 输出: 2560*1440</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回色彩深度</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(screen.<span class="property">colorDepth</span>)</span><br><span class="line"><span class="comment">// 输出: 24</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回色彩分辨率</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(screen.<span class="property">pixelDepth</span>)</span><br><span class="line"><span class="comment">// 输出: 24</span></span><br></pre></td></tr></table></figure>


<h4 id="Location"><a href="#Location" class="headerlink" title="Location"></a>Location</h4><ul>
<li>用于获得当前页面的地址 (URL)，并把浏览器重定向到新的页面</li>
<li>常用的属性使用和介绍</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">location</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回web主机的域名和端口号</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(location.<span class="property">host</span>)</span><br><span class="line"><span class="comment">// localhost:63342</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回 web 主机的域名</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(location.<span class="property">hostname</span>)</span><br><span class="line"><span class="comment">// localhost</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回当前页面的路径和文件名</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(location.<span class="property">pathname</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回 web 主机的端口 （80 或 443）</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(location.<span class="property">port</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回所使用的 web 协议（http:// 或 https://）</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(location.<span class="property">protocol</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回当前页面的 URL</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(location.<span class="property">href</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置需要跳转的页面的URL</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span> = <span class="string">&quot;https://www.titanjun.top/&quot;</span></span><br></pre></td></tr></table></figure>


<p>常用的相关方法介绍</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在浏览器中默认是会缓存浏览记录的</span></span><br><span class="line"><span class="comment">// 刷新当前页面, 会缓存</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">location</span>.<span class="title function_">reload</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 刷新当前页面, 不带缓存</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">location</span>.<span class="title function_">reload</span>(<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载新的页面</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">location</span>.<span class="title function_">assign</span>(<span class="string">&quot;greenWindow.html&quot;</span>)</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">location</span>.<span class="title function_">assign</span>(<span class="string">&quot;https:www.titanjun.top&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 替换当前页面(注意：不会再浏览器的历史记录表中留下记录)</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">location</span>.<span class="title function_">replace</span>(<span class="string">&quot;greenWindow.html&quot;</span>)</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">location</span>.<span class="title function_">replace</span>(<span class="string">&quot;https:www.titanjun.top&quot;</span>)</span><br></pre></td></tr></table></figure>


<h4 id="History"><a href="#History" class="headerlink" title="History"></a>History</h4><p>包含浏览器的历史记录</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取历史记录的长度</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(history.<span class="property">length</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回到上一页面</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">history</span>.<span class="title function_">back</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进入到下一页面</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">history</span>.<span class="title function_">forward</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// go() 里面的参数表示跳转页面的个数 </span></span><br><span class="line"><span class="comment">// 例如 history.go(2) 表示前进一个页面</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">history</span>.<span class="title function_">go</span>(<span class="number">2</span>)</span><br><span class="line"><span class="comment">// history.go(-1) 表示后退一个页面</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">history</span>.<span class="title function_">go</span>(-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>


<h3 id="Window相关方法"><a href="#Window相关方法" class="headerlink" title="Window相关方法"></a>Window相关方法</h3><h4 id="open-amp-close"><a href="#open-amp-close" class="headerlink" title="open&amp;close"></a>open&amp;close</h4><p><code>window.close()</code>: 关闭窗口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 用于打开一个新的浏览器窗口或查找一个已命名的窗口</span><br><span class="line">open(url?: string, target?: string, features?: string, replace?: boolean)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>url</code></td>
<td>一个可选的字符串，声明了要在新窗口中显示的文档的 URL。如果省略了这个参数，或者它的值是空字符串，那么新窗口就不会显示任何文档</td>
</tr>
<tr>
<td><code>target</code></td>
<td>一个可选的字符串，该字符串是一个由逗号分隔的特征列表，其中包括数字、字母和下划线，该字符声明了新窗口的名称。这个名称可以用作标记 <code>&lt;a&gt;</code> 和 <code>&lt;form&gt;</code> 的属性 target 的值。如果该参数指定了一个已经存在的窗口，那么<code>open()</code> 方法就不再创建一个新窗口，而只是返回对指定窗口的引用。在这种情况下，<code>features</code>将被忽略。</td>
</tr>
<tr>
<td><code>features</code></td>
<td>一个可选的字符串，声明了新窗口要显示的标准浏览器的特征。如果省略该参数，新窗口将具有所有标准特征。在窗口特征这个表格中，我们对该字符串的格式进行了详细的说明</td>
</tr>
<tr>
<td><code>replace</code></td>
<td>一个可选的布尔值。<code>true</code>装载到窗口的URL在窗口的浏览历史中创建一个新条目，<code>false</code>替换浏览历史中的当前条目</td>
</tr>
</tbody></table>
<p><code>window</code>中方法<code>open()</code>常用的特性</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>width</td>
<td>数值</td>
<td>新窗口的宽度, 不能超过100</td>
</tr>
<tr>
<td>height</td>
<td>数值</td>
<td>新窗口的高度, 不能超过100</td>
</tr>
<tr>
<td>top</td>
<td>数值</td>
<td>距离屏幕上方的像素</td>
</tr>
<tr>
<td>left</td>
<td>数值</td>
<td>距离屏幕左侧像素</td>
</tr>
<tr>
<td>toolbar</td>
<td>yes&#x2F;no</td>
<td>是否显示工具栏, IE浏览器有效</td>
</tr>
<tr>
<td>location</td>
<td>yes&#x2F;no</td>
<td>是否显示地址栏, IE浏览器有效</td>
</tr>
<tr>
<td>fullscreen</td>
<td>yes&#x2F;no</td>
<td>全屏显示</td>
</tr>
</tbody></table>
<h4 id="onload-x2F-onunload"><a href="#onload-x2F-onunload" class="headerlink" title="onload&#x2F;onunload"></a>onload&#x2F;onunload</h4><p><code>onload</code>加载事件和<code>onunload</code>卸载事件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;func()&quot;</span>&gt;</span>跳转<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">		<span class="comment">//onunload事件</span></span></span><br><span class="line"><span class="language-javascript">		<span class="comment">//当页面完全卸载再触发，只有IE支持</span></span></span><br><span class="line"><span class="language-javascript">		<span class="variable language_">window</span>.<span class="property">onunload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">			<span class="title function_">alert</span>(<span class="string">&quot;确定关闭&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">		&#125;;</span></span><br><span class="line"><span class="language-javascript">		<span class="keyword">function</span> <span class="title function_">func</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">			<span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span> = <span class="string">&quot;red.html&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">		&#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">		<span class="comment">//load事件</span></span></span><br><span class="line"><span class="language-javascript">		<span class="comment">//当页面加载完成的时候会触发该事件	</span></span></span><br><span class="line"><span class="language-javascript">		<span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">			<span class="title function_">alert</span>(<span class="string">&quot;我在界面加载完后才显示&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">		&#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">		<span class="title function_">alert</span>(<span class="string">&quot;页面加载中&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">	</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="onscroll"><a href="#onscroll" class="headerlink" title="onscroll"></a>onscroll</h4><p>当窗口发生滚动会触发该事件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">style</span>=<span class="string">&quot;height:3000px&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">h1</span>&gt;</span>我是顶部<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;goOn()&quot;</span> <span class="attr">style</span>=<span class="string">&quot;position: fixed;right: 50px;bottom: 50px&quot;</span>&gt;</span>返回顶部<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">		<span class="comment">//当窗口发生滚动会触发该事件</span></span></span><br><span class="line"><span class="language-javascript">		<span class="variable language_">window</span>.<span class="property">onscroll</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">			<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;滚动&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">			<span class="comment">//打印滚动高度</span></span></span><br><span class="line"><span class="language-javascript">			<span class="keyword">var</span> scrollTop = <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">scrollTop</span>||<span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">scrollTop</span>;</span></span><br><span class="line"><span class="language-javascript">			<span class="variable language_">console</span>.<span class="title function_">log</span>(scrollTop);</span></span><br><span class="line"><span class="language-javascript">		&#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">		<span class="comment">//返回顶部</span></span></span><br><span class="line"><span class="language-javascript">		<span class="keyword">function</span> <span class="title function_">goOn</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">			<span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">scrollTop</span> = <span class="number">0</span>;</span></span><br><span class="line"><span class="language-javascript">			<span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">scrollTop</span> = <span class="number">0</span>;</span></span><br><span class="line"><span class="language-javascript">		&#125;</span></span><br><span class="line"><span class="language-javascript">	</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h4 id="onresize"><a href="#onresize" class="headerlink" title="onresize"></a>onresize</h4><p>当浏览器发生缩放的时候就会反复触发resize事件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">		<span class="comment">//当浏览器发生缩放的时候就会反复触发resize事件		</span></span></span><br><span class="line"><span class="language-javascript">		<span class="variable language_">window</span>.<span class="property">onresize</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">			<span class="keyword">var</span> w = <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientWidth</span> || <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">clientWidth</span> || <span class="variable language_">window</span>.<span class="property">innerWidth</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">			<span class="keyword">var</span> h = <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientHeight</span> || <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">clientHeight</span> || <span class="variable language_">window</span>.<span class="property">innerHeight</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">			<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientWidth</span>, <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">clientWidth</span>, <span class="variable language_">window</span>.<span class="property">innerWidth</span>, w);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">			<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientHeight</span>, <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">clientHeight</span>, <span class="variable language_">window</span>.<span class="property">innerHeight</span>, h);</span></span><br><span class="line"><span class="language-javascript">		&#125;;</span></span><br><span class="line"><span class="language-javascript">	</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="JS弹窗"><a href="#JS弹窗" class="headerlink" title="JS弹窗"></a>JS弹窗</h3><p>在<code>JavaScript</code>中创建三种消息框：警告框、确认框、提示框</p>
<h4 id="警告框"><a href="#警告框" class="headerlink" title="警告框"></a>警告框</h4><ul>
<li>警告框经常用于确保用户可以得到某些信息。</li>
<li>当警告框出现后，用户需要点击确定按钮才能继续进行操作</li>
</ul>
<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/javascript/jsAlert.png?x-oss-process=style/titanjun" alt="Alert"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;showAlert()&quot;</span>&gt;</span>点击显示警告框<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">showAlert</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>(<span class="string">&#x27;你好, 这是一个警告框!&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="确认框"><a href="#确认框" class="headerlink" title="确认框"></a>确认框</h4><ul>
<li>确认框通常用于验证是否接受用户操作。</li>
<li>当确认卡弹出时，用户可以点击 “确认” 或者 “取消” 来确定用户操作。</li>
<li>当你点击 “确认”, 确认框返回<code>true</code>， 如果点击 “取消”, 确认框返回<code>false</code></li>
</ul>
<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/javascript/jsconfirm.png?x-oss-process=style/titanjun" alt="confirm"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;showConfirm()&quot;</span>&gt;</span>点击显示确认框<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">showConfirm</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> action = <span class="string">&#x27;&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> con = <span class="title function_">confirm</span>(<span class="string">&#x27;你好, 这是一个警告框!&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span> (con == <span class="literal">true</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                action = <span class="string">&#x27;选择了确认&#x27;</span></span></span><br><span class="line"><span class="language-javascript">            &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                action = <span class="string">&#x27;选择了取消&#x27;</span></span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(action)</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h4 id="提示框"><a href="#提示框" class="headerlink" title="提示框"></a>提示框</h4><ul>
<li>提示框经常用于提示用户在进入页面前输入某个值。</li>
<li>当提示框出现后，用户需要输入某个值，然后点击确认或取消按钮才能继续操纵。</li>
<li>如果用户点击确认，那么返回值为输入的值。如果用户点击取消，那么返回值为<code>null</code></li>
</ul>
<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/javascript/jsproptm.png?x-oss-process=style/titanjun" alt="image"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;showPrompt()&quot;</span>&gt;</span>点击显示提示框<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">showPrompt</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> action = <span class="string">&#x27;&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> person = <span class="title function_">prompt</span>(<span class="string">&#x27;请输入你的名字&#x27;</span>, <span class="string">&#x27;titanjun&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span> (person != <span class="literal">null</span> &amp;&amp; person != <span class="string">&quot;&quot;</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                action = <span class="string">&quot;你好: &quot;</span> + person</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(action)</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h3 id="JS计时器"><a href="#JS计时器" class="headerlink" title="JS计时器"></a>JS计时器</h3><ul>
<li>在<code>JavaScript</code>中有两种计时方式, 间歇性计时器和延迟性定时器</li>
<li><code>setInterval()</code>和<code>setTimeout()</code>是<code>HTML DOM Window</code>对象的两个方法</li>
<li>两个方法可以不使用<code>window</code>前缀，直接使用函数</li>
</ul>
<h4 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval"></a>setInterval</h4><ul>
<li>间隔指定的毫秒数不停地执行指定的代码</li>
<li>第一个参数是函数, 第二个参数间隔的毫秒数, 1000 毫秒是一秒</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// time不是定时器的名字, 只是定时器的编号, 是一个number类型</span></span><br><span class="line"><span class="keyword">var</span> time = <span class="variable language_">window</span>.<span class="built_in">setInterval</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;titanjun.top&quot;</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> time)</span><br></pre></td></tr></table></figure>

<ul>
<li>在开启定时器后, 如何让定时器停止工作?</li>
<li><code>clearInterval()</code>方法用于停止<code>setInterval()</code>方法执行的函数代码</li>
<li>一旦定时器停止工作后, 就必须重新启动定时器, 且定时器不能暂停, 只能停止和重启</li>
<li>要使用<code>clearInterval()</code>方法, 在创建计时方法时你必须使用全局变量</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;closeInterver()&quot;</span>&gt;</span>关闭定时器<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//setInterval(函数名,时间)</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 功能：创建一个间歇性定时器，每间隔参数二时间执行一次参数一函数</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 返回值：定时器的id，可以通过该id关闭定时器</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// time不是定时器的名字, 只是定时器的编号, 是一个number类型</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> time = <span class="variable language_">window</span>.<span class="built_in">setInterval</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;titanjun.top&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">        &#125;, <span class="number">1000</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> time)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 关闭定时器</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">closeInterver</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//注：js中没有恢复定时器一说，当你停止定时器之后，定时器就会被删掉，想要继续的话，直接新建一个定时器。</span></span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">window</span>.<span class="built_in">clearInterval</span>(time)</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h4 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a>setTimeout</h4><p>在指定的毫秒数后执行指定代码, 且只执行一次</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//setTimeout(函数名，时间)</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//功能：参数2时间以后再执行参数1函数</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//返回值：定时器的id</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(<span class="string">&quot;创建定时器，3秒后执行名为func的函数&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> timer = <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;titanjun.top&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">        &#125;, <span class="number">3000</span>)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 关闭定时器</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">closeTimer</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">window</span>.<span class="built_in">clearTimeout</span>(timer)</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><ul>
<li>当网页被加载时，浏览器会创建页面的文档对象模型（<code>Document Object Model</code>）</li>
<li><code>DOM</code>是访问HTML和操作<code>HTML</code>的标准</li>
<li>通过可编程的对象模型，<code>JavaScript</code>获得了足够的能力来创建动态的<code>HTML</code><ul>
<li><code>JavaScript</code>能够改变页面中的所有<code>HTML</code>元素</li>
<li><code>JavaScript</code>能够改变页面中的所有<code>HTML</code>属性</li>
<li><code>JavaScript</code>能够改变页面中的所有<code>CSS</code>样式</li>
<li><code>JavaScript</code>能够对页面中的所有事件做出反应</li>
</ul>
</li>
<li><code>HTML DOM</code>模型被构造为对象的树</li>
</ul>
<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/javascript/domlisten.png?x-oss-process=style/titanjun" alt="domlisten"></p>
<ul>
<li>DOM节点层级关系(DOM树)<ul>
<li>1、父节点(<code>parent node</code>)：父节点拥有任意数量的子节点</li>
<li>2、子节点(<code>child node</code>)：子节点只能拥有一个父节点</li>
<li>3、兄弟节点(<code>sibling node</code>)：拥有相同父节点的同级节点</li>
<li>4、根节点(<code>root node</code>)：一个<code>HTML</code>文档一般只有一个根节点，根节点没有父亲节点，是最上层的节点</li>
<li>祖先节点：包含子节点的节点都可以叫做祖先节点，其中包括了父节点</li>
<li>后代节点：一个节点内包含的所有节点，叫做后代节点，其中包括了子节点</li>
</ul>
</li>
<li>DOM节点的分类<ul>
<li>1、文档节点</li>
<li>2、标签(元素)节点</li>
<li>3、属性节点</li>
<li>4、文本节点</li>
<li>5、注释节点</li>
</ul>
</li>
</ul>
<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/javascript/domcategory.png?x-oss-process=style/titanjun" alt="domcategory"></p>
<h3 id="获取HTML标签"><a href="#获取HTML标签" class="headerlink" title="获取HTML标签"></a>获取HTML标签</h3><p>在<code>JavaScript</code>中需要操作<code>HTML</code>标签, 首先要获取该标签, 这里介绍三种方法</p>
<ul>
<li>通过<code>id</code>找到<code>HTML</code>元素</li>
<li>通过标签名找到<code>HTML</code>元素</li>
<li>通过类名找到<code>HTML</code>元素</li>
<li>通过<code>name</code>属性找到<code>HTML</code>元素</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--id div--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;idDiv&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--classs div--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;class1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;class1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;class1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;class1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--input--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;inputText&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;inputText&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;inputText&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--JavaScript--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 1. 根据元素id获取元素节点</span></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;-------getElementById--------&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> idDiv = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;idDiv&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(idDiv)</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> idDiv)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 2. 根据元素class属性获取元素节点, 返回数组</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 获取相同class属性的元素节点列表, 注意：此方法不支持IE8以下</span></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;-----------getElementsByClassName------------------&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> classDivs = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&#x27;class1&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; classDivs.<span class="property">length</span>; i++) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(classDivs[i])</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 3.根据标签名来获取元素节点的结合, 返回数组</span></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;-----------getElementsByTagName------------------&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> tagNameDics = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;div&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; tagNameDics.<span class="property">length</span>; i++) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(tagNameDics[i])</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 4. 根据name属性值来获取元素节点的集合, 返回数组</span></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;------------getElementsByName--------------------&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> nameDivs = <span class="variable language_">document</span>.<span class="title function_">getElementsByName</span>(<span class="string">&#x27;inputText&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; nameDivs.<span class="property">length</span>; i++) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(nameDivs[i])</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h3 id="获取属性节点"><a href="#获取属性节点" class="headerlink" title="获取属性节点"></a>获取属性节点</h3><ul>
<li>标签的属性分官方定义的属性和自定义属性</li>
<li>官方定义的属性可用点语法获取属性值</li>
<li>自定义属性只能通过<code>getAttribute</code>方法</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>  <span class="attr">id</span>=<span class="string">&quot;in&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;titanjun.top&quot;</span> <span class="attr">blog</span>=<span class="string">&quot;titanjun&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> input = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;in&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(input)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 1. 获取官方定义的属性节点可以直接使用点语法, 用法: 元素节点.属性名</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 得到元素对应的属性值</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> inType = input.<span class="property">type</span></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(inType)</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(input.<span class="property">placeholder</span>)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 修改元素对应的属性值</span></span></span><br><span class="line"><span class="language-javascript">        input.<span class="property">placeholder</span> = <span class="string">&quot;https://www.titanjun.top&quot;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;-----------getAttribute-----------&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 2. getAttribute方法, 可获取官方定义的属性和自定义的属性</span></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(input.<span class="title function_">getAttribute</span>(<span class="string">&#x27;placeholder&#x27;</span>))</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> blog = input.<span class="title function_">getAttribute</span>(<span class="string">&#x27;blog&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(blog)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;-----------setAttribute-----------&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 修改元素对应的属性名</span></span></span><br><span class="line"><span class="language-javascript">        input.<span class="title function_">setAttribute</span>(<span class="string">&#x27;blog&#x27;</span>, <span class="string">&#x27;titan&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(input)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;-----------removeEventListener-----------&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 移除元素节点中的某个属性节点, 某些低版本浏览器不支持</span></span></span><br><span class="line"><span class="language-javascript">        input.<span class="title function_">removeAttribute</span>(<span class="string">&#x27;blog&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(input)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h3 id="获取文本节点"><a href="#获取文本节点" class="headerlink" title="获取文本节点"></a>获取文本节点</h3><ul>
<li><code>innerHTML</code>: 从对象的开始标签到结束标签的全部内容,不包括本身Html标签</li>
<li><code>outerHTML</code>: 除了包含innerHTML的全部内容外, 还包含对象标签本身</li>
<li><code>innerText</code>: 从对象的开始标签到结束标签的全部的文本内容</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">        这是一个div盒子</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> jsDiv = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;box&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 1. 元素节点.innerHTML</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//从对象的开始标签到结束标签的全部内容,不包括本身Html标签</span></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;--------innerHTML--------&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> inner = jsDiv.<span class="property">innerHTML</span></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(jsDiv)</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> jsDiv)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 2. 元素节点.outerHTML</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//除了包含innerHTML的全部内容外, 还包含对象标签本身</span></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;--------innerHTML--------&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> outer = jsDiv.<span class="property">outerHTML</span></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(outer)</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> outer)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 3. 元素节点.innerText</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//从对象的开始标签到结束标签的全部的文本内容</span></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;--------innerHTML--------&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> text = jsDiv.<span class="property">innerText</span></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(text)</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> text)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 修改</span></span></span><br><span class="line"><span class="language-javascript">        jsDiv.<span class="property">innerText</span> = <span class="string">&quot;https://www.titanjun.top&quot;</span></span></span><br><span class="line"><span class="language-javascript">        jsDiv.<span class="property">innerHTML</span> = <span class="string">&quot;&lt;h2&gt;https://www.titanjun.top&lt;/h2&gt;&quot;</span></span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h3 id="读写行间样式表"><a href="#读写行间样式表" class="headerlink" title="读写行间样式表"></a>读写行间样式表</h3><p>获取像是表中的样式属性的属性值, 常用有两种方式</p>
<ul>
<li>方法一: 元素节点.style.样式属性名</li>
<li>方法二: 元素节点.style[“样式属性名”]</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;box&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 100px; height: 100px; background-color: red&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;changeColor()&quot;</span>&gt;</span>换颜色<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 获取元素节点</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> jsDiv = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;box&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 获取style属性节点</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> divStyle = jsDiv.<span class="property">style</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// console.log(divStyle)</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 获取像是表中的样式属性的属性值</span></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(divStyle.<span class="property">width</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(jsDiv.<span class="property">style</span>[<span class="string">&quot;height&quot;</span>])</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 设置样式表中样式属性的属性值</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 元素节点.style.样式属性名 = 样式属性值</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// background-color --- backgroundColor</span></span></span><br><span class="line"><span class="language-javascript">        jsDiv.<span class="property">style</span>.<span class="property">backgroundColor</span> = <span class="string">&#x27;green&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">changeColor</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> r = <span class="built_in">parseInt</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">256</span>);</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> g = <span class="built_in">parseInt</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">256</span>);</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> b = <span class="built_in">parseInt</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">256</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> colorStr = <span class="string">&quot;rgb(&quot;</span> + r + <span class="string">&quot;, &quot;</span> + g + <span class="string">&quot;, &quot;</span> + b + <span class="string">&quot;)&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">            jsDiv.<span class="property">style</span>.<span class="property">backgroundColor</span> = colorStr</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>设置样式表中样式属性的属性值时, 样式属性名遵循驼峰命名规则</li>
<li><code>HTML</code>中的-号去掉，-号后面的单词首字母大写</li>
<li>一般情况下, <code>css</code>的样式属性中出现”-“好, 则对应的<code>style</code>属性是: 去掉”-“号后面单词的第一个字母大写. 如果没有”-“号, 则两者一样</li>
</ul>
<table>
<thead>
<tr>
<th>CSS样式属性</th>
<th>Style对象属性</th>
</tr>
</thead>
<tbody><tr>
<td>color</td>
<td>color</td>
</tr>
<tr>
<td>font-size</td>
<td>fontSize</td>
</tr>
<tr>
<td>font-family</td>
<td>fontFamily</td>
</tr>
<tr>
<td>background-color</td>
<td>backgroundColor</td>
</tr>
<tr>
<td>background-image</td>
<td>backgroundImage</td>
</tr>
<tr>
<td>display</td>
<td>display</td>
</tr>
</tbody></table>
<h3 id="节点常用属性"><a href="#节点常用属性" class="headerlink" title="节点常用属性"></a>节点常用属性</h3><ul>
<li>在<code>DOM</code>中，每个节点都是一个对象</li>
<li>对象拥有方法和属性，并可通过<code>JavaScript</code>进行访问和操作</li>
<li>三个重要的节点属性是：<code>nodeName</code>, <code>nodeValue</code>, <code>nodeType</code></li>
</ul>
<table>
<thead>
<tr>
<th>节点类型</th>
<th>nodeName</th>
<th>nodeType</th>
<th>nodeValue</th>
</tr>
</thead>
<tbody><tr>
<td>元素节点</td>
<td>元素名称</td>
<td>1</td>
<td>null</td>
</tr>
<tr>
<td>属性节点</td>
<td>属性名称</td>
<td>2</td>
<td>属性值</td>
</tr>
<tr>
<td>文本节点</td>
<td>#text</td>
<td>3</td>
<td>文本内容不包括html</td>
</tr>
<tr>
<td>注释节点</td>
<td>#comment</td>
<td>8</td>
<td>注释内容</td>
</tr>
<tr>
<td>文档节点</td>
<td>#document</td>
<td>9</td>
<td>null</td>
</tr>
</tbody></table>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;box1&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是第一个P<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是第二个P<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是第三个P<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是第四个P<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;box2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;box3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;put&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;in&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;https://www.titanjun.top&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 节点共有的属性：nodeName、nodeType、nodeValue</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> div1 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;box1&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(div1)</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(div1.<span class="property">nodeName</span>, div1.<span class="property">nodeType</span>, div1.<span class="property">nodeValue</span>)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 1. 获取当前元素节点的所有的子节点</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> childNodesArr = div1.<span class="property">childNodes</span></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(childNodesArr)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 2. 获取当前元素节点的第一个子节点</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> firstChildNode = div1.<span class="property">firstChild</span></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(firstChildNode)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 3. 获取当前节点的最后一个节点</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> lastChhildNode = div1.<span class="property">lastChild</span></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(lastChhildNode)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 4. 获取该节点文档的根节点, 相当于document</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> rootNode = div1.<span class="property">ownerDocument</span></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(rootNode)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 5. 获取当前节点的父节点</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> parentNode = div1.<span class="property">parentNode</span></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(parentNode)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 6. 获取当前节点的前一个同级节点</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> div2 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;box2&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> previousNode = div2.<span class="property">previousSibling</span></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(previousNode)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 7. 获取当前节点的后一个同级节点</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> nextNode = div2.<span class="property">nextSibling</span></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(nextNode)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 8. 获取当前节点的所有属性节点</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> jsInput = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;put&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(jsInput.<span class="property">attributes</span>)</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h3 id="节点动态操作"><a href="#节点动态操作" class="headerlink" title="节点动态操作"></a>节点动态操作</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>titanjun<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>titanking<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 创建元素节点</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> div1 = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">        div1.<span class="property">id</span> = <span class="string">&#x27;box1&#x27;</span></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(div1)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 将一个新节点添加到某个节点的子节点列表的末尾上</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//父节点.appendChild(子节点)</span></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(div1)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 将新节点添加到父节点的某个子节点的前面</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> jsP = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;p&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">        jsP.<span class="property">innerHTML</span> = <span class="string">&quot;https://www.titanjun.top&quot;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//父节点.insertBefore(新节点, 子节点)</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> jsD = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;box&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">        jsD.<span class="title function_">insertBefore</span>(jsP, jsD.<span class="property">childNodes</span>[<span class="number">3</span>])</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(jsD)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 创建文本节点</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> jsStr = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&#x27;/titanjun.top&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 添加文本节点</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> jsP2 = jsD.<span class="property">childNodes</span>[<span class="number">1</span>]</span></span><br><span class="line"><span class="language-javascript">        jsP2.<span class="title function_">appendChild</span>(jsStr)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 替换节点, 将父节点中的某个子节点替换成新的节点</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> replaceDiv = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">        replaceDiv.<span class="property">id</span> = <span class="string">&#x27;box2&#x27;</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//父节点.replaceChild(新节点, 子节点)</span></span></span><br><span class="line"><span class="language-javascript">        div1.<span class="property">parentNode</span>.<span class="title function_">replaceChild</span>(replaceDiv, div1)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 复制节点</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 只复制本身</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> copyDiv1 = jsD.<span class="title function_">cloneNode</span>()</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(copyDiv1)</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 复制本身和子节点</span></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(jsD.<span class="title function_">cloneNode</span>(<span class="literal">true</span>))</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 删除节点, 删除父节点下对应的子节点</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//父节点.removeChild(子节点)</span></span></span><br><span class="line"><span class="language-javascript">        replaceDiv.<span class="property">parentNode</span>.<span class="title function_">removeChild</span>(replaceDiv)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 参照物父元素</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//当某个元素的父元素或以上元素都未进行CSS定位时，则返回body元素，也就是说元素的偏移量（offsetTop、offsetLeft）等属性是以body为参照物的</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//当某个元素的父元素进行了CSS定位时（absolute或者relative），则返回父元素，也就是说元素的偏移量是以父元素为参照物的</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//当某个元素及其父元素都进行CSS定位时，则返回距离最近的使用了CSS定位的元素</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> temp = jsD.<span class="property">childNodes</span>[<span class="number">1</span>].<span class="property">offsetParent</span></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(temp)</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>



<hr>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac环境下MySQL的安装和基本命令的使用</title>
    <url>/post/46193fbc.html</url>
    <content><![CDATA[<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-9dfa73f3a5747e75.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="mysql"></p>
<span id="more"></span>

<ul>
<li><code>MySQL</code>是一种关系数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。</li>
<li><code>MySQL</code>所使用的<code>SQL</code>语言是用于访问数据库的最常用标准化语言。</li>
<li>由于其体积小、速度快、总体拥有成本低，尤其是开放源码这一特点，许多中小型网站为了降低网站总体拥有成本而选择了<code>MySQL</code>作为网站数据库。</li>
<li><code>MySQL</code>是一个多用户、多线程的关系型数据库管理系统。 工作模式是基于客户机&#x2F;服务器结构。目前它可以支持几乎所有的操作系统</li>
<li>简单的来说，<code>MySQL</code>是一个开放的、快速的、多线程的、多用户的SQL数据库服务器</li>
</ul>
<h2 id="MySQL的安装"><a href="#MySQL的安装" class="headerlink" title="MySQL的安装"></a>MySQL的安装</h2><p>工欲善其事必先利其器, 要研究<code>MySQL</code>我们首先要安装<code>MySQL</code>, 这里只介绍<code>Mac</code>环境下的安装和数据库操作</p>
<h3 id="下载MySQL"><a href="#下载MySQL" class="headerlink" title="下载MySQL"></a>下载<code>MySQL</code></h3><p>直接打开<a href="https://dev.mysql.com/downloads/mysql/">MySQL官网下载页</a>, 选择<code>mac OS</code>系统后, 选择<code>DMG</code>格式下载软件</p>
<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-4b588c7801a15bf2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="SQLDownload1"></p>
<p>接着, 会跳转到如下页面, 你只需要选择不登录,直接下载即可(当然也可以选择注册并登录)</p>
<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-4d7bddda7663e338.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="SQLDownload2"></p>
<ul>
<li>下载好后, 按照<code>dmg</code>里面的<code>pkg</code>文件一路安装即可, 但是需要注意的是<ul>
<li>除了倒数第二步之外按照默认一路安装即可</li>
<li>倒数第二步会有一个设置管理员密码的过程, 设置好后, 一定要牢记该密码, 后期链接数据库会需要</li>
</ul>
</li>
<li>最后打开系统偏好设置, 最后会有一个<code>MySQL</code>的图标</li>
<li>打开<code>MySQL</code>会看到默认是开启的(安装的时候按照默认设置安装的情况下)</li>
</ul>
<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-a704a63464f08911.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<div class="note success"><p>到这里`MySQL`就已经基本安装完成了, 不需要再修改什么配置了</p></div>


<h3 id="安装Navicat-for-MySQL"><a href="#安装Navicat-for-MySQL" class="headerlink" title="安装Navicat for MySQL"></a>安装<code>Navicat for MySQL</code></h3><ul>
<li><code>Navicat for MySQL</code>是一套专为<code>MySQL</code>设计的高性能数据库管理及开发工具</li>
<li>它可以用于任何版本<code>3.21</code>或以上的 <code>MySQL</code>数据库服务器</li>
<li>支持大部份<code>MySQL</code>最新版本的功能，包括触发器、存储过程、函数、事件、视图、管理用户等</li>
<li><a href="http://www.navicat.com.cn/products/navicat-for-mysql/">正版下载地址</a>, 不过正版只有14天的试用时间</li>
<li>安装后, 按照下图完善配置即可, 其中连接名随意, 密码即为安装<code>MySQL</code>环境的时候设置的密码</li>
</ul>
<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-d826199a57d36385.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="MySQLConten"></p>
<h2 id="MySQL的基本命令"><a href="#MySQL的基本命令" class="headerlink" title="MySQL的基本命令"></a><code>MySQL</code>的基本命令</h2><h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><ul>
<li>首先要打开终端(<code>Windows</code>中是<code>cmd</code>), 以下命令均是在终端运行</li>
<li>启动&#x2F;停止服务只有在<code>Windows</code>系统中才需要运行, <code>Mac</code>环境下不需要</li>
</ul>
<h4 id="启动-x2F-停止服务"><a href="#启动-x2F-停止服务" class="headerlink" title="启动&#x2F;停止服务"></a>启动&#x2F;停止服务</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 启动服务</span></span><br><span class="line">    格式：net start 服务名称</span><br><span class="line">    示例：net start titansql</span><br><span class="line"></span><br><span class="line"><span class="comment">// 停止服务</span></span><br><span class="line">    格式：net stop 服务名称</span><br><span class="line">    示例：net stop titansql</span><br></pre></td></tr></table></figure>

<h4 id="连接数据"><a href="#连接数据" class="headerlink" title="连接数据"></a>连接数据</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">格式：mysql -u 用户名 -p</span><br><span class="line">示例：mysql -u root -p</span><br><span class="line"><span class="comment">// 此处会提示你输入密码(安装时设置的)</span></span><br></pre></td></tr></table></figure>

<h4 id="远程连接"><a href="#远程连接" class="headerlink" title="远程连接"></a>远程连接</h4><ul>
<li>链接他人或其他服务器的数据库<ul>
<li>格式：<code>mysql -h ip地址 -u 用户名 -p</code></li>
<li>输入对方<code>mysql</code>密码</li>
</ul>
</li>
</ul>
<h4 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h4><div class="note warning"><p>需要注意的是:</p></div>

<p>以下所有命令中如过结尾有分号(<code>;</code>)的一定不能省略, 否则不是一条完整的命令, 系统会提示你继续输入命令</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查看版本（连接后可以执行）</span></span><br><span class="line">select version();</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示当前时间（连接后可以执行）</span></span><br><span class="line">select now();</span><br><span class="line"></span><br><span class="line"><span class="comment">//退出登录(断开连接)</span></span><br><span class="line">quit或exit</span><br></pre></td></tr></table></figure>

<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-64606af819564228.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h3 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1、创建数据库</span></span><br><span class="line">    格式：create database 数据库名 charset=utf8;</span><br><span class="line">    示例：create database titansql charset=utf8;</span><br><span class="line"><span class="comment">// 2、删除数据库</span></span><br><span class="line">    格式：drop database 数据库名;</span><br><span class="line">    示例：drop database titansql;</span><br><span class="line"><span class="comment">// 3、切换数据库</span></span><br><span class="line">    格式：use 数据库名;</span><br><span class="line">    示例：use titansql;</span><br><span class="line"><span class="comment">// 4、查看当前选择的数据库</span></span><br><span class="line">    select database();</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>创建完成记得刷新<code>Navicat for MySQL</code></p>
<p><img data-src="http://p7hfnfk6u.bkt.clouddn.com/sqlSuccess.png" alt="image"></p>
<h3 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1、查看当前数据库中所有表</span></span><br><span class="line">    show tables;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 2、创建表</span></span><br><span class="line">    格式：create table 表名(列及类型);</span><br><span class="line">    说明：</span><br><span class="line">        <span class="comment">//id, name, age: 等为字段名</span></span><br><span class="line">        <span class="comment">//auto_increment: 表示自增长   </span></span><br><span class="line">        <span class="comment">//primary key: 表示主键  </span></span><br><span class="line">        <span class="comment">//int, varchar(20): 等为数据类型, 20为可存储的字节数</span></span><br><span class="line">        <span class="comment">//not null: 表示不为空</span></span><br><span class="line">        <span class="comment">//default: 为设置默认值</span></span><br><span class="line">    示例：create table student(<span class="type">id</span> <span class="type">int</span> auto_increment primary key, name varchar(<span class="number">20</span>) not null, age <span class="type">int</span> not null, gender bit <span class="keyword">default</span> <span class="number">1</span>, address varchar(<span class="number">20</span>), isDelete bit <span class="keyword">default</span> <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">// 3、删除表</span></span><br><span class="line">    格式：drop table 表名;</span><br><span class="line">    示例：drop table student;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 4、查看表结构</span></span><br><span class="line">    格式：desc 表名;</span><br><span class="line">    示例：desc student;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 5、查看建表语句</span></span><br><span class="line">    格式：show create table 表名;</span><br><span class="line">    示例：show create table student;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 6、重命名表名</span></span><br><span class="line">    格式：rename table 原表名 to 新表名;</span><br><span class="line">    示例：rename table car to newCar;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 7、修改表</span></span><br><span class="line">    格式：alter table 表名 add|change|drop 列名 类型;</span><br><span class="line">    示例：alter table newcar add isDelete bit <span class="keyword">default</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>


<h3 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、增</span><br><span class="line">    a、全列插入</span><br><span class="line">        格式：insert into 表名 values(...);</span><br><span class="line">        说明：主键列是自动增长，但是在全列插入时需要占位，通常使用<span class="number">0</span>，插入成功以后以实际数据为准</span><br><span class="line">        示例：insert into student values(<span class="number">0</span>, <span class="string">&quot;tom&quot;</span>, <span class="number">19</span>, <span class="number">1</span>, <span class="string">&quot;北京&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    b、缺省插入</span><br><span class="line">        格式：insert into 表名(列<span class="number">1</span>,列<span class="number">2</span>,……) values(值<span class="number">1</span>,值<span class="number">2</span>,……);</span><br><span class="line">        示例：insert into student(name, age, address) values(<span class="string">&quot;titan&quot;</span>, <span class="number">19</span>, <span class="string">&quot;上海&quot;</span>);</span><br><span class="line">    c、同时插入多条数据</span><br><span class="line">        格式：insert into 表名 values(...),(...),……</span><br><span class="line">        示例：insert into student values(<span class="number">0</span>, <span class="string">&quot;jun&quot;</span>, <span class="number">18</span>, <span class="number">0</span>, <span class="string">&quot;北京&quot;</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="string">&quot;poi&quot;</span>, <span class="number">22</span>, <span class="number">1</span>, <span class="string">&quot;海南&quot;</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="string">&quot;coder&quot;</span>, <span class="number">20</span>, <span class="number">0</span>, <span class="string">&quot;石家庄&quot;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="number">2</span>、删</span><br><span class="line">    格式：delete from 表名 where 条件;  </span><br><span class="line">    示例：delete from student where <span class="type">id</span>=<span class="number">4</span>;</span><br><span class="line">    注意：没有条件是全部删除，慎用</span><br><span class="line"><span class="number">3</span>、改</span><br><span class="line">    格式：update 表名 set 列<span class="number">1</span>=值<span class="number">1</span>,列<span class="number">2</span>=值<span class="number">2</span>,…… where 条件;</span><br><span class="line">    示例：update student set age=<span class="number">16</span> where <span class="type">id</span>=<span class="number">7</span>;  </span><br><span class="line">    注意：没有条件是全部列都修改，慎用</span><br><span class="line"><span class="number">4</span>、查</span><br><span class="line">    说明：查询表中的全部数据</span><br><span class="line">    格式：select * from 表名;</span><br><span class="line">    示例：select * from student;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><ul>
<li>格式：<code>select * from 表名;</code></li>
<li>说明：<ul>
<li><code>from</code>关键字后面是表名，表示数据来源于这张表</li>
<li><code>select</code>后面写表中的列名，如果是*表示在结果集中显示表中的所有列</li>
<li>在<code>select</code>后面的列名部分，可以使用<code>as</code>为列名起别名，这个别名显示在结果集中</li>
<li>如果要查询多个列，之间使用逗号分隔</li>
</ul>
</li>
<li>示例：</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查询所有数据</span></span><br><span class="line">select * from student;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询某列数据</span></span><br><span class="line">select name, age from student;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以别名显示搜索结果</span></span><br><span class="line">select name as a, age from student;</span><br></pre></td></tr></table></figure>

<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-82c6b03e2d0e3f89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="别名"></p>
<h4 id="消除重复行"><a href="#消除重复行" class="headerlink" title="消除重复行"></a>消除重复行</h4><ul>
<li>在<code>select</code>后面列前面使用<code>distinct</code>可以消除重复的行</li>
<li>示例：</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">select gender from student;</span><br><span class="line">select distinct gender from student;</span><br></pre></td></tr></table></figure>

<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-763a7bd7dcafd230.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="distinct"></p>
<h4 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1、语法</span></span><br><span class="line">    select * from 表名 where 条件</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 2、比较运算符</span></span><br><span class="line">        等于        =</span><br><span class="line">        大于        &gt;</span><br><span class="line">        小于        &lt;</span><br><span class="line">        大于等于    &gt;=</span><br><span class="line">        小于等于    &lt;=</span><br><span class="line">        不等于      !=或&lt;&gt;</span><br><span class="line">    需求：查询<span class="type">id</span>值大于<span class="number">8</span>的所有数据</span><br><span class="line">    示例：select * from student where <span class="type">id</span>&gt;<span class="number">8</span>;</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 3、逻辑运算符</span></span><br><span class="line">        and    并且</span><br><span class="line">        or     或者</span><br><span class="line">        not    非</span><br><span class="line">            </span><br><span class="line">    需求：查询<span class="type">id</span>值大于<span class="number">7</span>的女同学</span><br><span class="line">    示例：select * from student where <span class="type">id</span>&gt;<span class="number">7</span> and gender=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 4、模糊查询(like)</span></span><br><span class="line">        %: 表示任意多个任意字符</span><br><span class="line">        _: 表示一个任意字符</span><br><span class="line"></span><br><span class="line">    需求：查询姓习的同学</span><br><span class="line">    示例：</span><br><span class="line">        select * from student where name like <span class="string">&quot;习%&quot;</span>;</span><br><span class="line">        select * from student where name like <span class="string">&quot;习_&quot;</span>;</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 5、范围查询</span></span><br><span class="line">        <span class="keyword">in</span>                表示在一个非连续的范围内</span><br><span class="line">        between...and...  表示在一个连续的范围内</span><br><span class="line"></span><br><span class="line">    需求：查询编号为<span class="number">8</span>、<span class="number">10</span>、<span class="number">12</span>的学生</span><br><span class="line">    示例：select * from student where <span class="type">id</span> <span class="keyword">in</span> (<span class="number">8</span>,<span class="number">10</span>,<span class="number">12</span>);</span><br><span class="line">    需求：查询编号为<span class="number">6</span>到<span class="number">8</span>的学生</span><br><span class="line">    示例：select * from student where <span class="type">id</span> between <span class="number">6</span> and <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6、空判断</span></span><br><span class="line">        注意：null与<span class="string">&quot;&quot;</span>是不同的</span><br><span class="line">        判断空：is null</span><br><span class="line">        判断非空： is not null</span><br><span class="line"></span><br><span class="line">    需求：查询没有地址的同学</span><br><span class="line">    示例：select * from student where address is null;</span><br><span class="line">    需求：查询有地址的同学</span><br><span class="line">    示例：select * from student where address is not null;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 7、优先级</span></span><br><span class="line">        小括号，not 比较运算符，逻辑运算符</span><br><span class="line">        and比or优先级高，如果同时出现并希望先选or,需要结合()来使用</span><br></pre></td></tr></table></figure>


<h4 id="聚合操作"><a href="#聚合操作" class="headerlink" title="聚合操作"></a>聚合操作</h4><ul>
<li>为了快速等到统计数据，提供了5个聚合函数<ul>
<li><code>count(*)</code>: 表示计算总行数，括号中可以写*和列名</li>
<li><code>max(列)</code>: 表示求此列的最大值</li>
<li><code>min(列)</code>: 表示求此列的最小值</li>
<li><code>sum(列)</code>: 表示求此列的和</li>
<li><code>avg(列)</code>: 表示求此列的平均值</li>
</ul>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//需求：查询学生总数</span></span><br><span class="line">select count(*) from student;</span><br><span class="line"></span><br><span class="line"><span class="comment">//需求：查询女生的编号最大值</span></span><br><span class="line">select max(<span class="type">id</span>) from student where gender=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//需求：查询女生的编号最小值</span></span><br><span class="line">select min(<span class="type">id</span>) from student where gender=<span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//需求：查询所有学生的年龄和</span></span><br><span class="line">select sum(age) from student;</span><br><span class="line"></span><br><span class="line"><span class="comment">//需求：查询所有学生的年龄平均值</span></span><br><span class="line">select avg(age) from student;</span><br></pre></td></tr></table></figure>

<h4 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h4><ul>
<li>按照字段分组，表示此字段相同的数据会被放到一个集合中。</li>
<li>分组后，只能查询出相同的数据列，对于有差异的数据列无法显示在结果集中</li>
<li>可以对分组后的数据进行统计，做聚合运算</li>
<li>语法：<ul>
<li><code>select 列1,列2,聚合…… from 表名 group by 列1,列2,列3,……;</code></li>
</ul>
</li>
<li>需求：查询男女生总数</li>
<li>示例：</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">select gender,count(*) from student group by gender;</span><br><span class="line">select name,gender,count(*) from student group by gender,age;</span><br></pre></td></tr></table></figure>

<p>分组后的数据筛选：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">select 列<span class="number">1</span>,列<span class="number">2</span>,聚合…… from 表名 group by 列<span class="number">1</span>,列<span class="number">2</span>,列<span class="number">3</span>,…… having 列<span class="number">1</span>,……聚合……;</span><br><span class="line"></span><br><span class="line">示例：select gender,count(*) from student group by gender having gender;</span><br></pre></td></tr></table></figure>


<div class="note info"><p>`where`与`having`的区别：</p></div>

<ul>
<li><code>where</code>是对<code>from</code>后面指定的表进行筛选，属于对原始数据的筛选</li>
<li><code>having</code>是对<code>group by</code>的结果进行筛选</li>
</ul>
<h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><ul>
<li>语法：<code>select * from 表名 order by 列1 asc|desc，列2 asc|desc , ……;</code></li>
<li>说明：<ul>
<li>将数据按照列1进行排序，如果某些列1的值相同，则按照列2进行排序</li>
<li>默认按照从小到大的顺序排序</li>
<li><code>asc</code>: 升序</li>
<li><code>desc</code>: 降序</li>
</ul>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//需求：将没有被删除的数据按年龄排序</span></span><br><span class="line">select * from student where isDelete=<span class="number">0</span> order by age desc;</span><br><span class="line">select * from student where isDelete=<span class="number">0</span> order by age desc, <span class="type">id</span> desc;</span><br></pre></td></tr></table></figure>

<h4 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h4><ul>
<li>语法：<code>select * from 表名 limit start,count;</code></li>
<li>说明：<code>start</code>索引从0开始</li>
<li>示例：</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">select * from student limit <span class="number">0</span>,<span class="number">3</span>;</span><br><span class="line">select * from student limit <span class="number">3</span>,<span class="number">3</span>;</span><br><span class="line">select * from student where gender=<span class="number">1</span> limit <span class="number">0</span>,<span class="number">3</span>;</span><br></pre></td></tr></table></figure>


<h3 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 建表语句：</span></span><br><span class="line">    <span class="number">1</span>、create table <span class="keyword">class</span>(<span class="type">id</span> <span class="type">int</span> auto_increment primary key, name varchar(<span class="number">20</span>) not null, stuNum <span class="type">int</span> not null);</span><br><span class="line">    </span><br><span class="line">    <span class="number">2</span>、create table students(<span class="type">id</span> <span class="type">int</span> auto_increment primary key, name varchar(<span class="number">20</span>) not null, gender bit <span class="keyword">default</span> <span class="number">1</span>, classid <span class="type">int</span> not null, foreign key(classid) references <span class="keyword">class</span>(<span class="type">id</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询所有数据</span></span><br><span class="line">    select * from students;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 关联查询：</span></span><br><span class="line"><span class="comment">    分类：</span></span><br><span class="line"><span class="comment">    1、表A inner join 表B：</span></span><br><span class="line"><span class="comment">        表A与表B匹配的行会出现在结果集中</span></span><br><span class="line"><span class="comment">    2、表A left join 表B：</span></span><br><span class="line"><span class="comment">        表A与表B匹配的行会出现在结果集中，外加表A中独有的数据，未对应的数据使用null填充</span></span><br><span class="line"><span class="comment">    3、表A right join 表B：</span></span><br><span class="line"><span class="comment">        表A与表B匹配的行会出现在结果集中，外加表B中独有的数据，未对应的数据使用null填充</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">select students.name,<span class="keyword">class</span>.name from <span class="keyword">class</span> inner join students on <span class="keyword">class</span>.id=students.classid;</span><br><span class="line"></span><br><span class="line">select students.name,<span class="keyword">class</span>.name from <span class="keyword">class</span> left join students on <span class="keyword">class</span>.id=students.classid;</span><br><span class="line"></span><br><span class="line">select students.name,<span class="keyword">class</span>.name from <span class="keyword">class</span> right join students on <span class="keyword">class</span>.id=students.classid;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<div class="note success"><p>至此, `MySQL`中一些常用的命令行也基本介绍完了</p></div>

<p>下面看一些<code>MySQL</code>和<code>Python</code>是如何进行交互的</p>
<h2 id="MySQL和Python的交互"><a href="#MySQL和Python的交互" class="headerlink" title="MySQL和Python的交互"></a><code>MySQL</code>和<code>Python</code>的交互</h2><ul>
<li><code>Python</code>要对<code>MySQL</code>数据库进行操作, 需要引入<code>pymysql</code>模块</li>
<li><code>pymsql</code>是<code>Python</code>中操作<code>MySQL</code>的模块, 并且<code>pymysql</code>支持<code>python3.x</code>版本</li>
<li>首先要先安装<code>pymysql</code>, 终端执行一下语句</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip3 install pymysql</span><br></pre></td></tr></table></figure>

<h3 id="创建数据库连接"><a href="#创建数据库连接" class="headerlink" title="创建数据库连接"></a>创建数据库连接</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 链接数据库</span></span><br><span class="line"><span class="comment"># 参数1：mysql服务所在主机的IP(可以是IP地址, 本机链接可以是localhost)</span></span><br><span class="line"><span class="comment"># 参数2：用户名</span></span><br><span class="line"><span class="comment"># 参数3：密码</span></span><br><span class="line"><span class="comment"># 参数4：要连接的数据库名</span></span><br><span class="line"></span><br><span class="line">db = pymysql.connect(<span class="string">&#x27;localhost&#x27;</span>, <span class="string">&#x27;root&#x27;</span>, <span class="string">&#x27;titanjun&#x27;</span>, <span class="string">&#x27;titansql&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建游标, 查询数据默认为元组类型</span></span><br><span class="line">cursor = db.cursor()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建sql语句</span></span><br><span class="line">sql = <span class="string">&quot;select version()&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行sql语句</span></span><br><span class="line">cursor.execute(sql)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取返回的信息</span></span><br><span class="line">data = cursor.fetchone()</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭游标</span></span><br><span class="line">cursor.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭数据库</span></span><br><span class="line">db.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line">db = pymysql.connect(<span class="string">&#x27;localhost&#x27;</span>, <span class="string">&#x27;root&#x27;</span>, <span class="string">&#x27;jun.0929&#x27;</span>, <span class="string">&#x27;titansql&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建游标, 查询数据默认为元组类型</span></span><br><span class="line">cursor = db.cursor()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建表</span></span><br><span class="line"><span class="comment"># 在建表之前要检查表是否存在, 如果存在则删除</span></span><br><span class="line">cursor.execute(<span class="string">&quot;drop table if exists userinfo&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建表</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    sql = <span class="string">&quot;create table userinfo(id int auto_increment primary key, age int not null)&quot;</span></span><br><span class="line">    cursor.execute(sql)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;创建成功&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;创建表失败&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cursor.close()</span><br><span class="line">db.close()</span><br></pre></td></tr></table></figure>

<h3 id="在表中插入数据"><a href="#在表中插入数据" class="headerlink" title="在表中插入数据"></a>在表中插入数据</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line">db = pymysql.connect(<span class="string">&#x27;localhost&#x27;</span>, <span class="string">&#x27;root&#x27;</span>, <span class="string">&#x27;jun.0929&#x27;</span>, <span class="string">&#x27;titansql&#x27;</span>)</span><br><span class="line"></span><br><span class="line">cursor = db.cursor()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 插入数据的字符串命令</span></span><br><span class="line">sql = <span class="string">&#x27;insert into userinfo values&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>, <span class="number">20</span>):</span><br><span class="line">    ageStr = <span class="string">&quot;(0, %d)&quot;</span> % i</span><br><span class="line">    addsql = sql + ageStr</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        cursor.execute(addsql)</span><br><span class="line">        <span class="comment"># 提交到数据库, 不然无法保存新建或者修改的数据</span></span><br><span class="line">        db.commit()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;插入数据成功&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="comment"># 如果提交失败则回滚到上一次的提交, 否则下一次提交可能会冲突</span></span><br><span class="line">        db.rollback()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;插入数据失败&#x27;</span>)</span><br><span class="line"></span><br><span class="line">cursor.close()</span><br><span class="line">db.close()</span><br></pre></td></tr></table></figure>

<h3 id="修改-x2F-更新-x2F-删除数据"><a href="#修改-x2F-更新-x2F-删除数据" class="headerlink" title="修改&#x2F;更新&#x2F;删除数据"></a>修改&#x2F;更新&#x2F;删除数据</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line">db = pymysql.connect(<span class="string">&#x27;localhost&#x27;</span>, <span class="string">&#x27;root&#x27;</span>, <span class="string">&#x27;jun.0929&#x27;</span>, <span class="string">&#x27;titansql&#x27;</span>)</span><br><span class="line">cursor = db.cursor()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改/更新数据命令字符串</span></span><br><span class="line">sql = <span class="string">&#x27;update userinfo set age=30 where id=4&#x27;</span></span><br><span class="line"><span class="comment"># 删除数据命令字符串</span></span><br><span class="line"><span class="comment"># sql = &#x27;delete from userinfo where age=16&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    cursor.execute(sql)</span><br><span class="line">    db.commit()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;数据更新成功&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    db.rollback()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;数据更新失败&#x27;</span>)</span><br><span class="line"></span><br><span class="line">cursor.close()</span><br><span class="line">db.close()</span><br></pre></td></tr></table></figure>

<h3 id="查询数据-1"><a href="#查询数据-1" class="headerlink" title="查询数据"></a>查询数据</h3><ul>
<li><code>fetchone</code>: 获取下一个查询结果集，结果集是一个对象</li>
<li><code>fetchall</code>: 接收全部的返回的行</li>
<li><code>rowcount</code>: 是一个只读属性，返回<code>execute()</code>方法影响的行数</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line">db = pymysql.connect(<span class="string">&#x27;localhost&#x27;</span>, <span class="string">&#x27;root&#x27;</span>, <span class="string">&#x27;jun.0929&#x27;</span>, <span class="string">&#x27;titansql&#x27;</span>)</span><br><span class="line">cursor = db.cursor()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询数据字符串</span></span><br><span class="line">sql = <span class="string">&#x27;select * from userinfo where age&gt;16&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    cursor.execute(sql)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获得一条查询数据</span></span><br><span class="line">    <span class="built_in">print</span>(cursor.fetchone())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;查询到-%d-条数据&#x27;</span> % cursor.rowcount)</span><br><span class="line"></span><br><span class="line">    result = cursor.fetchall()</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> result:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%d--%d&#x27;</span> % (row[<span class="number">0</span>], row[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;数据查询成功&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;数据查询失败&#x27;</span>)</span><br><span class="line"></span><br><span class="line">cursor.close()</span><br><span class="line">db.close()</span><br></pre></td></tr></table></figure>


<div class="note success"><p>至此, `Python`和`MySQL`交互的最基本最简单的使用也介绍完了, 如有不足之处还望告知</p></div>


<hr>
]]></content>
      <categories>
        <category>数据库基础</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac环境下Redis的安装和基本命令的使用</title>
    <url>/post/52249095.html</url>
    <content><![CDATA[<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-e831aa18c01dab69.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Redis"></p>
<span id="more"></span>




<ul>
<li>上文中介绍了<code>NoSQL</code>和<code>MongoDB</code>的相关知识: <a href="https://www.titanjun.top/2018/07/23/MongoDB%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E5%92%8Cpymongo%E7%9A%84%E4%BD%BF%E7%94%A8/">MongoDB的安装及基本命令和pymongo的使用</a></li>
<li>这里主要介绍<code>key-value</code>存储星数据库–<code>Redis</code></li>
</ul>
<h2 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a><code>Redis</code>简介</h2><ul>
<li><code>Redis</code>是完全开源免费的，遵守<code>BSD</code>协议，是一个高性能的<code>key-value</code>数据库</li>
<li><code>Redis</code>与其他<code>key - value</code>缓存产品有以下三个特点：<ul>
<li><code>Redis</code>支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用</li>
<li><code>Redis</code>不仅仅支持简单的<code>key-value</code>类型的数据，同时还提供<code>list</code>，<code>set</code>，<code>zset</code>，<code>hash</code>等数据结构的存储。</li>
<li><code>Redis</code>支持数据的备份，即<code>master-slave</code>模式的数据备份</li>
</ul>
</li>
</ul>
<h3 id="Redis的优势"><a href="#Redis的优势" class="headerlink" title="Redis的优势"></a><code>Redis</code>的优势</h3><ul>
<li>性能极高 –<code>Redis</code>能读的速度是110000次&#x2F;s,写的速度是81000次&#x2F;s 。</li>
<li>丰富的数据类型 – <code>Redis</code>支持二进制案例的<code>Strings</code>, <code>Lists</code>, <code>Hashes</code>, <code>Sets</code>及 <code>Ordered Sets</code>数据类型操作。</li>
<li>原子 – <code>Redis</code>的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来</li>
<li>丰富的特性 – <code>Redis</code>还支持<code>publish/subscribe</code>, 通知, <code>key</code>过期等等特性</li>
</ul>
<h3 id="Redis与其他key-value存储有什么不同？"><a href="#Redis与其他key-value存储有什么不同？" class="headerlink" title="Redis与其他key-value存储有什么不同？"></a><code>Redis</code>与其他<code>key-value</code>存储有什么不同？</h3><ul>
<li><code>Redis</code>有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径</li>
<li><code>Redis</code>的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象</li>
<li><code>Redis</code>运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，因为数据量不能大于硬件内存</li>
<li>在内存数据库方面的另一个优点是，相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样<code>Redis</code>可以做很多内部复杂性很强的事情。同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问</li>
</ul>
<h3 id="Redis的安装"><a href="#Redis的安装" class="headerlink" title="Redis的安装"></a><code>Redis</code>的安装</h3><ul>
<li>至于安装, 我这里就不在班门弄斧了, 这里给大家推荐一篇博客: <a href="https://www.cnblogs.com/feijl/p/6879929.html">mac系统安装redis</a></li>
<li>文章写得非常详细, 建议参考安装</li>
</ul>
<h2 id="Redis命令操作"><a href="#Redis命令操作" class="headerlink" title="Redis命令操作"></a><code>Redis</code>命令操作</h2><ul>
<li><code>Redis</code>命令十分丰富，包括的命令组有<code>Cluster</code>、<code>Connection</code>、<code>Geo</code>、<code>Hashes</code>、<code>HyperLogLog</code>、<code>Keys</code>、<code>Lists</code>、<code>Pub/Sub</code>、<code>Scripting</code>、<code>Server</code>、<code>Sets</code>、<code>Sorted Sets</code>、<code>Strings</code>、<code>Transactions</code>一共14个<code>redis</code>命令组两百多个<code>redis</code>命令</li>
<li><a href="http://redis.cn/commands.html">Redis中文命令大全</a>, 可以通过检索功能快速查找命令</li>
<li><a href="http://redis.cn/map.html">查看网站结构图</a>,它以节点图的形式展示了所有redis命令</li>
</ul>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><ul>
<li><code>String</code>是<code>redis</code>最基本的类型，最大能存储512MB的数据</li>
<li><code>String</code>类型是二进制安全的，即可以存储任何数据、比如数字、图片、序列化对象等</li>
</ul>
<h4 id="设置值"><a href="#设置值" class="headerlink" title="设置值"></a>设置值</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># a、设置键值</span></span><br><span class="line">    <span class="built_in">set</span> key value</span><br><span class="line">    <span class="built_in">set</span> titan titan</span><br><span class="line"><span class="comment"># b、设置键值及过期时间，以秒为单位</span></span><br><span class="line">    setex key seconds value</span><br><span class="line">    setex c <span class="number">10</span> good</span><br><span class="line"><span class="comment"># c、设置多个键值</span></span><br><span class="line">    mset key value [key value ……]</span><br><span class="line">    mset d good e nice f bad</span><br></pre></td></tr></table></figure>


<h4 id="获取值"><a href="#获取值" class="headerlink" title="获取值"></a>获取值</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># a、根据键获取值，如果键不存在则返回None(null 0 nil)</span></span><br><span class="line">    get key</span><br><span class="line">    get d</span><br><span class="line"><span class="comment"># b、根据多个键获取多个值</span></span><br><span class="line">    mget key [key ……]</span><br><span class="line">    mget d f a</span><br></pre></td></tr></table></figure>

<h4 id="运算命令"><a href="#运算命令" class="headerlink" title="运算命令"></a>运算命令</h4><p>前提条件是：值是字符串类型的数字</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># a、将key对应的值加1</span></span><br><span class="line">    incr key</span><br><span class="line">    incr g</span><br><span class="line"><span class="comment"># b、将key对应的值减1</span></span><br><span class="line">    decr key</span><br><span class="line">    decr h</span><br><span class="line"><span class="comment"># c、将key对应的值加整数</span></span><br><span class="line">    incrby key intnum</span><br><span class="line">    incrby g <span class="number">12</span></span><br><span class="line"><span class="comment"># d、将key对应的值加整数</span></span><br><span class="line">    decrby key intnum</span><br><span class="line">    decrby g <span class="number">11</span></span><br></pre></td></tr></table></figure>


<h4 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># a、追加值</span></span><br><span class="line">    append key value</span><br><span class="line">    append d lucky</span><br><span class="line"><span class="comment"># b、获取值长度</span></span><br><span class="line">    strlen key</span><br><span class="line">    strlen d</span><br></pre></td></tr></table></figure>


<h3 id="Keys"><a href="#Keys" class="headerlink" title="Keys"></a>Keys</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、查找键，参数支持正则</span></span><br><span class="line">    keys pattern</span><br><span class="line"><span class="comment"># 2、判断键是否存在，如果存在返回1，不存在返回0</span></span><br><span class="line">    exists key</span><br><span class="line"><span class="comment"># 3、查看键对应的value类型</span></span><br><span class="line">    <span class="built_in">type</span> key</span><br><span class="line"><span class="comment"># 4、删除键及对应的值</span></span><br><span class="line">    <span class="keyword">del</span> key [key ……]</span><br><span class="line"><span class="comment"># 5、设置过期时间，以秒为单位</span></span><br><span class="line">    expire key seconds</span><br><span class="line"><span class="comment"># 6、查看有效时间，以秒为单位</span></span><br><span class="line">    ttl key</span><br></pre></td></tr></table></figure>


<h3 id="Hashes"><a href="#Hashes" class="headerlink" title="Hashes"></a>Hashes</h3><ul>
<li><code>hash</code>是一个<code>string</code>类型的<code>field</code>和<code>value</code>的映射表，<code>hash</code>特别适合用于存储对象</li>
<li><code>Redis</code>中每个<code>hash</code>可以存储 232 - 1 键值对（40多亿）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、设置</span></span><br><span class="line">    <span class="comment"># a、设置单个值</span></span><br><span class="line">        hset key field value</span><br><span class="line">        hset a1 field a1</span><br><span class="line">    <span class="comment"># b、设置多个值</span></span><br><span class="line">        hmset key field value [field value ……]</span><br><span class="line">        hmset a3 field1 a3 field2 a4</span><br><span class="line"><span class="comment"># 2、获取</span></span><br><span class="line">    <span class="comment"># a、获取一个属性的值</span></span><br><span class="line">        hget key field</span><br><span class="line">        hget a3 field1</span><br><span class="line">    <span class="comment"># b、获取多个属性的值</span></span><br><span class="line">        hmget key filed [filed ……]</span><br><span class="line">        hmget a3 field1 field2</span><br><span class="line">    <span class="comment"># c、获取所有属性和值</span></span><br><span class="line">        hgetall key</span><br><span class="line">        hgetall a3</span><br><span class="line">    <span class="comment"># d、获取所有属性</span></span><br><span class="line">        hkeys key</span><br><span class="line">        hkeys a3</span><br><span class="line">    <span class="comment"># e、获取所有值</span></span><br><span class="line">        hvals key</span><br><span class="line">        hvals a3</span><br><span class="line">    <span class="comment"># f、返回包含数据的个数</span></span><br><span class="line">        hlen key</span><br><span class="line">        hlen a3</span><br><span class="line"><span class="comment"># 3、其它</span></span><br><span class="line">    <span class="comment"># a、判断属性是否存在，存在返回1，不存在返回0</span></span><br><span class="line">        hexists key field</span><br><span class="line">        hexists a3 field3</span><br><span class="line">        hexists a3 field1</span><br><span class="line">    <span class="comment"># b、删除属性及值, 成功返回1, 失败返回0</span></span><br><span class="line">        hdel key field [field ……]</span><br><span class="line">        hdel a2 field</span><br><span class="line">    <span class="comment"># c、返回值的字符串长度</span></span><br><span class="line">        hstrlen key field</span><br><span class="line">        hstrlen a3 field1</span><br></pre></td></tr></table></figure>


<h3 id="列表-List"><a href="#列表-List" class="headerlink" title="列表(List)"></a>列表(List)</h3><ul>
<li><code>Redis</code>列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）</li>
<li>一个列表最多可以包含 232 - 1 个元素 (4294967295, 每个列表超过40亿个元素)。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、设置</span></span><br><span class="line">    <span class="comment"># a、在头部插入</span></span><br><span class="line">        lpush key value [vlaue ……]</span><br><span class="line">        lpush <span class="built_in">list</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line">    <span class="comment"># b、在尾部插入</span></span><br><span class="line">        rpush key value [vlaue ……]</span><br><span class="line">        rpush <span class="built_in">list</span> <span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span></span><br><span class="line">    <span class="comment"># c、在一个元素的前|后插入新元素</span></span><br><span class="line">        linsert key before|after pivot value</span><br><span class="line">        linsert <span class="built_in">list</span> before <span class="number">4</span> <span class="number">10</span></span><br><span class="line">        linsert <span class="built_in">list</span> after <span class="number">3</span> <span class="number">5</span></span><br><span class="line">    <span class="comment"># d、设置指定索引的元素值</span></span><br><span class="line">        lset key index value</span><br><span class="line">        lset <span class="built_in">list</span> <span class="number">3</span> <span class="number">11</span></span><br><span class="line">        lset <span class="built_in">list</span> -<span class="number">2</span> <span class="number">21</span></span><br><span class="line">        <span class="comment"># 注意：index从0开始</span></span><br><span class="line">        <span class="comment"># 注意：索引值可以是负数，表示偏移量是从list的尾部开始，如-1表示最后一个元素</span></span><br><span class="line"><span class="comment"># 2、获取</span></span><br><span class="line">    <span class="comment"># a、移除并返回key对应的list的第一个元素</span></span><br><span class="line">        lpop key</span><br><span class="line">        lpop <span class="built_in">list</span></span><br><span class="line">    <span class="comment"># b、移除并返回key对应的list的最后一个元素</span></span><br><span class="line">        rpop key</span><br><span class="line">        lpop <span class="built_in">list</span> </span><br><span class="line">    <span class="comment"># c、返回存储在key的列表中的指定范围的元素</span></span><br><span class="line">        lrange key start end</span><br><span class="line">        lrange <span class="built_in">list</span> <span class="number">2</span> <span class="number">4</span></span><br><span class="line">        <span class="comment"># 注意：start end都是从0开始</span></span><br><span class="line">        <span class="comment"># 注意：偏移量可以是负数</span></span><br><span class="line"><span class="comment"># 3、其它</span></span><br><span class="line">    <span class="comment"># a、裁剪列表，改为原集合的一个子集</span></span><br><span class="line">        ltrim key start end</span><br><span class="line">        ltrim <span class="built_in">list</span> <span class="number">0</span> <span class="number">2</span></span><br><span class="line">        <span class="comment"># 注意：start end都是从0开始</span></span><br><span class="line">        <span class="comment"># 注意：偏移量可以是负数</span></span><br><span class="line">    <span class="comment"># b、返回存储在key里的list的长度</span></span><br><span class="line">        llen key</span><br><span class="line">        llen <span class="built_in">list</span></span><br><span class="line">    <span class="comment"># c、返回列表中索引对应的值</span></span><br><span class="line">        lindex key index</span><br><span class="line">        lindex <span class="built_in">list</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>


<h3 id="集合-Set"><a href="#集合-Set" class="headerlink" title="集合(Set)"></a>集合(Set)</h3><ul>
<li><code>Redis</code>的<code>Set</code>是<code>String</code>类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。</li>
<li>&#96;Redis中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。</li>
<li>集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、设置</span></span><br><span class="line">    <span class="comment"># a、添加元素</span></span><br><span class="line">        sadd key member [member ……]</span><br><span class="line">        sadd set1 <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line">        sadd set2 <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span></span><br><span class="line"><span class="comment"># 2、获取</span></span><br><span class="line">    <span class="comment"># a、返回key集合中所有元素</span></span><br><span class="line">        smembers key</span><br><span class="line">        smembers set1</span><br><span class="line">    <span class="comment"># b、返回集合元素个数</span></span><br><span class="line">        scard key</span><br><span class="line">        scard set1</span><br><span class="line"><span class="comment"># 3、</span></span><br><span class="line">    <span class="comment"># a、求多个集合的交集</span></span><br><span class="line">        sinter key [key ……]</span><br><span class="line">        sinter set1 set2</span><br><span class="line">    <span class="comment"># b、求多个集合的差集</span></span><br><span class="line">        sdiff key [key ……]</span><br><span class="line">        sdiff set1 set2</span><br><span class="line">        <span class="comment"># 输出: 1 2 3 </span></span><br><span class="line">        sdiff set2 set1</span><br><span class="line">        <span class="comment"># 输出: 6 7 8</span></span><br><span class="line">        <span class="comment"># 注意: 两个结合前后位置变化输出的结果是不一样的</span></span><br><span class="line">    <span class="comment"># c、求多个集合的合集</span></span><br><span class="line">        sunion key [key ……]</span><br><span class="line">        sunion set1 set2</span><br><span class="line">    <span class="comment"># d、判断元素是否在集合中，存在返回1，不存在返回0</span></span><br><span class="line">        sismember key member</span><br><span class="line">        sismember set1 <span class="number">4</span></span><br><span class="line">        sismember set1 <span class="number">7</span></span><br></pre></td></tr></table></figure>


<h3 id="有序集合-sorted-set"><a href="#有序集合-sorted-set" class="headerlink" title="有序集合(sorted set)"></a>有序集合(sorted set)</h3><ul>
<li>有序集合，元素类型为<code>Sting</code>，元素具有唯一性，不能重复</li>
<li>每个元素都会关联一个<code>double</code>类型的<code>score</code>(表示权重),通过权重的大小排序，元素的<code>score</code>可以相同</li>
<li>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)</li>
<li>集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、设置</span></span><br><span class="line">    <span class="comment"># a、添加</span></span><br><span class="line">        zadd key score member [score member ……]</span><br><span class="line">        zadd slist <span class="number">1</span> a <span class="number">5</span> b <span class="number">3</span> c <span class="number">2</span> d <span class="number">4</span> e</span><br><span class="line"><span class="comment"># 2、获取</span></span><br><span class="line">    <span class="comment"># a、返回指定范围的元素</span></span><br><span class="line">        zrange key start end</span><br><span class="line">        zrange slist <span class="number">0</span> <span class="number">2</span></span><br><span class="line">    <span class="comment"># b、返回元素个数</span></span><br><span class="line">        zcard key</span><br><span class="line">        zcard slist</span><br><span class="line">    <span class="comment"># c、返回有序集合key中，score在min和max之间的元素的个数</span></span><br><span class="line">        zcount key <span class="built_in">min</span> <span class="built_in">max</span></span><br><span class="line">        zcount slist <span class="number">1</span> <span class="number">3</span></span><br><span class="line">    <span class="comment"># d、返回有序集合key中，成员member的score值</span></span><br><span class="line">        zscore key member</span><br><span class="line">        zscore slist e</span><br></pre></td></tr></table></figure>



<hr>
]]></content>
      <categories>
        <category>数据库基础</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB的安装及基本命令和pymongo的使用</title>
    <url>/post/fe1e9880.html</url>
    <content><![CDATA[<p><img data-src="https://cdn.scotch.io/1/OvQmgluRTe5alZTfiQK0_getting-started-with-python-mongo.jpg" alt="image"></p>
<span id="more"></span>



<h2 id="NoSQL简介"><a href="#NoSQL简介" class="headerlink" title="NoSQL简介"></a><code>NoSQL</code>简介</h2><h3 id="NoSQL介绍"><a href="#NoSQL介绍" class="headerlink" title="NoSQL介绍"></a><code>NoSQL</code>介绍</h3><ul>
<li><code>NoSQL</code>全名为<code>Not Only SQL</code>, 指的是非关系型数据库, 在现代的计算系统上每天网络上都会产生庞大的数据量, 网站的数据库性能可能出现问题, <code>NoSQL</code>便应运而生了</li>
<li><code>NoSQL</code>是一项全新的数据库革命性运动, 提倡运用非关系型的数据存储</li>
<li><code>NoSQL</code>用于超大规模数据的存储, 这些类型的数据存储不需要固定的模式，无需多余操作就可以横向扩展</li>
<li><code>NoSQL</code>的优点: 高扩展性、分布式计算、低成本、构架灵活</li>
<li><code>NoSQL</code>的缺点: 没有标准化、有限的查询功能</li>
</ul>
<h3 id="NoSQL数据库分类"><a href="#NoSQL数据库分类" class="headerlink" title="NoSQL数据库分类"></a><code>NoSQL</code>数据库分类</h3><table>
<thead>
<tr>
<th>类型</th>
<th>部分代表</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>列存储</td>
<td><code>Hbase</code> 和 <code>Cassandra</code> 和 <code>Hypertable</code></td>
<td>顾名思义，是按列存储数据的。最大的特点是方便存储结构化和半结构化数据，方便做数据压缩，对针对某一列或者某几列的查询有非常大的IO优势。</td>
</tr>
<tr>
<td>文档存储</td>
<td><code>MongoDB</code> 和 <code>CouchDB</code></td>
<td>文档存储一般用类似json的格式存储，存储的内容是文档型的。这样也就有有机会对某些字段建立索引，实现关系数据库的某些功能</td>
</tr>
<tr>
<td><code>key-value</code>存储</td>
<td><code>Tokyo Cabinet/Tyrant</code> 和 <code>Berkeley DB</code> 和 <code>MemcacheDB</code> 和 <code>Redis</code></td>
<td>可以通过<code>key</code>快速查询到其<code>value</code>。一般来说，存储不管<code>value</code>的格式，照单全收。（<code>Redis</code>包含了其他功能）</td>
</tr>
<tr>
<td>图存储</td>
<td><code>Neo4J</code> 和 <code>FlockDB</code></td>
<td>图形关系的最佳存储。使用传统关系数据库来解决的话性能低下，而且设计使用不方便</td>
</tr>
<tr>
<td>对象存储</td>
<td><code>db4o</code> 和 <code>Versant</code></td>
<td>通过类似面向对象语言的语法操作数据库，通过对象的方式存取数据</td>
</tr>
<tr>
<td>xml数据库</td>
<td><code>Berkeley DB XML</code> 和 <code>BaseX</code></td>
<td>高效的存储<code>XML</code>数据，并支持<code>XML</code>的内部查询语法，比如<code>XQuery</code>, <code>Xpath</code></td>
</tr>
</tbody></table>
<div class="note warning"><p>这里主要介绍`MongoDB`和`Redis`的相关介绍和使用</p></div>


<h2 id="什么是MongoDB"><a href="#什么是MongoDB" class="headerlink" title="什么是MongoDB"></a>什么是<code>MongoDB</code></h2><h3 id="MongoDB介绍"><a href="#MongoDB介绍" class="headerlink" title="MongoDB介绍"></a><code>MongoDB</code>介绍</h3><ul>
<li><code>MongoDB</code>是由<code>C++</code>编写的, 是一个基于分布式文件存储的开源数据库系统</li>
<li><code>MongoDB</code>旨在为<code>WEB</code>应用提供可扩展的高性能数据存储解决方案</li>
<li><code>MongoDB</code>将数据库存储为一个文档, 数据结构由键值对组成</li>
<li><code>MongoDB</code>文档类似于<code>JSON</code>对象, 字段值可以包含其他文档, 数组以及文档数组</li>
</ul>
<h3 id="MongoDB主要特点"><a href="#MongoDB主要特点" class="headerlink" title="MongoDB主要特点"></a><code>MongoDB</code>主要特点</h3><ul>
<li><code>MongoDB</code>提供了一个面向文档存储, 基本思路就是将原来的行概念换成更加灵活地文档模型, 一条记录可以表示非常复杂的层次关系</li>
<li><code>MongoDB</code>支持丰富的查询表达式, 查询指令使用<code>json</code>形式的标记, 可轻易查询文档中内嵌的对象及数组</li>
<li><code>MongoDB</code>支持<code>RUBY</code>、<code>Python</code>、<code>Java</code>、<code>C++</code>、<code>PHP</code>、<code>C#</code>等多种编程语言</li>
<li><code>MongoDB</code>包含索引、存储<code>JavaScript</code>、聚合、固定集合、文件存储等操作</li>
</ul>
<h3 id="MongoDB的安装"><a href="#MongoDB的安装" class="headerlink" title="MongoDB的安装"></a><code>MongoDB</code>的安装</h3><ul>
<li>这里提到的都是在<code>Mac</code>环境下<code>MongoDB</code>的安装过程, 其他环境下请自行百度, 这里就不在介绍了</li>
<li>安装方式有两种安装包安装和使用<code>brew</code>安装, 我是使用安装包安装的, 为了不误导大家, 这里就不介绍<code>brew</code>安装方式了</li>
</ul>
<h4 id="安装包安装"><a href="#安装包安装" class="headerlink" title="安装包安装"></a>安装包安装</h4><p>可以在官网下载安装包: <a href="https://www.mongodb.com/download-center#community">下载地址</a></p>
<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-9042ff35edee69ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>接下来我们使用如下命令来下载安装</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 注意修改下列文件名, 我的是4.0.0</span></span><br><span class="line"><span class="comment"># 进入 /usr/local</span></span><br><span class="line">cd /usr/local</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载</span></span><br><span class="line">sudo curl -O https://fastdl.mongodb.org/osx/mongodb-osx-x86_64-<span class="number">4.0</span><span class="number">.0</span>.tgz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压</span></span><br><span class="line">sudo tar -zxvf mongodb-osx-x86_64-<span class="number">4.0</span><span class="number">.0</span>.tgz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重命名为 mongodb 目录</span></span><br><span class="line">sudo mv mongodb-osx-x86_64-<span class="number">4.0</span><span class="number">.0</span> mongodb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装完成后，我们可以把 MongoDB 的二进制命令文件目录（安装目录/bin）添加到 PATH 路径中：</span></span><br><span class="line">export PATH=/usr/local/mongodb/<span class="built_in">bin</span>:$PATH</span><br></pre></td></tr></table></figure>

<h4 id="运行MongoDB"><a href="#运行MongoDB" class="headerlink" title="运行MongoDB"></a>运行<code>MongoDB</code></h4><ol>
<li>首先我们创建一个数据库存储目录 <code>/data/db</code></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /data/db</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>启动<code>mongodb</code>，默认数据库目录即为 <code>/data/db</code></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo mongod</span><br><span class="line"></span><br><span class="line"># 如果没有创建全局路径 PATH，需要进入以下目录</span><br><span class="line">cd /usr/local/mongodb/bin</span><br><span class="line">sudo ./mongod</span><br></pre></td></tr></table></figure>

<div class="note success"><p>打开浏览器, 在浏览器内输入`127.0.0.1:27017`, 如果出现下面这种则说明安装成功</p></div>

<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-74e0aa1894c837c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="success"></p>
<ol start="3">
<li>再打开一个终端进入执行以下命令：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cd /usr/local/mongodb/bin </span><br><span class="line">$ ./mongo</span><br></pre></td></tr></table></figure>

<div class="note success"><p>出现这种情况, 则说明数据库连接成功</p></div>

<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-95f780e734a7a32e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Content"></p>
<h3 id="安装可视化工具Studio-3T"><a href="#安装可视化工具Studio-3T" class="headerlink" title="安装可视化工具Studio 3T"></a>安装可视化工具<code>Studio 3T</code></h3><ul>
<li>这里推荐官网下载: <a href="https://studio3t.com/download/">下载地址</a></li>
<li>安装之后打开软件, 选择左上角<code>Connection</code>, 弹出一个新的弹窗</li>
<li>在点击新弹窗上面的<code>New Connection</code>, 弹出一个新的弹窗</li>
<li>在新窗口中输入名字和电脑IP, 点击<code>Save</code></li>
<li>最后选择你新添加的电脑IP, 点击<code>Connect</code>链接</li>
<li>详细步骤如下图所示:</li>
</ul>
<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-566ae508d2b8a580.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Stdio 3T"></p>
<h2 id="MongoDB基本命令操作"><a href="#MongoDB基本命令操作" class="headerlink" title="MongoDB基本命令操作"></a><code>MongoDB</code>基本命令操作</h2><h3 id="操作mongodb数据库"><a href="#操作mongodb数据库" class="headerlink" title="操作mongodb数据库"></a>操作mongodb数据库</h3><h4 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 语法：use 数据库名</span></span><br><span class="line"><span class="comment"># 示例:</span></span><br><span class="line">    use student</span><br></pre></td></tr></table></figure>

<div class="note warning"><p>注意:</p></div>

<ul>
<li>如果数据库不存在则创建数据库，否则切换到指定的数据库</li>
<li>如果刚刚创建的数据库不在列表内，如果要显示它，我们需要向刚刚创建的数据库中插入一些数据</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 该命令后面会继续介绍</span></span><br><span class="line">db.student.insert(&#123;name:<span class="string">&quot;titan&quot;</span>, age:<span class="number">18</span>, sex:<span class="number">1</span>,address:<span class="string">&quot;北京&quot;</span>, isDelete:<span class="number">0</span>&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="其他相关命令"><a href="#其他相关命令" class="headerlink" title="其他相关命令"></a>其他相关命令</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、删除数据库</span></span><br><span class="line">    <span class="comment"># 前提：使用当前数据库(use 数据库名)</span></span><br><span class="line">    db.dropDatabase()</span><br><span class="line"><span class="comment"># 2、查看所有数据</span></span><br><span class="line">    show dbs</span><br><span class="line"><span class="comment"># 3、查看当前正在使用的数据库</span></span><br><span class="line">    db</span><br><span class="line">    <span class="comment"># 或者</span></span><br><span class="line">    db.getName()</span><br><span class="line"><span class="comment"># 4、断开连接</span></span><br><span class="line">    exit</span><br><span class="line"><span class="comment"># 5、查看命令api</span></span><br><span class="line">    <span class="built_in">help</span></span><br></pre></td></tr></table></figure>

<h3 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、查看当前数据库下有哪些集合</span></span><br><span class="line">    show collections</span><br><span class="line"><span class="comment"># 2、创建集合</span></span><br><span class="line">    <span class="comment"># a、</span></span><br><span class="line">        <span class="comment"># 语法：db.createCollection(&quot;集合名&quot;)</span></span><br><span class="line">        <span class="comment"># 示例：</span></span><br><span class="line">            db.createCollection(<span class="string">&quot;class&quot;</span>)</span><br><span class="line">    <span class="comment"># b、</span></span><br><span class="line">        <span class="comment"># 语法：db.集合名.insert(文档)</span></span><br><span class="line">        <span class="comment"># 示例：</span></span><br><span class="line">            db.student.insert(&#123;name:<span class="string">&quot;titan1&quot;</span>, age:<span class="number">18</span>, sex:<span class="number">1</span>,address:<span class="string">&quot;上海&quot;</span>, isDelete:<span class="number">0</span>&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 区别：两者的区别在于前者创建的是一个空的集合，后者创建一个空的集合并添加一个文档</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3、删除当前数据库中的集合</span></span><br><span class="line">    <span class="comment"># 语法：db.集合名.drop()</span></span><br><span class="line">    <span class="comment"># 示例：</span></span><br><span class="line">        db.<span class="keyword">class</span>.drop()</span><br></pre></td></tr></table></figure>

<h3 id="文档操作"><a href="#文档操作" class="headerlink" title="文档操作"></a>文档操作</h3><h4 id="插入文档"><a href="#插入文档" class="headerlink" title="插入文档"></a>插入文档</h4><ol>
<li>使用<code>insert()</code>方法插入文档</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 插入一个</span></span><br><span class="line">    <span class="comment"># 语法：</span></span><br><span class="line">        db.集合名.insert(文档)</span><br><span class="line">    <span class="comment"># 示例:</span></span><br><span class="line">        db.student.insert(&#123;name:<span class="string">&quot;jun&quot;</span>, age:<span class="number">19</span>, sex:<span class="number">1</span>,address:<span class="string">&quot;北京&quot;</span>, isDelete:<span class="number">0</span>&#125;)</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 2. 插入多个</span></span><br><span class="line">    <span class="comment"># 语法：</span></span><br><span class="line">        db.集合名.insert([文档<span class="number">1</span>, 文档<span class="number">2</span>, ……, 文档n])</span><br><span class="line">    <span class="comment"># 示例：</span></span><br><span class="line">        db.student.insert([&#123;name:<span class="string">&quot;titan2&quot;</span>, age:<span class="number">17</span>, sex:<span class="number">0</span>,address:<span class="string">&quot;深圳&quot;</span>, isDelete:<span class="number">0</span>&#125;,&#123;name:<span class="string">&quot;coder&quot;</span>, age:<span class="number">20</span>, sex:<span class="number">0</span>,address:<span class="string">&quot;上海&quot;</span>, isDelete:<span class="number">0</span>&#125;])</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用<code>save()</code>方法插入文档</li>
</ol>
<ul>
<li>语法：<code>db.集合名.save(文档)</code></li>
<li>说明：如果不指定<code>_id</code>字段，<code>save()</code>方法类似于<code>insert()</code>方法。如果指定<code>_id</code>字段，则会更新<code>_id</code>字段的数据</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例1：</span></span><br><span class="line">db.student.save(&#123;name:<span class="string">&quot;pro&quot;</span>, age:<span class="number">22</span>, sex:<span class="number">1</span>,address:<span class="string">&quot;安徽&quot;</span>, isDelete:<span class="number">0</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例2：</span></span><br><span class="line">db.student.save(&#123;_<span class="built_in">id</span>:ObjectId(<span class="string">&quot;59950962019723fe2a0d8d17&quot;</span>),name:<span class="string">&quot;poi&quot;</span>, age:<span class="number">23</span>, sex:<span class="number">1</span>,address:<span class="string">&quot;安徽&quot;</span>, isDelete:<span class="number">0</span>&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="文档更新"><a href="#文档更新" class="headerlink" title="文档更新"></a>文档更新</h4><p>1、<code>update()</code>方法用于更新已存在的文档</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.集合名.update(</span><br><span class="line">        query,</span><br><span class="line">        update,</span><br><span class="line">        &#123;</span><br><span class="line">            upset:&lt;boolean&gt;,</span><br><span class="line">            multi:&lt;boolean&gt;,</span><br><span class="line">            writeConcern:&lt;document&gt;</span><br><span class="line">        &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li>参数说明：<ul>
<li><code>query</code>：<code>update</code>的查询条件，类似于<code>sql</code>里<code>update</code>语句内<code>where</code>后面的内容</li>
<li><code>update</code>：<code>update</code>的对象和一些更新的操作符<code>($set,$inc)</code>等，<code>$set</code>直接更新，<code>$inc</code>在原有的基础上累加后更新</li>
<li><code>upset</code>：可选，如果不存在<code>update</code>的记录，是否当新数据插入，<code>true</code>为插入，<code>False</code>为不插入，默认为<code>false</code></li>
<li><code>multi</code>：可选，<code>mongodb</code>默认是<code>false</code>，只更新找到的第一条记录，如果这个参数为<code>true</code>,就按照条件查找出来的数据全部更新</li>
<li><code>writeConcern</code>：可选，抛出异常的级别</li>
</ul>
</li>
<li>需求：将<code>pro</code>的年龄更新为25</li>
<li>示例：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">db.student.update(&#123;name:<span class="string">&quot;pro&quot;</span>&#125;,&#123;$<span class="built_in">set</span>:&#123;age:<span class="number">25</span>&#125;&#125;)</span><br><span class="line">              </span><br><span class="line"><span class="comment"># 累加：</span></span><br><span class="line">db.student.update(&#123;name:<span class="string">&quot;titan&quot;</span>&#125;,&#123;$inc:&#123;age:<span class="number">25</span>&#125;&#125;)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 全改：</span></span><br><span class="line">db.student.update(&#123;name:<span class="string">&quot;titan1&quot;</span>&#125;,&#123;$<span class="built_in">set</span>:&#123;age:<span class="number">42</span>&#125;&#125;,&#123;multi:true&#125;) </span><br></pre></td></tr></table></figure>

<p>2、<code>save()</code>方法通过传入的文档替换已有文档</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">db.集合名.save(</span><br><span class="line">    <span class="comment"># 文档数据</span></span><br><span class="line">    document,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"># 可选，抛出异常的级别</span></span><br><span class="line">        writeConcern:&lt;document&gt;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>


<h4 id="文档删除"><a href="#文档删除" class="headerlink" title="文档删除"></a>文档删除</h4><p>在执行<code>remove()</code>函数前，最好先执行<code>find()</code>命令来判断执行的条件是否存在</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.集合名.remove(</span><br><span class="line">    query,</span><br><span class="line">    &#123;</span><br><span class="line">        justOne:&lt;boolean&gt;,</span><br><span class="line">        writeConcern:&lt;document&gt;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li>参数说明：<ul>
<li><code>query</code>：可选，删除的文档的条件</li>
<li><code>justOne</code>：可选，如果为true或1，则只删除一个文档</li>
<li><code>writeConcern</code>：可选，抛出异常的级别</li>
</ul>
</li>
<li>示例：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.student.remove(&#123;name:&quot;poi&quot;&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="文档查询"><a href="#文档查询" class="headerlink" title="文档查询"></a>文档查询</h4><p>1、<code>find()</code>方法查询</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">db.集合名.find(</span><br><span class="line">    <span class="comment"># query：查询条件</span></span><br><span class="line">    query,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"># key：要显示的字段，1表示显示</span></span><br><span class="line">        &lt;key&gt;:<span class="number">1</span>,</span><br><span class="line">        &lt;key&gt;:<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例：</span></span><br><span class="line">    db.student.find(&#123;sex:<span class="number">0</span>&#125;,&#123;name:<span class="number">1</span>,age:<span class="number">1</span>&#125;)</span><br><span class="line">    db.student.find(&#123;&#125;,&#123;name:<span class="number">1</span>,age:<span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>2、其他查询方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查询集合下所有的文档(数据)：</span></span><br><span class="line">db.student.find()</span><br><span class="line"></span><br><span class="line"><span class="comment"># pretty()方法以格式化的方式来显示文档</span></span><br><span class="line">db.student.find().pretty()</span><br><span class="line"></span><br><span class="line"><span class="comment"># findOne()方法查询匹配结果的第一条数据</span></span><br><span class="line">db.student.findOne(&#123;gender:<span class="number">0</span>&#125;)</span><br></pre></td></tr></table></figure>


<h4 id="查询条件操作符"><a href="#查询条件操作符" class="headerlink" title="查询条件操作符"></a>查询条件操作符</h4><p>条件操作符用于比较两个表达式并从<code>Mongodb</code>集合中获取数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># a、大于 - $gt</span></span><br><span class="line">    <span class="comment"># 语法：</span></span><br><span class="line">        db.集合名.find(&#123;&lt;key&gt;:&#123;$gt:&lt;value&gt;&#125;&#125;)</span><br><span class="line">    <span class="comment"># 示例：</span></span><br><span class="line">        db.student.find(&#123;age:&#123;$gt:<span class="number">20</span>&#125;&#125;)</span><br><span class="line">        </span><br><span class="line"><span class="comment"># b、大于等于 - $gte</span></span><br><span class="line">    <span class="comment"># 语法：</span></span><br><span class="line">        db.集合名.find(&#123;&lt;key&gt;:&#123;$gte:&lt;value&gt;&#125;&#125;)</span><br><span class="line">        </span><br><span class="line"><span class="comment"># c、小于 - $lt</span></span><br><span class="line">    <span class="comment"># 语法：</span></span><br><span class="line">        db.集合名.find(&#123;&lt;key&gt;:&#123;$lt:&lt;value&gt;&#125;&#125;)</span><br><span class="line">        </span><br><span class="line"><span class="comment"># d、小于等于 - $lte</span></span><br><span class="line">    <span class="comment"># 语法：</span></span><br><span class="line">        db.集合名.find(&#123;&lt;key&gt;:&#123;$lte:&lt;value&gt;&#125;&#125;)</span><br><span class="line">        </span><br><span class="line"><span class="comment"># e、大于等于 和 小于等于 - $gte 和 $lte</span></span><br><span class="line">    <span class="comment"># 语法：</span></span><br><span class="line">        db.集合名.find(&#123;&lt;key&gt;:&#123;$gte:&lt;value&gt;,$lte:&lt;value&gt;&#125;&#125;)</span><br><span class="line">        </span><br><span class="line"><span class="comment"># f、等于 - :</span></span><br><span class="line">    <span class="comment"># 语法：</span></span><br><span class="line">        db.集合名.find(&#123;&lt;key&gt;:&lt;value&gt;&#125;)</span><br><span class="line">        </span><br><span class="line"><span class="comment"># g、使用_id进行查询</span></span><br><span class="line">    <span class="comment"># 语法：</span></span><br><span class="line">        db.student.find(&#123;<span class="string">&quot;_id&quot;</span>:ObjectId(<span class="string">&quot;id值&quot;</span>)&#125;)</span><br><span class="line">    <span class="comment"># 示例：</span></span><br><span class="line">        db.student.find(&#123;<span class="string">&quot;_id&quot;</span>:ObjectId(<span class="string">&quot;5995084b019723fe2a0d8d14&quot;</span>)&#125;)</span><br><span class="line">        </span><br><span class="line"><span class="comment"># h、查询某个结果集的数据条数</span></span><br><span class="line">    <span class="comment"># 示例：</span></span><br><span class="line">        db.student.find().count()</span><br><span class="line">        </span><br><span class="line"><span class="comment"># i、查询某个字段的值当中是否包含另一个值</span></span><br><span class="line">    <span class="comment"># 示例：</span></span><br><span class="line">        db.student.find(&#123;name:/ile/&#125;)</span><br><span class="line">        </span><br><span class="line"><span class="comment"># j、查询某个字段的值是否以另一个值开头</span></span><br><span class="line">    <span class="comment"># 示例：</span></span><br><span class="line">        db.student.find(&#123;name:/^li/&#125;)</span><br></pre></td></tr></table></figure>


<h4 id="条件查询and和or"><a href="#条件查询and和or" class="headerlink" title="条件查询and和or"></a>条件查询<code>and</code>和<code>or</code></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. AND条件</span></span><br><span class="line">    <span class="comment"># 语法：</span></span><br><span class="line">        db.集合名.find(&#123;条件<span class="number">1</span>,条件<span class="number">2</span>,……,条件n&#125;)</span><br><span class="line">    <span class="comment"># 示例：</span></span><br><span class="line">        db.student.find(&#123;gender:<span class="number">0</span>,age:&#123;$gt:<span class="number">16</span>&#125;&#125;)</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 2、OR条件</span></span><br><span class="line">    <span class="comment"># 语法：</span></span><br><span class="line">        db.集合名.find(</span><br><span class="line">            &#123;</span><br><span class="line">                $<span class="keyword">or</span>:[&#123;条件<span class="number">1</span>&#125;,&#123;条件<span class="number">2</span>&#125;,……,&#123;条件n&#125;]</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">    <span class="comment"># 示例：</span></span><br><span class="line">        db.student.find(&#123;$<span class="keyword">or</span>:[&#123;age:<span class="number">17</span>&#125;,&#123;age:&#123;$gte:<span class="number">20</span>&#125;&#125;]&#125;)</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 3、AND和OR联合使用</span></span><br><span class="line">    <span class="comment"># 语法：</span></span><br><span class="line">        db.集合名.find(</span><br><span class="line">            &#123;</span><br><span class="line">                条件<span class="number">1</span>,</span><br><span class="line">                条件<span class="number">2</span>,</span><br><span class="line">                $<span class="keyword">or</span>:[&#123;条件<span class="number">3</span>&#125;,&#123;条件<span class="number">4</span>&#125;]</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br></pre></td></tr></table></figure>


<h4 id="limit和skip"><a href="#limit和skip" class="headerlink" title="limit和skip"></a><code>limit</code>和<code>skip</code></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># a、limit()：读取指定数量的数据记录</span></span><br><span class="line">    db.student.find().limit(<span class="number">3</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># b、skip()：跳过指定数量的数据</span></span><br><span class="line">    db.student.find().skip(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># c、skip与limit联合使用</span></span><br><span class="line">    <span class="comment"># 通常用这种方式来实现分页功能</span></span><br><span class="line">    <span class="comment"># 示例：</span></span><br><span class="line">        db.student.find().skip(<span class="number">3</span>).limit(<span class="number">3</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 语法：</span></span><br><span class="line">    db.集合名.find().sort(&#123;&lt;key&gt;:<span class="number">1</span>|-<span class="number">1</span>&#125;)</span><br><span class="line"><span class="comment"># 示例：</span></span><br><span class="line">    db.student.find().sort(&#123;age:<span class="number">1</span>&#125;)</span><br><span class="line"><span class="comment"># 注意：1表示升序，-1表示降序</span></span><br></pre></td></tr></table></figure>


<h2 id="MongoDB和Python的交互"><a href="#MongoDB和Python的交互" class="headerlink" title="MongoDB和Python的交互"></a><code>MongoDB</code>和<code>Python</code>的交互</h2><h3 id="MongoDB数据类型"><a href="#MongoDB数据类型" class="headerlink" title="MongoDB数据类型"></a><code>MongoDB</code>数据类型</h3><p>下表为<code>MongoDB</code>中常用的几种数据类型</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>String</code></td>
<td>字符串。存储数据常用的数据类型。在<code>MongoDB</code>中，<code>UTF-8</code>编码的字符串才是合法的</td>
</tr>
<tr>
<td><code>Integer</code></td>
<td>整型数值。用于存储数值, 根据你所采用的服务器，可分为32位或64位</td>
</tr>
<tr>
<td><code>Boolean</code></td>
<td>布尔值。用于存储布尔值（真&#x2F;假）</td>
</tr>
<tr>
<td><code>Double</code></td>
<td>双精度浮点值。用于存储浮点值。</td>
</tr>
<tr>
<td><code>Min/Max keys</code></td>
<td>将一个值与<code>BSON</code>(二进制的 JSON）元素的最低值和最高值相对比</td>
</tr>
<tr>
<td><code>Array</code></td>
<td>用于将数组或列表或多个值存储为一个键。</td>
</tr>
<tr>
<td><code>Timestamp</code></td>
<td>时间戳。记录文档修改或添加的具体时间。</td>
</tr>
<tr>
<td><code>Object</code></td>
<td>用于内嵌文档。</td>
</tr>
<tr>
<td><code>Null</code></td>
<td>用于创建空值。</td>
</tr>
<tr>
<td><code>Symbol</code></td>
<td>符号。该数据类型基本上等同于字符串类型，但不同的是，它一般用于采用特殊符号类型的语言。</td>
</tr>
<tr>
<td><code>Date</code></td>
<td>日期时间。用<code>UNIX</code> 时间格式来存储当前日期或时间, 你可以指定自己的日期时间：创建<code>Date</code>对象，传入年月日信息。</td>
</tr>
<tr>
<td><code>Object ID</code></td>
<td>对象 ID。用于创建文档的 ID。</td>
</tr>
<tr>
<td><code>Binary Data</code></td>
<td>二进制数据。用于存储二进制数据。</td>
</tr>
<tr>
<td><code>Code</code></td>
<td>代码类型。用于在文档中存储<code>JavaScript</code>代码。</td>
</tr>
<tr>
<td><code>Regular expression</code></td>
<td>正则表达式类型。用于存储正则表达式。</td>
</tr>
</tbody></table>
<h4 id="ObjectId"><a href="#ObjectId" class="headerlink" title="ObjectId"></a>ObjectId</h4><ul>
<li><code>ObjectId</code>类似唯一主键，可以很快的去生成和排序，包含<code>12 bytes</code>，含义是：<ul>
<li>前 4 个字节表示创建 unix 时间戳,格林尼治时间 UTC 时间，比北京时间晚了 8 个小时</li>
<li>接下来的 3 个字节是机器标识码</li>
<li>紧接的两个字节由进程 id 组成 PID</li>
<li>最后三个字节是随机数</li>
</ul>
</li>
<li><code>MongoDB</code>中存储的文档必须有一个<code>_id</code>键, 这个键的值可以是任何类型的，默认是个<code>ObjectId</code>对象</li>
</ul>
<h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><p>集合中插入文档使用<code>insert_one()</code>方法和<code>insert_many()</code>方法</p>
<h4 id="插入一条数据"><a href="#插入一条数据" class="headerlink" title="插入一条数据"></a>插入一条数据</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymongo <span class="keyword">import</span> MongoClient</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接服务器</span></span><br><span class="line">conn = MongoClient(<span class="string">&quot;localhost&quot;</span>, <span class="number">27017</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取指定的数据库</span></span><br><span class="line">db = conn.mydb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取数据库中的指定的集合</span></span><br><span class="line">collection = db.student</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加文档</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 添加一条数据</span></span><br><span class="line">    one = collection.insert_one(&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;coder19&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">19</span>, <span class="string">&quot;gender&quot;</span>: <span class="number">1</span>, <span class="string">&quot;address&quot;</span>: <span class="string">&quot;北京&quot;</span>, <span class="string">&quot;isDelete&quot;</span>: <span class="number">0</span>&#125;)</span><br><span class="line">    <span class="built_in">print</span>(one)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取id值</span></span><br><span class="line">    <span class="built_in">print</span>(one.inserted_id)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;添加成功&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;添加失败&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 断开</span></span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure>

<p><code>insert_one()</code>方法返回<code>InsertOneResult</code>对象，改对象包含<code>inserted_id</code>属性，它是插入文档的<code>id</code>值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">one = collection.insert_one(&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;coder19&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">19</span>, <span class="string">&quot;gender&quot;</span>: <span class="number">1</span>, <span class="string">&quot;address&quot;</span>: <span class="string">&quot;北京&quot;</span>, <span class="string">&quot;isDelete&quot;</span>: <span class="number">0</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(one)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取id值</span></span><br><span class="line"><span class="built_in">print</span>(one.inserted_id)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果:</span></span><br><span class="line">    <span class="comment"># &lt;pymongo.results.InsertOneResult object at 0x10ec427c8&gt;</span></span><br><span class="line">    <span class="comment"># 5b557821258dc825c7c0cf57</span></span><br></pre></td></tr></table></figure>


<h4 id="插入多个文档"><a href="#插入多个文档" class="headerlink" title="插入多个文档"></a>插入多个文档</h4><p><code>insert_many()</code>方法返回<code>InsertManyResult</code>对象，该对象包含 <code>inserted_ids</code>属性，该属性保存着所有插入文档的<code>id</code>值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加文档</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 添加多条数据</span></span><br><span class="line">    mylist = [</span><br><span class="line">        &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;个人博客&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">10</span>, <span class="string">&#x27;address&#x27;</span>: <span class="string">&#x27;https://www.titanjun.top&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Github&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">11</span>, <span class="string">&#x27;address&#x27;</span>: <span class="string">&#x27;https://github.com/CoderTitan&#x27;</span>&#125;</span><br><span class="line">    ]</span><br><span class="line">    many = collection.insert_many(mylist)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(many)</span><br><span class="line">    <span class="comment"># 输出插入的所有文档对应的 _id 值</span></span><br><span class="line">    <span class="built_in">print</span>(many.inserted_ids)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;添加成功&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;添加失败&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="comment"># &lt;pymongo.results.InsertManyResult object at 0x10bf82cc8&gt;</span></span><br><span class="line"><span class="comment"># [ObjectId(&#x27;5b557a5d258dc8269a55f485&#x27;), ObjectId(&#x27;5b557a5d258dc8269a55f486&#x27;)]</span></span><br></pre></td></tr></table></figure>

<h4 id="插入指定-id的多个文档"><a href="#插入指定-id的多个文档" class="headerlink" title="插入指定_id的多个文档"></a>插入指定<code>_id</code>的多个文档</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 插入指定 _id 的多个文档</span></span><br><span class="line">    mylist = [</span><br><span class="line">        &#123;<span class="string">&#x27;_id&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;简书&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">12</span>, <span class="string">&#x27;address&#x27;</span>: <span class="string">&#x27;https://www.jianshu.com/u/5bd5e9ed569e&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;_id&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;csdn&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">13</span>, <span class="string">&#x27;address&#x27;</span>: <span class="string">&#x27;https://blog.csdn.net/shmilycoder&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;_id&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;掘金&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">14</span>, <span class="string">&#x27;address&#x27;</span>: <span class="string">&#x27;https://juejin.im/user/5a7a64ae6fb9a0636323fd06&#x27;</span>&#125;,</span><br><span class="line">    ]</span><br><span class="line">    many = collection.insert_many(mylist)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(many)</span><br><span class="line">    <span class="comment"># 输出插入的所有文档对应的 _id 值</span></span><br><span class="line">    <span class="built_in">print</span>(many.inserted_ids)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 输出结果:</span></span><br><span class="line"><span class="comment"># &lt;pymongo.results.InsertManyResult object at 0x10c457dc8&gt;</span></span><br><span class="line"><span class="comment"># [1, 2, 3]</span></span><br></pre></td></tr></table></figure>


<h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><h4 id="返回所有-x2F-第一条数据"><a href="#返回所有-x2F-第一条数据" class="headerlink" title="返回所有&#x2F;第一条数据"></a>返回所有&#x2F;第一条数据</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查询集合中的第一条数据</span></span><br><span class="line"><span class="built_in">print</span>(collection.find_one())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询集合中所有数据</span></span><br><span class="line"><span class="built_in">print</span>(collection.find())</span><br></pre></td></tr></table></figure>


<h4 id="根据id查询指定数据"><a href="#根据id查询指定数据" class="headerlink" title="根据id查询指定数据"></a>根据id查询指定数据</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输出一个Cursor对象</span></span><br><span class="line">res3 = collection.find(&#123;<span class="string">&#x27;_id&#x27;</span>: ObjectId(<span class="string">&#x27;5b52cdbbd87e53d6306f3585&#x27;</span>)&#125;)</span><br><span class="line"><span class="built_in">print</span>(res3)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 输出指定数据信息</span></span><br><span class="line">res12 = collection.find_one(&#123;<span class="string">&#x27;_id&#x27;</span>: ObjectId(<span class="string">&#x27;5b52cdbbd87e53d6306f3585&#x27;</span>)&#125;)</span><br><span class="line"><span class="built_in">print</span>(res12)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果:</span></span><br><span class="line"><span class="comment"># &lt;pymongo.cursor.Cursor object at 0x1027f2550&gt;</span></span><br><span class="line"><span class="comment"># &#123;&#x27;_id&#x27;: ObjectId(&#x27;5b52cdbbd87e53d6306f3585&#x27;), &#x27;name&#x27;: &#x27;hai&#x27;, &#x27;age&#x27;: 17.0, &#x27;gender&#x27;: 0.0, &#x27;address&#x27;: &#x27;北京&#x27;, &#x27;isDelete&#x27;: 0.0&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="根据指定条件查询"><a href="#根据指定条件查询" class="headerlink" title="根据指定条件查询"></a>根据指定条件查询</h4><p>查询集合中所有符合<code>key</code>为<code>value</code>的所有的数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">res10 = collection.find(&#123;<span class="string">&#x27;age&#x27;</span>: <span class="number">19</span>&#125;)</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> res10:</span><br><span class="line">    <span class="built_in">print</span>(row)</span><br></pre></td></tr></table></figure>

<h4 id="指定条件查询"><a href="#指定条件查询" class="headerlink" title="指定条件查询"></a>指定条件查询</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># age大于19的所有数据的集合</span></span><br><span class="line">res2 = collection.find(&#123;<span class="string">&#x27;age&#x27;</span>: &#123;<span class="string">&#x27;$gt&#x27;</span>: <span class="number">19</span>&#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># age大于19的所有数据的个数</span></span><br><span class="line">res2 = collection.count_documents(&#123;<span class="string">&#x27;age&#x27;</span>: &#123;<span class="string">&#x27;$gt&#x27;</span>: <span class="number">19</span>&#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定多条件查询</span></span><br><span class="line">res2 = collection.count_documents(&#123;<span class="string">&#x27;age&#x27;</span>: &#123;<span class="string">&#x27;$gt&#x27;</span>: <span class="number">19</span>&#125;, <span class="string">&#x27;gender&#x27;</span>: <span class="number">0</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 正则表达式查询</span></span><br><span class="line"><span class="comment"># name以c开头的数据</span></span><br><span class="line">res11 = collection.find(&#123;<span class="string">&#x27;name&#x27;</span>: &#123;<span class="string">&#x27;$regex&#x27;</span>: <span class="string">&#x27;^c&#x27;</span>&#125;&#125;)</span><br></pre></td></tr></table></figure>


<h4 id="返回指定条数记录"><a href="#返回指定条数记录" class="headerlink" title="返回指定条数记录"></a>返回指定条数记录</h4><p>如果我们要对查询结果设置指定条数的记录可以使用<code>limit()</code>方法，该方法只接受一个数字参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 只返回3条数据</span></span><br><span class="line">res5 = collection.find()limit(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 跳过指定条数返回</span></span><br><span class="line"><span class="comment"># 结果共6条数据</span></span><br><span class="line">res12 = collection.find(&#123;<span class="string">&#x27;age&#x27;</span>: &#123;<span class="string">&#x27;$gt&#x27;</span>: <span class="number">19</span>&#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 跳过前两条, 返回后面4条数据</span></span><br><span class="line">res13 = collection.find(&#123;<span class="string">&#x27;age&#x27;</span>: &#123;<span class="string">&#x27;$gt&#x27;</span>: <span class="number">19</span>&#125;&#125;).skip(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分页效果</span></span><br><span class="line"><span class="comment"># 跳过上一页的3条数据, 输出3条数据</span></span><br><span class="line">res5 = collection.find().skip(<span class="number">3</span>).limit(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>


<h3 id="修改文档"><a href="#修改文档" class="headerlink" title="修改文档"></a>修改文档</h3><ul>
<li>在<code>MongoDB</code>中使用<code>update_one()</code>和<code>update_many()</code>方法修改文档中的记录, 第一个参数为查询的条件，第二个参数为要修改的字段</li>
<li>在<code>update_one()</code>方法中, 如果查找到的匹配数据多余一条，则只会修改第一条</li>
<li>在<code>update_many()</code>方法中, 会修改所有符合条件的数据</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 更新一条数据</span></span><br><span class="line">collection.update_one(&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;coder1&#x27;</span>&#125;, &#123;<span class="string">&#x27;$set&#x27;</span>: &#123;<span class="string">&#x27;age&#x27;</span>: <span class="number">80</span>&#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新多条数据</span></span><br><span class="line">collection.update_many(&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;coder2&#x27;</span>&#125;, &#123;<span class="string">&#x27;$set&#x27;</span>: &#123;<span class="string">&#x27;age&#x27;</span>: <span class="number">90</span>&#125;&#125;)</span><br></pre></td></tr></table></figure>

<div class="note primary"><p>除了`update`方法之外还有一个`replace`方法, 两者的区别是</p></div>

<ul>
<li><code>update</code>只会修改<code>key</code>值对应的<code>value</code>值, 对其他的<code>value</code>值不做修改</li>
<li><code>replace</code>方法是除<code>id</code>不变, 其他值都会改变, 若未指定新值, 则赋值为空</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改前</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;修改前&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(collection.find_one(&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;coder1&#x27;</span>&#125;))</span><br><span class="line">    <span class="built_in">print</span>(collection.find_one(&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;coder19&#x27;</span>&#125;))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># update更新一条数据</span></span><br><span class="line">    collection.update_one(&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;coder1&#x27;</span>&#125;, &#123;<span class="string">&#x27;$set&#x27;</span>: &#123;<span class="string">&#x27;age&#x27;</span>: <span class="number">80</span>&#125;&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># replace更新数据</span></span><br><span class="line">    collection.replace_one(&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;coder19&#x27;</span>&#125;, &#123;<span class="string">&#x27;age&#x27;</span>: <span class="number">90</span>, <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;coder19&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 修改后</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;修改后&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(collection.find_one(&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;coder1&#x27;</span>&#125;))</span><br><span class="line">    <span class="built_in">print</span>(collection.find_one(&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;coder19&#x27;</span>&#125;))</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment"># 最后的输出结果</span></span><br><span class="line"><span class="comment"># 修改前</span></span><br><span class="line"><span class="comment"># &#123;&#x27;_id&#x27;: ObjectId(&#x27;5b5318d0258dc83e8de6f812&#x27;), &#x27;name&#x27;: &#x27;coder1&#x27;, &#x27;age&#x27;: 80, &#x27;gender&#x27;: 0, &#x27;address&#x27;: &#x27;杭州&#x27;, &#x27;isDelete&#x27;: 0&#125;</span></span><br><span class="line"><span class="comment"># &#123;&#x27;_id&#x27;: ObjectId(&#x27;5b557821258dc825c7c0cf57&#x27;), &#x27;name&#x27;: &#x27;coder19&#x27;, &#x27;age&#x27;: 19, &#x27;gender&#x27;: 1, &#x27;address&#x27;: &#x27;北京&#x27;, &#x27;isDelete&#x27;: 0&#125;</span></span><br><span class="line"><span class="comment"># 修改后</span></span><br><span class="line"><span class="comment"># &#123;&#x27;_id&#x27;: ObjectId(&#x27;5b5318d0258dc83e8de6f812&#x27;), &#x27;name&#x27;: &#x27;coder1&#x27;, &#x27;age&#x27;: 80, &#x27;gender&#x27;: 0, &#x27;address&#x27;: &#x27;杭州&#x27;, &#x27;isDelete&#x27;: 0&#125;</span></span><br><span class="line"><span class="comment"># &#123;&#x27;_id&#x27;: ObjectId(&#x27;5b557821258dc825c7c0cf57&#x27;), &#x27;age&#x27;: 90, &#x27;name&#x27;: &#x27;coder19&#x27;&#125;</span></span><br></pre></td></tr></table></figure>


<h3 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h3><ul>
<li>我们可以使用<code>delete_one()</code>和<code>delete_many()</code>方法来删除, 参数为查询对象，指定要删除哪些数据</li>
<li><code>delete_one()</code>: 删除符合条件的第一条数据</li>
<li><code>delete_many()</code>: 删除符合条件的所有数据, 若参数为空, 则表示删除所有数据</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除一条数据</span></span><br><span class="line">res = collection.delete_one(&#123;<span class="string">&#x27;age&#x27;</span>: <span class="number">90</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除多条数据</span></span><br><span class="line">res1 = collection.delete_many(&#123;<span class="string">&#x27;age&#x27;</span>: <span class="number">90</span>&#125;)</span><br><span class="line"><span class="comment"># 输出删除的数据的数量</span></span><br><span class="line"><span class="built_in">print</span>(res1.deleted_count)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一下两个方法建议不要轻易尝试, 否则所有数据将不复存在</span></span><br><span class="line"><span class="comment"># 删除所有数据</span></span><br><span class="line">res1 = collection.delete_many(&#123;&#125;)</span><br><span class="line"><span class="comment"># 输出删除的数据的数量</span></span><br><span class="line"><span class="built_in">print</span>(res1.deleted_count)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除集合</span></span><br><span class="line">collection.drop()</span><br><span class="line"><span class="comment"># 如果删除成功 drop() 返回 true，如果删除失败(集合不存在)则返回 false。</span></span><br></pre></td></tr></table></figure>

<h3 id="排序-1"><a href="#排序-1" class="headerlink" title="排序"></a>排序</h3><ul>
<li>使用<code>sort</code>进行排序, 默认降序排列</li>
<li>降序: <code>DESCENDING</code>, 升序: <code>ASCENDING</code></li>
<li>参数二也可以用1和-1: 1 为升序，-1 为降序</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 以age进行降序排列, 参数二可不传, 默认降序</span></span><br><span class="line">res4 = collection.find().sort(<span class="string">&#x27;age&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行升序排列</span></span><br><span class="line">res5 = collection.find().sort(<span class="string">&#x27;age&#x27;</span>, pymongo.ASCENDING)</span><br><span class="line">res5 = collection.find().sort(<span class="string">&#x27;age&#x27;</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>


<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a href="http://api.mongodb.com/python/current/api/pymongo/collection.html">更多集合相关用法详见官方文档</a></li>
<li><a href="http://api.mongodb.com/python/current/api/pymongo/">pymongo官方文档</a></li>
<li><a href="http://pc5s2udrk.bkt.clouddn.com/MongoDB1.pdf">MongoDB介绍</a></li>
</ul>
<blockquote>
<p>至此, <code>MongoDB</code>所有相关的内容这里也就全部都介绍完了</p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>数据库基础</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>MongoDB</tag>
        <tag>pymongo</tag>
      </tags>
  </entry>
  <entry>
    <title>NSRunLoop底层原理详解</title>
    <url>/post/76b52ee.html</url>
    <content><![CDATA[<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/ios/runloopmode.png" alt="NSRunLoop"></p>
<span id="more"></span>


<ul>
<li>正常情况下, 一个线程执行完, 程序就会立即退出, 比如一个命令行项目</li>
<li><code>NSRunLoop</code>是<code>iOS</code>中的消息处理机制,执行完某个事件后线程不会退出，而是进入休眠状态，当再次监测到需要出发事件时，线程激活，继续处理事件，处理完成后再次进入休眠</li>
<li>这种时间运行循环, 类似于一个<code>while</code>循环</li>
<li>默认情况下, 不需要我们手动创建<code>RunLoop</code>, 因为<code>cocoa</code>框架为我们创建了一个默认的<code>RunLoop</code></li>
<li><code>RunLoop</code>的主要作用<ul>
<li>保持程序的持续运行</li>
<li>处理<code>App</code>中的各种事件（手势、定时器、<code>Selector</code>等）</li>
<li>节省<code>CPU</code>资源、提高程序性能：该做任务的时候做任务，没事干的时候休息</li>
</ul>
</li>
<li><code>RunLoop</code>和线程的关系<ul>
<li>每条线程都有唯一的一个与之对应的<code>RunLoop</code>对象</li>
<li><code>RunLoop</code>保存在一个全局的<code>Dictionary</code>里, 线程作为<code>key</code>, <code>RunLoop</code>作为<code>value</code></li>
<li>线程刚创建时并没有<code>RunLoop</code>对象, <code>RunLoop</code>会在第一次获取线程时创建</li>
<li><code>RunLoop</code>会在线程结束时销毁</li>
<li>主线程的<code>RunLoop</code>已经自动获取(创建), 子线程默认没有开启<code>RunLoop</code></li>
</ul>
</li>
</ul>
<h2 id="RunLoop对象"><a href="#RunLoop对象" class="headerlink" title="RunLoop对象"></a>RunLoop对象</h2><ul>
<li>在<code>iOS</code>开发中<code>RunLoop</code>有两套<code>API</code>框架, 分别是<ul>
<li><code>Foundation</code>的<code>NSRunLoop</code></li>
<li><code>Core Foundation</code>的<code>CFRunLoopRef</code></li>
</ul>
</li>
<li><code>CFRunLoopRef</code>是基于<code>C</code>语言的开源框架, 有兴趣的可以到<a href="https://opensource.apple.com/tarballs/CF/">源码地址</a>下载源码, 不过没有<code>C</code>语言功底的只怕很难看懂</li>
<li><code>NSRunLoop</code>是对<code>CFRunLoopRef</code>的有一层封装, 是<code>OC</code>语法的框架</li>
<li>简单使用, 获取<code>RunLoop</code>对象</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取当前线程的RunLoop</span></span><br><span class="line">[<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line"><span class="comment">// 获取主线程的RunLoop</span></span><br><span class="line">[<span class="built_in">NSRunLoop</span> mainRunLoop];</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 获取主线程的RunLoop</span></span><br><span class="line"><span class="built_in">CFRunLoopGetMain</span>();</span><br><span class="line"><span class="comment">// 获取当前线程的RunLoop</span></span><br><span class="line"><span class="built_in">CFRunLoopGetCurrent</span>();</span><br></pre></td></tr></table></figure>

<h3 id="RunLoop相关的类"><a href="#RunLoop相关的类" class="headerlink" title="RunLoop相关的类"></a>RunLoop相关的类</h3><ul>
<li>因为<code>NSRunLoop</code>是不开源的, 但是<code>CFRunLoopRef</code>却是开源的, 从<a href="https://opensource.apple.com/tarballs/CF/">源码地址</a>下载<code>CFRunLoopRef</code>的源码</li>
<li>在源码中可以看到, 在<code>Core Foundation</code>中<code>CFRunLoopRef</code>有以下5个相关的类<ul>
<li><code>CFRunLoopRef</code></li>
<li><code>CFRunLoopModeRef</code></li>
<li><code>CFRunLoopSourceRef</code></li>
<li><code>CFRunLoopTimerRef</code></li>
<li><code>CFRunLoopObserverRef</code></li>
</ul>
</li>
</ul>
<h3 id="CFRunLoopRef"><a href="#CFRunLoopRef" class="headerlink" title="CFRunLoopRef"></a><code>CFRunLoopRef</code></h3><p><code>CFRunLoopRef</code>对象的主要核心代码如下</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> __CFRunLoop * <span class="built_in">CFRunLoopRef</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> __CFRunLoop &#123;</span><br><span class="line">    <span class="comment">// 线程对象</span></span><br><span class="line">    pthread_t _pthread;</span><br><span class="line">    <span class="comment">// 无序集合</span></span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _commonModes;</span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _commonModeItems;</span><br><span class="line">    <span class="comment">// 当前mode</span></span><br><span class="line">    <span class="built_in">CFRunLoopModeRef</span> _currentMode;</span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _modes;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<div class="note primary"><p>主要属性介绍</p></div>


<ul>
<li><code>CFMutableSetRef</code>是一个无序的集合, 在上面的代码中存储的都是<code>CFRunLoopModeRef</code>对象</li>
<li>其中<code>_modes</code>存储的是所有的<code>mode</code>对象</li>
<li><code>_currentMode</code>是指当前的<code>mode</code></li>
</ul>
<h3 id="CFRunLoopModeRef"><a href="#CFRunLoopModeRef" class="headerlink" title="CFRunLoopModeRef"></a><code>CFRunLoopModeRef</code></h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> __CFRunLoopMode *<span class="built_in">CFRunLoopModeRef</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> __CFRunLoopMode &#123;</span><br><span class="line">    <span class="comment">// mode名称</span></span><br><span class="line">    <span class="built_in">CFStringRef</span> _name;</span><br><span class="line">    Boolean _stopped;</span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _sources0;</span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _sources1;</span><br><span class="line">    <span class="built_in">CFMutableArrayRef</span> _observers;</span><br><span class="line">    <span class="built_in">CFMutableArrayRef</span> _timers;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>_name</code>: 该<code>__CFRunLoopMode</code>的名称</li>
<li><code>_sources0</code>和<code>_sources1</code>: 一个无序集合, 存储的都是<code>CFRunLoopSourceRef</code>对象</li>
<li><code>_observers</code>: 一个有序集合数组,存储的都是<code>CFRunLoopObserverRef</code>对象</li>
<li><code>_timers</code>: 一个有序集合数组,存储的都是<code>CFRunLoopTimerRef</code>对象</li>
<li>从这里我们可以看出以上几个类之间的关系, 大概可如下图所示</li>
</ul>
<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/ios/runloop_modes.png" alt="image"></p>
<ul>
<li><code>CFRunLoopModeRef</code>代表<code>RunLoop</code>的运行模式</li>
<li>一个<code>RunLoop</code>只能对应一个线程, 却包含若干个<code>Mode</code>，每个<code>Mode</code>又包含若干个<code>Source0/Source1/Timer/Observer</code></li>
<li><code>RunLoop</code>启动时只能选择其中一个<code>Mode</code>，作为<code>currentMode</code>同样只能有一个</li>
<li>如果需要切换<code>Mode</code>，只能退出当前<code>Loop</code>，再重新选择一个<code>Mode</code>进入,<br>不同组的<code>Source0/Source1/Timer/Observer</code>能分隔开来，互不影响</li>
<li>如果<code>Mode</code>里没有任何<code>Source0/Source1/Timer/Observer</code>，<code>RunLoop</code>会立马退出</li>
<li>以下是系统默认的集中<code>mode</code></li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">FOUNDATION_EXPORT <span class="built_in">NSRunLoopMode</span> <span class="keyword">const</span> <span class="built_in">NSDefaultRunLoopMode</span>;</span><br><span class="line">FOUNDATION_EXPORT <span class="built_in">NSRunLoopMode</span> <span class="keyword">const</span> <span class="built_in">NSRunLoopCommonModes</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="built_in">NSRunLoopMode</span> <span class="keyword">const</span> <span class="built_in">UITrackingRunLoopMode</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CF_EXPORT</span> <span class="keyword">const</span> <span class="built_in">CFRunLoopMode</span> kCFRunLoopDefaultMode;</span><br><span class="line"><span class="built_in">CF_EXPORT</span> <span class="keyword">const</span> <span class="built_in">CFRunLoopMode</span> kCFRunLoopCommonModes;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>kCFRunLoopDefaultMode</code>（<code>NSDefaultRunLoopMode</code>）：<code>App</code>的默认<code>Mode</code>，通常主线程是在这个<code>Mode</code>下运行</li>
<li><code>UITrackingRunLoopMode</code>：界面跟踪<code>Mode</code>，用于<code>ScrollView</code>追踪触摸滑动，保证界面滑动时不受其他<code>Mode</code>影响</li>
<li><code>kCFRunLoopCommonModes</code>（<code>NSRunLoopCommonModes</code>）: 并不是某一种特定的<code>mode</code>, 而是通用模式, 包括<code>kCFRunLoopDefaultMode</code>和<code>UITrackingRunLoopMode</code></li>
</ul>
<h3 id="CFRunLoopObserverRef"><a href="#CFRunLoopObserverRef" class="headerlink" title="CFRunLoopObserverRef"></a>CFRunLoopObserverRef</h3><p><code>CFRunLoopObserverRef</code>是观察者，能够监听<code>RunLoop</code>所有的状态改变。<br>可以监听的时间点有如下几种：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Run Loop Observer Activities */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">CF_OPTIONS</span>(<span class="built_in">CFOptionFlags</span>, <span class="built_in">CFRunLoopActivity</span>) &#123;</span><br><span class="line">    <span class="comment">// 即将进入Loop</span></span><br><span class="line">    kCFRunLoopEntry = (<span class="number">1</span>UL &lt;&lt; <span class="number">0</span>),</span><br><span class="line">    <span class="comment">// 即将处理Timer</span></span><br><span class="line">    kCFRunLoopBeforeTimers = (<span class="number">1</span>UL &lt;&lt; <span class="number">1</span>),</span><br><span class="line">    <span class="comment">// 即将处理Source</span></span><br><span class="line">    kCFRunLoopBeforeSources = (<span class="number">1</span>UL &lt;&lt; <span class="number">2</span>),</span><br><span class="line">    <span class="comment">// 即将进入休眠</span></span><br><span class="line">    kCFRunLoopBeforeWaiting = (<span class="number">1</span>UL &lt;&lt; <span class="number">5</span>),</span><br><span class="line">    <span class="comment">// 刚从休眠中唤醒</span></span><br><span class="line">    kCFRunLoopAfterWaiting = (<span class="number">1</span>UL &lt;&lt; <span class="number">6</span>),</span><br><span class="line">    <span class="comment">// 即将退出Loop</span></span><br><span class="line">    kCFRunLoopExit = (<span class="number">1</span>UL &lt;&lt; <span class="number">7</span>),</span><br><span class="line">    <span class="comment">// 所有状态</span></span><br><span class="line">    kCFRunLoopAllActivities = <span class="number">0x0FFFFFFF</span>U</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在主线程监听所有的状态</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建observer</span></span><br><span class="line"><span class="built_in">CFRunLoopObserverRef</span> observer = <span class="built_in">CFRunLoopObserverCreateWithHandler</span>(kCFAllocatorDefault, kCFRunLoopAllActivities, <span class="literal">YES</span>, <span class="number">0</span>, ^(<span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFRunLoopActivity</span> activity) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (activity) &#123;</span><br><span class="line">        <span class="keyword">case</span> kCFRunLoopEntry:</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;kCFRunLoopEntry&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kCFRunLoopBeforeTimers:</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;kCFRunLoopBeforeTimers&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kCFRunLoopBeforeSources:</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;kCFRunLoopBeforeSources&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kCFRunLoopBeforeWaiting:</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;kCFRunLoopBeforeWaiting&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kCFRunLoopAfterWaiting:</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;kCFRunLoopAfterWaiting&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kCFRunLoopExit:</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;kCFRunLoopExit&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 吧observer添加到RunLoop中</span></span><br><span class="line"><span class="built_in">CFRunLoopAddObserver</span>(<span class="built_in">CFRunLoopGetMain</span>(), observer, kCFRunLoopCommonModes);</span><br><span class="line"><span class="comment">// 释放</span></span><br><span class="line"><span class="built_in">CFRelease</span>(observer);</span><br></pre></td></tr></table></figure>

<h2 id="RunLoop消息类型"><a href="#RunLoop消息类型" class="headerlink" title="RunLoop消息类型"></a>RunLoop消息类型</h2><p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/ios/runloop_date.png" alt="image"></p>
<p>从上图可以看出消息类型大概可以分出两种, 第一种类型又可以细分为三种, 这三种都是异步执行的</p>
<h3 id="Port"><a href="#Port" class="headerlink" title="Port"></a>Port</h3><p>监听程序的<code>mach ports</code>，<code>ports</code>可以简单的理解为：内核通过<code>port</code>这种方式将信息发送，而<code>mach</code>则监听内核发来的<code>port</code>信息，然后将其整理，打包发给<code>runloop</code></p>
<h3 id="Customer"><a href="#Customer" class="headerlink" title="Customer"></a>Customer</h3><p>由开发人员自己发送, 苹果也提供了一个<code>CFRunLoopSource</code>来帮助处理, 简单介绍核心实:</p>
<ol>
<li>定义输入源（数据结构）</li>
<li>将输入源添加到runloop，那么这样就有了接受者，即为R1</li>
<li>协调输入源的客户端（单独线程），专门监听消息，然后将消息打包成<code>runloop</code>能够处理的样式，即第一步定义的输入源。它类似<code>Mach</code>的功能</li>
</ol>
<h3 id="Selector-Sources"><a href="#Selector-Sources" class="headerlink" title="Selector Sources"></a>Selector Sources</h3><p>NSObject类提供了很多方法供我们使用，这些方法是添加到runloop的，所以如果没有开启runloop的话，不会运行</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 主线程</span></span><br><span class="line">- (<span class="type">void</span>)performSelectorOnMainThread:(SEL)aSelector withObject:(<span class="keyword">nullable</span> <span class="type">id</span>)arg waitUntilDone:(<span class="type">BOOL</span>)wait modes:(<span class="keyword">nullable</span> <span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)array;</span><br><span class="line">- (<span class="type">void</span>)performSelectorOnMainThread:(SEL)aSelector withObject:(<span class="keyword">nullable</span> <span class="type">id</span>)arg waitUntilDone:(<span class="type">BOOL</span>)wait;</span><br><span class="line">	</span><br><span class="line"><span class="comment">/// 指定线程</span></span><br><span class="line">- (<span class="type">void</span>)performSelector:(SEL)aSelector onThread:(<span class="built_in">NSThread</span> *)thr withObject:(<span class="keyword">nullable</span> <span class="type">id</span>)arg waitUntilDone:(<span class="type">BOOL</span>)wait modes:(<span class="keyword">nullable</span> <span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)array;</span><br><span class="line">- (<span class="type">void</span>)performSelector:(SEL)aSelector onThread:(<span class="built_in">NSThread</span> *)thr withObject:(<span class="keyword">nullable</span> <span class="type">id</span>)arg waitUntilDone:(<span class="type">BOOL</span>)wait;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 针对当前线程, 延迟调用</span></span><br><span class="line">- (<span class="type">void</span>)performSelector:(SEL)aSelector withObject:(<span class="keyword">nullable</span> <span class="type">id</span>)anArgument afterDelay:(<span class="built_in">NSTimeInterval</span>)delay inModes:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSRunLoopMode</span>&gt; *)modes;</span><br><span class="line">- (<span class="type">void</span>)performSelector:(SEL)aSelector withObject:(<span class="keyword">nullable</span> <span class="type">id</span>)anArgument afterDelay:(<span class="built_in">NSTimeInterval</span>)delay;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 取消，在当前线程，和上面两个方法对应</span></span><br><span class="line">+ (<span class="type">void</span>)cancelPreviousPerformRequestsWithTarget:(<span class="type">id</span>)aTarget selector:(SEL)aSelector object:(<span class="keyword">nullable</span> <span class="type">id</span>)anArgument;</span><br><span class="line">+ (<span class="type">void</span>)cancelPreviousPerformRequestsWithTarget:(<span class="type">id</span>)aTarget;</span><br></pre></td></tr></table></figure>

<ul>
<li>上面提到的前四个方法是在指定线程运行<code>aSelector</code>, 一般情况下<code>aSelector</code>会添加到指定线程的<code>runloop</code></li>
<li>如果调用线程和指定线程为同一线程，且<code>wait</code>参数设为<code>YES</code>，那么<code>aSelector</code>会直接在指定线程运行，不再添加到<code>runloop</code>; </li>
<li>因为<code>wait</code>参数设为<code>YES</code>, 意味着要等待<code>aSelector</code>执行完成之后才回去执行后面的逻辑</li>
</ul>
<h2 id="RunLoop运行逻辑"><a href="#RunLoop运行逻辑" class="headerlink" title="RunLoop运行逻辑"></a>RunLoop运行逻辑</h2><p>根据苹果在<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW23">文档</a>里的说明，<code>RunLoop</code> 内部的逻辑大致如下:</p>
<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/ios/runloopflow.png" alt="image"></p>
<p>未查看<code>RunLoop</code>的执行流程, 我们可以新建一个项目, 并简单加一个触发事件, 如下所示</p>
<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/ios/runloop_cycle.png" alt="image"></p>
<ul>
<li>如图所示, 添加一个简单的触发事件, 并加上断点, 在打印区域输入<code>bt</code>命令后, 就能看到完整的执行流程了</li>
<li>从下往上查看, 所执行的相关函数大概流程是:</li>
<li><code>UIApplicationMain</code></li>
<li><code>CFRunLoopRunSpecific</code></li>
<li><code>__CFRunLoopRun</code></li>
<li><code>__CFRunLoopDoSources0</code></li>
<li>最后就是<code>[UIResponder touchesBegan:withEvent:]</code>触发函数了</li>
<li>下面的事情就是找到源码, 依次查看所执行的函数了</li>
<li>在源码中找到<code>CFRunLoop.c</code>文件, 搜索<code>CFRunLoopRunSpecific</code>方法, 就是核心代码了, 一起来看看吧</li>
<li>删除其他不相关的代码, 核心代码大概如下</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// RunLoop的实现, 大概在文件的2622行</span></span><br><span class="line">SInt32 <span class="built_in">CFRunLoopRunSpecific</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFStringRef</span> modeName, <span class="built_in">CFTimeInterval</span> seconds, Boolean returnAfterSourceHandled) &#123; &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 首先根据modeName找到对应mode</span></span><br><span class="line">    <span class="built_in">CFRunLoopModeRef</span> currentMode = __CFRunLoopFindMode(rl, modeName, <span class="literal">false</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 1. 通知 Observers: RunLoop 即将进入 loop。</span></span><br><span class="line">    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// __CFRunLoopRun中具体要做的事情</span></span><br><span class="line">    result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 11. 通知 Observers: RunLoop 即将退出。</span></span><br><span class="line">    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// __CFRunLoopRun的实现, 进入loop, 大概在文件的2304行</span></span><br><span class="line"><span class="keyword">static</span> int32_t __CFRunLoopRun(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopModeRef</span> rlm, <span class="built_in">CFTimeInterval</span> seconds, Boolean stopAfterHandle, <span class="built_in">CFRunLoopModeRef</span> previousMode) &#123;</span><br><span class="line"></span><br><span class="line">    int32_t retVal = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 通知 Observers: RunLoop 即将触发 Timer 回调。</span></span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。</span></span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 处理block</span></span><br><span class="line">        __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 处理Source0</span></span><br><span class="line">        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);</span><br><span class="line">        <span class="comment">// 如果处理Source0的结果是rrue</span></span><br><span class="line">        <span class="keyword">if</span> (sourceHandledThisLoop) &#123;</span><br><span class="line">            <span class="comment">// 再次处理block</span></span><br><span class="line">            __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Boolean poll = sourceHandledThisLoop || (<span class="number">0</span>ULL == timeout_context-&gt;termTSR);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 如果有Source1 (基于port) 处于ready状态，直接处理这个Source1然后跳转去处理消息。</span></span><br><span class="line">        <span class="keyword">if</span> (__CFRunLoopWaitForMultipleObjects(<span class="literal">NULL</span>, &amp;dispatchPort, <span class="number">0</span>, <span class="number">0</span>, &amp;livePort, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">            <span class="comment">// 如果有Source1, 就跳转到handle_msg</span></span><br><span class="line">            <span class="keyword">goto</span> handle_msg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7. 通知 Observers: RunLoop 的线程即将进入休眠(sleep)</span></span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);</span><br><span class="line">        __CFRunLoopSetSleeping(rl);</span><br><span class="line">	</span><br><span class="line">        <span class="comment">// 7. 调用mach_msg等待接受mach_port的消息。线程将进入休眠, 等待别的消息来唤醒当前线程</span></span><br><span class="line">        <span class="comment">// 一个基于 port 的Source 的事件。</span></span><br><span class="line">        <span class="comment">// 一个 Timer 到时间了</span></span><br><span class="line">        <span class="comment">// RunLoop 自身的超时时间到了</span></span><br><span class="line">        <span class="comment">// 被其他什么调用者手动唤醒</span></span><br><span class="line">        __CFRunLoopServiceMachPort(waitSet, &amp;msg, <span class="keyword">sizeof</span>(msg_buffer), &amp;livePort, poll ? <span class="number">0</span> : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        __CFRunLoopUnsetSleeping(rl);</span><br><span class="line">        <span class="comment">// 8. 通知Observers: 结束休眠, RunLoop的线程刚刚被唤醒了</span></span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 收到消息，处理消息。</span></span><br><span class="line">    handle_msg:;</span><br><span class="line">        <span class="keyword">if</span> (<span class="comment">/* 被timer唤醒 */</span>) &#123;</span><br><span class="line">            <span class="comment">// 01. 处理Timer</span></span><br><span class="line">            __CFRunLoopDoTimers(rl, rlm, mach_absolute_time())</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="comment">/* 被gcd唤醒 */</span>) &#123;</span><br><span class="line">            <span class="comment">// 02. 处理gcd</span></span><br><span class="line">            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 被Source1唤醒</span></span><br><span class="line">            <span class="comment">// 处理Source1</span></span><br><span class="line">            sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls) || sourceHandledThisLoop;</span><br><span class="line">	    &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 9. 处理Blocks</span></span><br><span class="line">        __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 10. 设置返回值, 根据不同的结果, 处理不同操作</span></span><br><span class="line">        <span class="keyword">if</span> (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">            <span class="comment">// 进入loop时参数说处理完事件就返回。</span></span><br><span class="line">            retVal = kCFRunLoopRunHandledSource;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123;</span><br><span class="line">            <span class="comment">// 超出传入参数标记的超时时间了</span></span><br><span class="line">            retVal = kCFRunLoopRunTimedOut;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopIsStopped(rl)) &#123;</span><br><span class="line">             <span class="comment">// 被外部调用者强制停止了</span></span><br><span class="line">            retVal = kCFRunLoopRunStopped;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123;</span><br><span class="line">            <span class="comment">// source/timer/observer一个都没有了</span></span><br><span class="line">            retVal = kCFRunLoopRunFinished;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没超时，mode里没空，loop也没被停止，那继续loop。</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span> == retVal);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success"><p>`RunLoop`</p></div>

<p>从上面的代码可以看到<code>RunLoop</code>其内部是一个<code>do-while</code>循环; 当你调用<code>CFRunLoopRun()</code>时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回</p>
<h2 id="RunLoop的底层实现"><a href="#RunLoop的底层实现" class="headerlink" title="RunLoop的底层实现"></a>RunLoop的底层实现</h2><ul>
<li>从上面代码可以看到，<code>RunLoop</code>的核心是基于<code>mach port</code>的，其进入休眠时调用的函数是<code>mach_msg()</code></li>
<li><code>Mach</code>本身提供的<code>API</code>非常有限，而且苹果也不鼓励使用<code>Mach</code>的<code>API</code></li>
<li>但是这些<code>API</code>非常基础，如果没有这些<code>API</code>的话，其他任何工作都无法实施</li>
<li>在<code>Mach</code>中，所有的东西都是通过自己的对象实现的，进程、线程和虚拟内存都被称为”对象”</li>
<li>和其他架构不同，<code>Mach</code>的对象间不能直接调用，只能通过消息传递的方式实现对象间的通信。</li>
<li>“消息”是<code>Mach</code>中最基础的概念，消息在两个端口 (<code>port</code>) 之间传递，这就是<code>Mach</code>的<code>IPC</code> (进程间通信) 的核心。</li>
</ul>
<p><code>Mach</code>的消息定义是在<code>&lt;mach/message.h&gt;</code>头文件的，很简单：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">  mach_msg_header_t header;</span><br><span class="line">  mach_msg_body_t body;</span><br><span class="line">&#125; mach_msg_base_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">  mach_msg_bits_t msgh_bits;</span><br><span class="line">  mach_msg_size_t msgh_size;</span><br><span class="line">  mach_port_t msgh_remote_port;</span><br><span class="line">  mach_port_t msgh_local_port;</span><br><span class="line">  mach_port_name_t msgh_voucher_port;</span><br><span class="line">  mach_msg_id_t msgh_id;</span><br><span class="line">&#125; mach_msg_header_t;</span><br></pre></td></tr></table></figure>

<ul>
<li>一条<code>Mach</code>消息实际上就是一个二进制数据包 (BLOB)，其头部定义了当前端口<code>local_port</code>和目标端口<code>remote_port</code></li>
<li>发送和接受消息是通过同一个<code>API</code>进行的，其<code>option</code>标记了消息传递的方向：</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">mach_msg_return_t mach_msg(</span><br><span class="line">	mach_msg_header_t *msg,</span><br><span class="line">	mach_msg_option_t option,</span><br><span class="line">	mach_msg_size_t send_size,</span><br><span class="line">	mach_msg_size_t rcv_size,</span><br><span class="line">	mach_port_name_t rcv_name,</span><br><span class="line">	mach_msg_timeout_t timeout,</span><br><span class="line">	mach_port_name_t notify</span><br><span class="line">);</span><br></pre></td></tr></table></figure>


<ul>
<li>为了实现消息的发送和接收，<code>mach_msg()</code>函数实际上是调用了一个<code>Mach</code>陷阱(<code>trap</code>)，即函数<code>mach_msg_trap()</code>，陷阱这个概念在<code>Mach</code>中等同于系统调用</li>
<li>当你在用户态调用<code>mach_msg_trap()</code>时会触发陷阱机制，切换到内核态；内核态中内核实现的<code>mach_msg()</code>函数会完成实际的工作</li>
<li>内核态中的<code>mach_msg()</code>, 如果没有消息就让线程休眠,有消息就唤醒线程</li>
</ul>
<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/ios/runloop_trcp.png" alt="image"></p>
<ul>
<li><code>RunLoop</code>的核心就是一个<code>mach_msg()</code> (见上面代码的第7步)，<code>RunLoop</code>调用这个函数去接收消息，如果没有别人发送<code>port</code>消息过来，内核会将线程置于等待状态</li>
<li>例如你在模拟器里跑起一个<code>iOS</code>的<code>App</code>，然后在<code>App</code>静止时点击暂停，你会看到主线程调用栈是停留在<code>mach_msg_trap()</code>这个地方</li>
</ul>
<h2 id="NSRunLoop应用实践"><a href="#NSRunLoop应用实践" class="headerlink" title="NSRunLoop应用实践"></a><code>NSRunLoop</code>应用实践</h2><h3 id="NSTimer问题"><a href="#NSTimer问题" class="headerlink" title="NSTimer问题"></a>NSTimer问题</h3><p>解决<code>NSTimer</code>在滑动时停止工作的问题</p>
<ul>
<li>上文有说到<code>CFRunLoopMode</code>主要使用的一般有三种<code>Mode</code></li>
<li><code>DefaultMode</code>是<code>App</code>平时所处的状态，<code>TrackingRunLoopMode</code>是追踪<code>ScrollView</code>滑动时的状态</li>
<li>当你创建一个<code>Timer</code>并加到<code>DefaultMode</code>时，<code>Timer</code>会得到重复回调，但此时滑动一个<code>TableView</code>时，<code>RunLoop</code>会将<code>mode</code>切换为<code>TrackingRunLoopMode</code>，这时<code>Timer</code>就不会被回调，并且也不会影响到滑动操作</li>
<li>下面我来看一下这个例子</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;ViewController.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="comment">// 在xib中添加一个可滚动的UITextView</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UITextView</span> *textView;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSInteger</span> timerCount;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加一个定时器</span></span><br><span class="line">    [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(timerClick) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">- (<span class="type">void</span>)timerClick &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;--------%ld&quot;</span>, (<span class="type">long</span>)<span class="keyword">self</span>.timerCount++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;touchesBegan&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<ul>
<li>上面代码中<code>scheduledTimerWithTimeInterval</code>方式添加的<code>NSTimer</code>会默认被添加到<code>DefaultMode</code>中</li>
<li>当程序运行的时候回正常执行定时器的方法</li>
<li>当我们正常滚动<code>UITextView</code>的时候, 从打印结果可以看到, 定时器停止执行了, 结束滚动<code>UITextView</code>的时候, 定时器方法会继续执行</li>
<li>输出结果如下所示</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2019-08-20 21:46:01.986843+0800 RunLoop[86811:3484205] --------0</span><br><span class="line">2019-08-20 21:46:02.986723+0800 RunLoop[86811:3484205] --------1</span><br><span class="line">2019-08-20 21:46:03.986040+0800 RunLoop[86811:3484205] --------2</span><br><span class="line">2019-08-20 21:46:04.986274+0800 RunLoop[86811:3484205] --------3</span><br><span class="line">2019-08-20 21:46:05.272525+0800 RunLoop[86811:3484205] touchesBegan</span><br><span class="line">2019-08-20 21:46:12.291035+0800 RunLoop[86811:3484205] --------4</span><br><span class="line">2019-08-20 21:46:12.986318+0800 RunLoop[86811:3484205] --------5</span><br><span class="line">2019-08-20 21:46:13.986197+0800 RunLoop[86811:3484205] --------6</span><br><span class="line">2019-08-20 21:46:14.986735+0800 RunLoop[86811:3484205] --------7</span><br></pre></td></tr></table></figure>

<ul>
<li>有时你需要一个<code>Timer</code>，在两个<code>Mode</code>中都能得到回调</li>
<li>一种办法就是将这个<code>Timer</code>分别加入这两个<code>Mode</code></li>
<li>另一种方式，就是将<code>Timer</code>加入到顶层的<code>RunLoop</code>的<code>commonModeItems</code>中</li>
<li><code>commonModeItems</code>被<code>RunLoop</code>自动更新到所有具有<code>Common</code>属性的<code>Mode</code>里去</li>
<li><code>CommonModes</code>并不是一个真的模式，它只是一个标记</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSTimer</span> *timer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:<span class="number">1</span> repeats:<span class="literal">YES</span> block:^(<span class="built_in">NSTimer</span> * _Nonnull timer) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;--------%ld&quot;</span>, (<span class="type">long</span>)<span class="keyword">self</span>.timerCount++);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br></pre></td></tr></table></figure>


<hr>
]]></content>
      <categories>
        <category>OC底层原理</category>
      </categories>
      <tags>
        <tag>NSRunLoop</tag>
      </tags>
  </entry>
  <entry>
    <title>NexT主题如何提高文章颜值</title>
    <url>/post/5a30761b.html</url>
    <content><![CDATA[<ul>
<li>博客搭建和主题配置教程: <a href="https://www.titanjun.top/categories/Hexo%E5%8D%9A%E5%AE%A2/">Hexo博客相关分类</a></li>
<li>博客主题配置好了, 也算穿上了华丽的外衣, 但是真正高质量的文章不但要有好的内容更要有美丽的外表结构</li>
<li>所以在提高外在美的同时, 我们也要提高文章的内在美</li>
<li>这里我们就介绍一些在NexT主题下提高文章颜值的方法</li>
</ul>
<span id="more"></span>

<h2 id="文章的模版文件（必读）"><a href="#文章的模版文件（必读）" class="headerlink" title="文章的模版文件（必读）"></a>文章的模版文件（必读）</h2><ul>
<li>Hexo博客新建文章的两种方式:<ul>
<li>直接在~&#x2F;blog&#x2F;source&#x2F;_posts&#x2F;下新建.md结尾的文件来写新的文章</li>
<li>站点文件夹根目录, 终端输入<code>hexo new post &lt;title&gt;</code>新建的文章</li>
</ul>
</li>
<li>关于文件最上方的参数, <a href="https://hexo.io/zh-cn/docs/variables.html#%E9%A1%B5%E9%9D%A2%E5%8F%98%E9%87%8F">Hexo变量</a></li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ！！！！！！！！！！</span></span><br><span class="line"><span class="comment">** 每一项的 : 后面均有一个空格</span></span><br><span class="line"><span class="comment">** 且 : 为英文符号</span></span><br><span class="line"><span class="comment">** ！！！！！！！！！！</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">title:</span><br><span class="line"><span class="comment">/* 文章标题，可以为中文 */</span></span><br><span class="line"></span><br><span class="line">date:</span><br><span class="line"><span class="comment">/* 建立日期，如果自己手动添加，请按固定格式</span></span><br><span class="line"><span class="comment">** 就算不写，页面每篇文章顶部的发表于……也能显示</span></span><br><span class="line"><span class="comment">** 只要在主题配置文件中，配置了 created_at 就行</span></span><br><span class="line"><span class="comment">** 那为什么还要自己加上？</span></span><br><span class="line"><span class="comment">** 自定义文章发布的时间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">updated:</span><br><span class="line"><span class="comment">/* 更新日期，其它与上面的建立日期类似</span></span><br><span class="line"><span class="comment">** 不过在页面每篇文章顶部，是更新于……</span></span><br><span class="line"><span class="comment">** 在主题配置文件中，是 updated_at</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">permalink:</span><br><span class="line"><span class="comment">/* 若站点配置文件下的 permalink 配置了 title</span></span><br><span class="line"><span class="comment">** 则可以替换文章 URL 里面的 title（文章标题）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">categories:</span><br><span class="line"><span class="comment">/* 分类，支持多级，比如：</span></span><br><span class="line"><span class="comment">- technology</span></span><br><span class="line"><span class="comment">- computer</span></span><br><span class="line"><span class="comment">- computer-aided-art</span></span><br><span class="line"><span class="comment">则为technology/computer/computer-aided-art</span></span><br><span class="line"><span class="comment">（不适用于 layout: page）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">tags:</span><br><span class="line"><span class="comment">/* 标签</span></span><br><span class="line"><span class="comment">** 多个可以这样写[标签1,标签2,标签3]</span></span><br><span class="line"><span class="comment">** （不适用于 layout: page）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">description:</span><br><span class="line"><span class="comment">/* 文章的描述，在每篇文章标题下方显示</span></span><br><span class="line"><span class="comment">** 并且作为网页的 description 元数据</span></span><br><span class="line"><span class="comment">** 如果不写，则自动取 &lt;!-- more --&gt;</span></span><br><span class="line"><span class="comment">** 之前的文字作为网页的 description 元数据</span></span><br><span class="line"><span class="comment">** 建议每篇文章都务必加上！</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">keywords:</span><br><span class="line"><span class="comment">/* 关键字，并且作为网页的 keywords 元数据</span></span><br><span class="line"><span class="comment">** 如果不写，则自动取 tags 里的项</span></span><br><span class="line"><span class="comment">** 作为网页的 keywords 元数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">comments:</span><br><span class="line"><span class="comment">/* 是否开启评论</span></span><br><span class="line"><span class="comment">** 默认值是 true</span></span><br><span class="line"><span class="comment">** 要关闭写 false</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">layout:</span><br><span class="line"><span class="comment">/* 页面布局，默认值是 post，默认值可以在</span></span><br><span class="line"><span class="comment">** 站点配置文件中修改 default_layout</span></span><br><span class="line"><span class="comment">** 另：404 页面可能用到，将其值改为 false</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">type:</span><br><span class="line"><span class="comment">/* categories，目录页面</span></span><br><span class="line"><span class="comment">** tags，标签页面</span></span><br><span class="line"><span class="comment">** picture，用来生成 group-pictures</span></span><br><span class="line"><span class="comment">** quote？</span></span><br><span class="line"><span class="comment">** https://reuixiy.github.io/uncategorized/2010/01/01/test.html</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">photos:</span><br><span class="line"><span class="comment">/* Gallery support，用来支持画廊 / 相册，用法如下：</span></span><br><span class="line"><span class="comment">- photo_url_1</span></span><br><span class="line"><span class="comment">- photo_url_2</span></span><br><span class="line"><span class="comment">- photo_url_3</span></span><br><span class="line"><span class="comment">https://reuixiy.github.io/uncategorized/2010/01/01/test.html</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">link:</span><br><span class="line"><span class="comment">/* 文章的外部链接</span></span><br><span class="line"><span class="comment">** https://reuixiy.github.io/uncategorized/2010/01/01/test.html</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">image:</span><br><span class="line"><span class="comment">/* 自定义的文章摘要图片，只在页面展示，文章内消失</span></span><br><span class="line"><span class="comment">** 此项只有参考本文 5.14 节配置好，否则请勿添加！</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">sticky:</span><br><span class="line"><span class="comment">/* 文章置顶</span></span><br><span class="line"><span class="comment">** 此项只有参考本文 5.15 节配置好，否则请勿添加！</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">password:</span><br><span class="line"><span class="comment">/* 文章密码，此项只有参考教程：</span></span><br><span class="line"><span class="comment">** http://shenzekun.cn/hexo的next主题个性化配置教程.html</span></span><br><span class="line"><span class="comment">** 第 24 节，配置好，否则请勿添加！</span></span><br><span class="line"><span class="comment">** 发现还是有 bug 的，就是右键在新标签中打开</span></span><br><span class="line"><span class="comment">** 然后无论是否输入密码，都能看到内容</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="Markdown语法总结"><a href="#Markdown语法总结" class="headerlink" title="Markdown语法总结"></a><code>Markdown</code>语法总结</h2><ul>
<li><code>Markdown</code>的使用优点和基本语法这里就不在介绍了</li>
<li>下面给大家推荐几款<code>Markdown</code>编辑软件<ul>
<li><a href="http://www.sdifen.com/mweb229.html">MWeb Mac中文破解版</a></li>
<li><a href="http://markeditor.com/app/markeditor">MarkEditor正版</a></li>
<li><a href="http://www.pc6.com/mac/133223.html">Markdown for mac</a></li>
<li><a href="http://www.pc6.com/mac/141060.html">Markdown plus Mac版</a></li>
</ul>
</li>
<li>如果有些用 <code>Markdwon</code> 的语法却达不到预期效果（甚至产生奇怪的 <code>bugs</code>），或者用 <code>Markdwon</code> 的语法无法实现，这时就可以考虑用 <code>HTML</code> 和 <code>CSS</code></li>
</ul>
<h3 id="分隔线和空行"><a href="#分隔线和空行" class="headerlink" title="分隔线和空行"></a>分隔线和空行</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 分隔线 */</span></span><br><span class="line">&lt;hr /&gt;</span><br><span class="line"><span class="comment">/* 注意事项 [6]：在XHTML 中，&lt;hr&gt; 必须被正确地关闭，比如 &lt;hr /&gt; */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 空行 */</span></span><br><span class="line">&lt;br /&gt;</span><br><span class="line"><span class="comment">/* 注意事项同上 */</span></span><br></pre></td></tr></table></figure>

<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">&lt;blockquote&gt;引用内容&lt;/blockquote&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果前后间隙很小，可以像下面这样写 */</span></span><br><span class="line">&lt;p&gt;&lt;blockquote&gt;引用内容&lt;/blockquote&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<h3 id="居中和右对齐"><a href="#居中和右对齐" class="headerlink" title="居中和右对齐"></a>居中和右对齐</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 居中 */</span></span><br><span class="line">&lt;center&gt;内容&lt;/center&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 右对齐 */</span></span><br><span class="line">&lt;div style=<span class="string">&quot;text-align:right&quot;</span>&gt;内容&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h3 id="字体大小和颜色"><a href="#字体大小和颜色" class="headerlink" title="字体大小和颜色"></a>字体大小和颜色</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">&lt;font color=<span class="string">&quot;#xxxxxx&quot;</span> size=<span class="string">&quot;number&quot;</span>&gt;内容&lt;/font&gt;</span><br><span class="line"><span class="comment">/* 详细请查看 http://www.w3school.com.cn/tags/tag_font.asp */</span></span><br></pre></td></tr></table></figure>

<h3 id="Todo-list"><a href="#Todo-list" class="headerlink" title="Todo list"></a>Todo list</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li&gt;&lt;i <span class="keyword">class</span>=<span class="string">&quot;fa fa-check-square&quot;</span>&gt;&lt;/i&gt; 已完成&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;i <span class="keyword">class</span>=<span class="string">&quot;fa fa-square&quot;</span>&gt;&lt;/i&gt; 未完成&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>

<h2 id="好玩写作样式"><a href="#好玩写作样式" class="headerlink" title="好玩写作样式"></a>好玩写作样式</h2><ul>
<li>添加一些特殊的样式，可以增加文章的可读性</li>
<li>可以从样式中选几个自己觉得比较好的、经常会用的使用, 太多反而会适得其反</li>
</ul>
<h3 id="主题自带样式"><a href="#主题自带样式" class="headerlink" title="主题自带样式"></a>主题自带样式</h3><p>先看一段效果图</p>
<ol>
<li><i class="fa fa-pencil"></i> 支持 Markdown<br><i>Hexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。</i></li>
<li><i class="fa fa-cloud-upload"></i> 一件部署<br><i>只需一条指令即可部署到 Github Pages，或其他网站。</i></li>
<li><i class="fa fa-cog"></i> 丰富的插件<br><i>Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade，CoffeeScript。</i></li>
</ol>
<p>这是上述的源码:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> &lt;i <span class="keyword">class</span>=<span class="string">&quot;fa fa-pencil&quot;</span>&gt;&lt;/i&gt; 支持 Markdown</span><br><span class="line">&lt;i&gt;Hexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。&lt;/i&gt;</span><br><span class="line"><span class="number">2.</span> &lt;i <span class="keyword">class</span>=<span class="string">&quot;fa fa-cloud-upload&quot;</span>&gt;&lt;/i&gt; 一件部署</span><br><span class="line">&lt;i&gt;只需一条指令即可部署到 Github Pages，或其他网站。&lt;/i&gt;</span><br><span class="line"><span class="number">3.</span> &lt;i <span class="keyword">class</span>=<span class="string">&quot;fa fa-cog&quot;</span>&gt;&lt;/i&gt; 丰富的插件</span><br><span class="line">&lt;i&gt;Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade，CoffeeScript。&lt;/i&gt;</span><br></pre></td></tr></table></figure>

<p>采用的是 <a href="https://fontawesome.com/icons?from=io">Font Awesome</a> 的图标，下面给出一些简单的使用例子，更多请查看官网的 <a href="https://fontawesome.com/how-to-use/svg-with-js">使用示例</a></p>
<p>效果:</p>
<ul>
<li><i class="fa fa-pencil"></i> 铅笔</li>
<li><i class="fa fa-cloud-upload"></i> 上传</li>
<li><i class="fa fa-download"></i> 下载</li>
</ul>
<p>源码:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- &lt;i <span class="keyword">class</span>=<span class="string">&quot;fa fa-pencil&quot;</span>&gt;&lt;/i&gt; 铅笔</span><br><span class="line">- &lt;i <span class="keyword">class</span>=<span class="string">&quot;fa fa-cloud-upload&quot;</span>&gt;&lt;/i&gt; 上传</span><br><span class="line">- &lt;i <span class="keyword">class</span>=<span class="string">&quot;fa fa-download&quot;</span>&gt;&lt;/i&gt; 下载</span><br></pre></td></tr></table></figure>

<p>放大图效果:</p>
<ul>
<li><i class="fa fa-download"></i> 下载</li>
<li><i class="fa fa-download fa-lg"></i> 下载变大 33%</li>
<li><i class="fa fa-download fa-2x"></i> 下载两倍大</li>
</ul>
<p>源码:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- &lt;i <span class="keyword">class</span>=<span class="string">&quot;fa fa-download&quot;</span>&gt;&lt;/i&gt; 下载</span><br><span class="line">- &lt;i <span class="keyword">class</span>=<span class="string">&quot;fa fa-download fa-lg&quot;</span>&gt;&lt;/i&gt; 下载变大 <span class="number">33</span>%</span><br><span class="line">- &lt;i <span class="keyword">class</span>=<span class="string">&quot;fa fa-download fa-2x&quot;</span>&gt;&lt;/i&gt; 下载两倍大</span><br></pre></td></tr></table></figure>


<h3 id="代码块高亮"><a href="#代码块高亮" class="headerlink" title="代码块高亮"></a>代码块高亮</h3><p>主题自带样式 代码块高亮</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">```[language] [title] [url] [link-text]</span><br><span class="line"></span><br><span class="line">`代码`</span><br><span class="line"></span><br></pre></td></tr></table></figure>




<ul>
<li>[language] 是代码语言的名称，用来设置代码块颜色高亮，非必须；</li>
<li>[title] 是顶部左边的说明，非必须；</li>
<li>[url] 是顶部右边的超链接地址，非必须；</li>
<li>[link text] 如它的字面意思，超链接的名称，非必须。</li>
</ul>
<p>亲测这 4 项应该是根据空格来分隔，而不是[]，故请不要加[]。除非如果你想写后面两个，但不想写前面两个，那么就必须加[]了，要这样写：[] [] [url] [link text]。</p>
<p>首先关于代码块颜色高亮，高亮的模式可以在主题配置文件中设置：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Code Highlight theme</span></span><br><span class="line"><span class="comment"># Available value:</span></span><br><span class="line"><span class="comment">#    normal | night | night eighties | night blue | night bright</span></span><br><span class="line"><span class="comment"># https://github.com/chriskempson/tomorrow-theme</span></span><br><span class="line"></span><br><span class="line">highlight_theme: normal</span><br></pre></td></tr></table></figure>

<p>要颜色正确高亮，代码语言的名称肯定要写对，各种支持语言的名称可以查看<a href="https://almostover.ru/2016-07/hexo-highlight-code-styles/">这篇文章</a>。当然，如果你和我一样懒，可以在站点配置文件_config.yml中设置自动高亮：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">highlight:</span><br><span class="line">  enable: true</span><br><span class="line">  line_number: true</span><br><span class="line"># 代码自动高亮</span><br><span class="line"><span class="deletion">-  auto_detect: false</span></span><br><span class="line"><span class="addition">+  auto_detect: true</span></span><br></pre></td></tr></table></figure>


<ul>
<li>红色-和绿色+的样式也是一种语言，叫diff，所以你只需在 [language] 这写diff，然后在相应代码前面加上-和+就行了</li>
<li>不过默认的-是绿色，+是红色，与 GitHub 上相反</li>
</ul>
<h3 id="文本居中引用"><a href="#文本居中引用" class="headerlink" title="文本居中引用"></a>文本居中引用</h3><p>效果:</p>
<blockquote class="blockquote-center">
<p>我还年轻，<br>我渴望上路。<br>带着最初的激情，<br>追寻着最初的梦想，<br>感受着最初的体验，<br>我们上路吧!</p>

</blockquote>

<p>源码:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">&#123;% cq %&#125;</span><br><span class="line">我还年轻，</span><br><span class="line">我渴望上路。</span><br><span class="line">带着最初的激情，</span><br><span class="line">追寻着最初的梦想，</span><br><span class="line">感受着最初的体验，</span><br><span class="line">我们上路吧!</span><br><span class="line">&#123;% endcq %&#125;</span><br></pre></td></tr></table></figure>

<p>更多 NexT 主题自带的标签样式，请点击：<a href="http://theme-next.iissnan.com/tag-plugins.html">http://theme-next.iissnan.com/tag-plugins.html</a></p>
<h3 id="主题自带样式-note-标签"><a href="#主题自带样式-note-标签" class="headerlink" title="主题自带样式 note 标签"></a>主题自带样式 note 标签</h3><p>在主题配置文件<code>_config.yml</code>里有一个关于这个的配置，但官方文档没有提供 <code>HTML</code> 的使用方式，个人认为这种方式更简单，也不会产生一些奇怪的显示 <code>bugs</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"># Note tag (bs-callout).</span><br><span class="line">note:</span><br><span class="line">  # 风格</span><br><span class="line">  style: flat</span><br><span class="line">  # 要不要图标</span><br><span class="line">  icons: <span class="literal">true</span></span><br><span class="line">  # 圆角矩形</span><br><span class="line">  border_radius: <span class="number">3</span></span><br><span class="line">  light_bg_offset: <span class="number">0</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% note default %&#125;</span><br><span class="line">default 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary %&#125;</span><br><span class="line">primary 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success %&#125;</span><br><span class="line">success 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info %&#125;</span><br><span class="line">info 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning %&#125;</span><br><span class="line">warning 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger %&#125;</span><br><span class="line">danger 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>

<p>显示效果：</p>
<div class="note default"><p>default 提示块标签</p>
</div>

<div class="note primary"><p>primary 提示块标签</p>
</div>

<div class="note success"><p>success 提示块标签</p>
</div>

<div class="note info"><p>info 提示块标签</p>
</div>

<div class="note warning"><p>warning 提示块标签</p>
</div>

<div class="note danger"><p>danger 提示块标签</p>
</div>



<p>里面的三种风格长啥样？开启图标长啥样？可以查看 <a href="https://github.com/iissnan/hexo-theme-next/pull/1697">这个页面</a> ，更多的介绍也在这个页面，请自行查看</p>
<h3 id="主题自带样式-label-标签"><a href="#主题自带样式-label-标签" class="headerlink" title="主题自带样式 label 标签"></a>主题自带样式 label 标签</h3><p><code>label</code>标签不建议加载段首, 首先可以在主题配置文件中有配置，需要配置下</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"># Label tag.</span><br><span class="line">label: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>然后效果如下（@ 前面的是<code>label</code>的名字，后面的是要显示的文字）</p>
<mark class="label default">default</mark>

<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">&#123;% label <span class="keyword">default</span>@default %&#125;</span><br></pre></td></tr></table></figure>

<mark class="label primary">primary</mark>

<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">&#123;% label primary@primary %&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<mark class="label success">success</mark>

<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">&#123;% label success@success %&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<mark class="label info">info</mark>

<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">&#123;% label info@info %&#125;</span><br></pre></td></tr></table></figure>

<mark class="label warning">warning</mark>

<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">&#123;% label warning@warning %&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<mark class="label danger">danger</mark>

<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">&#123;% label danger@danger %&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="主题自带样式-tabs-标签"><a href="#主题自带样式-tabs-标签" class="headerlink" title="主题自带样式 tabs 标签"></a>主题自带样式 tabs 标签</h3><p>首先可以在主题配置文件中有配置，需要配置下</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"># Tabs tag.</span><br><span class="line">tabs:</span><br><span class="line">  enable: <span class="literal">true</span></span><br><span class="line">  transition:</span><br><span class="line">    tabs: <span class="literal">true</span></span><br><span class="line">    labels: <span class="literal">true</span></span><br><span class="line">  border_radius: <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>效果：</p>
<div class="tabs" id="选项卡"><ul class="nav-tabs"><li class="tab"><a href="#选项卡-1">选项卡 1</a></li><li class="tab active"><a href="#选项卡-2">选项卡 2</a></li><li class="tab"><a href="#选项卡-3">选项卡 3</a></li></ul><div class="tab-content"><div class="tab-pane" id="选项卡-1"><p><strong>这是选项卡 1</strong> 呵呵哈哈哈哈哈哈哈哈呵呵哈哈哈哈哈哈哈哈呵呵哈哈哈哈哈哈哈哈呵呵哈哈哈哈哈哈哈哈呵呵哈哈哈哈哈哈哈哈呵呵哈哈哈哈哈哈哈哈……</p></div><div class="tab-pane active" id="选项卡-2"><p><strong>这是选项卡 2</strong></p></div><div class="tab-pane" id="选项卡-3"><p><strong>这是选项卡 3</strong> 哇，你找到我了！φ(≧ω≦*)♪～</p></div></div></div>

<p>源码:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">&#123;% tabs 选项卡, <span class="number">2</span> %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line">**这是选项卡 <span class="number">1</span>** 呵呵哈哈哈哈哈哈哈哈呵呵哈哈哈哈哈哈哈哈呵呵哈哈哈哈哈哈哈哈呵呵哈哈哈哈哈哈哈哈呵呵哈哈哈哈哈哈哈哈呵呵哈哈哈哈哈哈哈哈……</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line">**这是选项卡 <span class="number">2</span>**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line">**这是选项卡 <span class="number">3</span>** 哇，你找到我了！φ(≧ω≦*)♪～</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure>

<p>然后上面源码中, 2表示一开始在第二个选项卡，非必须，若数值为-1则隐藏选项卡内容</p>
<h3 id="主题自带样式-按钮"><a href="#主题自带样式-按钮" class="headerlink" title="主题自带样式 按钮"></a>主题自带样式 按钮</h3><p>效果: <a class="btn" href="https://www.titanjun.top"><i class="fa fa-download fa-lg fa-fw"></i>点击下载百度</a></p>
<p>源码:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">&#123;% btn https:<span class="comment">//www.baidu.com, 点击下载百度, download fa-lg fa-fw %&#125;</span></span><br></pre></td></tr></table></figure>

<p>关于按钮的更多使用可以前往 <a href="https://almostover.ru/2016-01/hexo-theme-next-test/#Button-tag-test">这个页面</a> 查看。</p>
<h3 id="自定义样式-引用"><a href="#自定义样式-引用" class="headerlink" title="自定义样式 引用"></a>自定义样式 引用</h3><p>首先由于是自定义的样式，故要自己将 CSS 代码加到custom.styl中</p>
<p>需加入<code>custom.styl</code>的代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义的引用样式</span></span><br><span class="line">blockquote.question &#123;</span><br><span class="line">    color: #<span class="number">555</span>;</span><br><span class="line">    border-left: <span class="number">4</span>px solid rgb(<span class="number">16</span>, <span class="number">152</span>, <span class="number">173</span>);</span><br><span class="line">    background-color: rgb(<span class="number">227</span>, <span class="number">242</span>, <span class="number">253</span>);</span><br><span class="line">    border-top-right-radius: <span class="number">3</span>px;</span><br><span class="line">    border-bottom-right-radius: <span class="number">3</span>px;</span><br><span class="line">    margin-bottom: <span class="number">20</span>px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>文字颜色改<code>color</code>的值</li>
<li>背景色改<code>background-color</code>的值</li>
<li>边框颜色和粗细改<code>border-left</code>的值</li>
</ul>
<p>使用:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">&lt;blockquote <span class="keyword">class</span>=<span class="string">&quot;question&quot;</span>&gt;内容&lt;/blockquote&gt;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h3><ul>
<li>文章中所有内容均摘自大佬的文章, 想看原文的朋友可参考</li>
<li><a href="https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html">https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html</a></li>
</ul>
]]></content>
      <categories>
        <category>Hexo博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title>NexT主题配置个性化设置</title>
    <url>/post/9eda55ce.html</url>
    <content><![CDATA[<ul>
<li>最近基于<code>NexT</code>主题重新搭建了自己的<a href="https://www.titanjun.top/">个人技术博客</a>, 现在主要是总结分享关于<code>NexT(8.12.2)</code>主题的相关配置和优化</li>
<li>我现在用的是<code>NexT</code>主题, 这是作者提供的<a href="http://theme-next.iissnan.com/">NexT主题中文配置</a></li>
</ul>
<span id="more"></span>



<h2 id="NexT常规配置"><a href="#NexT常规配置" class="headerlink" title="NexT常规配置"></a><code>NexT</code>常规配置</h2><h3 id="PDF-显示"><a href="#PDF-显示" class="headerlink" title="PDF 显示"></a>PDF 显示</h3><p><code>NexT</code>默认支持<code>PDF</code>自定义标签, 更改<code>NexT</code>主题的配置文件 <code>themes/next/_config.yml</code>，修改以下配置，详见<a href="https://github.com/next-theme/theme-next-pdf">官方文档</a></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">pdf:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Default height</span></span><br><span class="line">  <span class="attr">height:</span> <span class="string">550px</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>使用格式为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% pdf https://www.titanjun.top/test.pdf %&#125;</span><br></pre></td></tr></table></figure>


<h3 id="首页头像"><a href="#首页头像" class="headerlink" title="首页头像"></a>首页头像</h3><p>更改<code>NexT</code>主题的配置文件<code>themes/next/_config.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">/images/avatar.png</span>      <span class="comment"># 头像图片</span></span><br><span class="line">  <span class="attr">rounded:</span> <span class="literal">true</span>                <span class="comment"># 头像显示在圆里</span></span><br><span class="line">  <span class="attr">rotated:</span> <span class="literal">true</span>                <span class="comment"># 鼠标焦点落在头像时，是否转动头像</span></span><br></pre></td></tr></table></figure>


<h3 id="菜单显示中文"><a href="#菜单显示中文" class="headerlink" title="菜单显示中文"></a>菜单显示中文</h3><p>在博客的根目录里，找到<code>_config.yml</code>文件，然后设置以下的配置项，需要注意，这里的字体是 <code>zh-CN</code>，而不是<code>zh-Hans</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">language: zh-CN</span><br></pre></td></tr></table></figure>


<h3 id="启用文章目录"><a href="#启用文章目录" class="headerlink" title="启用文章目录"></a>启用文章目录</h3><p>更改<code>NexT</code>主题的配置文件<code>themes/next/_config.yml</code>，设置以下内容</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">toc:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">number:</span> <span class="literal">false</span>           <span class="comment"># 自动添加目录编号</span></span><br><span class="line">  <span class="attr">wrap:</span> <span class="literal">true</span>              <span class="comment"># 每行目录字数超长自动换行</span></span><br><span class="line">  <span class="attr">expand_all:</span> <span class="literal">true</span>        <span class="comment"># 展开所有级别</span></span><br><span class="line">  <span class="attr">max_depth:</span> <span class="number">5</span>            <span class="comment"># 目录的最大深度</span></span><br></pre></td></tr></table></figure>


<h3 id="设置右上角Github图标"><a href="#设置右上角Github图标" class="headerlink" title="设置右上角Github图标"></a>设置右上角<code>Github</code>图标</h3><p>主题的配置文件<code>themes/next/_config.yml</code>，设置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">github_banner:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">permalink:</span> <span class="string">https://https://github.com/CoderTitan</span></span><br><span class="line">  <span class="attr">title:</span> <span class="string">Follow</span> <span class="string">me</span> <span class="string">on</span> <span class="string">GitHub</span></span><br></pre></td></tr></table></figure>


<h3 id="修改上下篇文章顺序"><a href="#修改上下篇文章顺序" class="headerlink" title="修改上下篇文章顺序"></a>修改上下篇文章顺序</h3><p>在<code>NexT</code>主题中文章底部，有上下篇文章的链接, 默认的上一篇实在右侧, 下一篇是在左侧, 有点不太符合我们的阅读习惯, 可在主题的配置文件<code>themes/next/_config.yml</code>中修改</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Show previous post and next post in post footer if exists</span></span><br><span class="line"><span class="comment"># Available values: left | right | false</span></span><br><span class="line"><span class="comment"># left: 上一篇在右, 下一篇在左</span></span><br><span class="line"><span class="comment"># right: 上一篇在左, 下一篇在右</span></span><br><span class="line"><span class="comment"># false: 不显示</span></span><br><span class="line"><span class="attr">post_navigation:</span> <span class="string">right</span></span><br></pre></td></tr></table></figure>


<h3 id="设置侧栏阅读进度百分比"><a href="#设置侧栏阅读进度百分比" class="headerlink" title="设置侧栏阅读进度百分比"></a>设置侧栏阅读进度百分比</h3><p>主题的配置文件<code>themes/next/_config.yml</code>，设置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">back2top:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 是否显示在边栏</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="literal">true</span>  </span><br><span class="line">  <span class="comment"># 点击是否回到顶部</span></span><br><span class="line">  <span class="attr">scrollpercent:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="配置hexo站点的footer信息"><a href="#配置hexo站点的footer信息" class="headerlink" title="配置hexo站点的footer信息"></a>配置<code>hexo</code>站点的<code>footer</code>信息</h3><ul>
<li>底部<code>footer</code>可以开关显示<code>hexo</code>信息、<code>theme</code>信息、建站时间等个性化配置：</li>
<li>主题的配置文件<code>themes/next/_config.yml</code>，设置</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="attr">since:</span> <span class="number">2018</span>        <span class="comment"># 建站开始时间</span></span><br><span class="line">  <span class="attr">icon:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">user</span>       <span class="comment"># 设置 建站初始时间和至今时间中间的图标，默认是一个&#x27;小人像&#x27;，更改user为heart可以变成一个心</span></span><br><span class="line">    <span class="attr">animated:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">color:</span> <span class="string">&quot;#808080&quot;</span> <span class="comment"># 更改图标的颜色，红色为&#x27;#ff0000&#x27;</span></span><br><span class="line">  <span class="attr">powered:</span> <span class="literal">true</span>      <span class="comment"># 开启hexo驱动</span></span><br></pre></td></tr></table></figure>



<h3 id="启用文章打赏"><a href="#启用文章打赏" class="headerlink" title="启用文章打赏"></a>启用文章打赏</h3><p>主题的配置文件<code>themes/next/_config.yml</code>，设置以下内容，<code>themes/next/source/images</code> 文件夹下，图片目录路径也可自定义</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">reward_settings:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">animation:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">comment:</span> <span class="string">坚持原创技术分享，您的支持将鼓励我继续创作！</span></span><br><span class="line"></span><br><span class="line"><span class="attr">reward:</span></span><br><span class="line">  <span class="attr">wechatpay:</span> <span class="string">/images/wechatpay.png</span></span><br><span class="line">  <span class="attr">alipay:</span> <span class="string">/images/alipay.png</span></span><br></pre></td></tr></table></figure>


<h3 id="添加版权声明"><a href="#添加版权声明" class="headerlink" title="添加版权声明"></a>添加版权声明</h3><p>主题的配置文件<code>themes/next/_config.yml</code>，设置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">creative_commons:</span></span><br><span class="line">  <span class="attr">license:</span> <span class="string">by-nc-sa</span>       <span class="comment"># License类型： by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zero</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="literal">false</span>          <span class="comment"># 在侧边栏有一个版权的图片链接</span></span><br><span class="line">  <span class="attr">post:</span> <span class="literal">true</span>              <span class="comment"># 在每一篇文章末尾自动增加本文作者、本文链接、版权声明信息</span></span><br><span class="line">  <span class="attr">language:</span> <span class="string">deed.zh</span>       <span class="comment"># 点击链接后显示的版权信息的语言</span></span><br></pre></td></tr></table></figure>

<h3 id="添加标签-x2F-分类页面"><a href="#添加标签-x2F-分类页面" class="headerlink" title="添加标签&#x2F;分类页面"></a>添加标签&#x2F;分类页面</h3><p>主题的配置文件<code>themes/next/_config.yml</code>，设置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-archive</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-th</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-tags</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-user</span></span><br><span class="line">  <span class="comment">#schedule: /schedule/ || fa fa-calendar</span></span><br><span class="line">  <span class="comment">#commonweal: /404/ || fa fa-heartbeat</span></span><br><span class="line">  <span class="comment"># search: /search/ || fa fa-globe</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Enable / Disable menu icons / item badges.</span></span><br><span class="line"><span class="attr">menu_settings:</span></span><br><span class="line">  <span class="comment"># 是否显示各个页面的图标</span></span><br><span class="line">  <span class="attr">icons:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 是否显示分类/标签/归档页的内容量</span></span><br><span class="line">  <span class="attr">badges:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>


<p>通过<code>Hexo</code>创建一个标签&#x2F;分类&#x2F;关于页面</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入博客的根目录</span></span><br><span class="line"><span class="string">$</span> <span class="string">cd</span> <span class="string">blog</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建标签页</span></span><br><span class="line"><span class="string">$</span> <span class="string">hexo</span> <span class="string">new</span> <span class="string">page</span> <span class="string">&quot;about&quot;</span></span><br><span class="line"><span class="string">$</span> <span class="string">hexo</span> <span class="string">new</span> <span class="string">page</span> <span class="string">&quot;tags&quot;</span></span><br><span class="line"><span class="string">$</span> <span class="string">hexo</span> <span class="string">new</span> <span class="string">page</span> <span class="string">&quot;categories&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上命令执行完毕后，在根目录<code>source</code>文件夹下会多了如下文件</p>
<ul>
<li><code>tags/index.md</code></li>
<li><code>categories\index.md</code></li>
<li><code>about\index.md</code></li>
</ul>
<p>在对应的文件下分别添加对应内容, 必须使用<code>---</code>包裹配置内容，否则配置无效</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># tags/index.md</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">关于</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">&quot;about&quot;</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="comment"># about\index.md</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">标签</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">&quot;tags&quot;</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="comment"># categories\index.md</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">分类</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">&quot;categories&quot;</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>


<h3 id="启用不蒜子统计"><a href="#启用不蒜子统计" class="headerlink" title="启用不蒜子统计"></a>启用不蒜子统计</h3><p>主题的配置文件<code>themes/next/_config.yml</code>，设置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Show Views / Visitors of the website / page with busuanzi.</span></span><br><span class="line"><span class="comment"># For more information: http://ibruce.info/2015/04/04/busuanzi/</span></span><br><span class="line"><span class="attr">busuanzi_count:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_visitors:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_visitors_icon:</span> <span class="string">fa</span> <span class="string">fa-user</span></span><br><span class="line">  <span class="attr">total_views:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_views_icon:</span> <span class="string">fa</span> <span class="string">fa-eye</span></span><br><span class="line">  <span class="attr">post_views:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">post_views_icon:</span> <span class="string">far</span> <span class="string">fa-eye</span></span><br></pre></td></tr></table></figure>


<h3 id="修改网站底部图标"><a href="#修改网站底部图标" class="headerlink" title="修改网站底部图标"></a>修改网站底部图标</h3><p>主题的配置文件<code>themes/next/_config.yml</code>，设置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">icon:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">fa</span> <span class="string">fa-heart</span> </span><br><span class="line">    <span class="attr">animated:</span> <span class="literal">true</span> </span><br><span class="line">    <span class="attr">color:</span> <span class="string">&quot;#ff0000&quot;</span></span><br></pre></td></tr></table></figure>


<h3 id="网站底部添加备案信息"><a href="#网站底部添加备案信息" class="headerlink" title="网站底部添加备案信息"></a>网站底部添加备案信息</h3><p>主题的配置文件<code>themes/next/_config.yml</code>，设置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">beian:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">icp:</span> <span class="string">&#x27;备案号&#x27;</span></span><br></pre></td></tr></table></figure>


<h3 id="文章评分功能"><a href="#文章评分功能" class="headerlink" title="文章评分功能"></a>文章评分功能</h3><p><code>NexT</code>主题中已经集成了<code>widgetpack</code> 的星级评分系统，用户无须再安装或引入插件脚本，只需在 <a href="https://widgetpack.com/">widgetpack</a>中注册账号并修改主题配置即可</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Star rating support to each article.</span></span><br><span class="line"><span class="comment"># To get your ID visit https://widgetpack.com</span></span><br><span class="line"><span class="attr">rating:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">id:</span> <span class="comment">#&lt;app_id&gt;</span></span><br><span class="line">  <span class="attr">color:</span> <span class="comment">#f79533</span></span><br></pre></td></tr></table></figure>

<p>在控制台中点击左上角展开菜单，在<code>Rating</code> -&gt; <code>Setting</code>中将 <code>Vote via</code>选项改为<code>Device(cookie)</code>以开启匿名评分，该选项将基于设备认证访问者身份，如果不开启这个选项，那么就需要登录才能评分</p>
<h2 id="NexT高级配置"><a href="#NexT高级配置" class="headerlink" title="NexT高级配置"></a><code>NexT</code>高级配置</h2><h3 id="添加站内搜索"><a href="#添加站内搜索" class="headerlink" title="添加站内搜索"></a>添加站内搜索</h3><p><code>NexT</code>主题默认支持使用 <a href="https://github.com/theme-next/hexo-generator-searchdb">Hexo-Generator-Searchdb</a> 插件来实现本地搜索</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入博客的根目录</span></span><br><span class="line"><span class="string">cd</span> <span class="string">blog_rooot</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装搜索插件</span></span><br><span class="line"><span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-generator-searchdb</span> <span class="string">--save</span></span><br></pre></td></tr></table></figure>


<p>根目录配置文件<code>/_config.yml</code>，设置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">content:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">100</span></span><br></pre></td></tr></table></figure>


<p>主题的配置文件<code>themes/next/_config.yml</code>，设置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># auto /  manual，auto 自动搜索、manual：按回车[enter ]键手动搜索</span></span><br><span class="line">  <span class="attr">trigger:</span> <span class="string">auto</span></span><br><span class="line">  <span class="attr">top_n_per_article:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">unescape:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">preload:</span> <span class="literal">false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="添加RSS"><a href="#添加RSS" class="headerlink" title="添加RSS"></a>添加RSS</h3><p><code>NexT</code>主题默认支持<code>RSS</code>订阅, 安装插件<a href="https://github.com/hexojs/hexo-generator-feed">hexo-generator-feed</a></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入博客的根目录</span></span><br><span class="line"><span class="string">cd</span> <span class="string">blog_rooot</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装RSS插件</span></span><br><span class="line"><span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-generator-feed</span> <span class="string">--save</span></span><br></pre></td></tr></table></figure>


<p>根目录配置文件<code>/_config.yml</code>，设置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feed:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">atom</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">atom.xml</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">20</span></span><br><span class="line">  <span class="attr">hub:</span></span><br><span class="line">  <span class="attr">content:</span></span><br><span class="line">  <span class="attr">content_limit:</span> <span class="number">140</span></span><br><span class="line">  <span class="attr">content_limit_delim:</span> <span class="string">&#x27; &#x27;</span></span><br><span class="line">  <span class="attr">order_by:</span> <span class="string">-date</span></span><br><span class="line">  <span class="attr">icon:</span> <span class="string">icon.png</span></span><br><span class="line">  <span class="attr">autodiscovery:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">template:</span></span><br></pre></td></tr></table></figure>


<p>主题的配置文件<code>themes/next/_config.yml</code>，设置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="attr">RSS:</span> <span class="string">/atom.xml</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-rss</span></span><br></pre></td></tr></table></figure>

<h3 id="设置博客文章永久链接"><a href="#设置博客文章永久链接" class="headerlink" title="设置博客文章永久链接"></a>设置博客文章永久链接</h3><ul>
<li><code>hexo</code>的默认永久链接是在<code>_config.yml</code>里配置的，其生成默认规则是<code>permalink: :year/:month/:day/:title/</code>，是按照年、月、日、标题来生成的。</li>
<li>这种默认配置有个很不能接受的缺点，当文件名为中文时，会导致<code>url</code>链接中也出现中文, 复制后的链接会编码，非常不利于阅读，也不简洁。</li>
<li><a href="https://github.com/rozbo/hexo-abbrlink">hexo-abbrlink</a>支持使用不同的算法和进制生成文章的永久链接</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入博客的根目录</span></span><br><span class="line"><span class="string">cd</span> <span class="string">blog_rooot</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装abbrlink插件</span></span><br><span class="line"><span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-abbrlink</span> <span class="string">--save</span></span><br></pre></td></tr></table></figure>


<p>根目录配置文件<code>/_config.yml</code>，设置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#文章的永久链接, 如：http://localhost:4000/post/abaf7e89.html</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">post/:abbrlink.html</span></span><br><span class="line"><span class="attr">abbrlink:</span></span><br><span class="line">  <span class="attr">alg:</span> <span class="string">crc32</span>  <span class="comment"># 算法：crc16(default) and crc32</span></span><br><span class="line">  <span class="attr">rep:</span> <span class="string">hex</span>    <span class="comment"># 进制：dec(default) and hex</span></span><br></pre></td></tr></table></figure>


<p>生成的链接将会是这样的(官方样例)：</p>
<table>
<thead>
<tr>
<th>算法</th>
<th>进制</th>
<th>生成链接样例</th>
</tr>
</thead>
<tbody><tr>
<td>crc16</td>
<td>hex</td>
<td><a href="https://post.zz173.com/posts/66c8.html">https://post.zz173.com/posts/66c8.html</a></td>
</tr>
<tr>
<td>crc16</td>
<td>dec</td>
<td><a href="https://post.zz173.com/posts/65535.html">https://post.zz173.com/posts/65535.html</a></td>
</tr>
<tr>
<td>crc32</td>
<td>hex</td>
<td><a href="https://post.zz173.com/posts/8ddf18fb.html">https://post.zz173.com/posts/8ddf18fb.html</a></td>
</tr>
<tr>
<td>crc32</td>
<td>dec</td>
<td><a href="https://post.zz173.com/posts/1690090958.html">https://post.zz173.com/posts/1690090958.html</a></td>
</tr>
</tbody></table>
<p>安装完成后, 执行<code>hexo clean &amp; hexo g &amp; hexo s</code>查看效果</p>
<h3 id="字数与阅读时长统计"><a href="#字数与阅读时长统计" class="headerlink" title="字数与阅读时长统计"></a>字数与阅读时长统计</h3><p><code>NexT</code>主题默认支持使用 <a href="https://github.com/theme-next/hexo-symbols-count-time">hexo-symbols-count-time</a> 插件来统计文章字数和阅读时长</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入博客的根目录</span></span><br><span class="line"><span class="string">cd</span> <span class="string">blog_rooot</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装hexo-symbols-count-time插件</span></span><br><span class="line"><span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-symbols-count-time</span> <span class="string">--save</span></span><br></pre></td></tr></table></figure>


<p>根目录配置文件<code>/_config.yml</code>，设置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">time:</span> <span class="literal">true</span>                   <span class="comment"># 文章阅读时长</span></span><br><span class="line">  <span class="attr">symbols:</span> <span class="literal">true</span>                <span class="comment"># 文章字数统计</span></span><br><span class="line">  <span class="attr">total_time:</span> <span class="literal">true</span>             <span class="comment"># 站点总阅读时长</span></span><br><span class="line">  <span class="attr">total_symbols:</span> <span class="literal">true</span>          <span class="comment"># 站点总字数统计</span></span><br><span class="line">  <span class="attr">exclude_codeblock:</span> <span class="literal">true</span>      <span class="comment"># 排除代码字数统计</span></span><br></pre></td></tr></table></figure>

<p>主题的配置文件<code>themes/next/_config.yml</code>，设置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">separated_meta:</span> <span class="literal">false</span>         <span class="comment"># 是否另起一行显示（即不和发表时间等同一行显示）</span></span><br><span class="line">  <span class="attr">item_text_post:</span> <span class="literal">true</span>          <span class="comment"># 首页文章统计数量前是否显示文字描述（本文字数、阅读时长）</span></span><br><span class="line">  <span class="attr">item_text_total:</span> <span class="literal">false</span>        <span class="comment"># 页面底部统计数量前是否显示文字描述（站点总字数、站点阅读时长）</span></span><br></pre></td></tr></table></figure>


<h3 id="添加标签云"><a href="#添加标签云" class="headerlink" title="添加标签云"></a>添加标签云</h3><p><a href="https://github.com/D0n9X1n/hexo-tag-cloud">hexo-tag-cloud</a>标签云插件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入博客的根目录</span></span><br><span class="line"><span class="string">cd</span> <span class="string">blog_rooot</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装hexo-tag-cloud插件</span></span><br><span class="line"><span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-tag-cloud</span> <span class="string">--save</span></span><br></pre></td></tr></table></figure>

<p>根目录配置文件<code>/_config.yml</code>，设置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># hexo-tag-cloud</span></span><br><span class="line"><span class="attr">tag_cloud:</span></span><br><span class="line">  <span class="attr">textFont:</span> <span class="string">Trebuchet</span> <span class="string">MS,</span> <span class="string">Helvetica</span></span><br><span class="line">  <span class="attr">textColor:</span> <span class="string">&#x27;#333&#x27;</span></span><br><span class="line">  <span class="attr">textHeight:</span> <span class="number">16</span></span><br><span class="line">  <span class="attr">outlineColor:</span> <span class="string">&#x27;#E2E1D1&#x27;</span></span><br><span class="line">  <span class="attr">maxSpeed:</span> <span class="number">0.3</span></span><br><span class="line">  <span class="attr">pauseOnSelected:</span> <span class="literal">false</span> <span class="comment"># true 意味着当选中对应 tag 时,停止转动</span></span><br></pre></td></tr></table></figure>

<p>更改 <code>NexT</code> 主题的源文件 <code>themes/next/layout/_macro/sidebar.njk</code>, 然后在最后添加如下内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% if site.tags.length &gt; 1 %&#125;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;/js/tagcloud.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;/js/tagcanvas.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;div class=&quot;widget-wrap&quot;&gt;</span><br><span class="line">    &lt;h3 class=&quot;widget-title&quot;&gt;标签云&lt;/h3&gt;</span><br><span class="line">    &lt;div id=&quot;myCanvasContainer&quot; class=&quot;widget tagcloud&quot;&gt;</span><br><span class="line">        &lt;canvas width=&quot;250&quot; height=&quot;250&quot; id=&quot;resCanvas&quot; style=&quot;width=100%&quot;&gt;</span><br><span class="line">            &#123;&#123; list_tags() &#125;&#125;</span><br><span class="line">        &lt;/canvas&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>完成安装和显示，可以通过 <code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</code> 来进行本地预览, <code>hexo clean</code> 为必须选项。</li>
<li>PS:不要使用 <code>hexo g -d</code> 或者 <code>hexo d -g</code> 这类组合命令</li>
</ul>
<h3 id="添加豆瓣个人主页"><a href="#添加豆瓣个人主页" class="headerlink" title="添加豆瓣个人主页"></a>添加豆瓣个人主页</h3><p><a href="https://github.com/mythsman/hexo-douban">hexo-douban</a>插件支持在 <code>Hexo</code> 页面中嵌入豆瓣个人主页</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入博客的根目录</span></span><br><span class="line"><span class="string">cd</span> <span class="string">blog_rooot</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装</span></span><br><span class="line"><span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-douban</span> <span class="string">--save</span></span><br></pre></td></tr></table></figure>

<p>根目录配置文件<code>/_config.yml</code>，设置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">douban:</span></span><br><span class="line">  <span class="attr">user:</span> <span class="string">mythsman</span></span><br><span class="line">  <span class="attr">builtin:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">book:</span></span><br><span class="line">    <span class="attr">title:</span> <span class="string">&#x27;This is my book title&#x27;</span></span><br><span class="line">    <span class="attr">quote:</span> <span class="string">&#x27;This is my book quote&#x27;</span></span><br><span class="line">  <span class="attr">movie:</span></span><br><span class="line">    <span class="attr">title:</span> <span class="string">&#x27;This is my movie title&#x27;</span></span><br><span class="line">    <span class="attr">quote:</span> <span class="string">&#x27;This is my movie quote&#x27;</span></span><br><span class="line">  <span class="attr">game:</span></span><br><span class="line">    <span class="attr">title:</span> <span class="string">&#x27;This is my game title&#x27;</span></span><br><span class="line">    <span class="attr">quote:</span> <span class="string">&#x27;This is my game quote&#x27;</span></span><br><span class="line">  <span class="attr">timeout:</span> <span class="number">10000</span> </span><br></pre></td></tr></table></figure>

<ul>
<li>user: 你的豆瓣ID.打开豆瓣，登入账户，然后在右上角点击 “个人主页” ，这时候地址栏的URL大概是这样：”<a href="https://www.douban.com/people/xxxxxx/&quot;">https://www.douban.com/people/xxxxxx/&quot;</a> ，其中的”xxxxxx”就是你的个人ID了。</li>
<li>builtin: 是否将生成页面的功能嵌入hexo s和hexo g中，默认是false,另一可选项为true(1.x.x版本新增配置项)。</li>
<li>title: 该页面的标题.</li>
<li>quote: 写在页面开头的一段话,支持html语法.</li>
<li>timeout: 爬取数据的超时时间，默认是 10000ms ,如果在使用时发现报了超时的错(ETIMEOUT)可以把这个数据设置的大一点。</li>
<li>如果只想显示某一个页面(比如movie)，那就把其他的配置项注释掉即可。</li>
</ul>
<h3 id="启用sitemap功能"><a href="#启用sitemap功能" class="headerlink" title="启用sitemap功能"></a>启用sitemap功能</h3><p>为了让博文被<code>google</code>或百度检索，需要使用<code>hexo</code>的<code>sitemap</code>功能</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入博客的根目录</span></span><br><span class="line"><span class="string">cd</span> <span class="string">blog_rooot</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装</span></span><br><span class="line"><span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-generator-sitemap</span> <span class="string">--save</span></span><br><span class="line"><span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-generator-baidu-sitemap</span> <span class="string">--save</span></span><br></pre></td></tr></table></figure>

<p>修改主题的配置文件<code>themes/next/_config.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">sitemap:</span> <span class="string">/sitemap.xml</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-sitemap</span></span><br></pre></td></tr></table></figure>

<ul>
<li>执行<code>hexo clean &amp; hexo g</code>命令后即可访问站点地图</li>
<li>在<code>public</code>的静态文件根目录中会多出一个<code>sitemap.xml</code>文件，表示谷歌检索的<code>sitemap</code>安装成功</li>
</ul>
<h2 id="NexT进阶设置"><a href="#NexT进阶设置" class="headerlink" title="NexT进阶设置"></a><code>NexT</code>进阶设置</h2><h3 id="启用Canvas-Ribbon背景"><a href="#启用Canvas-Ribbon背景" class="headerlink" title="启用Canvas Ribbon背景"></a>启用<code>Canvas Ribbon</code>背景</h3><p><code>NexT</code>主题默认支持<code>Canvas Ribbon</code>背景，官方配置教程可以看<a href="https://github.com/theme-next/theme-next-canvas-ribbon">这里</a>，前提是需要下载指定的静态资源文件或者使用<code>CDN</code>静态资源文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 进入Next主题的目录</span><br><span class="line">cd themes/next</span><br><span class="line"></span><br><span class="line"># # 下载Canvas资源文件</span><br><span class="line">git clone https://github.com/theme-next/theme-next-canvas-ribbon source/lib/canvas-ribbon</span><br></pre></td></tr></table></figure>

<p>或者更改主题的配置文件<code>themes/next/_config.yml</code>，通过以下配置内容来指定<code>CDN</code>静态资源文件的<code>URL</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">vendors:</span></span><br><span class="line">  <span class="attr">canvas_ribbon:</span> <span class="string">//cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-ribbon@1/canvas-ribbon.js</span></span><br></pre></td></tr></table></figure>

<p>主题的配置文件<code>themes/next/_config.yml</code>，设置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">canvas_ribbon:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">size:</span> <span class="number">300</span>           <span class="comment"># Ribbon的宽度</span></span><br><span class="line">  <span class="attr">alpha:</span> <span class="number">0.6</span>          <span class="comment"># Ribbon的透明度</span></span><br><span class="line">  <span class="attr">zIndex:</span> <span class="number">-1</span>          <span class="comment"># Ribbon的显示级别</span></span><br></pre></td></tr></table></figure>


<h3 id="启用背景3D动画"><a href="#启用背景3D动画" class="headerlink" title="启用背景3D动画"></a>启用背景<code>3D</code>动画</h3><p><code>NexT</code>主题默认支持背景<code>3D</code>动画，官方配置教程可以看<a href="https://github.com/theme-next/theme-next-three">这里</a>，前提是需要下载指定的静态资源文件或者使用<code>CDN</code>静态资源文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 进入Next主题的目录</span><br><span class="line">cd themes/next</span><br><span class="line"></span><br><span class="line"># 下载3D资源文件</span><br><span class="line">git clone https://github.com/theme-next/theme-next-three source/lib/three</span><br></pre></td></tr></table></figure>

<p>或者更改主题的配置文件<code>themes/next/_config.yml</code>，通过以下配置内容来指定<code>CDN</code>静态资源文件的<code>URL</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">vendors:</span></span><br><span class="line">  <span class="attr">three:</span> <span class="string">//cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/three.min.js</span></span><br><span class="line">  <span class="attr">three_waves:</span> <span class="string">//cdn.jsdelivr.net/gh/theme-next/theme-next-three@latest/three-waves.min.js</span></span><br><span class="line">  <span class="attr">canvas_lines:</span> <span class="string">//cdn.jsdelivr.net/gh/theme-next/theme-next-three@latest/canvas_lines.min.js</span></span><br><span class="line">  <span class="attr">canvas_sphere:</span> <span class="string">//cdn.jsdelivr.net/gh/theme-next/theme-next-three@latest/canvas_sphere.min.js</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>主题的配置文件<code>themes/next/_config.yml</code>，设置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">three:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">three_waves:</span> <span class="literal">true</span>           <span class="comment"># 背景3D动画样式一</span></span><br><span class="line">  <span class="attr">canvas_lines:</span> <span class="literal">false</span>         <span class="comment"># 背景3D动画样式二</span></span><br><span class="line">  <span class="attr">canvas_sphere:</span> <span class="literal">false</span>        <span class="comment"># 背景3D动画样式三</span></span><br></pre></td></tr></table></figure>

<h3 id="启用Pjax"><a href="#启用Pjax" class="headerlink" title="启用Pjax"></a>启用<code>Pjax</code></h3><p><code>Pjax</code>主要用于加速<code>Web</code>页面的切换速度，同时也可以用来解决<code>Aplayer</code>音频播发器切换页面后播放出现中断的问题</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 进入Next主题的目录</span><br><span class="line">cd themes/next</span><br><span class="line"></span><br><span class="line"># 下载资源文件</span><br><span class="line">git clone https://github.com/theme-next/theme-next-pjax source/lib/pjax</span><br></pre></td></tr></table></figure>

<p>主题的配置文件<code>themes/next/_config.yml</code>，设置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pjax: true</span><br></pre></td></tr></table></figure>


<h3 id="添加顶部加载进度条"><a href="#添加顶部加载进度条" class="headerlink" title="添加顶部加载进度条"></a>添加顶部加载进度条</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 进入Next主题的目录</span><br><span class="line">cd themes/next</span><br><span class="line"></span><br><span class="line"># 下载资源文件</span><br><span class="line">git clone https://github.com/theme-next/theme-next-pace source/lib/pace</span><br></pre></td></tr></table></figure>

<p>主题的配置文件<code>themes/next/_config.yml</code>，设置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pace:</span><br><span class="line">  enable: true</span><br><span class="line">  theme: minimal</span><br></pre></td></tr></table></figure>


<h3 id="添加页面顶部阅读进度条"><a href="#添加页面顶部阅读进度条" class="headerlink" title="添加页面顶部阅读进度条"></a>添加页面顶部阅读进度条</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 进入Next主题的目录</span><br><span class="line">cd themes/next</span><br><span class="line"></span><br><span class="line"># 下载资源文件</span><br><span class="line">git clone https://github.com/theme-next/theme-next-reading-progress source/lib/reading_progress</span><br></pre></td></tr></table></figure>

<p>主题的配置文件<code>themes/next/_config.yml</code>，设置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reading_progress:</span><br><span class="line">  enable: true</span><br><span class="line">  position: top               # 进度条的位置：top | bottom</span><br><span class="line">  color: &quot;#37c6c0&quot;            # 进度条的颜色</span><br><span class="line">  height: 3px                 # 进度条的大小</span><br></pre></td></tr></table></figure>




<h2 id="CSS样式修改"><a href="#CSS样式修改" class="headerlink" title="CSS样式修改"></a>CSS样式修改</h2><h3 id="设置背景图片和透明度"><a href="#设置背景图片和透明度" class="headerlink" title="设置背景图片和透明度"></a>设置背景图片和透明度</h3><p>主题的配置文件<code>themes/next/_config.yml</code>，设置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">custom_file_path:</span></span><br><span class="line">  <span class="attr">style:</span> <span class="string">source/_data/styles.styl</span></span><br></pre></td></tr></table></figure>

<p>在博客根目录下的<code>source</code>文件夹下新建<code>_data</code>文件夹并添加<code>styles.styl</code>文件</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">// 添加背景图片</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  // 图片需放在根目录/source/images/<span class="attribute">background</span><span class="selector-class">.jpg</span></span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">/images/background.jpg</span>);//自己喜欢的图片地址</span><br><span class="line">  <span class="attribute">background-size</span>: cover;</span><br><span class="line">  <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">  <span class="attribute">background-attachment</span>: fixed;</span><br><span class="line">  <span class="attribute">background-position</span>: <span class="number">50%</span> <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//博客内容透明化</span><br><span class="line">//文章内容的透明度设置</span><br><span class="line"><span class="selector-class">.main-inner</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.98</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//侧边框的透明度设置</span><br><span class="line"><span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.95</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//菜单栏的透明度设置</span><br><span class="line"><span class="selector-class">.header-inner</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.95</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//搜索框（local-search）的透明度设置</span><br><span class="line"><span class="selector-class">.popup</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.95</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="设置页脚文字样式"><a href="#设置页脚文字样式" class="headerlink" title="设置页脚文字样式"></a>设置页脚文字样式</h3><p>在上述新添加的<code>source/_data/styles.styl</code>文件内添加如下代码</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">//页脚文字</span><br><span class="line"><span class="selector-class">.footer</span>, <span class="selector-class">.footer</span> <span class="selector-tag">a</span>, <span class="selector-class">.footer</span> <span class="selector-class">.with-love</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="鼠标点击特效"><a href="#鼠标点击特效" class="headerlink" title="鼠标点击特效"></a>鼠标点击特效</h3><p>鼠标点击特效常用的有礼花特效、爆炸特效、浮出爱心、浮出文字，可以点击下方按钮下载对应的<code>js</code>文件, 并保存在<code>themes\next\source\js\cursor\</code> 目录下</p>
<a class="btn" href="https://titanjun.oss-cn-hangzhou.aliyuncs.com/hexo-next/finder/fireworks.js"><i class="fa fa-download fa-lg fa-fw"></i>礼花特效</a>

<a class="btn" href="https://titanjun.oss-cn-hangzhou.aliyuncs.com/hexo-next/finder/explosion.js"><i class="fa fa-download fa-lg fa-fw"></i>爆炸特效</a>

<a class="btn" href="https://titanjun.oss-cn-hangzhou.aliyuncs.com/hexo-next/finder/clicklove.js"><i class="fa fa-download fa-lg fa-fw"></i>浮出爱心</a>

<a class="btn" href="https://titanjun.oss-cn-hangzhou.aliyuncs.com/hexo-next/finder/clicktext.js"><i class="fa fa-download fa-lg fa-fw"></i>浮出文字</a>


<p>新建一个自定义样式文件<code>themes\next\layout\_custom\custom.njk</code> , 添加如下代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;# 鼠标点击特效 #&#125;</span><br><span class="line">&#123;% if theme.cursor_effect == &quot;fireworks&quot; %&#125;</span><br><span class="line">  &lt;script async src=&quot;/js/cursor/fireworks.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&#123;% elseif theme.cursor_effect == &quot;explosion&quot; %&#125;</span><br><span class="line">  &lt;canvas class=&quot;fireworks&quot; style=&quot;position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;&quot; &gt;&lt;/canvas&gt;</span><br><span class="line">  &lt;script src=&quot;//cdn.bootcss.com/animejs/2.2.0/anime.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script async src=&quot;/js/cursor/explosion.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&#123;% elseif theme.cursor_effect == &quot;love&quot; %&#125;</span><br><span class="line">  &lt;script async src=&quot;/js/cursor/love.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&#123;% elseif theme.cursor_effect == &quot;text&quot; %&#125;</span><br><span class="line">  &lt;script async src=&quot;/js/cursor/text.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>


<p>将新建的<code>custom.njk</code>引入到<code>themes\next\layout\_layout.njk</code>文件代码中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    ....</span><br><span class="line">  &lt;!-- 页面点击效果 --&gt;</span><br><span class="line">  &#123;% include &#x27;_custom/custom.njk&#x27; %&#125;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>最后在主题配置文件中添加以下代码</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mouse click effect: fireworks | explosion | love | text</span></span><br><span class="line"><span class="attr">cursor_effect:</span> <span class="string">fireworks</span></span><br></pre></td></tr></table></figure>


<h3 id="站点运行时间设置"><a href="#站点运行时间设置" class="headerlink" title="站点运行时间设置"></a>站点运行时间设置</h3><p>在<code>thems/next/layout/_partials/footer.njk</code>文件内, 搜索<code>theme.footer.powered</code>, 在此之前添加如下代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!-- 网站运行时间的设置 --&gt;</span><br><span class="line">&lt;span id=&quot;timeDate&quot;&gt;载入天数...&lt;/span&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var now = new Date();</span><br><span class="line">    function createtime() &#123;</span><br><span class="line">        var grt= new Date(&quot;07/01/2016 09:00:00&quot;);//此处修改你的建站时间或者网站上线时间</span><br><span class="line">        now.setTime(now.getTime()+250);</span><br><span class="line">        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);</span><br><span class="line">        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);</span><br><span class="line">        if(String(hnum).length ==1 )&#123;hnum = &quot;0&quot; + hnum;&#125; minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);</span><br><span class="line">        mnum = Math.floor(minutes); if(String(mnum).length ==1 )&#123;mnum = &quot;0&quot; + mnum;&#125;</span><br><span class="line">        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);</span><br><span class="line">        snum = Math.round(seconds); if(String(snum).length ==1 )&#123;snum = &quot;0&quot; + snum;&#125;</span><br><span class="line">        document.getElementById(&quot;timeDate&quot;).innerHTML = &quot;本站已安全运行 &quot;+dnum+&quot; 天 &quot;+hnum + &quot; 小时 &quot; + mnum + &quot; 分 &quot; + snum + &quot; 秒&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    setInterval(&quot;createtime()&quot;,250);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="点击头像回到首页"><a href="#点击头像回到首页" class="headerlink" title="点击头像回到首页"></a>点击头像回到首页</h3><p>修改侧边栏模板代码<code>thems/next/layout/_partials/site-overview.njk</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  &#123;%- if theme.avatar.url %&#125;</span><br><span class="line">+    &lt;a href=&quot;/&quot;&gt;</span><br><span class="line">        &lt;img class=&quot;site-author-image&quot; itemprop=&quot;image&quot; alt=&quot;&#123;&#123; author &#125;&#125;&quot;</span><br><span class="line">          src=&quot;&#123;&#123; url_for(theme.avatar.url) &#125;&#125;&quot;&gt;</span><br><span class="line">+    &lt;/a&gt;</span><br><span class="line">  &#123;%- endif %&#125;</span><br></pre></td></tr></table></figure>


<h3 id="文章尾部添加本文结束标记"><a href="#文章尾部添加本文结束标记" class="headerlink" title="文章尾部添加本文结束标记"></a>文章尾部添加本文结束标记</h3><p>在主题的配置文件<code>themes/next/_config.yml</code>中设置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">custom_file_path:</span></span><br><span class="line">  <span class="attr">postBodyEnd:</span> <span class="string">source/_data/post-body-end.njk</span></span><br></pre></td></tr></table></figure>

<p>在博客根目录下的<code>source</code>文件夹下新建<code>_data</code>文件夹并添加<code>post-body-end.njk</code>文件, 并在文件中添加一下内容</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;text-align:center;color: #ccc;font-size:18px;&quot;</span>&gt;</span>------------- 本文结束啦<span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-paw&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span>感谢您的阅读 -------------<span class="tag">&lt;/<span class="name">div</span>&gt;</span>	</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>





<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://www.techgrow.cn/">hexo的next主题个性化配置教程</a></li>
<li><a href="https://reuixiy.github.io/">打造个性超赞博客Hexo+NexT+GithubPages的超深度优化</a></li>
<li><a href="http://www.zhaojun.im/hexo-valine-modify/">Hexo 优化 — 支持邮件通知的评论 Valine 增强版</a></li>
</ul>
<hr>
]]></content>
      <categories>
        <category>Hexo博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js搭建Web服务器</title>
    <url>/post/51f133d4.html</url>
    <content><![CDATA[<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/javascript/nodejs.png?x-oss-process=style/titanjun" alt="Node.js"></p>
<span id="more"></span>


<h2 id="Node-js介绍"><a href="#Node-js介绍" class="headerlink" title="Node.js介绍"></a>Node.js介绍</h2><ul>
<li><a href="https://github.com/CoderTitan/NodejsDemo">Demo地址</a></li>
<li><code>Node.js</code>发布于2009年5月，由Ryan Dahl(瑞恩·达尔)在<code>GitHub</code>上发布了最初版本的部分<code>Node.js</code>包，随后几个月里，有人开始使用Node.js开发应用</li>
<li><code>Node.js</code>是一个基于<code>Chrome JavaScript</code>运行时建立的平台， 是一个<code>Javascript</code>运行环境</li>
<li>Node 是一个服务器程序, 用Javascript这个语言开发服务器</li>
<li><code>Node.js</code>的实质是对<code>Chrome V8</code>引擎进行了封装</li>
<li><code>V8 JavaScript</code> 引擎是 <code>Google</code> 用于其 <code>Chrome</code> 浏览器的底层 JavaScript 引擎</li>
<li>传统意义上的<code>JavaScript</code>运行在浏览器上，这是因为浏览器内核实际上分为两个部分:渲染引擎和 <code>JavaScript</code> 引擎。前者负责渲染<code>HTML + CSS</code>，后者则负责运行<code>JavaScript</code>。Chrome 使用的<code>JavaScript</code> 引擎是 V8，它的速度非常快</li>
<li>参考<a href="https://www.ibm.com/developerworks/cn/opensource/os-nodejs/">Node.js 究竟是什么？</a>和<a href="https://nodejs.org/dist/latest-v7.x/docs/api/">Node.js的SDK文档</a></li>
</ul>
<h3 id="不需要搭建Apache等服务器"><a href="#不需要搭建Apache等服务器" class="headerlink" title="不需要搭建Apache等服务器"></a>不需要搭建<code>Apache</code>等服务器</h3><p>为什么Node.js这个服务器语言不需要搭建<code>Apache</code>等服务器</p>
<ul>
<li>因为<code>Node.js</code>是基于V8去封装，所以在下载<code>Node.js</code>的时候，就会自带V8，因此不需要在另外搭建。</li>
<li><code>Node.js</code>和<code>PHP</code>类似都是语言，是需要内核才需要跑起来的，<code>Node.js</code>依赖V8，PHP依赖<code>Apache</code>才能运行</li>
<li>比如OC就需要依赖<code>iPhone</code>手机内核才能跑起来</li>
</ul>
<h3 id="Node-js的优缺点"><a href="#Node-js的优缺点" class="headerlink" title="Node.js的优缺点"></a>Node.js的优缺点</h3><ul>
<li>Node.js优点：<ul>
<li>采用事件驱动、异步编程，为网络服务而设计。其实<code>Javascript</code>的匿名函数和闭包特性非常适合事件驱动、异步编程。而且<code>JavaScript</code>也简单易学，很多前端设计人员可以很快上手做后端设计。</li>
<li><code>Node.js</code>非阻塞模式的IO处理给<code>Node.js</code>带来在相对低系统资源耗用下的高性能与出众的负载能力，非常适合用作依赖其它IO资源的中间层服务。</li>
<li><code>Node.js</code>轻量高效，可以认为是数据密集型分布式部署环境下的实时应用系统的完美解决方案。Node非常适合如下情况：在响应客户端之前，您预计可能有很高的流量，但所需的服务器端逻辑和处理不一定很多。</li>
</ul>
</li>
<li>Node.js缺点：<ul>
<li>可靠性低</li>
<li>单进程，单线程，只支持单核CPU，不能充分的利用多核CPU服务器。</li>
<li>一旦这个进程崩掉，那么整个web服务就崩掉了。</li>
</ul>
</li>
</ul>
<h3 id="Node-js工作原理"><a href="#Node-js工作原理" class="headerlink" title="Node.js工作原理"></a>Node.js工作原理</h3><ul>
<li>传统Web服务器原理(T):传统的网络服务技术，是每个新增一个连接（请求）便生成一个新的线程，这个新的线程会占用系统内存，最终会占掉所有的可用内存。</li>
<li><code>Node.js</code>工作原理(T)：只运行在一个单线程中，使用非阻塞的异步 I&#x2F;O 调用，所有连接都由该线程处理，也就是一个新的连接，不会开启新的线程，仅仅一个线程去处理多个请求</li>
<li>那么问题来了: 既然<code>Node.js</code>是单线程的, 那么单线程怎么开启异步?怎么工作的？</li>
<li>这里我们将会引入一个事件驱动的概念:<ul>
<li>传统的<code>web server</code>多为基于线程模型: 你启动<code>Apache</code>或者什么<code>server</code>，它开始等待接受连接, 当收到一个连接，<code>server</code>保持连接直到事务请求完成,如果他需要花几微妙时间去读取磁盘或者访问数据库，<code>web server</code>就阻塞了IO操作（这也被称之为阻塞式IO),想提高这样的<code>web server</code>的性能就只有启动更多的线程。</li>
<li><code>Node.Js</code>使用事件驱动模型，类似iOS的<code>Runloop</code>,把事件存放到一个循环中，然后取出来处理，当<code>web server</code>接收到请求，放入事件队列，然后去服务下一个web请求。当这个请求完成，从事件队列中取出来执行处理，将结果返回给用户。因为<code>webserver</code>一直接受请求而不等待任何读写操作。（这也被称之为非阻塞式IO或者事件驱动IO）</li>
</ul>
</li>
</ul>
<h3 id="Node-js使用介绍"><a href="#Node-js使用介绍" class="headerlink" title="Node.js使用介绍"></a>Node.js使用介绍</h3><ul>
<li><code>Node.js</code>使用Module模块去划分不同的功能，以简化App开发，Module就是模块，跟组件化差不多，一个功能一个模块。</li>
<li><code>Node.js</code>内建了一个HTTP服务器，可以轻而易举的实现一个网站和服务器的组合，不像PHP那样，在使用PHP的时候，必须先搭建一个Apache之类的HTTP服务器，然后通过HTTP服务器的模块加载CGI调用，才能将PHP脚本的执行结果呈现给用户</li>
<li><code>require()</code> 函数，用于在当前模块中加载和使用其他模块；</li>
</ul>
<h2 id="Express模块-框架"><a href="#Express模块-框架" class="headerlink" title="Express模块(框架)"></a>Express模块(框架)</h2><ul>
<li>Express是Node.JS第三方库</li>
<li>Express可以处理各种HTTP请求</li>
<li>Express是目前最流行的基于Node.js的Web开发框架，</li>
<li>Express框架建立在node.js内置的http模块上，可以快速地搭建一个Web服务器</li>
</ul>
<h3 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h3><ul>
<li>打开终端，输入node -v，先查看是否已经安装</li>
<li>如果没有安装，就需要安装node软件</li>
<li>参考<a href="http://www.runoob.com/nodejs/nodejs-install-setup.html">Node.js 安装配置</a></li>
</ul>
<h3 id="安装npm"><a href="#安装npm" class="headerlink" title="安装npm"></a>安装npm</h3><ul>
<li>npm是随同<code>NodeJS</code>一起安装的包管理工具，用于下载<code>NodeJS</code>第三方库。</li>
<li>类似iOS开发中<code>cocoapods</code>，用于安装第三方框架</li>
<li>新版的<code>NodeJS</code>已经集成了npm，所以只要安装好Node.JS就好</li>
</ul>
<h3 id="下载第三方模块Express"><a href="#下载第三方模块Express" class="headerlink" title="下载第三方模块Express"></a>下载第三方模块<code>Express</code></h3><ul>
<li>首先先创建项目<ul>
<li>新建一个文件夹, 打开终端</li>
<li>cd到当前文件夹, 创建一个js文件, 如: <code>touch app.js</code></li>
</ul>
</li>
<li>安装<code>package.json</code>文件, 类似于CocoaPods中的<code>Podfile</code>   - cd到当前文件夹<ul>
<li>终端输入: <code>npm init</code></li>
</ul>
</li>
<li>最后安装express库 <ul>
<li>终端输入: <code>npm install express --save</code></li>
</ul>
</li>
</ul>
<h2 id="搭建简单的Http服务器"><a href="#搭建简单的Http服务器" class="headerlink" title="搭建简单的Http服务器"></a>搭建简单的Http服务器</h2><h3 id="服务器种类"><a href="#服务器种类" class="headerlink" title="服务器种类"></a>服务器种类</h3><ul>
<li>Web服务器: 处理<code>HTTP</code>请求的服务器</li>
<li><code>Socket</code>服务器(即时通讯): 通过<code>socket</code>传输<ul>
<li>即时通讯(IM): 允许两人或多人使用网路即时的传递文字讯息、档案、语音与视频交流</li>
</ul>
</li>
<li>流媒体服务器: 音视频处理程序, 接受流媒体格式文件,<code>flv/ts</code>等</li>
</ul>
<p>简单效果图</p>
<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-be8bdfac135d99e8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="请求返回结果.jpg"></p>
<h3 id="开始搭建Http服务器"><a href="#开始搭建Http服务器" class="headerlink" title="开始搭建Http服务器"></a>开始搭建Http服务器</h3><ul>
<li>require加载模块</li>
<li>监听端口号和网址, 端口号不能使用已经占用的端口比如（80），每个服务器相当于一个app，都需要端口，才能找到入口</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建HTTP服务器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 加载http模块</span></span><br><span class="line">var http = require(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 创建http服务器</span></span><br><span class="line"><span class="comment">// 参数: 请求的回调, 当有人访问服务器的时候,就会自动调用回调函数</span></span><br><span class="line">var server = http.createServer(function (request, response) &#123;</span><br><span class="line">    console.log(<span class="string">&#x27;有人访问了服务器&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回调数据</span></span><br><span class="line">    response.write(<span class="string">&#x27;Hello, My Love&#x27;</span>)</span><br><span class="line">    response.end()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 绑定端口</span></span><br><span class="line">server.listen(<span class="number">3030</span>, <span class="string">&#x27;192.168.2.11&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 执行</span></span><br><span class="line">console.log(<span class="string">&#x27;执行了3030&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="开始运行服务器"><a href="#开始运行服务器" class="headerlink" title="开始运行服务器"></a>开始运行服务器</h3><ul>
<li>那么还是要打开终端</li>
<li>输入: <code>node app.js</code><ul>
<li><code>app.ja</code>为文件名</li>
</ul>
</li>
</ul>
<h2 id="express搭建服务器"><a href="#express搭建服务器" class="headerlink" title="express搭建服务器"></a>express搭建服务器</h2><h3 id="express框架的使用"><a href="#express框架的使用" class="headerlink" title="express框架的使用"></a>express框架的使用</h3><ul>
<li>引入express模块</li>
<li>创建express服务器</li>
<li>get, post请求中: <ul>
<li>参数一: 请求根路径,若传<code>&#39;/&#39;</code>, 则url为: <code>http://192.168.0.0:3030</code></li>
<li>若传<code>&#39;/home&#39;</code>, 则url为: <code>http://192.168.0.0:3030/home</code></li>
<li>参数二: 请求数据的回调函数</li>
</ul>
</li>
<li>监听端口: 默认url为当前电脑的IP地址</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* express的服务器 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 导入express</span></span><br><span class="line">var express = require(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 创建express服务器</span></span><br><span class="line">var server = express()</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 访问服务器(get或者post)</span></span><br><span class="line"><span class="comment">//参数一: 请求根路径</span></span><br><span class="line"><span class="comment">//3.1 get请求</span></span><br><span class="line">server.get(<span class="string">&#x27;/&#x27;</span>, function (request, response) &#123;</span><br><span class="line">    <span class="comment">// console.log(request)</span></span><br><span class="line">    response.send(<span class="string">&#x27;get请求成功&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.2 post请求</span></span><br><span class="line">server.post(<span class="string">&#x27;/&#x27;</span>, function (request, response) &#123;</span><br><span class="line">    response.send(<span class="string">&#x27;post请求成功&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 绑定端口</span></span><br><span class="line">server.listen(<span class="number">4040</span>)</span><br><span class="line">console.log(<span class="string">&#x27;启动4040&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><ul>
<li>路由:针对不同的URL有不同的处理方式，比如以后会有首页，发现模块，每个模块处理不一样。</li>
<li>添加url路径,根据不同路径，显示不同内容</li>
<li>路由句柄(索引):执行完一个函数，在执行下一个 ,因为有时候处理一个请求，需要做很多其他事情，写在一起业务逻辑不好分开,所以多弄几个行数</li>
<li>函数一定要添加next参数，一定要调用next(),才会进行下面操作，代码使一行一行执行，解释性语言</li>
<li></li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* express的路由 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 导入express</span></span><br><span class="line">var express = require(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 创建express服务器</span></span><br><span class="line">var server = express()</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 访问服务器(get或者post)</span></span><br><span class="line"><span class="comment">//参数一: 请求根路径</span></span><br><span class="line"><span class="comment">//3.1 get请求</span></span><br><span class="line"><span class="comment">// next: 路由句柄</span></span><br><span class="line">server.get(<span class="string">&#x27;/home&#x27;</span>, function (request, response, next) &#123;</span><br><span class="line"></span><br><span class="line">    console.log(<span class="string">&#x27;从据库获取数据&#x27;</span>)</span><br><span class="line">    next()</span><br><span class="line"></span><br><span class="line">&#125;, function (request, response) &#123;</span><br><span class="line"></span><br><span class="line">    response.send(<span class="string">&#x27;这是请求返回的数据&#x27;</span>)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 绑定端口</span></span><br><span class="line">server.listen(<span class="number">4040</span>)</span><br><span class="line">console.log(<span class="string">&#x27;启动4040&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><ul>
<li>优化代码，使代码清晰可读</li>
<li>原理，发送一个请求给服务器的时候，会被中间件拦截，先由中间件处理，每个中间件都有一个回调函数作为参数,拦截到参数，就会自动执行回调函数。</li>
<li>注意：有中间件use，会先执行中间件的回调函数，然后才会调用get或者<code>post</code>的回调函数，也就是当监听到请求，先执行中间件，才会到get,post请求。</li>
<li>use是<code>express</code>注册中间件的方法</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* express的中间件 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 导入express</span></span><br><span class="line">var express = require(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 创建express服务器</span></span><br><span class="line">var server = express()</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 创建中间件:use</span></span><br><span class="line"><span class="comment">//截取请求, 拦截回调</span></span><br><span class="line">server.use(<span class="string">&#x27;/&#x27;</span>, function (request, response, next) &#123;</span><br><span class="line">    console.log(<span class="string">&#x27;执行中间件&#x27;</span>)</span><br><span class="line">    <span class="comment">// console.log(&#x27;获取数据库数据&#x27;)</span></span><br><span class="line">    console.log(request.query.page)</span><br><span class="line">    next()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 访问服务器(get或者post)</span></span><br><span class="line"><span class="comment">//参数一: 请求根路径</span></span><br><span class="line"><span class="comment">//4.1 get请求</span></span><br><span class="line">server.get(<span class="string">&#x27;/home&#x27;</span>, function (request, response) &#123;</span><br><span class="line">    <span class="comment">// console.log(request)</span></span><br><span class="line">    response.send(<span class="string">&#x27;get参数请求成功&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//5. 绑定端口</span></span><br><span class="line">server.listen(<span class="number">4040</span>)</span><br><span class="line">console.log(<span class="string">&#x27;启动4040&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="get请求参数"><a href="#get请求参数" class="headerlink" title="get请求参数"></a>get请求参数</h3><ul>
<li>request.query会把请求参数包装成字典对象，直接通过点就能获取参数</li>
<li>这里的请求地址为: <code>http://192.168.2.11:4040/home?page=12</code></li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* express的中间件 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 导入express</span></span><br><span class="line">var express = require(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 创建express服务器</span></span><br><span class="line">var server = express()</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 访问服务器(get或者post)</span></span><br><span class="line"><span class="comment">//参数一: 请求根路径</span></span><br><span class="line"><span class="comment">//4.1 get请求</span></span><br><span class="line">server.get(<span class="string">&#x27;/home&#x27;</span>, function (request, response) &#123;</span><br><span class="line">    <span class="comment">// console.log(request)</span></span><br><span class="line">    console.log(request.query.page)</span><br><span class="line">    response.send(<span class="string">&#x27;get参数请求成功&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//5. 绑定端口</span></span><br><span class="line">server.listen(<span class="number">4040</span>)</span><br><span class="line">console.log(<span class="string">&#x27;启动4040&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>输出结果</li>
<li><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">启动4040</span><br><span class="line">12</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="post请求参数"><a href="#post请求参数" class="headerlink" title="post请求参数"></a>post请求参数</h3><ul>
<li>这里先让我们看一下request的部分参数</li>
<li></li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">headers: </span><br><span class="line">   &#123; </span><br><span class="line">   <span class="comment">//请求头</span></span><br><span class="line">     host: <span class="string">&#x27;192.168.2.11:4040/home&#x27;</span>,</span><br><span class="line">     <span class="comment">//保持长连接</span></span><br><span class="line">     connection: <span class="string">&#x27;keep-alive&#x27;</span>,</span><br><span class="line">     <span class="string">&#x27;cache-control&#x27;</span>: <span class="string">&#x27;max-age=0&#x27;</span>,</span><br><span class="line">     <span class="string">&#x27;user-agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.84 Safari/537.36&#x27;</span>,</span><br><span class="line">     <span class="string">&#x27;upgrade-insecure-requests&#x27;</span>: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">     <span class="comment">//可接受的数据解析方式</span></span><br><span class="line">     accept: <span class="string">&#x27;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8&#x27;</span>,</span><br><span class="line">     <span class="string">&#x27;accept-encoding&#x27;</span>: <span class="string">&#x27;gzip, deflate&#x27;</span>,</span><br><span class="line">     <span class="string">&#x27;accept-language&#x27;</span>: <span class="string">&#x27;zh-CN,zh;q=0.9&#x27;</span>,</span><br><span class="line">     <span class="string">&#x27;if-none-match&#x27;</span>: <span class="string">&#x27;W/&quot;15-H7HlVCzzVfmRL56LAnLfNUaMM+8&quot;&#x27;</span> </span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>使用http发送请求，需要设置<code>content-type</code>字段</li>
<li><code>content-type</code>字段<ul>
<li><code>application/x-www-form-urlencoded</code>(普通请求，默认一般使用这种)</li>
<li><code>application/json</code>(带有json格式的参数，需要使用这个，比如参数是字典或者数组)</li>
<li><code>multipart/form-data</code>(传输文件，文件上传使用这个)</li>
</ul>
</li>
<li>AFN框架中<code>AFHTTPRequestSerializer</code>使用的是<code>application/x-www-form-urlencoded</code>，<code>AFJSONRequestSerializer</code>使用的是<code>application/json</code></li>
<li><code>Node.JS</code>需要使用<code>body-parser</code>模块,解析post请求参数</li>
<li>可以采用中间件的方式解析post请求参数<ul>
<li>注意<code>bodyParser.urlencoded</code>参数是一个字典，需要添加&#96;{}&#96;&#96;包装</li>
<li>extends必传参数，是否展开</li>
</ul>
</li>
<li>完整代码示例</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建Post请求</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 导入express</span></span><br><span class="line">var express = require(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 加载模块</span></span><br><span class="line">var bodyParse = require(<span class="string">&#x27;body-parser&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 创建服务器</span></span><br><span class="line">var server = express()</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 生成解析器</span></span><br><span class="line"><span class="comment">// application/x-www-form-urlencoded</span></span><br><span class="line">var urlencoded = bodyParse.urlencoded(&#123; extends:<span class="literal">true</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// application/json</span></span><br><span class="line">var jsonParser = bodyParse.json()</span><br><span class="line"></span><br><span class="line"><span class="comment">//5. 中间件: 把请求体参数 存放到request.body</span></span><br><span class="line">server.use(<span class="string">&#x27;./home&#x27;</span>, jsonParser)</span><br><span class="line"></span><br><span class="line"><span class="comment">//6. 请求数据</span></span><br><span class="line"><span class="comment">// request:request请求头,请求体</span></span><br><span class="line">server.post(<span class="string">&#x27;./home&#x27;</span>, function (request, response) &#123;</span><br><span class="line">    <span class="comment">//解析post请求参数</span></span><br><span class="line">    console.log(request.body)</span><br><span class="line">    response.send(request.body)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//7. 绑定端口</span></span><br><span class="line">server.listen(<span class="number">5050</span>)</span><br></pre></td></tr></table></figure>



<div class="note info"><p>[Demo地址](https://github.com/CoderTitan/WebServer)</p></div>

<hr>
<blockquote>
<p>参考文章:</p>
<ol>
<li><a href="http://blog.csdn.net/kaosini/article/details/8089597">Node.js优缺点</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/opensource/os-nodejs/">Node.js 究竟是什么？</a></li>
<li><a href="http://www.expressjs.com.cn/4x/api.html">Express 4.x API 中文手册</a></li>
<li><a href="https://msdn.microsoft.com/zh-cn/library/aa155110.aspx">JavaScript语言参考</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中常用的模块</title>
    <url>/post/85d9cd1f.html</url>
    <content><![CDATA[<ul>
<li>上一篇文章中记录了<a href="https://www.titanjun.top/2018/05/31/Python%E4%B8%AD%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8/">Python中模块的使用</a>, 这里就是记录一些常用的模块</li>
<li>最近学习中发现, 之前接触的模块好多却都忘记了怎么使用</li>
<li>这里就简单总结一下<code>os</code>, <code>random</code>等模块的使用吧</li>
<li><a href="https://github.com/CoderTitan/PythonDemo">GitHub代码示例目地址</a></li>
</ul>
<span id="more"></span>


<h2 id="os模块"><a href="#os模块" class="headerlink" title="os模块"></a><code>os</code>模块</h2><p> <code>os</code>模块简单的来说它是一个<code>Python</code>的系统编程的操作模块，可以处理文件和目录, 这些我们日常手动需要做的操作</p>
<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 获取操作系统的类型</span></span><br><span class="line"><span class="built_in">print</span>(os.name)</span><br><span class="line"><span class="comment"># 输出: posix</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;操作系统的类型</span></span><br><span class="line"><span class="string">nt -&gt; windows</span></span><br><span class="line"><span class="string">posix -&gt; Linux/Unix</span></span><br><span class="line"><span class="string">OS -&gt; Mac(内核是Linux)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 输出操作系统详细的信息</span></span><br><span class="line"><span class="built_in">print</span>(os.uname())</span><br><span class="line"><span class="comment"># 输出:</span></span><br><span class="line"><span class="comment"># posix.uname_result(sysname=&#x27;Darwin&#x27;, nodename=&#x27;xxx.local&#x27;, release=&#x27;17.5.0&#x27;, version=&#x27;Darwin Kernel Version 17.5.0: Mon Mar  5 22:24:32 PST 2018; root:xnu-4570.51.1~1/RELEASE_X86_64&#x27;, machine=&#x27;x86_64&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 获取操作系统中的环境变量(输出一个字典)</span></span><br><span class="line"><span class="built_in">print</span>(os.environ)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 获取指定的环境变量</span></span><br><span class="line"><span class="comment"># 参数为上述操作系统环境变量中字典的某一个键值对的键值</span></span><br><span class="line">os.environ.get(<span class="string">&#x27;PYTHONPATH&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 获取当前工作目录, 即当前python脚本所在的目录</span></span><br><span class="line"><span class="built_in">print</span>(os.getcwd())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. 返回指定目录下的所有的文件, 返回一个列表</span></span><br><span class="line"><span class="built_in">print</span>(os.listdir(path))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 7. 在制定目录下增删目录</span></span><br><span class="line"><span class="comment"># 在当前目录下创建文件</span></span><br><span class="line"><span class="comment"># 在制定的路径下创建</span></span><br><span class="line">os.mkdir(<span class="string">r&#x27;/Users/xxx/titan&#x27;</span>)</span><br><span class="line"><span class="comment"># 默认在当前目录下</span></span><br><span class="line">os.mkdir(<span class="string">&#x27;jun&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除目录</span></span><br><span class="line">os.rmdir(<span class="string">&#x27;jun&#x27;</span>)</span><br><span class="line">os.rmdir(<span class="string">&#x27;r&#x27;</span>/Users/xxx/titan<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 8. 获取文件属性</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;文件属性:&#x27;</span>, os.stat(<span class="string">&#x27;titan&#x27;</span>))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;输出:</span></span><br><span class="line"><span class="string">文件属性: os.stat_result(st_mode=16877, st_ino=10797606, st_dev=16777224, st_nlink=2, st_uid=501, st_gid=20, st_size=68, st_atime=1527059854, st_mtime=1527058920, st_ctime=1527058920)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 9. 重命名</span></span><br><span class="line"><span class="comment"># os.rename(&#x27;jun&#x27;, &#x27;titan&#x27;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 10. 删除普通文件</span></span><br><span class="line"><span class="comment"># os.remove(path)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="os模块中的常用值"><a href="#os模块中的常用值" class="headerlink" title="os模块中的常用值"></a>os模块中的常用值</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#curdir  表示当前文件夹   .表示当前文件夹  一般情况下可以省略</span></span><br><span class="line"><span class="built_in">print</span>(os.curdir)</span><br><span class="line"></span><br><span class="line"><span class="comment">#pardir  表示上一层文件夹   ..表示上一层文件夹  不可省略!</span></span><br><span class="line"><span class="built_in">print</span>(os.pardir)</span><br><span class="line"></span><br><span class="line"><span class="comment">#os.mkdir(&#x27;../../../man&#x27;)#相对路径  从当前目录开始查找</span></span><br><span class="line"><span class="comment">#os.mkdir(&#x27;/home/sy/man1&#x27;)#绝对路径  从根目录开始查找</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#name 获取代表操作系统的名称字符串</span></span><br><span class="line"><span class="built_in">print</span>(os.name) <span class="comment">#posix -&gt; linux或者unix系统  nt -&gt; window系统</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#sep 获取系统路径间隔符号  window -&gt;\    linux -&gt;/</span></span><br><span class="line"><span class="built_in">print</span>(os.sep)</span><br><span class="line"></span><br><span class="line"><span class="comment">#extsep 获取文件名称和后缀之间的间隔符号  window &amp; linux -&gt; .</span></span><br><span class="line"><span class="built_in">print</span>(os.extsep)</span><br><span class="line"></span><br><span class="line"><span class="comment">#linesep  获取操作系统的换行符号  window -&gt; \r\n  linux/unix -&gt; \n</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">repr</span>(os.linesep))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="处理文件路径"><a href="#处理文件路径" class="headerlink" title="处理文件路径"></a>处理文件路径</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 拼接路径</span></span><br><span class="line">p1 = <span class="string">&#x27;/xxx/GitHub/PythonDemo/PythonStudy&#x27;</span></span><br><span class="line">p2 = <span class="string">&#x27;6-os模块/jun.txt&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(os.path.join(p1, p2))</span><br><span class="line"><span class="comment"># 输出: /xxx/GitHub/PythonDemo/PythonStudy/6-os模块/jun.txt</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. # 拆分路径</span></span><br><span class="line">path2 = <span class="string">r&#x27;/xxx/GitHub/PythonDemo/PythonStudy/6-os模块/jun.txt&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;拆分路径:&#x27;</span>, os.path.split(path2))</span><br><span class="line"><span class="comment"># 输出一个元组: (&#x27;/xxx/GitHub/PythonDemo/PythonStudy/6-os模块&#x27;, &#x27;jun.txt&#x27;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 获取扩展名, 返回一个元组</span></span><br><span class="line">os.path.splitext(path2)</span><br><span class="line"><span class="comment"># 输出: (&#x27;/xxx/GitHub/PythonDemo/PythonStudy/6-os模块/jun&#x27;, &#x27;.txt&#x27;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 是否是目录</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;是否是目录:&#x27;</span>, os.path.isdir(path2))</span><br><span class="line"><span class="comment"># 是否是目录: False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 判断文件是否存在</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;文件是否存在:&#x27;</span>, os.path.isfile(path2))</span><br><span class="line"><span class="comment"># 文件是否存在: False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. 判断目录是否存在</span></span><br><span class="line">path3 = <span class="string">r&#x27;/Users/quanjunt/Documents/Quanjun/GitHub/PythonDemo/PythonStudy/6-os模块&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;判断目录是否存在:&#x27;</span>, os.path.exists(path3))</span><br><span class="line"><span class="comment"># 输出: False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 7.  获取文件大小(字节)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;文件大小:&#x27;</span>, os.path.getsize(path3))</span><br><span class="line"><span class="comment"># 文件大小: 170</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 8. 获取文件名</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;文件名:&#x27;</span>, os.path.basename(path2))</span><br><span class="line"><span class="comment"># 输出: jun.txt</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 9. 获取文件路径中的目录部分</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;文件目录:&#x27;</span>, os.path.dirname(path2))</span><br><span class="line"><span class="comment"># 输出: /xxx/GitHub/PythonDemo/PythonStudy/6-os模块</span></span><br></pre></td></tr></table></figure>


<h2 id="random模块"><a href="#random模块" class="headerlink" title="random模块"></a><code>random</code>模块</h2><p><code>random</code>是<code>python</code>产生伪随机数的模块，随机种子默认为系统时钟</p>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 首先要先导入模块</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.从序列的元素中随机挑选一个元素</span></span><br><span class="line">random.choice((<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>))</span><br><span class="line">random.choice(<span class="string">&quot;titanjun&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 从指定范围内，按指定基数递增的集合中获取一个随机数</span></span><br><span class="line"><span class="built_in">print</span>(random.randrange(<span class="number">10</span>, <span class="number">100</span>, <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 随机生成的一个实数，它在[0,1)范围内</span></span><br><span class="line">random.random()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机生成指定范围[a,b]的整数</span></span><br><span class="line"><span class="built_in">print</span>(random.randint(<span class="number">1</span>, <span class="number">6</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机生成指定范围[a,b)的整数</span></span><br><span class="line"><span class="built_in">print</span>(random.randrange(<span class="number">2</span>, <span class="number">8</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机生成指定范围[a,b)的指定步长的数</span></span><br><span class="line"><span class="built_in">print</span>(random.randrange(<span class="number">1</span>, <span class="number">10</span>, <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机生成指定序列中的指定个数的元素(返回列表)</span></span><br><span class="line"><span class="built_in">print</span>(random.sample(<span class="string">&#x27;titanjun&#x27;</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将序列的所有元素随机排序</span></span><br><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">random.shuffle(list1)</span><br><span class="line"><span class="built_in">print</span>(list1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机生成一个在该范围内的实数</span></span><br><span class="line"><span class="built_in">print</span>(random.uniform(<span class="number">2</span>, <span class="number">5</span>))</span><br></pre></td></tr></table></figure>

<h3 id="随机生成6位验证码"><a href="#随机生成6位验证码" class="headerlink" title="随机生成6位验证码"></a>随机生成6位验证码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">checkCode = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    temp = random.randint(<span class="number">0</span>, <span class="number">9</span>)</span><br><span class="line">    checkCode += <span class="built_in">str</span>(temp)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;6位随机验证码:&quot;</span>, checkCode)</span><br></pre></td></tr></table></figure>


















]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中模块的使用</title>
    <url>/post/fe2495d8.html</url>
    <content><![CDATA[<ul>
<li>做过开发工作的童鞋应该都知道, 在一个完整的项目中, 会有大量的代码, 而且慢慢代码量会越来越多, 代码也就越来越难以维护;</li>
<li>随着你的程序变得越来越长，你可能想要将它分割成几个更易于维护的文件。</li>
<li>你也可能想在不同的程序中使用顺手的函数，而不是把代码在它们之间中拷来拷去</li>
<li>为了解决类似问题, 我们把很多功能相似的函数分组, 分别放到不同的文件中,这样每个文件中的代码相对较少, 且函数功能相似;</li>
<li><a href="https://github.com/CoderTitan/PythonDemo">GitHub代码示例目地址</a></li>
</ul>
<span id="more"></span>

<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="模块简述"><a href="#模块简述" class="headerlink" title="模块简述"></a>模块简述</h3><ul>
<li>在<code>Python</code>中提供了一个方法可以从文件中获取定义，在脚本或者解释器的一个交互式实例中使用, 这样的文件被称为模块；</li>
<li>模块中的定义可以导入到另一个模块或主模块中（在脚本执行时可以调用的变量集位于最高级，并且处于计算器模式）</li>
<li>模块是包括 Python 定义和声明的文件。文件名就是模块名加上 .py 后缀。</li>
<li>模块的模块名（做为一个字符串）可以由全局变量 <code>__name__</code> 得到</li>
<li>模块主要分为内置模块, 三方模块和自定义模块</li>
</ul>
<h3 id="模块优点"><a href="#模块优点" class="headerlink" title="模块优点"></a>模块优点</h3><ul>
<li>提高了代码的可维护性</li>
<li>提高了代码的服用度, 当一个模块完毕, 可以被多个地方引用</li>
<li>可避免函数名和变量名的冲突</li>
</ul>
<h3 id="标准库模块"><a href="#标准库模块" class="headerlink" title="标准库模块"></a>标准库模块</h3><p>下面是一个使用<code>python</code>标准库中模块的例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;命令行参数如下:&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> sys.argv:</span><br><span class="line">   <span class="built_in">print</span>(i)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n\nPython 路径为：&#x27;</span>, sys.path, <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果如下</span></span><br><span class="line">命令行参数如下:</span><br><span class="line">../GitHub/PythonDemo/PythonStudy/<span class="number">7</span>-模块/<span class="number">1</span>-模块概述.py</span><br><span class="line"></span><br><span class="line">Python 路径为： [<span class="string">&#x27;/Users/../GitHub/PythonDemo/PythonStudy/7-模块&#x27;</span>, <span class="string">&#x27;/Users/../GitHub/PythonDemo/PythonStudy&#x27;</span>, <span class="string">&#x27;/Library/Frameworks/Python.framework/Versions/3.6/lib/python36.zip&#x27;</span>, <span class="string">&#x27;/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6&#x27;</span>, <span class="string">&#x27;/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/lib-dynload&#x27;</span>, <span class="string">&#x27;/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages&#x27;</span>, <span class="string">&#x27;/Applications/PyCharm.app/Contents/helpers/pycharm_matplotlib_backend&#x27;</span>] </span><br></pre></td></tr></table></figure>

<ul>
<li><code>argv</code>: 获取命令行参数的列表</li>
<li><code>import sys</code> 引入<code>python</code>标准库中的<code>sys.py</code>模块</li>
<li><code>import</code>: 这是引入一个模块的方法(后面会提到)</li>
<li><code>sys.path</code>: 包含了一个<code>Python</code>解释器自动查找所需模块的路径的列表</li>
</ul>
<h2 id="自定义模块"><a href="#自定义模块" class="headerlink" title="自定义模块"></a>自定义模块</h2><ul>
<li><code>Python</code>中不但可以使用第三方模块和系统模块, 同时我们还可以使用自定义模块, </li>
<li>在<code>Python</code>中一个<code>.py</code>文件就是一个模块</li>
<li>下面是我自定义的一个<code>Titan.py</code>模块, 代码如下</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;这是Titan模块&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义变量</span></span><br><span class="line">age = <span class="number">20</span></span><br><span class="line">name = <span class="string">&#x27;titan&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义方法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sayGood</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;good&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sayNice</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;nice&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sayBad</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;bad&#x27;</span>)</span><br></pre></td></tr></table></figure>


<h2 id="导入模块"><a href="#导入模块" class="headerlink" title="导入模块"></a>导入模块</h2><h3 id="import方式"><a href="#import方式" class="headerlink" title="import方式"></a><code>import</code>方式</h3><p>在<code>Python</code>中导入另一个文件或者模块, 受用的语法是<code>import</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 引入单个或多个模块</span></span><br><span class="line"><span class="keyword">import</span> module1[, module2[,... moduleN]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line"><span class="comment"># 一次导入多个模块</span></span><br><span class="line"><span class="keyword">import</span> time, random, os</span><br><span class="line"><span class="comment"># 一次导入一个模块</span></span><br><span class="line"><span class="keyword">import</span> calendar</span><br></pre></td></tr></table></figure>

<div class='note warning'><p>需要注意的是: </p></div>

<ul>
<li>一个模块只会被导入一次，不管你执行了多少次<code>import</code>, 可以防止模块被重复引用</li>
<li>引入任何模块时(包括自定义模块), 不用加<code>.py</code>后缀</li>
<li>当我们使用<code>import</code>语句的时候，<code>Python</code>解释器是怎样找到对应的文件的呢？<ul>
<li>这就涉及到<code>Python</code>的搜索路径，搜索路径是由一系列目录名组成的，<code>Python</code>解释器就依次从这些目录中去寻找所引入的模块。</li>
<li>这看起来很像环境变量，事实上，也可以通过定义环境变量的方式来确定搜索路径。</li>
<li>搜索路径是在<code>Python</code>编译或安装的时候确定的，安装新的库应该也会修改。搜索路径被存储在<code>sys</code>模块中的<code>path</code>变量</li>
</ul>
</li>
</ul>
<div class="note info"><p>使用示例</p></div>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Titan</span><br><span class="line"></span><br><span class="line">Titan.sayBad()</span><br><span class="line">Titan.sayGood()</span><br><span class="line"><span class="built_in">print</span>(Titan.name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果:</span></span><br><span class="line">bad</span><br><span class="line">good</span><br><span class="line">titan</span><br></pre></td></tr></table></figure>

<h3 id="from…import方式"><a href="#from…import方式" class="headerlink" title="from…import方式"></a><code>from…import</code>方式</h3><p>从模块中导入一个指定的部分到当前的命名空间, 同样也可以导入一个模块中的多个部分(或者导入多个方法或变量), 格式如下:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">from modname import name1[, name2[, ... nameN]]</span><br></pre></td></tr></table></figure>

<div class="note info"><p>使用示例</p></div>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Titan <span class="keyword">import</span> sayGood, sayBad, age</span><br><span class="line"></span><br><span class="line">sayBad()</span><br><span class="line">sayGood()</span><br><span class="line"><span class="built_in">print</span>(age)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果:</span></span><br><span class="line">bad</span><br><span class="line">good</span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure>

<div class="note warning"><p>需要注意的是:</p></div>

<p>这种方式, 可能会导致和本文件中定义的方法或者变量重名, 这里需要注意</p>
<h3 id="from…import-方式"><a href="#from…import-方式" class="headerlink" title="from…import*方式"></a><code>from…import*</code>方式</h3><p>把一个模块中所有的内容, 全部倒入当前命名空间, 但是最好不要过多地使用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 格式:</span></span><br><span class="line"><span class="keyword">from</span> modname <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用:</span></span><br><span class="line"><span class="keyword">from</span> Titan <span class="keyword">import</span> *</span><br><span class="line">sayGood()</span><br><span class="line"><span class="built_in">print</span>(age)</span><br></pre></td></tr></table></figure>

<h2 id="模块内置属性和函数"><a href="#模块内置属性和函数" class="headerlink" title="模块内置属性和函数"></a>模块内置属性和函数</h2><h3 id="name-属性"><a href="#name-属性" class="headerlink" title="__name__属性"></a><code>__name__</code>属性</h3><ul>
<li>除了包含函数定义外，模块也可以包含可执行语句, 这些语句一般用来初始化模块, 他们仅在第一次被导入的地方执行一次</li>
<li>模块就是一个可执行的<code>.py</code>文件, 一个模块呗另一个程序引用, 模块中的一些可执行语句便会执行</li>
<li>如果我们不想让模块中的某些代码执行, 可以用<code>__name__</code>属性来使程序仅调用模块中的一部分</li>
<li>现在我们将模块中的代码修改如下:</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;这是Titan模块&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sayGood</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;good&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sayNice</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;nice&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sayBad</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;bad&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    age = <span class="number">20</span></span><br><span class="line">    name = <span class="string">&#x27;titan&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>name</code>和<code>main</code>前后都是双下划线</li>
<li>每一个模块中都有一个<code>__name__</code>属性, 当其值等于<code>__main__</code>时, 表明该模块自身在执行, 否则被引入了其他文件</li>
<li>当前文件如果为程序的入口文件, 则<code>__name__</code>属性的值为<code>__main__</code></li>
</ul>
<h3 id="dir-函数"><a href="#dir-函数" class="headerlink" title="dir()函数"></a><code>dir()</code>函数</h3><ul>
<li>内置的函数<code>dir()</code> 可以找到模块内定义的所有名称, 以一个字符串列表的形式返回</li>
<li>如果没有给定参数，那么<code>dir()</code>函数会罗列出当前定义的所有名称</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Titan</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(Titan))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果:</span></span><br><span class="line">[<span class="string">&#x27;__builtins__&#x27;</span>, <span class="string">&#x27;__cached__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>, <span class="string">&#x27;__file__&#x27;</span>, <span class="string">&#x27;__loader__&#x27;</span>, <span class="string">&#x27;__name__&#x27;</span>, <span class="string">&#x27;__package__&#x27;</span>, <span class="string">&#x27;__spec__&#x27;</span>, <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;sayBad&#x27;</span>, <span class="string">&#x27;sayGood&#x27;</span>, <span class="string">&#x27;sayNice&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>())</span><br><span class="line"><span class="comment"># 输出结果:</span></span><br><span class="line">[<span class="string">&#x27;Titan&#x27;</span>, <span class="string">&#x27;__annotations__&#x27;</span>, <span class="string">&#x27;__builtins__&#x27;</span>, <span class="string">&#x27;__cached__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>, <span class="string">&#x27;__file__&#x27;</span>, <span class="string">&#x27;__loader__&#x27;</span>, <span class="string">&#x27;__name__&#x27;</span>, <span class="string">&#x27;__package__&#x27;</span>, <span class="string">&#x27;__spec__&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里定义一个新的变量</span></span><br><span class="line"><span class="built_in">sum</span> = <span class="number">30</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>())</span><br><span class="line"><span class="comment"># 输出结果:</span></span><br><span class="line">[<span class="string">&#x27;Titan&#x27;</span>, <span class="string">&#x27;__annotations__&#x27;</span>, <span class="string">&#x27;__builtins__&#x27;</span>, <span class="string">&#x27;__cached__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>, <span class="string">&#x27;__file__&#x27;</span>, <span class="string">&#x27;__loader__&#x27;</span>, <span class="string">&#x27;__name__&#x27;</span>, <span class="string">&#x27;__package__&#x27;</span>, <span class="string">&#x27;__spec__&#x27;</span>, <span class="string">&#x27;sum&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把定义的变量删除后</span></span><br><span class="line"><span class="keyword">del</span> <span class="built_in">sum</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>())</span><br><span class="line"><span class="comment"># 输出结果:</span></span><br><span class="line">[<span class="string">&#x27;Titan&#x27;</span>, <span class="string">&#x27;__annotations__&#x27;</span>, <span class="string">&#x27;__builtins__&#x27;</span>, <span class="string">&#x27;__cached__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>, <span class="string">&#x27;__file__&#x27;</span>, <span class="string">&#x27;__loader__&#x27;</span>, <span class="string">&#x27;__name__&#x27;</span>, <span class="string">&#x27;__package__&#x27;</span>, <span class="string">&#x27;__spec__&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p>这里我们先思考这样一个问题: 在同一个项目中有两个或两个以上的开发者分别定义了相同名字的模块(当然狮子啊不同的目录中, 同一个目录下不可能创建出相同名字的文件), 那么模块该如何调用</p>
<div class="note success"><p>解决</p></div>

<ul>
<li>为了解决上述模块命名的冲突, 引入了按照目录来组织模块的方法, 成为包</li>
<li>包是一种管理<code>Python</code>模块命名空间的形式，采用”点模块名称”</li>
<li>引入包以后, 只要顶层的包不与其他人的发生冲突, 那么模块就都不会与别人的发生冲突</li>
<li>所谓顶层的包指的是上一层的文件目录</li>
<li>同一个包可以包含多个模块</li>
<li>例如: 名为<code>A.B</code>的模块表示了名为<code>A</code>的包中名为<code>B</code>的子模块</li>
</ul>
<div class="note warning"><p>需要注意的是:</p></div>

<p>在每一个包内(模块的同级目录下)必须要创建一个名为<code>__init__.py</code>的文件, 主要是为了避免一些滥竽充数的名字, 目前该文件内可以什么都不用写, 如图所示:</p>
<p><img data-src="http://p7hfnfk6u.bkt.clouddn.com/Snip20180531_1.png" alt="包.png"></p>
<div class="note success"><p>调用方法</p></div>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> a.Titan</span><br><span class="line"><span class="keyword">import</span> b.Titan</span><br><span class="line"><span class="keyword">import</span> b.coder</span><br><span class="line"></span><br><span class="line">a.Titan.sayGood()</span><br><span class="line">b.Titan.sayGood()</span><br><span class="line">b.coder.sayGood()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果:</span></span><br><span class="line">good--a</span><br><span class="line">good--b</span><br><span class="line">good--coder</span><br></pre></td></tr></table></figure>

<h2 id="安装使用第三方模块"><a href="#安装使用第三方模块" class="headerlink" title="安装使用第三方模块"></a>安装使用第三方模块</h2><h3 id="pip简介"><a href="#pip简介" class="headerlink" title="pip简介"></a><code>pip</code>简介</h3><ul>
<li>在<code>Python</code>中第三方库是通过<code>pip</code>安装和管理的, <code>pip</code>就像<code>iOS</code>中的<code>pod</code>一样, 负责安装和管理第三方库</li>
<li>在<code>Mac</code>和<code>Linux</code>系统中<code>pip</code>是默认安装过的, 一般无需重新安装, 如有问题, 请自行百度解决</li>
<li>在<code>Mac</code>系统中会有一个默认的<code>Python2.7</code>版本的, 我自己安装了一个3.6的版本, 自然默认也安装了<code>pip</code></li>
<li>下面是一些<code>Python3.6</code>中<code>pip</code>的命令, 这里需要以<code>pip3</code>为命令头执行</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看当前pip版本</span></span><br><span class="line">pip3 -V</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装第三方库</span></span><br><span class="line">pip3 install ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对pip进行升级</span></span><br><span class="line">pip3 install --upgrade pip3</span><br></pre></td></tr></table></figure>

<h3 id="安装第三方库"><a href="#安装第三方库" class="headerlink" title="安装第三方库"></a>安装第三方库</h3><ul>
<li><code>Mac</code>系统安装第三方库, 直接打开终端执行安装命令即可</li>
<li><code>Pillow</code>已经是<code>Python</code>平台事实上的图像处理标准库了</li>
<li><code>PIL</code>功能非常强大，但<code>API</code>却非常简单易用</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">pip3 install Pillow</span><br></pre></td></tr></table></figure>

<h3 id="第三方模块的使用"><a href="#第三方模块的使用" class="headerlink" title="第三方模块的使用"></a>第三方模块的使用</h3><h4 id="操作图像"><a href="#操作图像" class="headerlink" title="操作图像"></a>操作图像</h4><p>下面是最常见的图像缩放操作示例代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开一个jpg图像文件，注意是当前路径:</span></span><br><span class="line">im = Image.<span class="built_in">open</span>(<span class="string">&#x27;titan.jpg&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获得图像尺寸</span></span><br><span class="line">w, h = im.size</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;image size: %sx%s&#x27;</span> % (w, h))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 缩放到50%:</span></span><br><span class="line">im.thumbnail((w//<span class="number">2</span>, h//<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;image to: %sx%s&#x27;</span> % (w//<span class="number">2</span>, h//<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把缩放后的图像用jpeg格式保存:</span></span><br><span class="line">im.save(<span class="string">&#x27;jun.jpg&#x27;</span>, <span class="string">&#x27;jpeg&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>其他功能如切片、旋转、滤镜、输出文字、调色板等一应俱全, 代码如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageFilter</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开一个jpg图像文件，注意是当前路径:</span></span><br><span class="line">im = Image.<span class="built_in">open</span>(<span class="string">&#x27;jun.jpg&#x27;</span>)</span><br><span class="line"><span class="comment"># 应用模糊滤镜:</span></span><br><span class="line">im2 = im.<span class="built_in">filter</span>(ImageFilter.BLUR)</span><br><span class="line">im2.save(<span class="string">&#x27;jun1.jpg&#x27;</span>, <span class="string">&#x27;jpeg&#x27;</span>)</span><br></pre></td></tr></table></figure>

<div class='note warning'><p>相关参考</p></div>

<ul>
<li><a href="https://github.com/CoderTitan/PythonDemo">GitHub代码示例目地址</a></li>
<li><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014320027235877860c87af5544f25a8deeb55141d60c5000">Pillow简单实用</a></li>
</ul>
<hr>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中的运算符和条件循环语句</title>
    <url>/post/b4004272.html</url>
    <content><![CDATA[<ul>
<li>上文<a href="https://www.titanjun.top/2018/04/10/Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A301/">Python数据类型详解01</a>中主要介绍了<code>Python</code>中的一些常用的数据类型</li>
<li>这篇文章主要介绍一些<code>Python</code>中的运算符</li>
</ul>
<span id="more"></span>

<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p>以下假设变量a为9，变量b为7：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
</table>
<ul>
<li>| 	加 - 两个对象相加 | 	a + b 输出结果 16</li>
</ul>
<ul>
<li>| 	减 - 得到负数或是一个数减去另一个数 | 	a - b 输出结果 -2</li>
</ul>
<ul>
<li>| 	乘 - 两个数相乘或是返回一个被重复若干次的字符串 | 	a * b 输出结果 63<br>&#x2F; | 	除 - x除以y	 | a &#x2F; b 输出结果 1.2857142857142858<br>% | 	取模 - 返回除法的余数 | 	a % b 输出结果 2<br><code>**</code> | 	幂 - 返回x的y次幂 | 	2**3， 输出结果 8<br><code>//</code> | 	取整除 - 返回商的整数部分 | 	9&#x2F;&#x2F;2 输出结果 4 , 9.0&#x2F;&#x2F;2.0 输出结果 4.0</li>
</ul>
<h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><p>以下假设变量a为10，变量b为20：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D;&#x3D;</td>
<td>等于 - 比较对象是否相等</td>
<td>(a &#x3D;&#x3D; b) 返回 False。</td>
</tr>
<tr>
<td>!&#x3D;</td>
<td>不等于 - 比较两个对象是否不相等</td>
<td>(a !&#x3D; b) 返回 true.</td>
</tr>
<tr>
<td>&lt;&gt;</td>
<td>不等于 - 比较两个对象是否不相等</td>
<td>(a &lt;&gt; b) 返回 true。这个运算符类似 !&#x3D; 。</td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>大于 - 返回x是否大于y</td>
<td>(a &gt; b) 返回 False。</td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>小于 - 返回x是否小于y。所有比较运算符返回1表示真，返回0表示假。这分别与特殊的变量True和False等价。注意，这些变量名的大写。</td>
<td>(a &lt; b) 返回 true。</td>
</tr>
<tr>
<td><code>&gt;=</code></td>
<td>大于等于 - 返回x是否大于等于y。</td>
<td>(a &gt;&#x3D; b) 返回 False。</td>
</tr>
<tr>
<td><code>&lt;=</code></td>
<td>小于等于 - 返回x是否小于等于y。</td>
<td>(a &lt;&#x3D; b) 返回 true。</td>
</tr>
</tbody></table>
<h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p>以下假设变量a为10，变量b为20：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D;</td>
<td>简单的赋值运算符</td>
<td>c &#x3D; a + b 将 a + b 的运算结果赋值为 c</td>
</tr>
<tr>
<td>+&#x3D;</td>
<td>加法赋值运算符</td>
<td>c +&#x3D; a 等效于 c &#x3D; c + a</td>
</tr>
<tr>
<td>-&#x3D;</td>
<td>减法赋值运算符</td>
<td>c -&#x3D; a 等效于 c &#x3D; c - a</td>
</tr>
<tr>
<td>*&#x3D;</td>
<td>乘法赋值运算符</td>
<td>c *&#x3D; a 等效于 c &#x3D; c * a</td>
</tr>
<tr>
<td>&#x2F;&#x3D;</td>
<td>除法赋值运算符</td>
<td>c &#x2F;&#x3D; a 等效于 c &#x3D; c &#x2F; a</td>
</tr>
<tr>
<td>%&#x3D;</td>
<td>取模赋值运算符</td>
<td>c %&#x3D; a 等效于 c &#x3D; c % a</td>
</tr>
<tr>
<td><code>**=</code></td>
<td>幂赋值运算符</td>
<td>c **&#x3D; a 等效于 c &#x3D; c ** a</td>
</tr>
<tr>
<td><code>//=</code></td>
<td>取整除赋值运算符</td>
<td>c &#x2F;&#x2F;&#x3D; a 等效于 c &#x3D; c &#x2F;&#x2F; a</td>
</tr>
</tbody></table>
<blockquote>
<p>以上这三类基本和其他语言的运算符没什么区别, 也没有什么地方是需要敲黑板的, 下面介绍的僵尸<code>Python</code>中比较特殊的运算符了</p>
</blockquote>
<h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p>按位运算符是把数字看作二进制来进行计算的。<code>Python</code>中的按位运算法则如下：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;</td>
<td>按位与运算符</td>
<td>(a &amp; b) 输出结果 12 ，二进制解释： 0000 1100</td>
</tr>
<tr>
<td>^</td>
<td>按位异或运算符</td>
<td>(a ^ b) 输出结果 49 ，二进制解释： 0011 0001</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>左移动运算符</td>
<td>a &lt;&lt; 2 输出结果 240 ，二进制解释： 1111 0000</td>
</tr>
</tbody></table>
<blockquote>
<blockquote>
<p>| 	右移动运算符 | 	a &gt;&gt; 2 输出结果 15 ，二进制解释： 0000 1111</p>
</blockquote>
</blockquote>
<p>该运算符的运算方法是: 先将数字转成二进制, 再把二进制的每一位数字进行以上运算符运算, 最后再把结果转成十进制输出, 测试如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 5.位运算符</span></span><br><span class="line">a = <span class="number">60</span>            <span class="comment"># 60 = 0011 1100</span></span><br><span class="line">b = <span class="number">13</span>            <span class="comment"># 13 = 0000 1101</span></span><br><span class="line">c = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运算和输出结果</span></span><br><span class="line">c = a &amp; b        <span class="comment"># 12 = 0000 1100</span></span><br><span class="line">c = a | b        <span class="comment"># 61 = 0011 1101</span></span><br><span class="line">c = a ^ b        <span class="comment"># 49 = 0011 0001</span></span><br><span class="line">c = ~a           <span class="comment"># -61 = 1100 0011</span></span><br><span class="line">c = a &lt;&lt; <span class="number">2</span>       <span class="comment"># 240 = 1111 0000</span></span><br><span class="line">c = a &gt;&gt; <span class="number">2</span>       <span class="comment"># 15 = 0000 1111</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p><code>Python</code>语言支持逻辑运算符，但是与其他语言(<code>Swift</code>)中的逻辑运算符(<code>&amp;, |, !</code>)不同, 注意区别位运算符, 使用时不要用错了, 以下假设变量 a 为 10, b为 20:</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>and</td>
<td>x and y	布尔”与” - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值</td>
<td>(a and b) 返回 20。</td>
</tr>
<tr>
<td>or</td>
<td>x or y	布尔”或”	- 如果 x 是非 0，它返回 x 的值，否则它返回 y 的计算值</td>
<td>(a or b) 返回 10。</td>
</tr>
<tr>
<td>not</td>
<td>not x	布尔”非” - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True</td>
<td>not(a and b) 返回 False</td>
</tr>
</tbody></table>
<h3 id="成员运算符"><a href="#成员运算符" class="headerlink" title="成员运算符"></a>成员运算符</h3><p><code>Python</code>支持成员运算符, 支持字符串，列表或元组</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>in</td>
<td>如果在指定的序列中找到值返回True，否则返回False</td>
<td>x 在 y序列中 , 如果x在y序列中返回True。</td>
</tr>
<tr>
<td>not in</td>
<td>如果在指定的序列中没有找到值返回True，否则返回False</td>
<td>x 不在 y序列中 , 如果x不在y序列中返回True。</td>
</tr>
</tbody></table>
<p>测试示例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 成员运算符</span></span><br><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="number">3</span> <span class="keyword">in</span> list1)         <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">10</span> <span class="keyword">in</span> list1)        <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">10</span> <span class="keyword">not</span> <span class="keyword">in</span> list1)    <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">str1 = <span class="string">&#x27;titanjun&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;jun&#x27;</span> <span class="keyword">in</span> str1)       <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<h3 id="身份运算符"><a href="#身份运算符" class="headerlink" title="身份运算符"></a>身份运算符</h3><p>身份运算符用于比较两个对象的存储单元</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>is</td>
<td>is是判断两个标识符是不是引用自一个对象</td>
<td>x is y, 如果 id(x) 等于 id(y) , is 返回结果 1</td>
</tr>
<tr>
<td>is not</td>
<td>is not是判断两个标识符是不是引用自不同对象</td>
<td>x is not y, 如果 id(x) 不等于 id(y). is not 返回结果 1</td>
</tr>
</tbody></table>
<h3 id="Python运算符优先级"><a href="#Python运算符优先级" class="headerlink" title="Python运算符优先级"></a><code>Python</code>运算符优先级</h3><p>以下表格列出了从最高到最低优先级的所有运算符：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>**</code></td>
<td>指数 (最高优先级)</td>
</tr>
<tr>
<td><code>~, +, -</code></td>
<td>按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@)</td>
</tr>
<tr>
<td><code>*, /, %, //</code></td>
<td>乘，除，取模和取整除</td>
</tr>
<tr>
<td><code>+, -</code></td>
<td>加法减法</td>
</tr>
<tr>
<td><code>&gt;&gt;, &lt;&lt;</code></td>
<td>右移，左移运算符</td>
</tr>
<tr>
<td><code>&amp;</code></td>
<td>位 ‘AND’</td>
</tr>
<tr>
<td>&#96;^,</td>
<td>&#96;</td>
</tr>
<tr>
<td><code>&lt;=, &lt;, &gt;, &gt;=</code></td>
<td>比较运算符</td>
</tr>
<tr>
<td><code>&lt;&gt;, ==, !=</code></td>
<td>等于运算符</td>
</tr>
<tr>
<td><code>=, %=, /=, //=, -=, +=, *=, **=</code></td>
<td>赋值运算符</td>
</tr>
<tr>
<td><code>is, is not</code></td>
<td>身份运算符</td>
</tr>
<tr>
<td><code>in, not in</code></td>
<td>成员运算符</td>
</tr>
<tr>
<td><code>not, or, and</code></td>
<td>逻辑运算符</td>
</tr>
</tbody></table>
<h2 id="条件和循环语句"><a href="#条件和循环语句" class="headerlink" title="条件和循环语句"></a>条件和循环语句</h2><ul>
<li><code>Python</code>程序语言指定任何非0和非空<code>null</code>值为<code>true</code>，0 或者 <code>null</code>为<code>false</code></li>
<li>由于 <code>python</code> 并不支持 <code>switch</code> 语句，所以多个条件判断，只能用 <code>elif</code> 来实现</li>
</ul>
<h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><ul>
<li>if语句的使用和其他语言没什么区别, 主要是格式不一样, 没有大括号, 主要时注意缩进</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 判断条件：</span><br><span class="line">    执行语句……</span><br><span class="line"><span class="keyword">elif</span> 判断条件：</span><br><span class="line">    执行语句……</span><br><span class="line"><span class="keyword">else</span>：</span><br><span class="line">    执行语句……</span><br></pre></td></tr></table></figure>

<p>使用示例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># if-else语句</span></span><br><span class="line"><span class="keyword">if</span> <span class="number">2</span> &gt; <span class="number">3</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;真的&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;假的&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># if-elif语句</span></span><br><span class="line">a = <span class="number">3</span></span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">1</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">elif</span> (a == <span class="number">2</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<h3 id="While循环语句"><a href="#While循环语句" class="headerlink" title="While循环语句"></a>While循环语句</h3><p>与C语言中用法一样, 这里就不在赘述了</p>
<h3 id="for-循环语句"><a href="#for-循环语句" class="headerlink" title="for 循环语句"></a>for 循环语句</h3><p><code>Python</code>中 <code>for</code>循环可以遍历任何序列的项目，如一个列表或者一个字符串。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># for循环</span></span><br><span class="line"><span class="comment"># 输出每一个字符</span></span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> <span class="string">&quot;char&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(s)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用索引</span></span><br><span class="line">list2 = [<span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(list2)):</span><br><span class="line">    <span class="built_in">print</span>(list2[index])</span><br></pre></td></tr></table></figure>

<ul>
<li><p>其中, 函数 <code>len()</code> 返回列表的长度，即元素的个数。 <code>range</code>返回一个序列的数, 这个后面会说到</p>
</li>
<li><p>在 <code>python</code> 中，<code>for … else</code> 表示<code>for</code> 中的语句和普通的没有区别，<code>else</code> 中的语句会在循环正常执行完（即 <code>for</code> 不是通过 <code>break</code> 跳出而中断的）的情况下执行，<code>while … else</code> 也是一样。</p>
</li>
<li><p>对于<code>Python</code>语言, 我也是小白, 正在努力学习中, 文中如有不足之处, 还望多多指教</p>
</li>
<li><p>测试代码详见 <a href="https://github.com/CoderTitan/PythonDemo">GitHub地址</a></p>
</li>
<li><p>后期会持续更新相关文章</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python之错误异常和文件处理</title>
    <url>/post/64abe4fe.html</url>
    <content><![CDATA[<ul>
<li>之前的文章介绍的都是<code>Python</code>的一些语法和使用方法, 详情可参考<a href="https://www.titanjun.top/categories/Python%E5%9F%BA%E7%A1%80/">Python知识</a> </li>
<li>然而这里我们要说的是编程中我们最不想见到的, 但是却也是不得不面对的<code>Bug</code></li>
<li>除此之外, 这里还会介绍一下<code>Python</code>中的文件读取</li>
</ul>
<span id="more"></span>

<h2 id="错误和异常"><a href="#错误和异常" class="headerlink" title="错误和异常"></a>错误和异常</h2><p><code>Python</code> 中（至少）有两种错误：语法错误和异常（<code>syntax errors</code> 和 <code>exceptions</code> ）</p>
<h3 id="语法错误"><a href="#语法错误" class="headerlink" title="语法错误"></a>语法错误</h3><p>语法错误，也被称作解析错误, 使我们在学习<code>Python</code>过程中最常遇到的错误, 来看看下面两个错误示例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="literal">True</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;titan&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 错误信息:</span></span><br><span class="line">File <span class="string">&quot;../5-读文件.py&quot;</span>, line <span class="number">19</span></span><br><span class="line">    <span class="keyword">if</span> <span class="literal">True</span></span><br><span class="line">          ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure>

<ul>
<li>语法分析器指出错误出现的文件(<code>File</code>)和错误行(<code>line 19</code>)</li>
<li>在检测到错误的位置前面显示一个小“箭头”</li>
<li>错误是由箭头前面的标记引起的（或者至少是这么检测的）</li>
<li>此处错误是因为<code>Print</code>函数的前面, <code>if</code>语句后面少了一个冒号(<code>:</code>)</li>
</ul>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><ul>
<li>在没有语法错误的情况下, 当我们执行当前程序的时候也可能会引发错误</li>
<li>运行期检测到的错误称为 异常，并且程序不会无条件的崩溃</li>
<li>异常能够编译通过, 但是不能运行成功; 而语法错误不能编译成功</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">1</span> / <span class="number">0</span>)</span><br><span class="line"><span class="comment"># 错误信息:</span></span><br><span class="line">File <span class="string">&quot;../5-读文件.py&quot;</span>, line <span class="number">22</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span> / <span class="number">0</span>)</span><br><span class="line">ZeroDivisionError: division by zero</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="number">1</span> + <span class="string">&quot;12&quot;</span>)</span><br><span class="line"><span class="comment"># 错误信息:</span></span><br><span class="line">File <span class="string">&quot;../5-读文件.py&quot;</span>, line <span class="number">22</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span> + <span class="string">&quot;12&quot;</span>)</span><br><span class="line">TypeError: unsupported operand <span class="built_in">type</span>(s) <span class="keyword">for</span> +: <span class="string">&#x27;int&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;str&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="number">1</span> + ad * <span class="number">2</span>)</span><br><span class="line"><span class="comment"># 错误信息:</span></span><br><span class="line">File <span class="string">&quot;../5-读文件.py&quot;</span>, line <span class="number">22</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span> + ad * <span class="number">2</span>)</span><br><span class="line">NameError: name <span class="string">&#x27;ad&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br></pre></td></tr></table></figure>

<ul>
<li>错误信息的第一行, 指出了异常出现的文件和错误行</li>
<li>第二行, 提示了是哪一条语句出现了错误</li>
<li>第三行, 指出了是哪一种异常信息;异常也有不同的类型，异常类型做为错误信息的一部分显示出来</li>
<li>以上三种异常分别为: 零除错误(<code>ZeroDivisionError</code>), 类型错误(<code>TypeError</code>) 和 命名错误(<code>NameError</code>)</li>
<li>相关异常信息<a href="https://docs.python.org/3/library/exceptions.html">官方文档</a></li>
</ul>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><ul>
<li>我们都知道, 正常情况下, 程序执行过程中遇到错误或者异常, 程序便会中断执行, 这也就以为着后面的程序将无法执行</li>
<li>但是在<code>Python</code>中, 我们可以针对异常做出一些处理, 使之在遇到异常错误时, 继续执行后面的代码</li>
<li>异常类其实是<code>class</code>类, 所有的错误都是继承自<code>BaseException</code></li>
</ul>
<p>注意: 还有一些错误是无法跳过的, 比如内存错误</p>
<div class='note info'><p>错误处理的语句 </p></div>

<h4 id="第一种格式"><a href="#第一种格式" class="headerlink" title="第一种格式"></a>第一种格式</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 格式:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    语句t</span><br><span class="line"><span class="keyword">except</span> 错误码 <span class="keyword">as</span> e:</span><br><span class="line">    语句<span class="number">1</span></span><br><span class="line"><span class="keyword">except</span> 错误码 <span class="keyword">as</span> e:</span><br><span class="line">    语句<span class="number">2</span></span><br><span class="line"><span class="keyword">except</span> 错误码 <span class="keyword">as</span> e:</span><br><span class="line">    语句<span class="number">3</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">except</span> 错误码 <span class="keyword">as</span> e:</span><br><span class="line">    语句n</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    语句e</span><br></pre></td></tr></table></figure>

<div class='note warning'><p>需要注意的是: </p></div>

<ul>
<li>语句中的<code>else</code>是可有可无的</li>
<li><code>except</code>语句中的<code>as e</code>也可以不加</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 错误处理的语句(else可有可无)</span></span><br><span class="line"><span class="keyword">try</span>.......<span class="keyword">except</span>....<span class="keyword">else</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式:</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    语句t</span><br><span class="line"><span class="keyword">except</span> 错误码<span class="number">1</span>:</span><br><span class="line">    语句<span class="number">1</span></span><br><span class="line"><span class="keyword">except</span> 错误码<span class="number">2</span>:</span><br><span class="line">    语句<span class="number">2</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    语句<span class="number">3</span></span><br></pre></td></tr></table></figure>

<h4 id="第二种格式"><a href="#第二种格式" class="headerlink" title="第二种格式"></a>第二种格式</h4><p>一个 <code>except</code> 子句可以在括号中列出多个异常的名字, 对于指定的一些异常做统一处理</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">7</span> / <span class="number">0</span>)</span><br><span class="line"><span class="keyword">except</span> (ZeroDivisionError, NameError):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;程序异常&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="第三种格式"><a href="#第三种格式" class="headerlink" title="第三种格式"></a>第三种格式</h4><p>无论遇到的是哪一种异常, 均做统一处理</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">7</span> / <span class="number">0</span>)</span><br><span class="line"><span class="keyword">except</span> :</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;程序异常&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="try-语句工作方式"><a href="#try-语句工作方式" class="headerlink" title="try 语句工作方式"></a><code>try</code> 语句工作方式</h4><ul>
<li>首先，执行 <code>try</code> 子句 （在 <code>try</code> 和 <code>except</code> 关键字之间的部分）</li>
<li>如果没有异常发生， <code>except</code> 子句 在 <code>try</code> 语句执行完毕后就被忽略了</li>
<li>如果在 <code>try</code> 子句执行过程中发生了异常，那么该子句其余的部分就会被忽略</li>
<li>如果异常匹配于 <code>except</code> 关键字后面指定的异常类型，就执行对应的<code>except</code>子句。然后继续执行 <code>try</code> 语句之后的代码</li>
<li>如果发生了一个异常，在 <code>except</code> 子句中没有与之匹配的分支，它就会传递到上一级 <code>try</code> 语句中</li>
<li>如果最终仍找不到对应的处理语句，它就成为一个 未处理异常，终止程序运行，显示提示信息</li>
</ul>
<h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例:"></a>使用示例:</h4><p>一个 <code>try</code> 语句可能包含多个 <code>except</code> 子句，分别指定处理不同的异常。至多只会有一个分支被执行。异常处理程序只会处理对应的 <code>try</code> 子句中发生的异常，在同一个 <code>try</code> 语句中，其他子句中发生的异常则不作处理</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">7</span> / <span class="number">0</span>)</span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;除数为0&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> NameError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;没有改变量&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> SyntaxError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;不知道&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>一个 <code>except</code> 子句可以在括号中列出多个异常的名字</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">try:</span><br><span class="line">    print(<span class="number">7</span> / <span class="number">0</span>)</span><br><span class="line">except (ZeroDivisionError, NameError):</span><br><span class="line">    print(<span class="string">&#x27;程序异常&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>最后一个 <code>except</code> 子句可以省略异常名称，以作为通配符使用。你需要慎用此法，因为它会轻易隐藏一个实际的程序错误！可以使用这种方法打印一条错误信息，然后重新抛出异常（允许调用者处理这个异常):</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">&#x27;myfile.txt&#x27;</span>)</span><br><span class="line">    s = f.readline()</span><br><span class="line">    i = <span class="built_in">int</span>(s.strip())</span><br><span class="line"><span class="keyword">except</span> OSError <span class="keyword">as</span> err:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;OS error: &#123;0&#125;&quot;</span>.<span class="built_in">format</span>(err))</span><br><span class="line"><span class="keyword">except</span> ValueError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Could not convert data to an integer.&quot;</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Unexpected error:&quot;</span>, sys.exc_info()[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">raise</span></span><br></pre></td></tr></table></figure>

<p><code>try … except</code> 语句可以带有一个 else子句，该子句只能出现在所有 except 子句之后。当 try 语句没有抛出异常时，需要执行一些代码，可以使用这个子句。例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">7</span> / <span class="number">0</span>)</span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;除数为0&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> NameError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;没有改变量&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;代码OK&#x27;</span>)</span><br></pre></td></tr></table></figure>


<h3 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h3><p><code>raise</code>语句允许程序员强制抛出一个指定的异常</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">raise</span> NameError(<span class="string">&#x27;TitanJun&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 异常信息:</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;../1-异常处理.py&quot;</span>, line <span class="number">95</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">raise</span> NameError(<span class="string">&#x27;TitanJun&#x27;</span>)</span><br><span class="line">NameError: TitanJun</span><br></pre></td></tr></table></figure>

<p>如果你需要明确一个异常是否抛出，但不想处理它，<code>raise</code> 语句可以让你很简单的重新抛出该异常:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">raise</span> NameError(<span class="string">&#x27;TitanJun&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> NameError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;NameError错误&#x27;</span>)</span><br><span class="line">    <span class="keyword">raise</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 错误信息:</span></span><br><span class="line">NameError错误</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;../1-异常处理.py&quot;</span>, line <span class="number">97</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">raise</span> NameError(<span class="string">&#x27;TitanJun&#x27;</span>)</span><br><span class="line">NameError: TitanJun</span><br></pre></td></tr></table></figure>


<h3 id="定义清理行为"><a href="#定义清理行为" class="headerlink" title="定义清理行为"></a>定义清理行为</h3><ul>
<li><code>try</code> 语句还有另一个可选的子句: <code>try--except--finally</code>，目的在于定义在任何情况下都一定要执行的功能</li>
<li>不管有没有发生异常，<code>finally</code>子句 在程序离开 <code>try</code> 后都一定会被执行</li>
<li>当 <code>try</code> 语句中发生了未被 <code>except</code> 捕获的异常（或者它发生在 <code>except</code> 或 <code>else</code> 子句中），在 <code>finally</code> 子句执行完后它会被重新抛出。 - <code>try </code>语句经由 <code>break</code>，<code>continue</code> 或 <code>return</code> 语句退 出也一样会执行 <code>finally</code> 子句</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">7</span> / <span class="number">0</span>)</span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;除数为0&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> NameError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;没有改变量&#x27;</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;我一定要执行&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 输出:</span></span><br><span class="line">除数为<span class="number">0</span></span><br><span class="line">我一定要执行</span><br></pre></td></tr></table></figure>

<h3 id="预定义清理行为"><a href="#预定义清理行为" class="headerlink" title="预定义清理行为"></a>预定义清理行为</h3><p>有些对象定义了标准的清理行为，无论对象操作是否成功，不再需要该对象的时候就会起作用。以下示例尝试打开文件并把内容打印到屏幕上</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">open</span>(<span class="string">&quot;myfile.txt&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(line)</span><br></pre></td></tr></table></figure>

<p>这段代码的问题在于在代码执行完后没有立即关闭打开的文件。这在简单的脚本里没什么，但是大型应用程序就会出问题。<code>with</code> 语句使得文件之类的对象可以 确保总能及时准确地进行清理</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;myfile.txt&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        <span class="built_in">print</span>(line)</span><br></pre></td></tr></table></figure>

<p>语句执行后，文件 <code>f</code> 总会被关闭，即使是在处理文件中的数据时出错也一样。其它对象是否提供了预定义的清理行为要查看它们的文档</p>
<h2 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h2><ul>
<li>在<code>Python</code>中文件的读写, 通常以文本打开，这意味着，你从文件读出和向文件写入的字符串会被特定的编码方式（默认是UTF-8）编码。</li>
<li>模式后面的 <code>&#39;b&#39;</code> 以 二进制模式 打开文件：数据会以字节对象的形式读出和写入。</li>
<li>这种模式应该用于所有不包含文本的文件</li>
</ul>
<h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><p>函数 <code>open()</code> 返回文件对象，通常的用法需要两个参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">open</span>(<span class="params">file, mode=<span class="string">&#x27;r&#x27;</span>, buffering=<span class="literal">None</span>, encoding=<span class="literal">None</span>, errors=<span class="literal">None</span>, newline=<span class="literal">None</span>, closefd=<span class="literal">True</span></span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用</span></span><br><span class="line">path = <span class="string">r&#x27;/Users/xxx/text.txt&#x27;</span></span><br><span class="line">file = <span class="built_in">open</span>(path, <span class="string">&#x27;r&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>参数一: 一个含有文件名的字符串</li>
<li>参数二: 描述如何使用该文件的字符串, 默认为 <code>&#39;r&#39;</code><ul>
<li><code>&#39;r&#39;</code>: 时表示只是读取文件</li>
<li><code>&#39;rb&#39;</code>: 以二进制形式打开一个文件用于只读, 文件描述放在文件的开头</li>
<li><code>&#39;w&#39;</code>: 表示只是写入文件（已经存在的同名文件将被删掉)</li>
<li><code>&#39;wb&#39;</code>: 打开一个文件用于写入二进制, 如果该文件已经存在会覆盖, 如果不存在则创建新文件</li>
<li><code>&#39;w+&#39;</code>: 打开一个文件用于读写</li>
<li><code>&#39;a&#39;</code>: 表示打开文件进行追加，写入到文件中的任何数据将自动添加到末尾</li>
<li><code>&#39;r+&#39;</code>: 表示打开文件进行读取和写入</li>
<li><code>&#39;b&#39;</code>: 以 二进制模式 打开文件</li>
</ul>
</li>
</ul>
<h3 id="文件对象方法"><a href="#文件对象方法" class="headerlink" title="文件对象方法"></a>文件对象方法</h3><h4 id="read"><a href="#read" class="headerlink" title="read()"></a>read()</h4><ul>
<li>要读取文件内容，需要调用 <code>file.read(size)</code>，该方法读取若干数量的数据并以字符串形式返回其内容</li>
<li><code>size</code> 是可选的数值，指定字符串长度, 如果没有指定 <code>size</code> 或者指定为负数，就会读取并返回整个文件。</li>
<li>当文件大小为当前机器内存两倍时，就会产生问题。反之，会尽可能按比较大的 <code>size</code> 读取和返回数据。</li>
<li>如果到了文件末尾，<code>file.read()</code>会返回一个空字符串</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 读取文件</span></span><br><span class="line"><span class="built_in">str</span> = file.read()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>)</span><br></pre></td></tr></table></figure>

<h4 id="readline"><a href="#readline" class="headerlink" title="readline()"></a>readline()</h4><ul>
<li><code>file.readline()</code> 从文件中读取单独一行，字符串结尾会自动加上一个换行符（<code>\n</code>），只有当文件最后一行没有以换行符结尾时，这一操作才会被忽略。</li>
<li>这样返回值就不会有混淆，如果 <code>file.readline()</code> 返回一个空字符串，那就表示到达了文件末尾，如果是一个空行，就会描述为 <code>&#39;\n&#39;</code>，一个只包含换行符的字符串</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">file.readline()</span><br></pre></td></tr></table></figure>

<h4 id="遍历文件对象"><a href="#遍历文件对象" class="headerlink" title="遍历文件对象"></a>遍历文件对象</h4><p>可以循环遍历文件对象来读取文件中的每一行。这是一种内存高效、快速，并且代码简介的方式</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> file:</span><br><span class="line">    print(line)</span><br></pre></td></tr></table></figure>

<div class='note primary'><p>如果你想把文件中的所有行读到一个列表中，你也可以使用 `list(file)` 或者 `file.readlines()`</p></div>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 把文件读到列表中</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(file))</span><br><span class="line"><span class="built_in">print</span>(file.readlines())</span><br></pre></td></tr></table></figure>

<h4 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h4><ul>
<li><code>write</code>: 将 <code>string</code> 的内容写入文件，并返回写入字符的长度</li>
<li><code>writelines</code>: 用于向文件中写入一序列的字符串, 没有返回值</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 写入文件</span></span><br><span class="line">leng = file.write(<span class="string">&#x27;我是一只小鸭子&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(leng)</span><br><span class="line"><span class="comment"># 输出: 7</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入一个序列</span></span><br><span class="line">file.writelines([<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;Python&#x27;</span>])</span><br></pre></td></tr></table></figure>

<div class='note warning'><p>想要写入其他非字符串内容，首先要将它转换为字符串</p></div>


<h4 id="tell-x2F-seek"><a href="#tell-x2F-seek" class="headerlink" title="tell&#x2F;seek"></a>tell&#x2F;seek</h4><ul>
<li><code>tell</code>: 返回一个整数，代表文件对象在文件中的指针位置，该数值计量了自文件开头到指针处的比特数。</li>
<li>需要改变文件对象指针话话，使用 <code>file.seek(offset,from_what)</code>。</li>
<li>指针在该操作中从指定的引用位置移动 <code>offset</code> 比特，引用位置由 <code>from_what</code> 参数指定。 </li>
<li><code>from_what</code> 值为 0 表示自文件起始处开始，1 表示自当前文件指针位置开始，2 表示自文件末尾开始。</li>
<li><code>from_what</code> 可以忽略，其默认值为零，此时从文件头开始</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l = file.readline()</span><br><span class="line"><span class="built_in">print</span>(l)</span><br><span class="line"></span><br><span class="line">pos = file.tell()</span><br><span class="line"><span class="built_in">print</span>(pos)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出:</span></span><br><span class="line"><span class="string">b&#x27;https://www.titanjun.top/\n&#x27;</span></span><br><span class="line"><span class="number">26</span></span><br></pre></td></tr></table></figure>

<p>重新设置文件读取指针到开头</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">file.seek(<span class="number">5</span>, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(file.readline())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出:</span></span><br><span class="line"><span class="string">b&#x27;https://www.titanjun.top/\n&#x27;</span></span><br><span class="line"><span class="string">b&#x27;://www.titanjun.top/\n&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="close"><a href="#close" class="headerlink" title="close"></a>close</h4><ul>
<li>当你使用完一个文件时，调用 <code>file.close()</code> 方法就可以关闭它并释放其占用的所有系统资源。 </li>
<li>在调用 <code>file.close()</code> 方法后，试图再次使用文件对象将会自动失败</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">file.close()</span><br><span class="line"></span><br><span class="line">file.read()</span><br><span class="line"></span><br><span class="line">File <span class="string">&quot;../5-读文件.py&quot;</span>, line <span class="number">64</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    file.read()</span><br><span class="line">ValueError: read of closed file</span><br></pre></td></tr></table></figure>

<h4 id="关键字with"><a href="#关键字with" class="headerlink" title="关键字with"></a>关键字<code>with</code></h4><ul>
<li>用关键字 <code>with</code> 处理文件对象是个好习惯。</li>
<li>它的先进之处在于文件用完后会自动关闭，就算发生异常也没关系。</li>
<li>它是 <code>try-finally</code> 块的简写</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(path, <span class="string">&#x27;rb+&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    <span class="built_in">str</span> = file.read()</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>)</span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python之高阶函数</title>
    <url>/post/7f54d88f.html</url>
    <content><![CDATA[<ul>
<li>做过<code>Swift</code>开发的童鞋都知道, 在<code>Swift</code>中有许多的高阶函数(<code>Map</code>, <code>Filter</code>, <code>Reduce</code>, <code>Zip</code>等), 这些在开发中让我们节省大量代码</li>
<li><code>Python</code>中同样有许多的内置函数, 但是这里也只介绍几个常用的高阶函数</li>
</ul>
<span id="more"></span>


<h3 id="map映射"><a href="#map映射" class="headerlink" title="map映射"></a><code>map</code>映射</h3><p>根据提供的函数对指定序列做映射, 并返回映射后的序列</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>(function, iterable, ...)</span><br></pre></td></tr></table></figure>

<h4 id="参数-x2F-返回值"><a href="#参数-x2F-返回值" class="headerlink" title="参数&#x2F;返回值"></a>参数&#x2F;返回值</h4><ul>
<li><code>function</code> – 函数, 序列中的每个元素需要执行的操作, 可以是匿名函数</li>
<li><code>iterable</code> – 一个或多个序列</li>
<li><code>Python 2.x</code>中返回列表, <code>Python 3.x</code>中返回<code>map</code>类</li>
</ul>
<h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 调用外部函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">square</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line">res = <span class="built_in">map</span>(square, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(res))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用匿名函数</span></span><br><span class="line">res1 = <span class="built_in">map</span>(<span class="keyword">lambda</span> x: x * <span class="number">3</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(res1))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用内置函数</span></span><br><span class="line">res2 = <span class="built_in">map</span>(<span class="built_in">str</span>, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(res2))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多个序列</span></span><br><span class="line">res3 = <span class="built_in">map</span>(<span class="keyword">lambda</span> x, y: x * y, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(res3))</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;输出结果</span></span><br><span class="line"><span class="string">&lt;map object at 0x1041a5da0&gt;</span></span><br><span class="line"><span class="string">[1, 4, 9, 16]</span></span><br><span class="line"><span class="string">[3, 6, 9, 12]</span></span><br><span class="line"><span class="string">[&#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;]</span></span><br><span class="line"><span class="string">[3, 4, 12, 4]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>


<h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a><code>reduce</code></h3><ul>
<li>函数会对参数序列中元素进行累积</li>
<li>函数将集合中的所有数据进行下列操作：用传给<code>educe</code>中的函数<code>function</code>先对集合中的第1、2个元素进行操作，得到的结果再与第三个数据用<code>function</code>函数运算，最后得到一个结果</li>
<li>在<code>Python3</code>中，<code>reduce</code>函数已经被从全局名字空间里移除了，它现在被放置在<code>fucntools</code>模块里，如果想要使用它，则需要通过引入<code>functools</code>模块来调用<code>reduce</code>函数</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">reduce(function, iterable[, initializer])</span><br></pre></td></tr></table></figure>

<h4 id="参数-x2F-返回值-1"><a href="#参数-x2F-返回值-1" class="headerlink" title="参数&#x2F;返回值"></a>参数&#x2F;返回值</h4><ul>
<li><code>function</code> – 函数, 序列中的每个元素需要执行的操作, 可以是匿名函数</li>
<li><code>iterable</code> – 需要执行操作的序列</li>
<li><code>initializer</code> – 可选，初始参数</li>
<li>最后返回函数的计算结果, 和初始参数类型相同</li>
</ul>
<h4 id="使用示例-1"><a href="#使用示例-1" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 求元素的和</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mySum</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">red = reduce(mySum, list1)</span><br><span class="line"><span class="built_in">print</span>(red)</span><br><span class="line"></span><br><span class="line">red2 = reduce(mySum, list1, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(red2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 匿名函数</span></span><br><span class="line">red3 = reduce(<span class="keyword">lambda</span> x, y: x * y, list1)</span><br><span class="line"><span class="built_in">print</span>(red3)</span><br><span class="line"></span><br><span class="line">red4 = reduce(<span class="keyword">lambda</span> x, y: x * y, list1, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(red4)</span><br><span class="line"></span><br><span class="line">red5 = reduce(<span class="keyword">lambda</span> x, y: x + y, [<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>], <span class="string">&#x27;数字: &#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(red5)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;输出结果:</span></span><br><span class="line"><span class="string">10</span></span><br><span class="line"><span class="string">12</span></span><br><span class="line"><span class="string">24</span></span><br><span class="line"><span class="string">72</span></span><br><span class="line"><span class="string">数字: 1234</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>


<h3 id="filter过滤"><a href="#filter过滤" class="headerlink" title="filter过滤"></a><code>filter</code>过滤</h3><p>用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">filter</span>(function, iterable)</span><br></pre></td></tr></table></figure>

<h4 id="参数-x2F-返回值-2"><a href="#参数-x2F-返回值-2" class="headerlink" title="参数&#x2F;返回值"></a>参数&#x2F;返回值</h4><ul>
<li><code>function</code> – 过滤操作执行的函数</li>
<li><code>iterable</code> – 需要过滤的序列</li>
<li>序列的每个元素作为参数传递给函数进行判，然后返回<code>True</code>或<code>False</code>，最后将返回<code>True</code>的元素放到新列表中</li>
<li><code>Python 2.x</code>中返回的是过滤后的列表, 而<code>Python 3.x</code>中返回到是一个<code>filter</code>类</li>
</ul>
<h4 id="使用示例-2"><a href="#使用示例-2" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">isOdd</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">list2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">fil0 = <span class="built_in">filter</span>(isOdd, list2)</span><br><span class="line"><span class="built_in">print</span>(fil0)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(fil0))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 匿名函数</span></span><br><span class="line">fil = <span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x % <span class="number">2</span> == <span class="number">0</span>, list2)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(fil))</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;输出结果:</span></span><br><span class="line"><span class="string">&lt;filter object at 0x1039e20f0&gt;</span></span><br><span class="line"><span class="string">[1, 3, 5]</span></span><br><span class="line"><span class="string">[2, 4, 6]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>


<h3 id="sorted排序"><a href="#sorted排序" class="headerlink" title="sorted排序"></a><code>sorted</code>排序</h3><ul>
<li>在列表中有一个内置的排序函数<code>sort()</code>, 对列表的对象进行排序, 没有返回值</li>
<li><code>sorted()</code>函数对所有可迭代的对象进行排序操作</li>
<li><code>sort</code>与<code>sorted</code>区别：<ul>
<li><code>sort</code>是应用在<code>list</code>上的方法，<code>sorted</code>可以对所有可迭代的对象进行排序操作。</li>
<li><code>list</code>的<code>sort</code>方法返回的是对已经存在的列表进行操作，而内建函数<code>sorted</code>方法返回的是一个新的<code>list</code>，而不是在原来的基础上进行的操作</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span>.sort(cmp=<span class="literal">None</span>, key=<span class="literal">None</span>, reverse=<span class="literal">False</span>)</span><br><span class="line"><span class="built_in">sorted</span>(iterable[, cmp[, key[, reverse]]])</span><br></pre></td></tr></table></figure>

<h4 id="参数-x2F-返回值-3"><a href="#参数-x2F-返回值-3" class="headerlink" title="参数&#x2F;返回值"></a>参数&#x2F;返回值</h4><ul>
<li><code>iterable</code> – 可迭代对象</li>
<li><code>cmp</code> – 比较的函数，这个具有两个参数，参数的值都是从可迭代对象中取出，此函数必须遵守的规则为，大于则返回1，小于则返回-1，等于则返回0。</li>
<li><code>key</code> – 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。</li>
<li><code>reverse</code> – 排序规则，<code>reverse = True</code>降序，<code>reverse = False</code>升序(默认）</li>
<li><code>sort</code>没有返回值, <code>sorted</code>返回重新排序的列表</li>
</ul>
<h4 id="使用示例-3"><a href="#使用示例-3" class="headerlink" title="使用示例"></a>使用示例</h4><p>使用<code>sort()</code>排序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用sort</span></span><br><span class="line">list3 = [<span class="number">3</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">4</span>]</span><br><span class="line">list3.sort()</span><br><span class="line"><span class="built_in">print</span>(list3)</span><br><span class="line"></span><br><span class="line">aList = [<span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Taobao&#x27;</span>, <span class="string">&#x27;Facebook&#x27;</span>]</span><br><span class="line">aList.sort(reverse=<span class="literal">True</span>) <span class="comment"># 降序</span></span><br><span class="line"><span class="built_in">print</span>(aList)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">takeSecond</span>(<span class="params">elem</span>):</span><br><span class="line">    <span class="keyword">return</span> elem[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">random = [(<span class="number">2</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">4</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">3</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定第二个元素排序</span></span><br><span class="line">random.sort(key=takeSecond)</span><br><span class="line"><span class="built_in">print</span>(random)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;输出结果:</span></span><br><span class="line"><span class="string">[0, 2, 3, 4, 5, 7]</span></span><br><span class="line"><span class="string">[&#x27;Taobao&#x27;, &#x27;Runoob&#x27;, &#x27;Google&#x27;, &#x27;Facebook&#x27;, &#x27;123&#x27;]</span></span><br><span class="line"><span class="string">[(4, 1), (2, 2), (1, 3), (3, 4)]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>使用<code>sorted()</code>函数排序时</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list4 = <span class="built_in">sorted</span>(list3)</span><br><span class="line"><span class="built_in">print</span>(list4)</span><br><span class="line"></span><br><span class="line"><span class="comment">#按绝对值大小排序</span></span><br><span class="line">list5 = [<span class="number">4</span>,-<span class="number">7</span>,<span class="number">2</span>,<span class="number">6</span>,-<span class="number">3</span>]</span><br><span class="line"><span class="comment">#key接受函数来实现自定义排序规则</span></span><br><span class="line">list6 = <span class="built_in">sorted</span>(list5, key=<span class="built_in">abs</span>)</span><br><span class="line"><span class="built_in">print</span>(list6)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将序排列</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(list5, key=<span class="built_in">abs</span>, reverse=<span class="literal">True</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#函数可以自己写</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">myLen</span>(<span class="params"><span class="built_in">str</span></span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(<span class="built_in">str</span>)</span><br><span class="line"></span><br><span class="line">list7 = [<span class="string">&#x27;b333&#x27;</span>,<span class="string">&#x27;a1111111&#x27;</span>,<span class="string">&#x27;c22&#x27;</span>,<span class="string">&#x27;d5554&#x27;</span>]</span><br><span class="line">list8 = <span class="built_in">sorted</span>(list7, key=myLen) <span class="comment"># 默认升序排序</span></span><br><span class="line"><span class="built_in">print</span>(list8)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 匿名函数</span></span><br><span class="line">list9 = <span class="built_in">sorted</span>(list7, key=<span class="keyword">lambda</span> x: <span class="built_in">len</span>(x), reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(list9)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;输出结果:</span></span><br><span class="line"><span class="string">[0, 2, 3, 4, 5, 7]</span></span><br><span class="line"><span class="string">[2, -3, 4, 6, -7]</span></span><br><span class="line"><span class="string">[-7, 6, 4, -3, 2]</span></span><br><span class="line"><span class="string">[&#x27;c22&#x27;, &#x27;b333&#x27;, &#x27;d5554&#x27;, &#x27;a1111111&#x27;]</span></span><br><span class="line"><span class="string">[&#x27;a1111111&#x27;, &#x27;d5554&#x27;, &#x27;b333&#x27;, &#x27;c22&#x27;]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="enumerate"><a href="#enumerate" class="headerlink" title="enumerate"></a><code>enumerate</code></h3><ul>
<li>用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在<code>for</code>循环当中</li>
<li><code>Python 2.3</code>以上版本可用，<code>2.6</code>添加<code>start</code>参数</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">enumerate</span>(sequence, [start=<span class="number">0</span>])</span><br></pre></td></tr></table></figure>

<h4 id="参数-x2F-返回值-4"><a href="#参数-x2F-返回值-4" class="headerlink" title="参数&#x2F;返回值"></a>参数&#x2F;返回值</h4><ul>
<li><code>sequence</code> – 一个序列、迭代器或其他支持迭代对象</li>
<li><code>start</code> – 下标起始位置</li>
<li>函数返回<code>enumerate</code>(枚举) 对象</li>
</ul>
<h4 id="使用示例-4"><a href="#使用示例-4" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">seasons = [<span class="string">&#x27;Spring&#x27;</span>, <span class="string">&#x27;Summer&#x27;</span>, <span class="string">&#x27;Fall&#x27;</span>, <span class="string">&#x27;Winter&#x27;</span>]</span><br><span class="line">sea1 = <span class="built_in">enumerate</span>(seasons)</span><br><span class="line"><span class="built_in">print</span>(sea1)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(sea1))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义起始索引</span></span><br><span class="line">sea2 = <span class="built_in">list</span>(<span class="built_in">enumerate</span>(seasons, start=<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(sea2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 普通的 for 循环</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> seasons:</span><br><span class="line">     <span class="built_in">print</span>(i, seasons[i])</span><br><span class="line">     i +=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># for 循环使用 enumerate</span></span><br><span class="line"><span class="keyword">for</span> i, ele <span class="keyword">in</span> <span class="built_in">enumerate</span>(seasons):</span><br><span class="line">    <span class="built_in">print</span>(i, ele)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;输出结果:</span></span><br><span class="line"><span class="string">&lt;enumerate object at 0x103a46438&gt;</span></span><br><span class="line"><span class="string">[(0, &#x27;Spring&#x27;), (1, &#x27;Summer&#x27;), (2, &#x27;Fall&#x27;), (3, &#x27;Winter&#x27;)]</span></span><br><span class="line"><span class="string">[(1, &#x27;Spring&#x27;), (2, &#x27;Summer&#x27;), (3, &#x27;Fall&#x27;), (4, &#x27;Winter&#x27;)]</span></span><br><span class="line"><span class="string">0 Spring</span></span><br><span class="line"><span class="string">1 Summer</span></span><br><span class="line"><span class="string">2 Fall</span></span><br><span class="line"><span class="string">3 Winter</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0 Spring</span></span><br><span class="line"><span class="string">1 Summer</span></span><br><span class="line"><span class="string">2 Fall</span></span><br><span class="line"><span class="string">3 Winter</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="zip"><a href="#zip" class="headerlink" title="zip"></a><code>zip</code></h3><ul>
<li>用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的对象，这样做的好处是节约了不少的内存</li>
<li>如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同</li>
<li>函数有一个参数, 接受一个或多个序列</li>
<li>函数利用<code>*</code>号操作符，可以将元组解压为列表</li>
<li><code>zip</code>方法在<code>Python 2.x</code>中返回一个列表, 在<code>Python 3.x</code>中返回一个对象</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">zip</span>([iterable, ...])</span><br></pre></td></tr></table></figure>

<h4 id="使用示例-5"><a href="#使用示例-5" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">c = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">zip1 = <span class="built_in">zip</span>(a, b)</span><br><span class="line"><span class="built_in">print</span>(zip1)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(zip1))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 两个列表不同元素个数, 元素个数与最短的列表一致</span></span><br><span class="line">zip2 = <span class="built_in">zip</span>(a, c)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(zip2))</span><br><span class="line"></span><br><span class="line"><span class="comment"># `*`号操作符，可以将元组解压为列表</span></span><br><span class="line">a1, c1 = <span class="built_in">zip</span>(*<span class="built_in">zip</span>(a, c))</span><br><span class="line"><span class="built_in">print</span>(a1)</span><br><span class="line"><span class="built_in">print</span>(c1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;输出结果:</span></span><br><span class="line"><span class="string">&lt;zip object at 0x103a41408&gt;</span></span><br><span class="line"><span class="string">[(1, &#x27;a&#x27;), (2, &#x27;b&#x27;), (3, &#x27;c&#x27;)]</span></span><br><span class="line"><span class="string">[(1, 4), (2, 5), (3, 6)]</span></span><br><span class="line"><span class="string">(1, 2, 3)</span></span><br><span class="line"><span class="string">(4, 5, 6)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>


<h3 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a><code>reverse</code></h3><ul>
<li><code>reverse()</code>函数用于将列表中的元素反向排列</li>
<li>该函数没有参数没有返回值</li>
<li>使用示例如下</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list31 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">list31.reverse()</span><br><span class="line"><span class="built_in">print</span>(list31)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出:</span></span><br><span class="line">[<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure>















]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python数据类型详解01</title>
    <url>/post/8d410658.html</url>
    <content><![CDATA[<ul>
<li><code>Python</code>（英语发音：<code>/ˈpaɪθən/</code>）, 是一种面向对象、解释型计算机程序设计语言，由<code>Guido van Rossum</code>于1989年发明，第一个公开发行版发行于1991年。</li>
<li><code>Python</code>是纯粹的自由软件， 源代码和解释器<code>CPython</code>遵循 <code>GPL(GNU General Public License)</code>协议 。</li>
<li>Python语法简洁清晰，特色之一是强制用空白符(white space)作为语句缩进<ul>
<li><code>Python</code> 是一种解释型语言： 这意味着开发过程中没有了编译这个环节。类似于PHP和Perl语言</li>
<li><code>Python</code> 是交互式语言： 这意味着，您可以在一个<code>Python</code>提示符，直接互动执行写你的程序</li>
<li><code>Python</code> 是面向对象语言: 这意味着<code>Python</code>支持面向对象的风格或代码封装在对象的编程技术</li>
<li><code>Python</code>是初学者的语言：<code>Python</code> 对初级程序员而言，是一种伟大的语言，它支持广泛的应用程序开发，从简单的文字处理到 WWW 浏览器再到游戏</li>
</ul>
</li>
</ul>
<span id="more"></span>

<h2 id="Mac系统下搭建Python环境"><a href="#Mac系统下搭建Python环境" class="headerlink" title="Mac系统下搭建Python环境"></a>Mac系统下搭建<code>Python</code>环境</h2><ul>
<li>首先到<a href="https://www.python.org/download">Python官网</a> 下载安装最新版本的<code>Python</code>, 安装比较无脑,一路按下去就OK<ul>
<li>具体可参考<a href="https://www.cnblogs.com/code-juggler/p/6344646.html">在Mac OS上搭建Python的开发环境</a></li>
</ul>
</li>
<li>安装<code>Python</code>开发软件, 推荐两款开发软件<code>Pycharm</code>和<code>Sublime Text</code>, 这里只介绍<code>Pycharm</code>的安装和破解方法<ul>
<li>首先到<a href="http://www.pc6.com/mac/500474.html">这里下载</a><code>Pycharm</code>软件</li>
<li>然后<a href="https://blog.csdn.net/u014044812/article/details/78727496">到这里</a>找软件的相关破解方法</li>
</ul>
</li>
<li><code>Python</code>的开发环境和开发软件都搞定之后,下面我们就来看看<code>Python</code>的基本语法吧</li>
<li>测试代码详见 <a href="https://github.com/CoderTitan/PythonDemo">GitHub地址</a></li>
</ul>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p><code>Python</code>的输出语法和<code>Swift</code>的输出一样</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello Python&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ul>
<li><code>python</code>中单行注释采用 # 开头。</li>
<li><code>python</code> 中多行注释使用三个单引号 <code>&#39;&#39;&#39;</code> 或三个双引号 <code>&quot;&quot;&quot;</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 这里是单行注释</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">这是多行注释，使用单引号。</span></span><br><span class="line"><span class="string">这是多行注释，使用单引号。</span></span><br><span class="line"><span class="string">这是多行注释，使用单引号。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">这是多行注释，使用双引号。</span></span><br><span class="line"><span class="string">这是多行注释，使用双引号。</span></span><br><span class="line"><span class="string">这是多行注释，使用双引号。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p><code>Python</code>中的变量不需要声明，变量的赋值操作既是变量声明和定义的过程。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">counter = <span class="number">100</span> <span class="comment"># 赋值整型变量</span></span><br><span class="line">miles = <span class="number">1000.0</span> <span class="comment"># 浮点型</span></span><br><span class="line">name = <span class="string">&quot;John&quot;</span> <span class="comment"># 字符串</span></span><br></pre></td></tr></table></figure>

<p>Python允许你同时为多个变量赋值, 也可以为多个对象指定多个变量。例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = b = c = <span class="number">1</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 多变量赋值</span></span><br><span class="line">a, b, c = <span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;jun&quot;</span> </span><br></pre></td></tr></table></figure>

<h2 id="标准数据类型"><a href="#标准数据类型" class="headerlink" title="标准数据类型"></a>标准数据类型</h2><ul>
<li><code>Python</code>有五个标准的数据类型：<ul>
<li><code>Numbers</code>（数字）</li>
<li><code>String</code>（字符串）</li>
<li><code>List</code>（列表）</li>
<li><code>Tuple</code>（元组）</li>
<li><code>Dictionary</code>（字典）</li>
</ul>
</li>
</ul>
<h3 id="Numbers（数字）"><a href="#Numbers（数字）" class="headerlink" title="Numbers（数字）"></a><code>Numbers</code>（数字）</h3><ul>
<li><code>Number</code>是不可被改变的数据类型, 当你指定一个值时，<code>Number</code>对象就会被创建</li>
<li><code>Python</code>支持四种不同的数值类型：<ul>
<li><code>int</code>（有符号整型）</li>
<li><code>long</code>（长整型[也可以代表八进制和十六进制]）</li>
<li><code>float</code>（浮点型）</li>
<li><code>complex</code>（复数）</li>
</ul>
</li>
<li>复数: 和数学中的复数含义一样, 复数由实数部分和虚数部分构成，可以用<code>a + bj</code>, 或者<code>complex(a, b)</code>表示， 复数的实部a和虚部b都是浮点型</li>
</ul>
<table>
<thead>
<tr>
<th>int</th>
<th>long</th>
<th>float</th>
<th>complex</th>
</tr>
</thead>
<tbody><tr>
<td>10</td>
<td>51924361L</td>
<td>0.0</td>
<td>3.14j</td>
</tr>
<tr>
<td>100</td>
<td>-0x19323L</td>
<td>15.20</td>
<td>45.j</td>
</tr>
<tr>
<td>-786</td>
<td>0122L</td>
<td>-21.9</td>
<td>9.322e-36j</td>
</tr>
<tr>
<td>080</td>
<td>0xDEFABCECBDAECBFBAEl</td>
<td>32.3+e18</td>
<td>.876j</td>
</tr>
<tr>
<td>-0490</td>
<td>535633629843L</td>
<td>-90.</td>
<td>-.6545+0J</td>
</tr>
<tr>
<td>-0x260</td>
<td>-052318172735L</td>
<td>-32.54e100</td>
<td>3e+26J</td>
</tr>
<tr>
<td>0x69</td>
<td>-4721885298529L</td>
<td>70.2-E12</td>
<td>4.53e-7j</td>
</tr>
</tbody></table>
<h3 id="Python字符串"><a href="#Python字符串" class="headerlink" title="Python字符串"></a><code>Python</code>字符串</h3><ul>
<li>字符串或串(String)是由数字、字母、下划线组成的一串字符</li>
<li>和<code>Swift</code>中的字符串一样, 每一个字符都有一个与之对应的索引</li>
<li><code>python</code>的字串列表有2种取值顺序:<ul>
<li>从左到右索引默认0开始的，最大范围是字符串长度少1</li>
<li>从右到左索引默认-1开始的，最大范围是字符串开头</li>
<li>获取某一部分字符串的格式: [头下标:尾下标]</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 字符串</span></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&#x27;Hello Python&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 输出完整字符串</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;完整字符串--&quot;</span> + <span class="built_in">str</span>)</span><br><span class="line"><span class="comment"># 结果输出:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 输出第一个字符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;第一个字符--&quot;</span> + <span class="built_in">str</span>[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 输出第三到七个字符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;第3-7个字符--&quot;</span> + <span class="built_in">str</span>[<span class="number">2</span>:<span class="number">6</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 输出低2个字符开始的所有字符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;第2个开始的所有字符--&quot;</span> + <span class="built_in">str</span>[<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 拼接字符串</span></span><br><span class="line"><span class="comment"># 像上面一样, 字符串用 `+`拼接</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;拼接--&quot;</span> + <span class="built_in">str</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. 输出3次</span></span><br><span class="line"><span class="comment"># `*` 表示重复操作, 需要重复操作几次, 后面跟上次数即可</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span> * <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 7. 输出最后一个字符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最后一个字符--&quot;</span> + <span class="built_in">str</span>[-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 8. 输出倒数第二个字符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;倒数第二个字符--&quot;</span> + <span class="built_in">str</span>[-<span class="number">2</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>下面是以上语法的输出结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">完整字符串--Hello Python</span><br><span class="line">第一个字符--H</span><br><span class="line">第<span class="number">3</span>-<span class="number">7</span>个字符--llo </span><br><span class="line">第<span class="number">2</span>个开始的所有字符--ello Python</span><br><span class="line">拼接--Hello Python</span><br><span class="line">Hello PythonHello PythonHello Python</span><br><span class="line">最后一个字符--n</span><br><span class="line">倒数第二个字符--o</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<h3 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h3><ul>
<li><code>List</code>（列表） 是 <code>Python</code> 中使用最频繁的数据类型, 和<code>C</code>语言中的数组一样, 语法操作和上述字符串类似</li>
<li>列表可以完成大多数集合类的数据结构实现。它支持字符，数字，字符串甚至可以包含列表（所谓嵌套）。</li>
<li>列表用<code>[ ]</code>标识。是<code>python</code>最通用的复合数据类型</li>
<li>列表中的值得分割也可以用到变量[头下标:尾下标]，就可以截取相应的列表<ul>
<li>从左到右索引默认0开始的</li>
<li>从右到左索引默认-1开始</li>
<li>下标可以为空表示取到头或尾。</li>
</ul>
</li>
<li>加号（+）是列表连接运算符，星号（*）是重复操作</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># List 列表</span></span><br><span class="line">list1 = [<span class="number">12</span>, <span class="number">34</span>, <span class="number">3.14</span>, <span class="number">5.3</span>, <span class="string">&#x27;titan&#x27;</span>]</span><br><span class="line">list2 = [<span class="number">10</span>, <span class="string">&#x27;jun&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.完整列表</span></span><br><span class="line"><span class="built_in">print</span>(list1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.列表第一个元素</span></span><br><span class="line"><span class="built_in">print</span>(list1[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.获取第2-3个元素</span></span><br><span class="line"><span class="built_in">print</span>(list1[<span class="number">1</span>:<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.获取第三个到最后的所有元素</span></span><br><span class="line"><span class="built_in">print</span>(list1[<span class="number">2</span>:])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.获取最后一个元素</span></span><br><span class="line"><span class="built_in">print</span>(list1[-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6.获取倒数第二个元素</span></span><br><span class="line"><span class="built_in">print</span>(list1[-<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 7.获取最后三个元素</span></span><br><span class="line"><span class="built_in">print</span>(list1[-<span class="number">3</span>:-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 8.合并列表</span></span><br><span class="line"><span class="built_in">print</span>(list1 + list2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 9.重复操作两次</span></span><br><span class="line"><span class="built_in">print</span>(list2 * <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>上述语句输出结果如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">12</span>, <span class="number">34</span>, <span class="number">3.14</span>, <span class="number">5.3</span>, <span class="string">&#x27;titan&#x27;</span>]</span><br><span class="line"><span class="number">12</span></span><br><span class="line">[<span class="number">34</span>]</span><br><span class="line">[<span class="number">3.14</span>, <span class="number">5.3</span>, <span class="string">&#x27;titan&#x27;</span>]</span><br><span class="line">titan</span><br><span class="line"><span class="number">5.3</span></span><br><span class="line">[<span class="number">3.14</span>, <span class="number">5.3</span>]</span><br><span class="line">[<span class="number">12</span>, <span class="number">34</span>, <span class="number">3.14</span>, <span class="number">5.3</span>, <span class="string">&#x27;titan&#x27;</span>, <span class="number">10</span>, <span class="string">&#x27;jun&#x27;</span>]</span><br><span class="line">[<span class="number">10</span>, <span class="string">&#x27;jun&#x27;</span>, <span class="number">10</span>, <span class="string">&#x27;jun&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><ul>
<li>元组是另一个数据类型(<code>Python</code>中的元组和<code>Swift</code>中的元组类似)</li>
<li>元组用”()”标识。内部元素用逗号隔开</li>
<li>元素不能二次赋值，相当于只读列表</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 元组</span></span><br><span class="line">tuple1 = (<span class="number">12</span>, <span class="number">34</span>, <span class="number">3.14</span>, <span class="number">5.3</span>, <span class="string">&#x27;titan&#x27;</span>)</span><br><span class="line">tuple2 = (<span class="number">10</span>, <span class="string">&#x27;jun&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.完整元组</span></span><br><span class="line"><span class="built_in">print</span>(tuple1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.元组一个元素</span></span><br><span class="line"><span class="built_in">print</span>(tuple1[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.获取第2-3个元素</span></span><br><span class="line"><span class="built_in">print</span>(tuple1[<span class="number">2</span>:<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.获取第三个到最后的所有元素</span></span><br><span class="line"><span class="built_in">print</span>(tuple1[<span class="number">2</span>:])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.获取最后一个元素</span></span><br><span class="line"><span class="built_in">print</span>(tuple1[-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6.获取倒数第二个元素</span></span><br><span class="line"><span class="built_in">print</span>(tuple1[-<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 7.获取最后三个元素</span></span><br><span class="line"><span class="built_in">print</span>(tuple1[-<span class="number">3</span>:-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 8.合并元组</span></span><br><span class="line"><span class="built_in">print</span>(tuple1 + tuple2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 9.重复操作两次</span></span><br><span class="line"><span class="built_in">print</span>(tuple2 * <span class="number">2</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(<span class="number">12</span>, <span class="number">34</span>, <span class="number">3.14</span>, <span class="number">5.3</span>, <span class="string">&#x27;titan&#x27;</span>)</span><br><span class="line"><span class="number">12</span></span><br><span class="line">(<span class="number">3.14</span>,)</span><br><span class="line">(<span class="number">3.14</span>, <span class="number">5.3</span>, <span class="string">&#x27;titan&#x27;</span>)</span><br><span class="line">titan</span><br><span class="line"><span class="number">5.3</span></span><br><span class="line">(<span class="number">3.14</span>, <span class="number">5.3</span>)</span><br><span class="line">(<span class="number">12</span>, <span class="number">34</span>, <span class="number">3.14</span>, <span class="number">5.3</span>, <span class="string">&#x27;titan&#x27;</span>, <span class="number">10</span>, <span class="string">&#x27;jun&#x27;</span>)</span><br><span class="line">(<span class="number">10</span>, <span class="string">&#x27;jun&#x27;</span>, <span class="number">10</span>, <span class="string">&#x27;jun&#x27;</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里注意下, 当截取某一范围的数据时, 类似[2:3], [-3:-1], 实际的取值范围是含左不含右, 等同于数学中的半开半闭区间(左闭右开)–[2, 3)</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 因元组的元素是只读的, 不能二次赋值, 所以请注意, 以下写法是错误的</span></span><br><span class="line"><span class="comment"># 运行会报错: TypeError: &#x27;tuple&#x27; object does not support item assignment</span></span><br><span class="line">tuple2[<span class="number">0</span>] = <span class="number">20</span></span><br><span class="line">tuple2[<span class="number">1</span>] = <span class="string">&quot;titan&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><ul>
<li>字典(<code>dictionary</code>)是除列表以外<code>python</code>之中最灵活的内置数据结构类型。</li>
<li>列表是有序的对象集合，字典是无序的对象集合。</li>
<li>两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过索引存取。</li>
<li>字典用”{ }”标识。字典由索引(key)和它对应的值value组成</li>
<li>这里的字典的key值, 不仅仅可以用字符串, 还可以用<code>Number</code>类型</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 字典</span></span><br><span class="line">dict1 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;jun&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>, <span class="string">&#x27;score&#x27;</span>: <span class="number">90.98</span>&#125;</span><br><span class="line">dict2 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;titan&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 完整字典</span></span><br><span class="line"><span class="built_in">print</span>(dict2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.修改或添加字典元素</span></span><br><span class="line">dict2[<span class="string">&#x27;name&#x27;</span>] = <span class="string">&#x27;brother&#x27;</span></span><br><span class="line">dict2[<span class="string">&#x27;age&#x27;</span>] = <span class="number">20</span></span><br><span class="line">dict2[<span class="number">3</span>] = <span class="string">&#x27;完美&#x27;</span></span><br><span class="line">dict2[<span class="number">0.9</span>] = <span class="number">0.9</span></span><br><span class="line"><span class="built_in">print</span>(dict2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.根据键值获取value</span></span><br><span class="line"><span class="built_in">print</span>(dict1[<span class="string">&#x27;score&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.获取所有的键值</span></span><br><span class="line"><span class="built_in">print</span>(dict1.keys())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.获取所有的value值</span></span><br><span class="line"><span class="built_in">print</span>(dict1.values())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.删除字典元素</span></span><br><span class="line"><span class="keyword">del</span> dict1[<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(dict1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6.清空字典所有条目</span></span><br><span class="line">dict1.clear()</span><br><span class="line"><span class="built_in">print</span>(dict1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 7.删除字典</span></span><br><span class="line">dict3 = &#123;<span class="number">2</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">del</span> dict3</span><br><span class="line"><span class="comment"># 当该数组呗删除之后, 在调用会报错</span></span><br><span class="line"><span class="comment"># print(dict3)</span></span><br></pre></td></tr></table></figure>

<p>上述语句的输出结果如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;titan&#x27;</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;brother&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>, <span class="number">3</span>: <span class="string">&#x27;完美&#x27;</span>, <span class="number">0.9</span>: <span class="number">0.9</span>&#125;</span><br><span class="line"><span class="number">90.98</span></span><br><span class="line">dict_keys([<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;score&#x27;</span>])</span><br><span class="line">dict_values([<span class="string">&#x27;jun&#x27;</span>, <span class="number">18</span>, <span class="number">90.98</span>])</span><br><span class="line">&#123;<span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>, <span class="string">&#x27;score&#x27;</span>: <span class="number">90.98</span>&#125;</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><ul>
<li>集合对象是由一组无序排列的值组成的序列，集合成员可以做字典中的键</li>
<li>集合<code>sets</code>有两种不同的类型：可变集合<code>set</code>和不可变集合<code>frozenset</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 集合</span></span><br><span class="line">s = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 输出</span></span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 用set转化已存在的类型, 可以去重</span></span><br><span class="line"><span class="comment"># 集合不会存在相同的元素</span></span><br><span class="line">myList = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>]</span><br><span class="line">mySet = <span class="built_in">set</span>(myList)</span><br><span class="line"><span class="built_in">print</span>(mySet)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 添加元素(已经存在的元素, 无法添加)</span></span><br><span class="line">mySet.add(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(mySet)</span><br><span class="line">mySet.add(<span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(mySet)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.删除元素</span></span><br><span class="line">mySet.remove(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(mySet)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.方法difference</span></span><br><span class="line">set1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>&#125;</span><br><span class="line">set2 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line"><span class="comment"># 用set1和set2做difference</span></span><br><span class="line">diff = set1.difference(set2)</span><br><span class="line"><span class="built_in">print</span>(diff)</span><br><span class="line"><span class="comment"># 输出: &#123;4&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用set2和set1做difference</span></span><br><span class="line">diff2 = set2.difference(set1)</span><br><span class="line"><span class="built_in">print</span>(diff2)</span><br><span class="line"><span class="comment"># 输出: &#123;5, 6&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. 返回相同的元素</span></span><br><span class="line">inter = set1.intersection(set2)</span><br><span class="line"><span class="built_in">print</span>(inter)</span><br><span class="line"><span class="comment"># 输出: &#123;1, 2&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 7.合并集合</span></span><br><span class="line">union1 = set1.union(set2)</span><br><span class="line"><span class="built_in">print</span>(union1)</span><br><span class="line"><span class="comment"># 输出: &#123;1, 2, 4, 5, 6&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><ul>
<li>有时候，我们需要对数据内置的类型进行转换，数据类型的转换，你只需要将数据类型作为函数名即可。</li>
<li>以下几个内置的函数可以执行数据类型之间的转换。这些函数返回一个新的对象，表示转换的值</li>
</ul>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>int(x)</td>
<td>将x转换为一个整数</td>
</tr>
<tr>
<td>long(x)</td>
<td>将x转换为一个长整数</td>
</tr>
<tr>
<td>float(x)</td>
<td>将x转换到一个浮点数</td>
</tr>
<tr>
<td>complex(real [,imag])</td>
<td>创建一个复数</td>
</tr>
<tr>
<td>str(x)</td>
<td>将对象 x 转换为字符串</td>
</tr>
<tr>
<td>repr(x)</td>
<td>将对象 x 转换为表达式字符串</td>
</tr>
<tr>
<td>eval(str)</td>
<td>用来计算在字符串中的有效Python表达式,并返回一个对象</td>
</tr>
<tr>
<td>tuple(s)</td>
<td>将序列 s 转换为一个元组</td>
</tr>
<tr>
<td>list(s)</td>
<td>将序列 s 转换为一个列表</td>
</tr>
<tr>
<td>set(s)</td>
<td>转换为可变集合</td>
</tr>
<tr>
<td>dict(d)</td>
<td>创建一个字典。d 必须是一个序列 (key,value)元组。</td>
</tr>
<tr>
<td>frozenset(s)</td>
<td>转换为不可变集合</td>
</tr>
<tr>
<td>chr(x)</td>
<td>将一个整数转换为一个字符</td>
</tr>
<tr>
<td>unichr(x)</td>
<td>将一个整数转换为Unicode字符</td>
</tr>
<tr>
<td>ord(x)</td>
<td>将一个字符转换为它的整数值</td>
</tr>
<tr>
<td>hex(x)</td>
<td>将一个整数转换为一个十六进制字符串</td>
</tr>
<tr>
<td>oct(x)</td>
<td>将一个整数转换为一个八进制字符串</td>
</tr>
</tbody></table>
<p>使用示例如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数据类型转换</span></span><br><span class="line">dic = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;jun&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>&#125;</span><br><span class="line"><span class="comment"># 1.将x转换为一个整数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(<span class="number">9.89</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(<span class="string">&#x27;9&#x27;</span>))</span><br><span class="line"><span class="comment"># print(int(&#x27;8.89&#x27;)) # 这样的写法会报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.创建一个复数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">complex</span>(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">complex</span>(<span class="string">&#x27;3&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">complex</span>(-<span class="number">2</span>, -<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.转换为一个浮点型</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">float</span>(<span class="number">9</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">float</span>(<span class="string">&#x27;12.45&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.转换为字符串</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(<span class="number">9</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(<span class="number">9.09</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(<span class="string">&#x27;89&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(dic))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.转换为表达式字符串</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">repr</span>(<span class="number">9.09</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">repr</span>(<span class="number">9</span> + <span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">repr</span>(dic))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6.用来计算在字符串中的有效Python表达式,并返回一个对象</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">eval</span>(<span class="string">&#x27;3*9&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">eval</span>(<span class="string">&quot;dic[&#x27;age&#x27;]*2&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 7.将序列转换为一个元组</span></span><br><span class="line">list7 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">tuple</span>(list7))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 8.将序列转换为一个列表</span></span><br><span class="line">tuple8 = (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;d&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(tuple8))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 9.转换为可变集合</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">set</span>(list7))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 10.创建一个字典</span></span><br><span class="line">dic10 = <span class="built_in">dict</span>([(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;titan&#x27;</span>), (<span class="string">&#x27;age&#x27;</span>, <span class="number">17</span>)])</span><br><span class="line"><span class="built_in">print</span>(dic10)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 11.转换为不可变集合</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">frozenset</span>(&#123;<span class="number">1</span>, <span class="number">2</span>&#125;))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 12.将一个整数转换为一个字符</span></span><br><span class="line"><span class="comment"># 48对应字符&#x27;0&#x27;(参照ASCII码表)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="number">122</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 13.将一个字符转换为它的整数值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">ord</span>(<span class="string">&#x27;0&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 14.将一个整数转换为一个十六进制字符串</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 15.将一个整数转换为一个八进制字符串</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">oct</span>(<span class="number">10</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>对于<code>Python</code>语言, 我也是小白, 正在努力学习中, 文中如有不足之处, 还望多多指教</li>
<li>测试代码详见 <a href="https://github.com/CoderTitan/PythonDemo">GitHub地址</a></li>
<li>后期会持续更新相关文章</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python数据类型详解02</title>
    <url>/post/144857e2.html</url>
    <content><![CDATA[<ul>
<li>上文<a href="https://www.titanjun.top/2018/04/10/Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A301/">Python数据类型详解01</a>中主要介绍了<code>Python</code>中的一些常用的数据类型</li>
<li>这篇文章主要介绍一些<code>Python</code>中的一些常用的模块</li>
</ul>
<span id="more"></span>

<h2 id="Number-数字"><a href="#Number-数字" class="headerlink" title="Number(数字)"></a>Number(数字)</h2><ul>
<li><code>Python</code> 中数学运算常用的函数基本都在 <code>math</code> 模块、<code>cmath</code> 模块中。</li>
<li><code>math</code> 模块提供了许多对浮点数的数学运算函数。</li>
<li><code>cmath</code> 模块包含了一些用于复数运算的函数。</li>
<li><code>cmath</code> 模块的函数跟 <code>math</code> 模块函数基本一致，区别是 <code>cmath</code> 模块运算的是复数，<code>math</code> 模块运算的是数学运算。</li>
<li>要使用 <code>math</code> 或 <code>cmath</code> 函数必须先导入：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="keyword">import</span> cmath</span><br></pre></td></tr></table></figure>

<h3 id="Python数学常量"><a href="#Python数学常量" class="headerlink" title="Python数学常量"></a>Python数学常量</h3><p>在<code>math</code>模块中定义了三个数学常量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 自然常数 e</span></span><br><span class="line">e = <span class="number">2.718281828459045</span></span><br><span class="line"><span class="comment"># 圆周率，一般以π来表示</span></span><br><span class="line">pi = <span class="number">3.141592653589793</span></span><br><span class="line"><span class="comment"># 2π</span></span><br><span class="line">tau = <span class="number">6.283185307179586</span></span><br></pre></td></tr></table></figure>

<h3 id="Python三角函数"><a href="#Python三角函数" class="headerlink" title="Python三角函数"></a>Python三角函数</h3><p>要直接访问的，需要导入 <code>math</code> 模块, 然后通过 math 静态对象调用方法</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>acos(x)</td>
<td>返回x的反余弦弧度值。</td>
</tr>
<tr>
<td>asin(x)</td>
<td>返回x的反正弦弧度值。</td>
</tr>
<tr>
<td>atan(x)</td>
<td>返回x的反正切弧度值。</td>
</tr>
<tr>
<td>atan2(y, x)</td>
<td>返回给定的 X 及 Y 坐标值的反正切值。</td>
</tr>
<tr>
<td>cos(x)</td>
<td>返回x的弧度的余弦值。</td>
</tr>
<tr>
<td>hypot(x, y)</td>
<td>返回欧几里德范数 <code>sqrt(x*x + y*y)</code>。</td>
</tr>
<tr>
<td>sin(x)</td>
<td>返回的x弧度的正弦值。</td>
</tr>
<tr>
<td>tan(x)</td>
<td>返回x弧度的正切值。</td>
</tr>
<tr>
<td>degrees(x)</td>
<td>将弧度转换为角度,如degrees(math.pi&#x2F;2) ， 返回90.0</td>
</tr>
<tr>
<td>radians(x)</td>
<td>将角度转换为弧度</td>
</tr>
</tbody></table>
<h3 id="Python数学函数"><a href="#Python数学函数" class="headerlink" title="Python数学函数"></a>Python数学函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>返回值 ( 描述 )</th>
</tr>
</thead>
<tbody><tr>
<td>abs(x)</td>
<td>返回数字的绝对值，如abs(-12) 返回 12</td>
</tr>
<tr>
<td>ceil(x)</td>
<td>返回数字的上入整数(小数向上取整)，如math.ceil(4.1) 返回 5, math.ceil(4.0) 返回 4</td>
</tr>
<tr>
<td>cmp(x, y)</td>
<td>如果 <code>x &lt; y</code> 返回 -1, 如果 <code>x == y</code> 返回 0, 如果 <code>x &gt; y</code> 返回 1; (Python在3.x中已经弃用)</td>
</tr>
<tr>
<td>exp(x)</td>
<td>返回e的x次幂, 如math.exp(2) 返回7.38905609893065</td>
</tr>
<tr>
<td>fabs(x)</td>
<td>返回数字的绝对值，如<code>math.fabs(-10)</code> 返回10.0</td>
</tr>
<tr>
<td>floor(x)</td>
<td>返回数字的下舍整数(小数向下取整)，如math.floor(4.9)返回 4</td>
</tr>
<tr>
<td>log(x)</td>
<td>如<code>math.log(math.e)</code>返回1.0, <code>math.log(100,10)</code>返回2.0</td>
</tr>
<tr>
<td>log10(x)</td>
<td>返回以10为基数的x的对数，如<code>math.log10(100)</code>返回 2.0</td>
</tr>
<tr>
<td>max(x1, x2,…)</td>
<td>返回给定参数的最大值，参数可以为序列。</td>
</tr>
<tr>
<td>min(x1, x2,…)</td>
<td>返回给定参数的最小值，参数可以为序列。</td>
</tr>
<tr>
<td>modf(x)</td>
<td>返回x的整数部分与小数部分(元组形式)，两部分的数值符号与x相同，整数部分以浮点型表示; 如:<code>math.modf(99.09)</code>, 返回(0.09000000000000341, 99.0)</td>
</tr>
<tr>
<td>pow(x, y)</td>
<td><code>x**y</code> 运算后的值。</td>
</tr>
<tr>
<td>round(x [,n])</td>
<td>返回浮点数x的四舍五入值，如给出n值，则代表舍入到小数点后的位数; 如round(90.09, 1)输出:90.1; 如:<code>round(90.09)</code>输出:90</td>
</tr>
<tr>
<td>sqrt(x)</td>
<td>返回数字x的平方根, 如:<code>math.sqrt(4)</code>返回 2.0</td>
</tr>
</tbody></table>
<ul>
<li>其中<code>abs()</code> 和 <code>fabs()</code> 区别<ul>
<li><code>abs()</code>是一个内置函数，而<code>fabs()</code>在<code>math</code>模块中定义的。</li>
<li><code>fabs()</code>函数只适用于<code>float</code>和<code>integer</code>类型，而<code> abs()</code> 也适用于复数</li>
</ul>
</li>
</ul>
<h3 id="Python随机数函数"><a href="#Python随机数函数" class="headerlink" title="Python随机数函数"></a>Python随机数函数</h3><ul>
<li>随机数可以用于数学，游戏，安全等领域中，还经常被嵌入到算法中，用以提高算法效率，并提高程序的安全性。</li>
<li>随机数函数需要导入 <code>random</code> 模块，然后通过 <code>random</code> 静态对象调用函数方法</li>
<li><code>Python</code>包含以下常用随机数函数：</li>
</ul>
<h4 id="choice"><a href="#choice" class="headerlink" title="choice"></a>choice</h4><p>从序列(元组, 列表, 字符串)的元素中随机挑选一个元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">random.choice( seq  )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试用例</span></span><br><span class="line"><span class="comment"># 从序列的元素中随机挑选一个元素</span></span><br><span class="line"><span class="built_in">print</span>(random.choice((<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>)))</span><br><span class="line"><span class="built_in">print</span>(random.choice([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]))</span><br><span class="line"><span class="comment"># 随机返回一个字符</span></span><br><span class="line"><span class="built_in">print</span>(random.choice(<span class="string">&quot;titanjun&quot;</span>))</span><br></pre></td></tr></table></figure>

<h4 id="randrange"><a href="#randrange" class="headerlink" title="randrange"></a>randrange</h4><p>返回指定递增基数集合中的一个随机数，默认基数缺省值为1, 默认类型为int</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">randrange(self, start, stop=<span class="literal">None</span>, step=<span class="number">1</span>, _<span class="built_in">int</span>=<span class="built_in">int</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>参数<ul>
<li><code>start</code> – 指定范围内的开始值，包含在范围内。</li>
<li><code>stop</code> – 指定范围内的结束值，不包含在范围内。</li>
<li><code>step</code> – 指定递增基数</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输出 100 &lt;= number &lt; 1000 间的随机偶数</span></span><br><span class="line"><span class="built_in">print</span>(random.randrange(<span class="number">100</span>, <span class="number">1000</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure>

<h4 id="random"><a href="#random" class="headerlink" title="random"></a>random</h4><p>随机生成的一个实数，它在[0,1)范围内</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(random.random())</span><br></pre></td></tr></table></figure>

<h4 id="seed"><a href="#seed" class="headerlink" title="seed"></a>seed</h4><p>该函数没有返回值, 改变随机数生成器的种子, 可生成同一个随机数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">random.seed(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(random.random())</span><br><span class="line">random.seed()</span><br><span class="line"><span class="built_in">print</span>(random.random())</span><br></pre></td></tr></table></figure>

<h4 id="shuffle"><a href="#shuffle" class="headerlink" title="shuffle"></a>shuffle</h4><ul>
<li>将列表的所有元素随机排序, 没有返回值</li>
<li>因元组不支持二次赋值, 所以元组不支持重新排列</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将序列的所有元素随机排序</span></span><br><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">random.shuffle(list1)</span><br><span class="line"><span class="built_in">print</span>(list1)</span><br></pre></td></tr></table></figure>

<h4 id="uniform"><a href="#uniform" class="headerlink" title="uniform"></a>uniform</h4><ul>
<li>随机生成一个在[x, y)范围内的实数</li>
<li>参数:<ul>
<li>x – 随机数的最小值，包含该值。</li>
<li>y – 随机数的最大值，不包含该值。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(random.uniform(<span class="number">2</span>, <span class="number">5</span>))</span><br></pre></td></tr></table></figure>

<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>上一篇文章<a href="https://www.titanjun.top/2018/04/10/Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A301/">Python数据类型详解01</a>介绍了字符串的一些基础知识, 这里就主要介绍字符创中常用的函数和语法</p>
<h3 id="in-和-not-in"><a href="#in-和-not-in" class="headerlink" title="in 和 not in"></a><code>in</code> 和 <code>not in</code></h3><p>判断字符串是否包含指定字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 判断字符串中是否包含某字符串</span></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&#x27;Hello Python&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;llo&#x27;</span> <span class="keyword">in</span> <span class="built_in">str</span>):</span><br><span class="line">    <span class="built_in">str</span> += <span class="string">&#x27; True&#x27;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">str</span> += <span class="string">&#x27; False&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断字符串是否不包含某字符串</span></span><br><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;py&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">str</span>):</span><br><span class="line">    <span class="built_in">str</span> += <span class="string">&#x27; not in&#x27;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">str</span> += <span class="string">&#x27; in&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>)</span><br><span class="line"></span><br><span class="line">// 分别输出</span><br><span class="line">Hello Python <span class="literal">True</span></span><br><span class="line">Hello Python <span class="literal">True</span> <span class="keyword">not</span> <span class="keyword">in</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h3><p>把其他类型的数据格式化为字符串形式返回, 字符串和其他类型之间要有<code>%</code>分开</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>%c</code></td>
<td>格式化字符及其ASCII码</td>
</tr>
<tr>
<td><code>%s</code></td>
<td>格式化字符串</td>
</tr>
<tr>
<td><code>%d</code></td>
<td>格式化整数</td>
</tr>
<tr>
<td><code>%u</code></td>
<td>格式化无符号整型</td>
</tr>
<tr>
<td><code>%o</code></td>
<td>格式化无符号八进制数</td>
</tr>
<tr>
<td><code>%x</code></td>
<td>格式化无符号十六进制数</td>
</tr>
<tr>
<td><code>%X</code></td>
<td>格式化无符号十六进制数（大写）</td>
</tr>
<tr>
<td><code>%f</code></td>
<td>格式化浮点数字，可指定小数点后的精度</td>
</tr>
<tr>
<td><code>%e</code></td>
<td>用科学计数法格式化浮点数</td>
</tr>
<tr>
<td><code>%E</code></td>
<td>作用同%e，用科学计数法格式化浮点数</td>
</tr>
<tr>
<td><code>%g</code></td>
<td>%f和%e的简写</td>
</tr>
<tr>
<td><code>%G</code></td>
<td>%f 和 %E 的简写</td>
</tr>
<tr>
<td><code>%p</code></td>
<td>用十六进制数格式化变量的地址</td>
</tr>
</tbody></table>
<p>使用方式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;che is %d&#x27;</span> % <span class="number">19</span>)</span><br><span class="line"></span><br><span class="line">// 跟C语言的写法</span><br><span class="line">prin他(<span class="string">&quot;che is %d&quot;</span>, <span class="number">19</span>)</span><br></pre></td></tr></table></figure>

<h3 id="str-format-函数"><a href="#str-format-函数" class="headerlink" title="str.format()函数"></a><code>str.format()</code>函数</h3><ul>
<li><code>Python2.6</code> 开始，新增了一种格式化字符串的函数 <code>str.format()</code>，它增强了字符串格式化的功能。<br>基本语法是通过 <code>&#123;&#125;</code> 和 <code>:</code> 来代替以前的 <code>%</code> 。</li>
<li><code>format</code> 函数可以接受不限个参数，位置可以不按顺序。</li>
</ul>
<p>简单使用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># format函数</span></span><br><span class="line"><span class="comment"># 不设置指定位置，按默认顺序</span></span><br><span class="line">str1 = <span class="string">&#x27;&#123;&#125; &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;python&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(str1)</span><br><span class="line"><span class="comment"># 设置指定位置</span></span><br><span class="line">str2 = <span class="string">&#x27;&#123;0&#125;&#123;1&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;Python&#x27;</span>, <span class="string">&#x27;字符串&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(str2)</span><br><span class="line"><span class="comment"># 设置指定位置</span></span><br><span class="line">str3 = <span class="string">&#x27;&#123;1&#125; &#123;0&#125; &#123;1&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;che&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(str3)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置参数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;姓名: &#123;name&#125;, 年龄: &#123;age&#125;&quot;</span>.<span class="built_in">format</span>(name=<span class="string">&#x27;che&#x27;</span>, age=<span class="number">18</span>))</span><br><span class="line"><span class="comment"># 设置字典参数</span></span><br><span class="line">dic = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;jun&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;姓名: &#123;name&#125;, 年龄: &#123;age&#125;&quot;</span>.<span class="built_in">format</span>(**dic))</span><br><span class="line"><span class="comment"># 设置列表参数</span></span><br><span class="line">list0 = [<span class="string">&#x27;titan&#x27;</span>, <span class="number">20</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;姓名: &#123;0[0]&#125;, 年龄: &#123;0[1]&#125;&quot;</span>.<span class="built_in">format</span>(list0))</span><br><span class="line"></span><br><span class="line">/*输出结果</span><br><span class="line">hello python</span><br><span class="line">Python字符串</span><br><span class="line">che hello che</span><br><span class="line">姓名: che, 年龄: <span class="number">18</span></span><br><span class="line">姓名: jun, 年龄: <span class="number">20</span></span><br><span class="line">姓名: titan, 年龄: <span class="number">20</span></span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<h3 id="格式化操作符辅助指令"><a href="#格式化操作符辅助指令" class="headerlink" title="格式化操作符辅助指令"></a>格式化操作符辅助指令</h3><p>相关操作符具体的使用后面再说</p>
<p><img data-src="http://titanjun.oss-cn-hangzhou.aliyuncs.com/python/String-1.png" alt="image description"></p>
<h3 id="数字格式化操作符"><a href="#数字格式化操作符" class="headerlink" title="数字格式化操作符"></a>数字格式化操作符</h3><table>
<thead>
<tr>
<th>数字</th>
<th>格式</th>
<th>输出</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>3.1415926</td>
<td><code>&#123;:.2f&#125;</code></td>
<td>3.14</td>
<td>保留小数点后两位</td>
</tr>
<tr>
<td>3.1415926</td>
<td><code>&#123;:+.2f&#125;</code></td>
<td>+3.14</td>
<td>带符号保留小数点后两位</td>
</tr>
<tr>
<td>-1</td>
<td><code>&#123;:+.2f&#125;</code></td>
<td>-1.00</td>
<td>带符号保留小数点后两位</td>
</tr>
<tr>
<td>2.71828</td>
<td><code>&#123;:.0f&#125;</code></td>
<td>3</td>
<td>不带小数</td>
</tr>
<tr>
<td>5</td>
<td><code>&#123;:0&gt;2d&#125;</code></td>
<td>05</td>
<td>数字补零 (填充左边, 宽度为2)</td>
</tr>
<tr>
<td>5</td>
<td><code>&#123;:x&lt;4d&#125;</code></td>
<td>5xxx</td>
<td>数字补x (填充右边, 宽度为4)</td>
</tr>
<tr>
<td>10</td>
<td><code>&#123;:x&lt;4d&#125;</code></td>
<td>10xx</td>
<td>数字补x (填充右边, 宽度为4)</td>
</tr>
<tr>
<td>1000000</td>
<td><code>&#123;:,&#125;</code></td>
<td>1,000,000</td>
<td>以逗号分隔的数字格式</td>
</tr>
<tr>
<td>0.25</td>
<td><code>&#123;:.2%&#125;</code></td>
<td>25.00%</td>
<td>百分比格式</td>
</tr>
<tr>
<td>1000000000</td>
<td><code>&#123;:.2e&#125;</code></td>
<td>1.00e+09</td>
<td>指数记法</td>
</tr>
<tr>
<td>13</td>
<td><code>&#123;:10d&#125;</code></td>
<td>13</td>
<td>右对齐 (默认, 宽度为10)</td>
</tr>
<tr>
<td>13</td>
<td><code>&#123;:&lt;10d&#125;</code></td>
<td>13</td>
<td>左对齐 (宽度为10)</td>
</tr>
<tr>
<td>13</td>
<td><code>&#123;:^10d&#125;</code></td>
<td>13</td>
<td>中间对齐 (宽度为10)</td>
</tr>
</tbody></table>
<p>进制转换(以十进制数字11为例)</p>
<table>
<thead>
<tr>
<th>进制</th>
<th>格式</th>
<th>输出</th>
</tr>
</thead>
<tbody><tr>
<td>二进制</td>
<td><code>&#39;&#123;:b&#125;&#39;.format(11)</code></td>
<td>1011</td>
</tr>
<tr>
<td>十进制</td>
<td><code>&#39;&#123;:d&#125;&#39;.format(11)</code></td>
<td>11</td>
</tr>
<tr>
<td>八进制</td>
<td><code>&#39;&#123;:o&#125;&#39;.format(11)</code></td>
<td>13</td>
</tr>
<tr>
<td>十六进制</td>
<td><code>&#39;&#123;:x&#125;&#39;.format(11)</code></td>
<td>b</td>
</tr>
<tr>
<td>小写十六进制</td>
<td><code>&#39;&#123;:#x&#125;&#39;.format(11)</code></td>
<td>0xb</td>
</tr>
<tr>
<td>大写十六进制</td>
<td><code>&#39;&#123;:#X&#125;&#39;.format(11)</code></td>
<td>0XB</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;百分比: %d%%&#x27;</span> % <span class="number">23</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125;索引值: &#123;&#123;0&#125;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;jun&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="number">9</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;:#X&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="number">9</span>))</span><br><span class="line"></span><br><span class="line">/*输出结果: </span><br><span class="line">百分比: <span class="number">23</span>%</span><br><span class="line">jun索引值: &#123;<span class="number">0</span>&#125;</span><br><span class="line"><span class="number">0x9</span></span><br><span class="line"><span class="number">0X9</span></span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<h3 id="字符串的内建函数"><a href="#字符串的内建函数" class="headerlink" title="字符串的内建函数"></a>字符串的内建函数</h3><p>下列方法实现了<code>string</code>模块的大部分方法，如下表所示列出了目前字符串内建支持的方法，所有的方法都包含了对<code>Unicode</code>的支持，有一些甚至是专门用于<code>Unicode</code>的</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>返回结果</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>&#39;titan&#39;.capitalize()</code></td>
<td>Titan</td>
<td>把字符串的第一个字符大写</td>
</tr>
<tr>
<td><code>&#39;hello\tpython&#39;.expandtabs()</code></td>
<td>hello python</td>
<td>把字符串 string 中的 tab 符号转为空格，tab 符号默认的空格数是 8</td>
</tr>
<tr>
<td><code>str5.find(&#39;irl&#39;)</code></td>
<td>11</td>
<td>检测 str 是否包含在 string 中，如果 beg 和 end 指定范围，则检查是否包含在指定范围内，如果是返回开始的索引值，否则返回-1</td>
</tr>
<tr>
<td><code>str5.rfind(&#39;irl&#39;)</code></td>
<td>11</td>
<td>同find方法, 从右向左查询</td>
</tr>
<tr>
<td>str5.index(‘gi’)</td>
<td>10</td>
<td>跟find()方法一样，只不过如果str不在 string中会报一个异常.</td>
</tr>
<tr>
<td>str5.rindex(‘gi’)</td>
<td>10</td>
<td>同index方法, 从右向左查询</td>
</tr>
<tr>
<td><code>&#39;jun0929&#39;.isalnum()</code></td>
<td>True</td>
<td>至少有一个字符并且所有字符都是字母或数字则返回 True,否则返回 False</td>
</tr>
<tr>
<td><code>&#39;titan&#39;.isalpha()</code></td>
<td>True</td>
<td>至少有一个字符并且所有字符都是字母则返回 True,否则返回 False</td>
</tr>
<tr>
<td><code>u&#39;23e&#39;.isdecimal()</code></td>
<td>False</td>
<td>字符串只包含十进制字符返回True，否则返回False(只针对unicode对象)</td>
</tr>
<tr>
<td><code>&quot;123456&quot;.isdigit()</code></td>
<td>True</td>
<td>字符串只包含数字则返回 True 否则返回 False</td>
</tr>
<tr>
<td><code>&#39;23e&#39;.islower()</code></td>
<td>True</td>
<td>字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 False</td>
</tr>
<tr>
<td><code>u&quot;23443434&quot;isnumeric()</code></td>
<td>True</td>
<td>字符串中只包含数字字符，则返回 True，否则返回 False(只针对unicode对象)</td>
</tr>
<tr>
<td><code>&quot;       &quot;.isspace()</code></td>
<td>True</td>
<td>字符串中只包含空格，则返回 True，否则返回 False.</td>
</tr>
<tr>
<td><code>&#39;JING&#39;.isupper()</code></td>
<td>True</td>
<td>字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True，否则返回 False</td>
</tr>
<tr>
<td><code>&#39;-&#39;.join( [&#39;a&#39;, &#39;s&#39;, &#39;d&#39;] )</code></td>
<td>a-s-d</td>
<td>用于将序列中的元素以指定的字符连接生成一个新的字符串</td>
</tr>
<tr>
<td><code>&#39;THIS&#39;.lower</code></td>
<td>this</td>
<td>返回将字符串中所有大写字符转换为小写后生成的字符串</td>
</tr>
<tr>
<td><code>&quot;88this&quot;.lstrip(&#39;8&#39;)</code></td>
<td>this</td>
<td>返回截掉字符串左边的空格或指定字符后生成的新字符串</td>
</tr>
<tr>
<td><code>&#39;this88&#39;.rstrip(&#39;8&#39;)</code></td>
<td>this</td>
<td>返回截掉字符串右边的空格或指定字符后生成的新字符串</td>
</tr>
<tr>
<td><code>max(&#39;python&#39;)</code></td>
<td>z</td>
<td>返回字符串中最大的字母</td>
</tr>
<tr>
<td><code>min(&#39;python&#39;)</code></td>
<td>h</td>
<td>返回字符串中最小的字母</td>
</tr>
<tr>
<td><code>&#39;https://www.titanjun.top&#39;.partition(&#39;://&#39;)</code></td>
<td>(‘https’, ‘:&#x2F;&#x2F;‘, ‘<a href="http://www.titanjun.top&/#39;">www.titanjun.top&#39;</a>)</td>
<td>返回一个3元的元组，第一个为分隔符左边的子串，第二个为分隔符本身，第三个为分隔符右边的子串</td>
</tr>
<tr>
<td><code>&#39;this&#39;.startswith(&#39;th&#39;, 1, 4)</code></td>
<td>False</td>
<td>检查字符串在制定范围内是否是以指定子字符串开头</td>
</tr>
<tr>
<td><code>&quot;0jun0&quot;.strip(&#39;0&#39;)</code></td>
<td>jun</td>
<td>返回移除字符串头尾指定的字符生成的新字符串</td>
</tr>
<tr>
<td><code>&#39;Python&#39;.swapcase()</code></td>
<td>pYTHON</td>
<td>返回大小写字母转换后生成的新字符串</td>
</tr>
<tr>
<td><code>&#39;hello python&#39;.title()</code></td>
<td>Hello Python</td>
<td>返回所有单词都是以大写开始</td>
</tr>
<tr>
<td><code>&#39;jun&#39;.upper()</code></td>
<td>JUN</td>
<td>返回小写字母转为大写字母的字符串</td>
</tr>
</tbody></table>
<p>除了以上方法外还有下列重要方法</p>
<h4 id="count-方法"><a href="#count-方法" class="headerlink" title="count()方法"></a>count()方法</h4><p>返回子字符串在字符串中出现的次数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span>.count(sub, start= <span class="number">0</span>,end=<span class="built_in">len</span>(string))</span><br><span class="line"></span><br><span class="line">//使用</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;hello world&#x27;</span>.count(<span class="string">&#x27;l&#x27;</span>, <span class="number">1</span>, <span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;hello world&#x27;</span>.count(<span class="string">&#x27;l&#x27;</span>))</span><br><span class="line"></span><br><span class="line">//输出: </span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<ul>
<li>参数<ul>
<li><code>sub</code> – 搜索的子字符串</li>
<li><code>start</code> – 字符串开始搜索的位置。默认为第一个字符,第一个字符索引值为0。</li>
<li><code>end</code> – 字符串中结束搜索的位置。字符中第一个字符的索引为 0。默认为字符串的最后一个位置。</li>
</ul>
</li>
</ul>
<h4 id="center-方法"><a href="#center-方法" class="headerlink" title="center()方法"></a>center()方法</h4><p>返回一个原字符串居中,并使用空格填充至长度 width 的新字符串。默认填充字符为空格</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span>.center(width, fillchar)</span><br><span class="line"></span><br><span class="line">//使用</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span> = <span class="string">&#x27;titan&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>.center(<span class="number">8</span>, <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;--titan---&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>.center(<span class="number">9</span>)</span><br><span class="line"><span class="string">&#x27;   titan   &#x27;</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>不提供 <code>fillchar</code> 参数则默认为空格</li>
<li>当 <code>width</code> 参数小于等于原字符串的长度时，原样返回</li>
<li>无法使左右字符数相等时候，左侧字符会比右侧少 1</li>
</ul>
<h4 id="encode-方法"><a href="#encode-方法" class="headerlink" title="encode()方法"></a>encode()方法</h4><p>以 encoding 指定的编码格式编码字符串。errors参数可以指定不同的错误处理方案</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span>.encode(encoding=<span class="string">&#x27;UTF-8&#x27;</span>,errors=<span class="string">&#x27;strict&#x27;</span>)</span><br><span class="line"></span><br><span class="line">//示例</span><br><span class="line"><span class="string">&#x27;titan&#x27;</span>.encode(<span class="string">&#x27;UTF-8&#x27;</span>,<span class="string">&#x27;strict&#x27;</span>)</span><br><span class="line"></span><br><span class="line">//输出: <span class="string">b&#x27;titan&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>encoding</code> – 要使用的编码，如”UTF-8”。</li>
<li><code>errors</code> – 设置不同错误的处理方案。默认为 <code>strict</code>,意为编码错误引起一个<code>UnicodeError</code>。 其他可能得值有 <code>ignore</code>, <code>replace</code>, <code>xmlcharrefreplace</code>, <code>backslashreplace</code> 以及通过 <code>codecs.register_error()</code> 注册的任何值。</li>
</ul>
<h4 id="endswith-方法"><a href="#endswith-方法" class="headerlink" title="endswith()方法"></a>endswith()方法</h4><p>用于判断字符串是否以指定后缀结尾，如果以指定后缀结尾返回True，否则返回False</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span>.endswith(suffix[, start[, end]])</span><br><span class="line"></span><br><span class="line">//使用示例</span><br><span class="line">str5 = <span class="string">&#x27;her is my girl friend haha!!&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(str5.endswith(<span class="string">&#x27;!!&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(str5.endswith(<span class="string">&#x27;ha&#x27;</span>, <span class="number">0</span>, <span class="built_in">len</span>(str5) - <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">//输出结果: 都是<span class="literal">True</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>suffix</code> – 该参数可以是一个字符串或者是一个元素</li>
<li><code>start</code> – 字符串中的开始位置, 可不传</li>
<li><code>end</code> – 字符中结束位置, 可不传</li>
</ul>
<h4 id="ljust-和-rjust-方法"><a href="#ljust-和-rjust-方法" class="headerlink" title="ljust() 和 rjust()方法"></a>ljust() 和 rjust()方法</h4><ul>
<li><code>ljust()</code>: 返回一个原字符串左对齐,并使用空格填充至指定长度的新字符串。如果指定的长度小于原字符串的长度则返回原字符串</li>
<li><code>rjust()</code>: 返回一个原字符串右对齐</li>
<li>参数<ul>
<li><code>width</code> – 指定字符串长度。</li>
<li><code>fillchar</code> – 填充字符，默认为空格</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span>.ljust(width[, fillchar])</span><br><span class="line"><span class="built_in">str</span>.rjust(width[, fillchar])</span><br><span class="line"></span><br><span class="line">//测试用例</span><br><span class="line"><span class="built_in">str</span> = <span class="string">&quot;this is string example....wow!!!&quot;</span>;</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">str</span>.ljust(<span class="number">50</span>, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">str</span>.rjust(<span class="number">50</span>, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">//输出:</span><br><span class="line">this <span class="keyword">is</span> string example....wow!!!<span class="number">000000000000000000</span></span><br><span class="line">000000000000000000this <span class="keyword">is</span> string example....wow!!!</span><br></pre></td></tr></table></figure>

<h4 id="replace-方法"><a href="#replace-方法" class="headerlink" title="replace()方法"></a>replace()方法</h4><p>返回字符串中的 old（旧字符串） 替换成 new(新字符串)后生成的新字符串，如果指定第三个参数max，则替换不超过 max 次</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span>.replace(old, new[, <span class="built_in">max</span>])</span><br><span class="line"></span><br><span class="line">//测试</span><br><span class="line"><span class="built_in">str</span> = <span class="string">&#x27;Python is a good language!&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(str7.replace(<span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">//输出: </span><br><span class="line">Pythin <span class="keyword">is</span> a giod language!</span><br></pre></td></tr></table></figure>

<h4 id="split-方法"><a href="#split-方法" class="headerlink" title="split()方法"></a>split()方法</h4><p>通过指定分隔符对字符串进行切片，如果参数 num 有指定值，则仅分隔 num 个子字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span>.split(<span class="built_in">str</span>=<span class="string">&quot;&quot;</span>, num=string.count(<span class="built_in">str</span>))</span><br><span class="line"></span><br><span class="line">//测试</span><br><span class="line">str7 = <span class="string">&#x27;Python is a good language!&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(str7.split(<span class="string">&#x27; &#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(str7.split(<span class="string">&#x27; &#x27;</span>, <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">//输出:</span><br><span class="line">[<span class="string">&#x27;Python&#x27;</span>, <span class="string">&#x27;is&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;good&#x27;</span>, <span class="string">&#x27;language!&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;Python&#x27;</span>, <span class="string">&#x27;is&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;good language!&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h4 id="splitlines-方法"><a href="#splitlines-方法" class="headerlink" title="splitlines()方法"></a>splitlines()方法</h4><p>按照行(<code>&#39;\r&#39;, &#39;\r\n&#39;, \n&#39;</code>)分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span>.splitlines([keepends])</span><br><span class="line"></span><br><span class="line">//测试</span><br><span class="line">str8 = <span class="string">&#x27;ab c\n\nde fg\rkl\r\n&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(str8.splitlines())</span><br><span class="line"></span><br><span class="line">str9 = <span class="string">&#x27;ab c\n\nde fg\rkl\r\n&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(str9.splitlines(<span class="literal">True</span>))</span><br><span class="line"></span><br><span class="line">//输出:</span><br><span class="line">[<span class="string">&#x27;ab c&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;de fg&#x27;</span>, <span class="string">&#x27;kl&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;ab c\n&#x27;</span>, <span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;de fg\r&#x27;</span>, <span class="string">&#x27;kl\r\n&#x27;</span>]</span><br></pre></td></tr></table></figure>


<ul>
<li>对于<code>Python</code>语言, 我也正在努力学习中, 文中如有不足之处, 还望多多指教</li>
<li>测试代码详见 <a href="https://github.com/CoderTitan/PythonDemo">GitHub地址</a></li>
<li>后期会持续更新相关文章, 未完待续…</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python数据类型详解03</title>
    <url>/post/634f6774.html</url>
    <content><![CDATA[<ul>
<li>第一篇<a href="https://www.titanjun.top/2018/04/10/Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A301/">Python数据类型详解01</a>中主要介绍了<code>Python</code>中的一些常用的数据类型的基础知识</li>
<li>第二篇<a href="https://www.titanjun.top/2018/04/17/Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A302/">Python数据类型详解02</a>文章中, 详细介绍了数字(<code>Number</code>)和字符串的一些函数和模块的使用</li>
<li>这篇文章主要介绍一些<code>Python</code>中的一序列(列表&#x2F;元组&#x2F;字典)</li>
</ul>
<span id="more"></span>

<h2 id="列表-List"><a href="#列表-List" class="headerlink" title="列表(List)"></a>列表(List)</h2><p>先回顾下上一篇<a href="https://www.titanjun.top/2018/04/10/Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A301/">Python数据类型详解01</a>文章中介绍的列表的基础知识</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># List 列表</span></span><br><span class="line">list1 = [<span class="number">12</span>, <span class="number">34</span>, <span class="number">3.14</span>, <span class="number">5.3</span>, <span class="string">&#x27;titan&#x27;</span>]</span><br><span class="line">list2 = [<span class="number">10</span>, <span class="string">&#x27;jun&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.完整列表</span></span><br><span class="line"><span class="built_in">print</span>(list1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.列表第一个元素</span></span><br><span class="line"><span class="built_in">print</span>(list1[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.获取第2-3个元素</span></span><br><span class="line"><span class="built_in">print</span>(list1[<span class="number">1</span>:<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.获取第三个到最后的所有元素</span></span><br><span class="line"><span class="built_in">print</span>(list1[<span class="number">2</span>:])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.获取最后一个元素</span></span><br><span class="line"><span class="built_in">print</span>(list1[-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6.获取倒数第二个元素</span></span><br><span class="line"><span class="built_in">print</span>(list1[-<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 7.获取最后三个元素</span></span><br><span class="line"><span class="built_in">print</span>(list1[-<span class="number">3</span>:-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 8.合并列表</span></span><br><span class="line"><span class="built_in">print</span>(list1 + list2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 9.重复操作两次</span></span><br><span class="line"><span class="built_in">print</span>(list2 * <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h3 id="添加和删除列表元素"><a href="#添加和删除列表元素" class="headerlink" title="添加和删除列表元素"></a>添加和删除列表元素</h3><p>对列表的数据项进行修改或更新，你也可以使用append()方法来添加列表项</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = []          <span class="comment">## 空列表</span></span><br><span class="line">list1.append(<span class="string">&#x27;Google&#x27;</span>)   <span class="comment">## 使用 append() 添加元素</span></span><br><span class="line">list1.append(<span class="string">&#x27;Baidu&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(list1)</span><br><span class="line"></span><br><span class="line">//输出:</span><br><span class="line">[<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Baidu&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>使用 <code>del</code> 语句来删除列表的元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">del</span> list1[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">//输出:</span><br><span class="line">[<span class="string">&#x27;Google&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h3 id="列表脚本操作符"><a href="#列表脚本操作符" class="headerlink" title="列表脚本操作符"></a>列表脚本操作符</h3><p>列表对 + 和 星号 的操作符与字符串相似。+ 号用于组合列表，星号 号用于重复列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 脚本操作符</span></span><br><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment"># 元素个数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(list1))</span><br><span class="line"><span class="comment"># 重复</span></span><br><span class="line">list2 = [<span class="number">2</span>] * <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(list2)</span><br><span class="line"><span class="comment"># 是否包含某元素</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">3</span> <span class="keyword">in</span> list1):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;3在列表内&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;3不在列表内&#x27;</span>)</span><br><span class="line"><span class="comment"># 遍历列表</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> list1 :</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 输出结果:</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>]</span><br><span class="line"><span class="number">3</span>在列表内</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<h3 id="列表函数-amp-方法"><a href="#列表函数-amp-方法" class="headerlink" title="列表函数&amp;方法"></a>列表函数&amp;方法</h3><p>下面将会列出在列表中常用的函数和方法</p>
<table>
<thead>
<tr>
<th>函数表达式</th>
<th>输出结果</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>len(list1)</code></td>
<td>3</td>
<td>列表元素个数</td>
</tr>
<tr>
<td><code>max([1, 2, &#39;s&#39;])</code></td>
<td>s</td>
<td>返回列表元素的最大值</td>
</tr>
<tr>
<td><code>min([1, 2, &#39;s&#39;])</code></td>
<td>1</td>
<td>返回列表元素的最小值</td>
</tr>
<tr>
<td><code>list((&#39;q&#39;, 1)</code></td>
<td><code>[&#39;q&#39;, 1]</code></td>
<td>将元组转换为列表</td>
</tr>
<tr>
<td><code>list1.append(2)</code></td>
<td>[1, 2, 3, 2]</td>
<td>在列表末尾添加新的对象</td>
</tr>
<tr>
<td><code>list1.count(2)</code></td>
<td>2</td>
<td>统计某个元素在列表中出现的次数</td>
</tr>
<tr>
<td><code>list1.index(3)</code></td>
<td>2</td>
<td>从列表中找出某个值第一个匹配项的索引位置</td>
</tr>
<tr>
<td><code>list1.insert(1, &#39;jun&#39;)</code></td>
<td>[1, ‘jun’, 2, 3, 2]</td>
<td>将对象插入列表的指定位置</td>
</tr>
<tr>
<td><code>list1.remove(3)</code></td>
<td>[1, ‘jun’, 2, 2]</td>
<td>移除列表中某个值的第一个匹配项</td>
</tr>
<tr>
<td><code>list1.reverse()</code></td>
<td>[2, 2, ‘jun’, 1]</td>
<td>对列表的元素进行反向排列</td>
</tr>
<tr>
<td><code>list1.sort()</code></td>
<td>[2, 2, ‘jun’, 1]</td>
<td>对原列表进行排序, 如果指定参数，则使用比较函数指定的比较函数</td>
</tr>
</tbody></table>
<h4 id="extend-方法"><a href="#extend-方法" class="headerlink" title="extend()方法"></a>extend()方法</h4><p>用于在列表末尾一次性追加另一个序列(元组和列表)中的多个值（用新列表扩展原来的列表）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list3 = [<span class="number">12</span>, <span class="string">&#x27;as&#x27;</span>, <span class="number">45</span>]</span><br><span class="line">list4 = (<span class="number">23</span>, <span class="string">&#x27;ed&#x27;</span>)</span><br><span class="line">list3.extend(list4)</span><br><span class="line"><span class="built_in">print</span>(list3)</span><br><span class="line"></span><br><span class="line">//输出:</span><br><span class="line">[<span class="number">12</span>, <span class="string">&#x27;as&#x27;</span>, <span class="number">45</span>, <span class="number">23</span>, <span class="string">&#x27;ed&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h4 id="pop-方法"><a href="#pop-方法" class="headerlink" title="pop()方法"></a>pop()方法</h4><p>用于移除列表中的一个元素（默认最后一个元素），并且返回该元素的值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span>.pop(obj=<span class="built_in">list</span>[-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">//使用</span><br><span class="line">list3 = [<span class="number">12</span>, <span class="string">&#x27;as&#x27;</span>, <span class="number">45</span>, <span class="number">23</span>, <span class="string">&#x27;ed&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(list3)</span><br><span class="line"><span class="built_in">print</span>(list3.pop())</span><br><span class="line"><span class="built_in">print</span>(list3)</span><br><span class="line"><span class="built_in">print</span>(list3.pop(<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(list3)</span><br><span class="line"></span><br><span class="line">//输出:</span><br><span class="line">ed</span><br><span class="line">[<span class="number">12</span>, <span class="string">&#x27;as&#x27;</span>, <span class="number">45</span>, <span class="number">23</span>]</span><br><span class="line"><span class="number">45</span></span><br><span class="line">[<span class="number">12</span>, <span class="string">&#x27;as&#x27;</span>, <span class="number">23</span>]</span><br></pre></td></tr></table></figure>

<h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><p>先回顾一下上篇文章介绍的元组的基础知识</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 元组</span></span><br><span class="line">tuple1 = (<span class="number">12</span>, <span class="number">34</span>, <span class="number">3.14</span>, <span class="number">5.3</span>, <span class="string">&#x27;titan&#x27;</span>)</span><br><span class="line">tuple2 = (<span class="number">10</span>, <span class="string">&#x27;jun&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.完整元组</span></span><br><span class="line"><span class="built_in">print</span>(tuple1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.元组一个元素</span></span><br><span class="line"><span class="built_in">print</span>(tuple1[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.获取第2-3个元素</span></span><br><span class="line"><span class="built_in">print</span>(tuple1[<span class="number">2</span>:<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.获取第三个到最后的所有元素</span></span><br><span class="line"><span class="built_in">print</span>(tuple1[<span class="number">2</span>:])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.获取最后一个元素</span></span><br><span class="line"><span class="built_in">print</span>(tuple1[-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6.获取倒数第二个元素</span></span><br><span class="line"><span class="built_in">print</span>(tuple1[-<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 7.获取最后三个元素</span></span><br><span class="line"><span class="built_in">print</span>(tuple1[-<span class="number">3</span>:-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 8.合并元组</span></span><br><span class="line"><span class="built_in">print</span>(tuple1 + tuple2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 9.重复操作两次</span></span><br><span class="line"><span class="built_in">print</span>(tuple2 * <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h3 id="元组运算符"><a href="#元组运算符" class="headerlink" title="元组运算符"></a>元组运算符</h3><p>与列表的运算符和操作类似, 如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 计算元素个数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)))</span><br><span class="line"><span class="comment"># 合并元组</span></span><br><span class="line">tuple1 = (<span class="number">1</span>, <span class="number">2</span>) + (<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(tuple1)</span><br><span class="line"><span class="comment"># 重复</span></span><br><span class="line">tuple2 = (<span class="string">&#x27;jun&#x27;</span>,) * <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(tuple2)</span><br><span class="line"><span class="comment"># 检测是否包含某元素</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">2</span> <span class="keyword">in</span> tuple1):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;2在该元组内&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;不在元组内&#x27;</span>)</span><br><span class="line"><span class="comment"># 遍历元组</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> tuple1:</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line">//输出:</span><br><span class="line"><span class="number">3</span></span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">(<span class="string">&#x27;jun&#x27;</span>, <span class="string">&#x27;jun&#x27;</span>, <span class="string">&#x27;jun&#x27;</span>)</span><br><span class="line"><span class="number">2</span>在该元组内</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>

<h3 id="元组内置函数"><a href="#元组内置函数" class="headerlink" title="元组内置函数"></a>元组内置函数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tuple1 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>) </span><br><span class="line"><span class="comment"># 元组中元素最大值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">max</span>(tuple1))</span><br><span class="line"><span class="comment"># 元组中元素最小值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">min</span>(tuple1))</span><br><span class="line"><span class="comment"># 列表转换为元组</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">tuple</span>([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;f&#x27;</span>]))</span><br><span class="line"></span><br><span class="line">//输出:</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;f&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>先看看上文中介绍到的字典的相关基础知识, 需要注意的是: 键必须不可变，所以可以用数字，字符串或元组充当，所以用列表就不行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 字典</span></span><br><span class="line">dict1 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;jun&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>, <span class="string">&#x27;score&#x27;</span>: <span class="number">90.98</span>&#125;</span><br><span class="line">dict2 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;titan&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 完整字典</span></span><br><span class="line"><span class="built_in">print</span>(dict2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.修改或添加字典元素</span></span><br><span class="line">dict2[<span class="string">&#x27;name&#x27;</span>] = <span class="string">&#x27;brother&#x27;</span></span><br><span class="line">dict2[<span class="string">&#x27;age&#x27;</span>] = <span class="number">20</span></span><br><span class="line">dict2[<span class="number">3</span>] = <span class="string">&#x27;完美&#x27;</span></span><br><span class="line">dict2[<span class="number">0.9</span>] = <span class="number">0.9</span></span><br><span class="line"><span class="built_in">print</span>(dict2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.根据键值获取value</span></span><br><span class="line"><span class="built_in">print</span>(dict1[<span class="string">&#x27;score&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.获取所有的键值</span></span><br><span class="line"><span class="built_in">print</span>(dict1.keys())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.获取所有的value值</span></span><br><span class="line"><span class="built_in">print</span>(dict1.values())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.删除字典元素</span></span><br><span class="line"><span class="keyword">del</span> dict1[<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(dict1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6.清空字典所有条目</span></span><br><span class="line">dict1.clear()</span><br><span class="line"><span class="built_in">print</span>(dict1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 7.删除字典</span></span><br><span class="line">dict3 = &#123;<span class="number">2</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">del</span> dict3</span><br><span class="line"><span class="comment"># 当该数组呗删除之后, 在调用会报错</span></span><br><span class="line"><span class="comment"># print(dict3)</span></span><br></pre></td></tr></table></figure>


<h3 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dic1 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;titan&#x27;</span>, <span class="string">&#x27;age&#x27;</span>:<span class="number">20</span>&#125;</span><br><span class="line"><span class="comment"># 计算字典元素个数，即键的总数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(dic1))</span><br><span class="line"><span class="comment"># 字典(Dictionary) str() 函数将值转化为适于人阅读的形式，以可打印的字符串表示</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(dic1))</span><br><span class="line"><span class="comment"># 返回输入的变量类型，如果变量是字典就返回字典类型</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(dic1))</span><br><span class="line"></span><br><span class="line">//输出:</span><br><span class="line"><span class="number">2</span></span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;titan&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>&#125;</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;dict&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>

<h3 id="内置方法"><a href="#内置方法" class="headerlink" title="内置方法"></a>内置方法</h3><h4 id="copy-方法"><a href="#copy-方法" class="headerlink" title="copy()方法"></a>copy()方法</h4><ul>
<li><code>copy() </code>函数返回一个字典的浅复制</li>
<li>直接赋值和 <code>copy</code> 的区别</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1 =  &#123;<span class="string">&#x27;user&#x27;</span>:<span class="string">&#x27;runoob&#x27;</span>,<span class="string">&#x27;num&#x27;</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]&#125;</span><br><span class="line"> </span><br><span class="line">dict2 = dict1          <span class="comment"># 浅拷贝: 引用对象</span></span><br><span class="line">dict3 = dict1.copy()   <span class="comment"># 浅拷贝：深拷贝父对象（一级目录），子对象（二级目录）不拷贝，还是引用</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 修改 data 数据</span></span><br><span class="line">dict1[<span class="string">&#x27;user&#x27;</span>]=<span class="string">&#x27;root&#x27;</span></span><br><span class="line">dict1[<span class="string">&#x27;num&#x27;</span>].remove(<span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="built_in">print</span>(dict1)</span><br><span class="line"><span class="built_in">print</span>(dict2)</span><br><span class="line"><span class="built_in">print</span>(dict3)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">&#123;<span class="string">&#x27;num&#x27;</span>: [<span class="number">2</span>, <span class="number">3</span>], <span class="string">&#x27;user&#x27;</span>: <span class="string">&#x27;root&#x27;</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;num&#x27;</span>: [<span class="number">2</span>, <span class="number">3</span>], <span class="string">&#x27;user&#x27;</span>: <span class="string">&#x27;root&#x27;</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;num&#x27;</span>: [<span class="number">2</span>, <span class="number">3</span>], <span class="string">&#x27;user&#x27;</span>: <span class="string">&#x27;runoob&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>实例中 <code>dict2</code> 其实是 <code>dict1</code> 的引用（别名），所以输出结果都是一致的，<code>dict3</code> 父对象进行了深拷贝，不会随<code>dict1</code> 修改而修改，子对象是浅拷贝所以随 <code>dict1</code> 的修改而修改</p>
<h4 id="fromkeys-方法"><a href="#fromkeys-方法" class="headerlink" title="fromkeys()方法"></a>fromkeys()方法</h4><ul>
<li><code>fromkeys()</code> 函数用于创建一个新字典，</li>
<li>参数一: 以序列<code>seq</code>中元素做字典的键</li>
<li>参数二: <code>value</code>为字典所有键对应的初始值(可选参数)</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dict</span>.fromkeys(seq[, value])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用</span></span><br><span class="line">dic2 = <span class="built_in">dict</span>.fromkeys([<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;titan&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(dic2)</span><br><span class="line">dic3 = <span class="built_in">dict</span>.fromkeys([<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;titan&#x27;</span>], <span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(dic3)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出:</span></span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="literal">None</span>, <span class="string">&#x27;titan&#x27;</span>: <span class="literal">None</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;titan&#x27;</span>: <span class="number">20</span>&#125;</span><br></pre></td></tr></table></figure>

<h4 id="get-和-setdefault-方法"><a href="#get-和-setdefault-方法" class="headerlink" title="get() 和 setdefault()方法"></a>get() 和 setdefault()方法</h4><ul>
<li><code>get()</code> 函数返回指定键的值，如果值不在字典中返回默认值</li>
<li><code>setdefault()</code>和<code>get()</code> 方法类似, 如果键不存在于字典中，将会添加键并将值设为默认值(同事也会把键值对添加到字典中)</li>
<li>参数一: 字典中要查找的键。</li>
<li>参数二: 如果指定键的值不存在时，返回该默认值值(可选参数)</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dict</span>.get(key, default=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用</span></span><br><span class="line">dic5 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;titan&#x27;</span>, <span class="string">&#x27;age&#x27;</span>:<span class="number">20</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(dic5.get(<span class="string">&#x27;name&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(dic5.get(<span class="string">&#x27;Sex&#x27;</span>, <span class="string">&#x27;man&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(dic5.setdefault(<span class="string">&#x27;name&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(dic5.setdefault(<span class="string">&#x27;Sex&#x27;</span>, <span class="string">&#x27;man&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(dic5)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果:</span></span><br><span class="line">titan</span><br><span class="line">man</span><br><span class="line">titan</span><br><span class="line">man</span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;titan&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;Sex&#x27;</span>: <span class="string">&#x27;man&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<h4 id="update-方法"><a href="#update-方法" class="headerlink" title="update()方法"></a>update()方法</h4><p>把字典的键&#x2F;值对更新到另一个字典里(合并字典)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dict</span>.update(dict2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用</span></span><br><span class="line">dic6 = &#123;<span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;new&#x27;</span>&#125;</span><br><span class="line">dic5.update(dic6)</span><br><span class="line"><span class="built_in">print</span>(dic5)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出:</span></span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;titan&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;Sex&#x27;</span>: <span class="string">&#x27;man&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;new&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<h4 id="pop-和-popitem-方法"><a href="#pop-和-popitem-方法" class="headerlink" title="pop() 和 popitem() 方法"></a>pop() 和 popitem() 方法</h4><ul>
<li><code>pop()</code>: 删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值</li>
<li><code>popitem()</code>: 随机返回并删除字典中的一对键和值。<br>如果字典已经为空，却调用了此方法，就报出KeyError异常</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pop(key[,default])</span><br><span class="line">popitem()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用</span></span><br><span class="line"><span class="built_in">print</span>(dic5.pop(<span class="string">&#x27;Sex&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(dic5)</span><br><span class="line"><span class="built_in">print</span>(dic5.popitem())</span><br><span class="line"><span class="built_in">print</span>(dic5)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出:</span></span><br><span class="line">man</span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;titan&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;new&#x27;</span>&#125;</span><br><span class="line">(<span class="string">&#x27;sex&#x27;</span>, <span class="string">&#x27;new&#x27;</span>)</span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;titan&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>&#125;</span><br></pre></td></tr></table></figure>

<h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dic2 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;titan&#x27;</span>, <span class="string">&#x27;age&#x27;</span>:<span class="number">20</span>&#125;</span><br><span class="line"><span class="comment"># 判断键是否存在于字典中, 在True, 不在False</span></span><br><span class="line"><span class="built_in">print</span>(dic2.__contains__(<span class="string">&#x27;name&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以列表返回可遍历的(键, 值) 元组数组</span></span><br><span class="line"><span class="built_in">print</span>(dic2.items())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除字典内所有元素</span></span><br><span class="line">dic2.clear()</span><br><span class="line"><span class="built_in">print</span>(dic2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果:</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line">dict_items([(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;titan&#x27;</span>), (<span class="string">&#x27;age&#x27;</span>, <span class="number">20</span>)])</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h2><ul>
<li><code>Python</code> 提供了一个 <code>time</code> 和 <code>calendar</code> </li>
<li>模块可以用于格式化日期和时间。</li>
<li>时间间隔是以秒为单位的浮点小数。</li>
<li>每个时间戳都以自从1970年1月1日午夜（历元）经过了多长时间来表示</li>
<li>在介绍时间之前, 先介绍一下什么时间元组</li>
</ul>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
<th>取值</th>
</tr>
</thead>
<tbody><tr>
<td>tm_year</td>
<td>4位数年</td>
<td>2018</td>
</tr>
<tr>
<td>tm_mon</td>
<td>月</td>
<td>1 到 12</td>
</tr>
<tr>
<td>tm_mday</td>
<td>日</td>
<td>1到31</td>
</tr>
<tr>
<td>tm_hour</td>
<td>小时</td>
<td>0 到 23</td>
</tr>
<tr>
<td>tm_min</td>
<td>分钟</td>
<td>0 到 59</td>
</tr>
<tr>
<td>tm_sec</td>
<td>秒</td>
<td>0 到 61 (60或61 是闰秒)</td>
</tr>
<tr>
<td>tm_wday</td>
<td>礼拜几</td>
<td>0到6 (0是周一)</td>
</tr>
<tr>
<td>tm_yday</td>
<td>一年的第几日</td>
<td>1 到 366(儒略历)</td>
</tr>
<tr>
<td>tm_isdst</td>
<td>夏令时</td>
<td>-1, 0, 1, -1是决定是否为夏令时的旗帜</td>
</tr>
</tbody></table>
<p>获取时间的简单示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 日期和时间</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前时间戳</span></span><br><span class="line">ticks = time.time()</span><br><span class="line"><span class="built_in">print</span>(ticks)</span><br><span class="line"><span class="comment"># 本地时间</span></span><br><span class="line">localTime = time.localtime()</span><br><span class="line"><span class="built_in">print</span>(localTime)</span><br><span class="line"><span class="comment"># 格式化时间</span></span><br><span class="line"><span class="built_in">print</span>(time.asctime(localTime))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果:</span></span><br><span class="line"><span class="number">1524051644.320941</span></span><br><span class="line">time.struct_time(tm_year=<span class="number">2018</span>, tm_mon=<span class="number">4</span>, tm_mday=<span class="number">18</span>, tm_hour=<span class="number">19</span>, tm_min=<span class="number">40</span>, tm_sec=<span class="number">44</span>, tm_wday=<span class="number">2</span>, tm_yday=<span class="number">108</span>, tm_isdst=<span class="number">0</span>)</span><br><span class="line">Wed Apr <span class="number">18</span> <span class="number">19</span>:<span class="number">40</span>:<span class="number">44</span> <span class="number">2018</span></span><br></pre></td></tr></table></figure>

<h3 id="格式化日期"><a href="#格式化日期" class="headerlink" title="格式化日期"></a>格式化日期</h3><p>先看几个简单示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.格式化日期</span></span><br><span class="line"><span class="comment"># 格式化成 2018-04-18 19:49:44 形式</span></span><br><span class="line">newDate1 = time.strftime(<span class="string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>, time.localtime())</span><br><span class="line"><span class="built_in">print</span>(newDate1)</span><br><span class="line"><span class="comment"># 格式化成 Wed Apr 18 19:50:53 2018 形式</span></span><br><span class="line">newDate2 = time.strftime(<span class="string">&#x27;%a %b %d %H:%M:%S %Y&#x27;</span>, time.localtime())</span><br><span class="line"><span class="built_in">print</span>(newDate2)</span><br><span class="line"><span class="comment"># 将时间字符串转化为时间戳</span></span><br><span class="line">timeNum = time.mktime(time.strptime(newDate2, <span class="string">&quot;%a %b %d %H:%M:%S %Y&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(timeNum)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果:</span></span><br><span class="line"><span class="number">2018</span>-04-<span class="number">18</span> <span class="number">19</span>:<span class="number">52</span>:<span class="number">21</span></span><br><span class="line">Wed Apr <span class="number">18</span> <span class="number">19</span>:<span class="number">52</span>:<span class="number">21</span> <span class="number">2018</span></span><br><span class="line"><span class="number">1524052341.0</span></span><br></pre></td></tr></table></figure>

<ul>
<li>这里介绍下上面用到的相关<code>Python</code>中时间和日期相关的格式化符号<ul>
<li><code>%y</code>: 两位数的年份表示（00-99）</li>
<li><code>%Y</code>: 四位数的年份表示（000-9999）</li>
<li><code>%m</code>: 月份（01-12）</li>
<li><code>%d</code>: 月内中的一天（0-31）</li>
<li><code>%H</code>: 24小时制小时数（0-23）</li>
<li><code>%I</code>: 12小时制小时数（01-12）</li>
<li><code>%M</code>: 分钟数（00&#x3D;59）</li>
<li><code>%S</code>: 秒（00-59）</li>
<li><code>%a</code>: 本地简化星期名称</li>
<li><code>%A</code>: 本地完整星期名称</li>
<li><code>%b</code>: 本地简化的月份名称</li>
<li><code>%B</code>: 本地完整的月份名称</li>
<li><code>%c</code>: 本地相应的日期表示和时间表示</li>
<li><code>%j</code>: 年内的一天（001-366）</li>
<li><code>%p</code>: 本地A.M.或P.M.的等价符</li>
<li><code>%U</code>: 一年中的星期数（00-53）星期天为星期的开始</li>
<li><code>%w</code>: 星期（0-6），星期天为星期的开始</li>
<li><code>%W</code>: 一年中的星期数（00-53）星期一为星期的开始</li>
<li><code>%x</code>: 本地相应的日期表示</li>
<li><code>%X</code>: 本地相应的时间表示</li>
<li><code>%Z</code>: 当前时区的名称</li>
<li><code>%%</code>: %号本身</li>
</ul>
</li>
</ul>
<h3 id="Time-模块"><a href="#Time-模块" class="headerlink" title="Time 模块"></a>Time 模块</h3><p><code>Time</code> 模块包含了以下内置函数，既有时间处理相的，也有转换时间格式的</p>
<h4 id="Time模块的属性"><a href="#Time模块的属性" class="headerlink" title="Time模块的属性"></a>Time模块的属性</h4><ul>
<li><code>timezone</code>: 当地时区（未启动夏令时）距离格林威治的偏移秒数（&gt;0，美洲;&lt;&#x3D;0大部分欧洲，亚洲，非洲）</li>
<li><code>tzname</code>: 包含一对根据情况的不同而不同的字符串，分别是带夏令时的本地时区名称，和不带的</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(time.timezone)</span><br><span class="line"><span class="built_in">print</span>(time.tzname)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">-<span class="number">28800</span></span><br><span class="line">(<span class="string">&#x27;CST&#x27;</span>, <span class="string">&#x27;CST&#x27;</span>)</span><br></pre></td></tr></table></figure>


<h4 id="altzone-方法"><a href="#altzone-方法" class="headerlink" title="altzone()方法"></a>altzone()方法</h4><p>返回格林威治西部的夏令时地区的偏移秒数。如果该地区在格林威治东部会返回负值（如西欧，包括英国）。对夏令时启用地区才能使用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(time.altzone)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果:</span></span><br><span class="line">-<span class="number">28800</span></span><br></pre></td></tr></table></figure>

<h4 id="asctime-方法"><a href="#asctime-方法" class="headerlink" title="asctime()方法"></a>asctime()方法</h4><p>接受时间元组并返回一个可读的形式为<code>&quot;Tue Dec 11 18:07:14 2008&quot;</code>（2008年12月11日 周二18时07分14秒）的24个字符的字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">localTime = time.localtime()</span><br><span class="line"><span class="built_in">print</span>(localTime)</span><br><span class="line"><span class="comment"># 格式化时间</span></span><br><span class="line"><span class="built_in">print</span>(time.asctime(localTime))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果:</span></span><br><span class="line">time.struct_time(tm_year=<span class="number">2018</span>, tm_mon=<span class="number">4</span>, tm_mday=<span class="number">18</span>, tm_hour=<span class="number">19</span>, tm_min=<span class="number">40</span>, tm_sec=<span class="number">44</span>, tm_wday=<span class="number">2</span>, tm_yday=<span class="number">108</span>, tm_isdst=<span class="number">0</span>)</span><br><span class="line">Wed Apr <span class="number">18</span> <span class="number">19</span>:<span class="number">40</span>:<span class="number">44</span> <span class="number">2018</span></span><br></pre></td></tr></table></figure>

<h4 id="ctime-和-gmtime-和-localtime-方法"><a href="#ctime-和-gmtime-和-localtime-方法" class="headerlink" title="ctime() 和 gmtime() 和 localtime()方法"></a>ctime() 和 gmtime() 和 localtime()方法</h4><ul>
<li><code>ctime</code>: 把一个时间戳（按秒计算的浮点数）转化为<code>time.asctime()</code>的形式。</li>
<li><code>gmtime</code>: 将一个时间戳转换为UTC时区（0时区）的<code>struct_time</code>（<code>struct_time是在time</code>模块中定义的表示时间的对象）</li>
<li><code>localtime</code>: 类似<code>gmtime</code>，作用是格式化时间戳为本地的时间</li>
<li>如果参数未给或者为None的时候，将会默认<code>time.time()</code>为参数</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">time.ctime([ sec ])</span><br><span class="line">time.gmtime([ sec ])</span><br><span class="line">time.localtime([ sec ])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用</span></span><br><span class="line"><span class="built_in">print</span>(time.ctime())</span><br><span class="line"><span class="built_in">print</span>(time.ctime(time.time() - <span class="number">100</span>))</span><br><span class="line"><span class="built_in">print</span>(time.gmtime())</span><br><span class="line"><span class="built_in">print</span>(time.gmtime(time.time() - <span class="number">100</span>))</span><br><span class="line"><span class="built_in">print</span>(time.localtime())</span><br><span class="line"><span class="built_in">print</span>(time.localtime(time.time() - <span class="number">100</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果:</span></span><br><span class="line">Wed Apr <span class="number">18</span> <span class="number">20</span>:<span class="number">18</span>:<span class="number">19</span> <span class="number">2018</span></span><br><span class="line">Wed Apr <span class="number">18</span> <span class="number">20</span>:<span class="number">16</span>:<span class="number">39</span> <span class="number">2018</span></span><br><span class="line">time.struct_time(tm_year=<span class="number">2018</span>, tm_mon=<span class="number">4</span>, tm_mday=<span class="number">18</span>, tm_hour=<span class="number">12</span>, tm_min=<span class="number">25</span>, tm_sec=<span class="number">44</span>, tm_wday=<span class="number">2</span>, tm_yday=<span class="number">108</span>, tm_isdst=<span class="number">0</span>)</span><br><span class="line">time.struct_time(tm_year=<span class="number">2018</span>, tm_mon=<span class="number">4</span>, tm_mday=<span class="number">18</span>, tm_hour=<span class="number">12</span>, tm_min=<span class="number">24</span>, tm_sec=<span class="number">4</span>, tm_wday=<span class="number">2</span>, tm_yday=<span class="number">108</span>, tm_isdst=<span class="number">0</span>)</span><br><span class="line">time.struct_time(tm_year=<span class="number">2018</span>, tm_mon=<span class="number">4</span>, tm_mday=<span class="number">19</span>, tm_hour=<span class="number">9</span>, tm_min=<span class="number">45</span>, tm_sec=<span class="number">19</span>, tm_wday=<span class="number">3</span>, tm_yday=<span class="number">109</span>, tm_isdst=<span class="number">0</span>)</span><br><span class="line">time.struct_time(tm_year=<span class="number">2018</span>, tm_mon=<span class="number">4</span>, tm_mday=<span class="number">19</span>, tm_hour=<span class="number">9</span>, tm_min=<span class="number">43</span>, tm_sec=<span class="number">39</span>, tm_wday=<span class="number">3</span>, tm_yday=<span class="number">109</span>, tm_isdst=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h4 id="gmtime-方法"><a href="#gmtime-方法" class="headerlink" title="gmtime()方法"></a>gmtime()方法</h4><ul>
<li>接收<code>struct_time</code>对象作为参数，返回用秒数来表示时间的浮点数</li>
<li>如果输入的值不是一个合法的时间，将触发 <code>OverflowError</code> 或 <code>ValueError</code></li>
<li>参数: 结构化的时间或者完整的9位元组元素</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">time.mktime(t)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用</span></span><br><span class="line">t = (<span class="number">2018</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">2</span>, <span class="number">34</span>, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(time.mktime(t))</span><br><span class="line"><span class="built_in">print</span>(time.mktime(time.localtime()))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果:</span></span><br><span class="line"><span class="number">1524103820.0</span></span><br><span class="line"><span class="number">1524104835.0</span></span><br></pre></td></tr></table></figure>

<h4 id="sleep-方法"><a href="#sleep-方法" class="headerlink" title="sleep()方法"></a>sleep()方法</h4><p>推迟调用线程，可通过参数<code>secs</code>指秒数，表示进程推迟的时间</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">time.sleep(t)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用</span></span><br><span class="line"><span class="built_in">print</span>(time.ctime())</span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(time.ctime())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果:</span></span><br><span class="line">Thu Apr <span class="number">19</span> <span class="number">10</span>:<span class="number">29</span>:<span class="number">51</span> <span class="number">2018</span></span><br><span class="line">Thu Apr <span class="number">19</span> <span class="number">10</span>:<span class="number">29</span>:<span class="number">54</span> <span class="number">2018</span></span><br></pre></td></tr></table></figure>

<h4 id="strftime-方法"><a href="#strftime-方法" class="headerlink" title="strftime()方法"></a>strftime()方法</h4><ul>
<li>接收以时间元组，并返回以可读字符串表示的当地时间，格式由参数<code>format</code>决定, 上面已经简单介绍过了</li>
<li>参数<code>format</code> – 格式字符串</li>
<li>参数<code>t</code> – 可选的参数t是一个<code>struct_time</code>对象</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">time.strftime(<span class="built_in">format</span>[, t])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用</span></span><br><span class="line">newDate1 = time.strftime(<span class="string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>, time.localtime())</span><br><span class="line"><span class="built_in">print</span>(newDate1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果:</span></span><br><span class="line"><span class="number">2018</span>-04-<span class="number">19</span> <span class="number">10</span>:<span class="number">35</span>:<span class="number">22</span></span><br></pre></td></tr></table></figure>

<h4 id="strptime-方法"><a href="#strptime-方法" class="headerlink" title="strptime()方法"></a>strptime()方法</h4><ul>
<li>函数根据指定的格式把一个时间字符串解析为时间元组</li>
<li>参数一: 时间字符串</li>
<li>参数二: 格式化字符串</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">time.strptime(string[, <span class="built_in">format</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用</span></span><br><span class="line">structTime= time.strptime(<span class="string">&#x27;20 Nov 2018&#x27;</span>, <span class="string">&#x27;%d %b %Y&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(structTime)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果:</span></span><br><span class="line">time.struct_time(tm_year=<span class="number">2018</span>, tm_mon=<span class="number">11</span>, tm_mday=<span class="number">20</span>, tm_hour=<span class="number">0</span>, tm_min=<span class="number">0</span>, tm_sec=<span class="number">0</span>, tm_wday=<span class="number">1</span>, tm_yday=<span class="number">324</span>, tm_isdst=-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h4 id="tzset-方法"><a href="#tzset-方法" class="headerlink" title="tzset()方法"></a>tzset()方法</h4><p>根据环境变量TZ重新初始化时间相关设置, 标准TZ环境变量格式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">std offset [dst [offset [,start[/time], end[/time]]]]</span><br></pre></td></tr></table></figure>

<ul>
<li><code>std</code> 和 <code>dst</code>: 三个或者多个时间的缩写字母。传递给 <code>time.tzname</code>.</li>
<li><code>offset</code>: 距<code>UTC</code>的偏移，格式： <code>[+|-]hh[:mm[:ss]] &#123;h=0-23, m/s=0-59&#125;</code>。</li>
<li><code>start[/time]</code>, <code>end[/time]</code>: <code>DST</code> 开始生效时的日期。格式为 <code>m.w.d</code> — 代表日期的月份、周数和日期。<code>w=1</code> 指月份中的第一周，而 <code>w=5</code> 指月份的最后一周。<code>start</code> 和 <code>end</code> 可以是以下格式之一：<ul>
<li><code>Jn</code>: 儒略日 <code>n (1 &lt;= n &lt;= 365)</code>。闰年日（2月29）不计算在内。</li>
<li><code>n</code>: 儒略日 <code>(0 &lt;= n &lt;= 365)</code>。 闰年日（2月29）计算在内</li>
<li><code>Mm.n.d</code>: 日期的月份、周数和日期。<code>w=1</code> 指月份中的第一周，而 <code>w=5</code> 指月份的最后一周。</li>
<li><code>time</code>:（可选）<code>DST</code> 开始生效时的时间（24 小时制）。默认值为 02:00（指定时区的本地时间）</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 没有返回值</span></span><br><span class="line">time.tzset()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">os.environ[<span class="string">&#x27;TZ&#x27;</span>] = <span class="string">&#x27;EST+05EDT,M4.1.0,M10.5.0&#x27;</span></span><br><span class="line">time.tzset()</span><br><span class="line"><span class="built_in">print</span> time.strftime(<span class="string">&#x27;%X %x %Z&#x27;</span>)</span><br><span class="line"></span><br><span class="line">os.environ[<span class="string">&#x27;TZ&#x27;</span>] = <span class="string">&#x27;AEST-10AEDT-11,M10.5.0,M3.5.0&#x27;</span></span><br><span class="line">time.tzset()</span><br><span class="line"><span class="built_in">print</span> time.strftime(<span class="string">&#x27;%X %x %Z&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果为：</span></span><br><span class="line"><span class="number">13</span>:<span class="number">00</span>:<span class="number">40</span> 02/<span class="number">17</span>/09 EST</span><br><span class="line">05:<span class="number">00</span>:<span class="number">40</span> 02/<span class="number">18</span>/09 AEDT</span><br></pre></td></tr></table></figure>

<h3 id="日历（Calendar）模块"><a href="#日历（Calendar）模块" class="headerlink" title="日历（Calendar）模块"></a>日历（Calendar）模块</h3><ul>
<li>此模块的函数都是日历相关的，例如打印某月的字符月历。</li>
<li>星期一是默认的每周第一天，星期天是默认的最后一天。</li>
<li>介绍一下<code>Calendar</code>模块的相关函数</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 返回当前每周起始日期的设置, 默认情况下，首次载入caendar模块时返回0，即星期一</span></span><br><span class="line"><span class="built_in">print</span>(calendar.firstweekday())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 是闰年返回True，否则为false</span></span><br><span class="line"><span class="comment"># calendar.isleap(year)</span></span><br><span class="line"><span class="built_in">print</span>(calendar.isleap(<span class="number">2016</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回在Y1，Y2两年之间的闰年总数</span></span><br><span class="line"><span class="comment"># calendar.leapdays(y1,y2)</span></span><br><span class="line"><span class="built_in">print</span>(calendar.leapdays(<span class="number">2015</span>, <span class="number">2021</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回一个元组, 第一个元素是该月的第一天是星期几(0-6, 0是星期日), 第二个元素是该月有几天</span></span><br><span class="line"><span class="comment"># calendar.monthcalendar(year,month)</span></span><br><span class="line"><span class="built_in">print</span>(calendar.monthrange(<span class="number">2018</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回给定日期是星期几(0-6, 0是星期一)</span></span><br><span class="line"><span class="comment"># calendar.weekday(year,month,day)</span></span><br><span class="line"><span class="built_in">print</span>(calendar.weekday(<span class="number">2018</span>, <span class="number">4</span>, <span class="number">19</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置每周的起始日期</span></span><br><span class="line"><span class="comment"># calendar.setfirstweekday(weekday) 无返回值</span></span><br><span class="line">calendar.setfirstweekday(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(calendar.firstweekday())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果:</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">(<span class="number">6</span>, <span class="number">30</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<h4 id="calendar-和-prcal方法"><a href="#calendar-和-prcal方法" class="headerlink" title="calendar 和 prcal方法"></a><code>calendar</code> 和 <code>prcal</code>方法</h4><p>返回一个多行字符串格式的year年年历，3个月一行，间隔距离为<code>c</code>。 每日宽度间隔为<code>w</code>字符。每行长度为<code>21* W+18+2* C</code>。<code>l</code>是每星期行数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">calendar.calendar(year,w=<span class="number">2</span>,l=<span class="number">1</span>,c=<span class="number">6</span>)</span><br><span class="line">calendar.prcal(year,w=<span class="number">2</span>,l=<span class="number">1</span>,c=<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">//使用</span><br><span class="line">year18 = calendar.calendar(<span class="number">2018</span>)</span><br><span class="line"><span class="built_in">print</span>(year18)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(calendar.prcal(<span class="number">2018</span>))</span><br></pre></td></tr></table></figure>

<h4 id="month-和-prmonth方法"><a href="#month-和-prmonth方法" class="headerlink" title="month 和 prmonth方法"></a><code>month</code> 和 <code>prmonth</code>方法</h4><p>返回一个多行字符串格式的<code>year</code>年<code>month</code>月日历，两行标题，一周一行。每日宽度间隔为<code>w</code>字符。每行的长度为<code>7* w+6</code>。<code>l</code>是每星期的行数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">calendar.month(year,month,w=<span class="number">2</span>,l=<span class="number">1</span>)</span><br><span class="line">calendar.prmonth(year,month,w=<span class="number">2</span>,l=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">//使用</span><br><span class="line">monthTime = calendar.month(<span class="number">2018</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(monthTime)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(calendar.prmonth(<span class="number">2018</span>, <span class="number">4</span>))</span><br></pre></td></tr></table></figure>

<h4 id="timegm方法"><a href="#timegm方法" class="headerlink" title="timegm方法"></a><code>timegm</code>方法</h4><p>和<code>time.gmtime</code>相反：接受一个时间元组形式，返回该时刻的时间戳（1970纪元后经过的浮点秒数）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">calendar.timegm(tupletime)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用</span></span><br><span class="line"><span class="built_in">print</span>(calendar.timegm(time.localtime()))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="number">1524150128</span></span><br></pre></td></tr></table></figure>


<hr>
<ul>
<li>到这里, <code>Python</code>相关的数据类型(数字, 字符串, 元组, 列表和字典)基本都介绍完毕了</li>
<li><code>Python</code>中的常用的时间格式和时间相关的模块(<code>time</code>和<code>calendar</code>)也都介绍完了</li>
<li>文章中有些地方可能也不是很全面, 会继续努力</li>
<li>另外, 在<code>Python</code>中，其他处理日期和时间的模块还有：<a href="https://docs.python.org/3/library/datetime.html#module-datetime">datetime模块</a> 和 <a href="http://labix.org/python-dateutil">dateutil模块</a></li>
<li>这两个模块这里也不再详细介绍了, <code>Python</code>相关文章后期会持续更新……</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python的面向对象和正则表达式</title>
    <url>/post/30901519.html</url>
    <content><![CDATA[<ul>
<li>之前的几篇文章主要介绍了<code>Python</code>中的一些数据类型和主要函数用法, 可参考<a href="https://www.titanjun.top/categories/Python%E5%9F%BA%E7%A1%80/">Python相关文章</a>, 这篇文章主要介绍面向对象和正则表达式</li>
<li><code>Python</code>和<code>Objective-C</code>一样是一门面向对象的的开发语言, 对于做过iOS开发的童鞋, 肯定对OC也是相当熟悉了, 这里也不做过多介绍了</li>
</ul>
<span id="more"></span>

<h2 id="创建类"><a href="#创建类" class="headerlink" title="创建类"></a>创建类</h2><p>使用 <code>class</code> 语句来创建一个新类，<code>class</code> 之后为类的名称并以冒号结尾:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span>:</span><br><span class="line">   <span class="string">&#x27;类的帮助信息&#x27;</span>   <span class="comment">#类文档字符串</span></span><br><span class="line">   class_suite  <span class="comment">#类体</span></span><br></pre></td></tr></table></figure>

<p>下面是一个具体的<code>Python</code> 类的示例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="string">&#x27;人类的基类&#x27;</span></span><br><span class="line"></span><br><span class="line">    empCount = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, sex</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.sex = sex</span><br><span class="line">        Person.empCount += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">displayCount</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;被调用次数: %d&quot;</span> % Person.empCount)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">displayPerson</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;姓名:&quot;</span>, self.name, <span class="string">&#x27;,&#x27;</span>, <span class="string">&quot;性别:&quot;</span>, self.sex)</span><br></pre></td></tr></table></figure>

<ul>
<li>上述示例中:<ul>
<li><code>empCount</code> 变量是一个类变量，它的值将在这个类的所有实例之间共享, 可以在内部类或外部类使用 <code>Person.empCount</code> 访问</li>
<li><code>__init__()</code>: 类的构造函数或初始化方法，当创建了这个类的实例时就会调用该方法(和OC中相同)</li>
<li><code>displayCount</code>和<code>displayPerson</code>: 类的实例方法, 可通过初始化后的对象访问</li>
<li><code>self</code>: 代表类的实例, 而不是类本身</li>
</ul>
</li>
</ul>
<h3 id="创建实例对象"><a href="#创建实例对象" class="headerlink" title="创建实例对象"></a>创建实例对象</h3><ul>
<li>在实例化类的方式中, 每一种语言都有不同的初始化方式, 在OC中用<code>[[Person alloc] init]</code>, 在<code>Swift</code>中用<code>Person()</code>, 在<code>Java</code>和<code>JavaScript</code>中则是使用关键字<code>new</code></li>
<li>但是在 <code>Python</code> 中并没有类似关键字, 其初始化方式和<code>Swift</code>的方式类似</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.创建第一个对象</span></span><br><span class="line">person1 = Person(<span class="string">&quot;titan&quot;</span>, <span class="string">&#x27;man&#x27;</span>)</span><br><span class="line"><span class="comment"># 2.创建第二个对象</span></span><br><span class="line">person2 = Person(<span class="string">&#x27;jun&#x27;</span>, <span class="string">&#x27;woman&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="属性访问"><a href="#属性访问" class="headerlink" title="属性访问"></a>属性访问</h3><p>在<code>Python</code>中属性和实例方法的访问都是通过点语法的形式, 如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.创建第一个对象</span></span><br><span class="line">person1 = Person(<span class="string">&quot;titan&quot;</span>, <span class="string">&#x27;man&#x27;</span>)</span><br><span class="line">person1.displayPerson()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.创建第二个对象</span></span><br><span class="line">person2 = Person(<span class="string">&#x27;jun&#x27;</span>, <span class="string">&#x27;woman&#x27;</span>)</span><br><span class="line">person2.displayPerson()</span><br><span class="line">person2.displayCount()</span><br><span class="line"><span class="built_in">print</span>(Person.empCount)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果:</span></span><br><span class="line">姓名: titan , 性别: man</span><br><span class="line">姓名: jun , 性别: woman</span><br><span class="line">被调用次数: <span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<h3 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h3><p>关于属性操作的相关函数, 添加&#x2F;修改&#x2F;删除类的属性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 3.增加类的属性</span><br><span class="line">person1.age = 19</span><br><span class="line">print(person1.age)</span><br><span class="line"></span><br><span class="line"># 4.修改属性值</span><br><span class="line">person1.age = 20</span><br><span class="line">print(person1.age)</span><br><span class="line"></span><br><span class="line"># 5.删除属性</span><br><span class="line">del person1.age</span><br><span class="line"># 此处条用age属性会报错</span><br><span class="line"># print(person1.age)</span><br></pre></td></tr></table></figure>

<p>这里在介绍一些相关函数操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 6.常用函数</span></span><br><span class="line"><span class="comment"># 6.1.检查是否存在一个属性</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hasattr</span>(person1, <span class="string">&#x27;age&#x27;</span>)) <span class="comment">#False</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hasattr</span>(person1, <span class="string">&#x27;name&#x27;</span>)) <span class="comment">#True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 6.2.访问对象的属性</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">getattr</span>(person1, <span class="string">&#x27;name&#x27;</span>))  <span class="comment">#titan</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 6.3.设置一个属性(如果属性不存在，会创建一个新属性)</span></span><br><span class="line"><span class="built_in">setattr</span>(person2, <span class="string">&#x27;age&#x27;</span>, <span class="number">17</span>)</span><br><span class="line"><span class="built_in">print</span>(person2.age) <span class="comment">#17</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 6.4.删除属性</span></span><br><span class="line"><span class="built_in">delattr</span>(person2, <span class="string">&#x27;age&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="内置类属性"><a href="#内置类属性" class="headerlink" title="内置类属性"></a>内置类属性</h3><ul>
<li><code>__name__</code>: 类名</li>
<li><code>__doc__</code> : 类的文档字符串</li>
<li><code>__dict__</code> : 类的属性（包含一个字典，由类的数据属性组成）</li>
<li><code>__module__</code>: 类定义所在的模块（类的全名是<code>__main__.className</code>，如果类位于一个导入模块<code>mymod</code>中，那么<code>className.- __module__ </code>等于 <code>mymod</code>）</li>
<li><code>__bases__ </code>: 类的所有父类构成元素（包含了一个由所有父类组成的元组）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python内置类属性</span></span><br><span class="line"><span class="comment"># 1.类的文档字符串</span></span><br><span class="line"><span class="built_in">print</span>(Person.__doc__)</span><br><span class="line"><span class="comment"># 输出结果: 人类的基类</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.类的所有父类构成元素</span></span><br><span class="line"><span class="built_in">print</span>(Person.__bases__)</span><br><span class="line"><span class="comment"># 输出结果: (&lt;class &#x27;object&#x27;&gt;,)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.类名</span></span><br><span class="line"><span class="built_in">print</span>(Person.__name__)</span><br><span class="line"><span class="comment"># 输出结果: Person</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 类定义所在的模块</span></span><br><span class="line"><span class="built_in">print</span>(Person.__module__)</span><br><span class="line"><span class="comment"># 输出结果: __main__</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.类的属性(字典)</span></span><br><span class="line"><span class="built_in">print</span>(Person.__dict__)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;输出结果</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&#x27;__module__&#x27;: &#x27;__main__&#x27;, </span></span><br><span class="line"><span class="string">&#x27;__doc__&#x27;: &#x27;人类的基类&#x27;, </span></span><br><span class="line"><span class="string">&#x27;empCount&#x27;: 2, </span></span><br><span class="line"><span class="string">&#x27;__init__&#x27;: &lt;function Person.__init__ at 0x1041a7510&gt;, </span></span><br><span class="line"><span class="string">&#x27;displayCount&#x27;: &lt;function Person.displayCount at 0x1041a76a8&gt;, </span></span><br><span class="line"><span class="string">&#x27;displayPerson&#x27;: &lt;function Person.displayPerson at 0x1041a7730&gt;, </span></span><br><span class="line"><span class="string">&#x27;__dict__&#x27;: &lt;attribute &#x27;__dict__&#x27; of &#x27;Person&#x27; objects&gt;, </span></span><br><span class="line"><span class="string">&#x27;__weakref__&#x27;: &lt;attribute &#x27;__weakref__&#x27; of &#x27;Person&#x27; objects&gt;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="私有属性和方法"><a href="#私有属性和方法" class="headerlink" title="私有属性和方法"></a>私有属性和方法</h3><ul>
<li><code>__private_attrs</code>：两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时 <code>self.__private_attrs</code></li>
<li>在类的内部，使用 <code>def</code> 关键字可以为类定义一个方法，与一般函数定义不同，类方法必须包含参数<code>self</code>, 且为第一个参数</li>
<li><code>__private_method</code>：两个下划线开头，声明该方法为私有方法，不能在类地外部调用。在类的内部调用 <code>self.__private_methods</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="下划线说明"><a href="#下划线说明" class="headerlink" title="下划线说明"></a>下划线说明</h3><ul>
<li><code>__foo__</code>: 定义的是特殊方法，一般是系统定义名字 ，类似 <code>__init__()</code> 之类的。</li>
<li><code>_foo</code>: 以单下划线开头的表示的是 <code>protected</code> 类型的变量，即保护类型只能允许其本身与子类进行访问，不能用于 <code>from module import *</code></li>
<li><code>__foo</code>: 双下划线的表示的是私有类型(<code>private</code>)的变量, 只能是允许这个类本身进行访问了。</li>
</ul>
<h2 id="Python-正则表达式"><a href="#Python-正则表达式" class="headerlink" title="Python 正则表达式"></a>Python 正则表达式</h2><ul>
<li>正则表达式是一个特殊的字符序列，它能帮助你方便的检查一个字符串是否与某种模式匹配。</li>
<li><code>Python</code> 自1.5版本起增加了 <code>re</code> 模块，它提供 <code>Perl</code> 风格的正则表达式模式</li>
<li><code>re</code> 模块使 <code>Python</code> 语言拥有全部的正则表达式功能</li>
<li><code>compile</code> 函数根据一个模式字符串和可选的标志参数生成一个正则表达式对象, 该对象拥有一系列方法用于正则表达式匹配和替换</li>
<li><code>re</code> 模块也提供了与这些方法功能完全一致的函数，这些函数使用一个模式字符串做为它们的第一个参数</li>
</ul>
<h3 id="re-match-和-re-search函数"><a href="#re-match-和-re-search函数" class="headerlink" title="re.match 和 re.search函数"></a><code>re.match</code> 和 <code>re.search</code>函数</h3><ul>
<li><code>re.match</code>: 尝试从字符串的起始位置匹配一个模式，匹配成功<code>re.match</code>方法返回一个匹配的对象，否则<code>match()</code>就返回<code>none</code></li>
<li><code>re.search</code>: 扫描整个字符串并返回第一个成功的匹配, 匹配成功<code>re.search</code>方法返回一个匹配的对象，否则返回<code>None</code></li>
</ul>
<h4 id="函数语法："><a href="#函数语法：" class="headerlink" title="函数语法："></a>函数语法：</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">re.<span class="keyword">match</span>(pattern, string, flags=<span class="number">0</span>)</span><br><span class="line">re.search(pattern, string, flags=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h4 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h4><ul>
<li><code>pattern</code>: 匹配的正则表达式</li>
<li><code>string</code>: 要匹配的字符串</li>
<li><code>flags</code>: 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等</li>
<li>正则表达式修饰符-可选标志, 部分介绍如下, 详细介绍可参见文章最后附录部分<ul>
<li><code>re.I</code> 忽略大小写</li>
<li><code>re.L</code> 表示特殊字符集 <code>\w, \W, \b, \B, \s, \S</code> 依赖于当前环境</li>
<li><code>re.M</code> 多行模式</li>
<li><code>re.S</code> 即为 . 并且包括换行符在内的任意字符（. 不包括换行符）</li>
<li><code>re.U</code> 表示特殊字符集 <code>\w, \W, \b, \B, \d, \D, \s, \S</code> 依赖于 <code>Unicode</code> 字符属性数据库</li>
<li><code>re.X</code> 为了增加可读性，忽略空格和<code>#</code>后面的注释</li>
</ul>
</li>
</ul>
<h4 id="匹配对象的相关方法"><a href="#匹配对象的相关方法" class="headerlink" title="匹配对象的相关方法"></a>匹配对象的相关方法</h4><ul>
<li><code>group(num=0)</code>: 匹配的整个表达式的字符串，group() 可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组</li>
<li><code>groups()</code>: 返回一个包含所有小组字符串的元组，从 1 到 所含的小组号</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 正则表达式</span></span><br><span class="line"><span class="comment"># 1. re.match函数</span></span><br><span class="line"><span class="keyword">match</span> = re.<span class="keyword">match</span>(<span class="string">&#x27;https&#x27;</span>, <span class="string">&#x27;https :// www .titanjun .top&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">match</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">match</span>.group())</span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">match</span>.groups())</span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">match</span>.span())</span><br><span class="line"></span><br><span class="line">match2 = re.<span class="keyword">match</span>(<span class="string">&#x27;www&#x27;</span>, <span class="string">&#x27;https://www.titanjun.top&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(match2)</span><br><span class="line"><span class="comment"># print(match2.group())</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-------华丽分割线--------&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. re.search</span></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&#x27;https :// www .titanjun .top&#x27;</span></span><br><span class="line">search1 = re.search(<span class="string">r&#x27;www&#x27;</span>, <span class="built_in">str</span>, re.M | re.I)</span><br><span class="line"><span class="built_in">print</span>(search1)</span><br><span class="line"><span class="built_in">print</span>(search1.span())</span><br><span class="line"><span class="built_in">print</span>(search1.group())</span><br><span class="line"><span class="built_in">print</span>(search1.groups())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果:</span></span><br><span class="line">&lt;_sre.SRE_Match <span class="built_in">object</span>; span=(<span class="number">0</span>, <span class="number">5</span>), <span class="keyword">match</span>=<span class="string">&#x27;https&#x27;</span>&gt;</span><br><span class="line">https</span><br><span class="line">()</span><br><span class="line">(<span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line"><span class="literal">None</span></span><br><span class="line">-------华丽分割线--------</span><br><span class="line">&lt;_sre.SRE_Match <span class="built_in">object</span>; span=(<span class="number">10</span>, <span class="number">13</span>), <span class="keyword">match</span>=<span class="string">&#x27;www&#x27;</span>&gt;</span><br><span class="line">(<span class="number">10</span>, <span class="number">13</span>)</span><br><span class="line">www</span><br><span class="line">()</span><br></pre></td></tr></table></figure>

<h3 id="re-sub方法"><a href="#re-sub方法" class="headerlink" title="re.sub方法"></a><code>re.sub</code>方法</h3><p>用于替换字符串中的匹配项</p>
<h4 id="函数语法：-1"><a href="#函数语法：-1" class="headerlink" title="函数语法："></a>函数语法：</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">re.sub(pattern, repl, string, count=<span class="number">0</span>, flags=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h4 id="函数参数-1"><a href="#函数参数-1" class="headerlink" title="函数参数"></a>函数参数</h4><ul>
<li><code>pattern</code>: 正则中的模式字符串。</li>
<li><code>repl</code>: 替换的字符串，也可为一个函数。</li>
<li><code>string</code>: 要被查找替换的原始字符串。</li>
<li><code>count</code>: 模式匹配后替换的最大次数，默认 0 表示替换所有的匹配</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 3. sub替换函数</span></span><br><span class="line">subStr = <span class="string">&#x27;2018-05-03 # 文章的写作日期&#x27;</span></span><br><span class="line"><span class="comment"># 删除注释</span></span><br><span class="line">subStr2 = re.sub(<span class="string">&#x27;#.*$&#x27;</span>, <span class="string">&#x27;&#x27;</span>, subStr)</span><br><span class="line"><span class="built_in">print</span>(subStr2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 时间上替换-</span></span><br><span class="line"><span class="comment"># \D: 代表任意非数字</span></span><br><span class="line">subStr3 = re.sub(<span class="string">&#x27;\D&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, subStr2)</span><br><span class="line"><span class="built_in">print</span>(subStr3)</span><br><span class="line"><span class="built_in">print</span>(re.sub(<span class="string">&#x27;\D&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, subStr2, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果:</span></span><br><span class="line"><span class="number">2018</span>-05-03 </span><br><span class="line"><span class="number">2018.05</span><span class="number">.03</span>.</span><br><span class="line"><span class="number">2018.05</span><span class="number">.03</span></span><br></pre></td></tr></table></figure>

<h3 id="re-compile-函数"><a href="#re-compile-函数" class="headerlink" title="re.compile 函数"></a><code>re.compile</code> 函数</h3><p>用于编译正则表达式，生成一个正则表达式<code>Pattern</code>对象，供 <code>match()</code> 和 <code>search()</code> 这两个函数使用</p>
<h4 id="函数语法"><a href="#函数语法" class="headerlink" title="函数语法"></a>函数语法</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">re.<span class="built_in">compile</span>(pattern[, flags])</span><br></pre></td></tr></table></figure>

<h4 id="函数参数-2"><a href="#函数参数-2" class="headerlink" title="函数参数"></a>函数参数</h4><ul>
<li><code>pattern</code>: 一个字符串形式的正则表达式</li>
<li><code>flags</code>: 可选，表示匹配模式，比如忽略大小写，多行模式等</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 4. compile 函数</span></span><br><span class="line">pattern = re.<span class="built_in">compile</span>(<span class="string">r&#x27;\d+&#x27;</span>)  <span class="comment"># 用于匹配至少一个数字</span></span><br><span class="line"><span class="built_in">print</span>(pattern.<span class="keyword">match</span>(<span class="string">&#x27;titan0929&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(pattern.<span class="keyword">match</span>(<span class="string">&#x27;titan0929&#x27;</span>, <span class="number">5</span>, <span class="number">7</span>)) <span class="comment"># 从第5个字符开始匹配</span></span><br><span class="line">m = pattern.<span class="keyword">match</span>(<span class="string">&#x27;0929titan&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(m.group())</span><br><span class="line"><span class="built_in">print</span>(m.start())</span><br><span class="line"><span class="built_in">print</span>(m.end())</span><br><span class="line"><span class="built_in">print</span>(m.span())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果:</span></span><br><span class="line"><span class="literal">None</span></span><br><span class="line">&lt;_sre.SRE_Match <span class="built_in">object</span>; span=(<span class="number">5</span>, <span class="number">7</span>), <span class="keyword">match</span>=<span class="string">&#x27;09&#x27;</span>&gt;</span><br><span class="line">0929</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">(<span class="number">0</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>当匹配成功时返回一个 Match 对象，其中：<ul>
<li><code>group([group1, …])</code>: 方法用于获得一个或多个分组匹配的字符串，当要获得整个匹配的子串时，可直接使用 <code>group()</code> 或 <code>group(0)</code></li>
<li><code>start([group])</code>:  方法用于获取分组匹配的子串在整个字符串中的起始位置（子串第一个字符的索引），参数默认值为 0；</li>
<li><code>end([group])</code> 方法用于获取分组匹配的子串在整个字符串中的结束位置（子串最后一个字符的索引+1），参数默认值为 0；</li>
<li><code>span([group])</code>: 方法返回所匹配成功的范围,  <code>(start(group), end(group))</code></li>
</ul>
</li>
</ul>
<h3 id="findall函数"><a href="#findall函数" class="headerlink" title="findall函数"></a><code>findall</code>函数</h3><p>在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果没有找到匹配的，则返回空列表</p>
<h4 id="函数语法-1"><a href="#函数语法-1" class="headerlink" title="函数语法"></a>函数语法</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">findall(string[, pos[, endpos]])</span><br></pre></td></tr></table></figure>

<h4 id="函数参数-3"><a href="#函数参数-3" class="headerlink" title="函数参数"></a>函数参数</h4><ul>
<li><code>string</code>: 待匹配的字符串。</li>
<li><code>pos</code>: 可选参数，指定字符串的起始位置，默认为 0。</li>
<li><code>endpos</code>: 可选参数，指定字符串的结束位置，默认为字符串的长度</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 5. findall</span></span><br><span class="line">pattern2 = re.<span class="built_in">compile</span>(<span class="string">r&#x27;\d+&#x27;</span>)  <span class="comment"># 用于匹配至少一个数字</span></span><br><span class="line">fin1 = pattern2.findall(<span class="string">&#x27;titanjun09-www123titan29&#x27;</span>)</span><br><span class="line">fin2 = pattern2.findall(<span class="string">&#x27;titan123jun45www90&#x27;</span>, <span class="number">6</span>, <span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(fin1)</span><br><span class="line"><span class="built_in">print</span>(fin2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果:</span></span><br><span class="line">[<span class="string">&#x27;09&#x27;</span>, <span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;29&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;23&#x27;</span>, <span class="string">&#x27;45&#x27;</span>]</span><br></pre></td></tr></table></figure>


<h3 id="split函数"><a href="#split函数" class="headerlink" title="split函数"></a><code>split</code>函数</h3><p>按照能够匹配的子串将字符串分割后返回列表</p>
<h4 id="函数语法-2"><a href="#函数语法-2" class="headerlink" title="函数语法"></a>函数语法</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">re.split(pattern, string[, maxsplit=<span class="number">0</span>, flags=<span class="number">0</span>])</span><br></pre></td></tr></table></figure>

<h4 id="函数参数-4"><a href="#函数参数-4" class="headerlink" title="函数参数"></a>函数参数</h4><ul>
<li><code>pattern</code>: 匹配的正则表达式</li>
<li><code>string</code>: 要匹配的字符串</li>
<li><code>maxsplit</code>: 分隔次数，maxsplit&#x3D;1 分隔一次，默认为 0，不限制次数</li>
<li><code>flags</code>: 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 6. split</span></span><br><span class="line">split1 = re.split(<span class="string">&#x27;\W+&#x27;</span>, <span class="string">&#x27;https://www.titanjun.top&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(split1)</span><br><span class="line">split2 = re.split(<span class="string">&#x27;\W+&#x27;</span>, <span class="string">&#x27;https://www.titanjun.top&#x27;</span>, <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(split2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果:</span></span><br><span class="line">[<span class="string">&#x27;https&#x27;</span>, <span class="string">&#x27;www&#x27;</span>, <span class="string">&#x27;titanjun&#x27;</span>, <span class="string">&#x27;top&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;https&#x27;</span>, <span class="string">&#x27;www.titanjun.top&#x27;</span>]</span><br></pre></td></tr></table></figure>


<hr>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="正则表达式修饰符-可选标志"><a href="#正则表达式修饰符-可选标志" class="headerlink" title="正则表达式修饰符 - 可选标志"></a>正则表达式修饰符 - 可选标志</h3><p>正则表达式可以包含一些可选标志修饰符来控制匹配的模式。修饰符被指定为一个可选的标志。多个标志可以通过按位 <code>OR(|)</code> 它们来指定</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>re.I</code></td>
<td>使匹配对大小写不敏感</td>
</tr>
<tr>
<td><code>re.L</code></td>
<td>做本地化识别（<code>locale-aware</code>）匹配</td>
</tr>
<tr>
<td><code>re.M</code></td>
<td>多行匹配，影响 <code>^</code>和 <code>$</code></td>
</tr>
<tr>
<td><code>re.S</code></td>
<td>使 . 匹配包括换行在内的所有字符</td>
</tr>
<tr>
<td><code>re.U</code></td>
<td>根据<code>Unicode</code>字符集解析字符。这个标志影响 <code>\w, \W, \b, \B.</code></td>
</tr>
<tr>
<td><code>re.X</code></td>
<td>该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解。</td>
</tr>
</tbody></table>
<h3 id="正则表达式模式"><a href="#正则表达式模式" class="headerlink" title="正则表达式模式"></a>正则表达式模式</h3><ul>
<li>模式字符串使用特殊的语法来表示一个正则表达式：<ul>
<li>字母和数字表示他们自身</li>
<li>标点符号只有被转义时才匹配自身，否则它们表示特殊的含义</li>
<li>反斜杠本身需要使用反斜杠转义</li>
<li>由于正则表达式通常都包含反斜杠，所以最好使用原始字符串来表示, 模式元素(如 <code>r&#39;\t&#39;</code>，等价于 <code>&#39;\\t&#39;</code>)匹配相应的特殊字符</li>
</ul>
</li>
<li>下表列出了正则表达式模式语法中的特殊元素, 如果你使用模式的同时提供了可选的标志参数，某些模式元素的含义会改变</li>
</ul>
<table>
<thead>
<tr>
<th>模式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>^</code></td>
<td>匹配字符串的开头</td>
</tr>
<tr>
<td><code>.</code></td>
<td>匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符。</td>
</tr>
<tr>
<td><code>[...]</code></td>
<td>用来表示一组字符,单独列出：<code>[amk]</code> 匹配 <code>&#39;a&#39;</code>，<code>&#39;m&#39;</code>或<code>&#39;k&#39;</code></td>
</tr>
<tr>
<td><code>[^...]</code></td>
<td>不在<code>[]</code>中的字符：<code>[^abc]</code> 匹配除了<code>a,b,c</code>之外的字符。</td>
</tr>
<tr>
<td><code>re*</code></td>
<td>匹配0个或多个的表达式。</td>
</tr>
<tr>
<td><code>re+</code></td>
<td>匹配1个或多个的表达式。</td>
</tr>
<tr>
<td><code>re?</code></td>
<td>匹配0个或1个由前面的正则表达式定义的片段</td>
</tr>
<tr>
<td><code>re&#123; n&#125;</code></td>
<td>精确匹配 n 个前面表达式。例如， <code>o&#123;2&#125;</code> 不能匹配 <code>&quot;Bob&quot;</code> 中的 <code>&quot;o&quot;</code>，但是能匹配 <code>&quot;food&quot;</code> 中的两个 <code>o</code></td>
</tr>
<tr>
<td><code>re&#123; n,&#125;</code></td>
<td>匹配 n 个前面表达式。例如， <code>o&#123;2,&#125;</code> 不能匹配<code>&quot;Bob&quot;</code>中的<code>&quot;o&quot;</code>，但能匹配 <code>&quot;foooood&quot;</code>中的所有 <code>o</code>,<code>&quot;o&#123;1,&#125;&quot;</code> 等价于 <code>&quot;o+&quot;</code>。<code>&quot;o&#123;0,&#125;&quot;</code> 则等价于<code> &quot;o*&quot;</code>。</td>
</tr>
<tr>
<td><code>re&#123; n, m&#125;</code></td>
<td>匹配 n 到 m 次由前面的正则表达式定义的片段</td>
</tr>
<tr>
<td><code>(re)</code></td>
<td>匹配括号内的表达式，也表示一个组</td>
</tr>
<tr>
<td><code>(?imx)</code></td>
<td>正则表达式包含三种可选标志：i, m, 或 x 。只影响括号中的区域。</td>
</tr>
<tr>
<td><code>(?-imx)</code></td>
<td>正则表达式关闭 i, m, 或 x 可选标志。只影响括号中的区域。</td>
</tr>
<tr>
<td><code>(?: re)</code></td>
<td>类似 <code>(...)</code>, 但是不表示一个组</td>
</tr>
<tr>
<td><code>(?imx: re)</code></td>
<td>在括号中使用i, m, 或 x 可选标志</td>
</tr>
<tr>
<td><code>(?-imx: re)</code></td>
<td>在括号中不使用i, m, 或 x 可选标志</td>
</tr>
<tr>
<td><code>(?#...)</code></td>
<td>注释.</td>
</tr>
<tr>
<td><code>(?= re)</code></td>
<td>前向肯定界定符。如果所含正则表达式，以 … 表示，在当前位置成功匹配时成功，否则失败。但一旦所含表达式已经尝试，匹配引擎根本没有提高；模式的剩余部分还要尝试界定符的右边。</td>
</tr>
<tr>
<td><code>(?! re)</code></td>
<td>前向否定界定符。与肯定界定符相反；当所含表达式不能在字符串当前位置匹配时成功</td>
</tr>
<tr>
<td><code>(?&gt; re)</code></td>
<td>匹配的独立模式，省去回溯。</td>
</tr>
<tr>
<td><code>\w</code></td>
<td>匹配字母数字及下划线</td>
</tr>
<tr>
<td><code>\W</code></td>
<td>匹配非字母数字及下划线</td>
</tr>
<tr>
<td><code>\s</code></td>
<td>匹配任意空白字符，等价于 <code>[\t\n\r\f]</code></td>
</tr>
<tr>
<td><code>\S</code></td>
<td>匹配任意非空字符</td>
</tr>
<tr>
<td><code>\d</code></td>
<td>匹配任意数字，等价于 <code>[0-9]</code></td>
</tr>
<tr>
<td><code>\D</code></td>
<td>匹配任意非数字</td>
</tr>
<tr>
<td><code>\A</code></td>
<td>匹配字符串开始</td>
</tr>
<tr>
<td><code>\Z</code></td>
<td>匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串。</td>
</tr>
<tr>
<td><code>\z</code></td>
<td>匹配字符串结束</td>
</tr>
<tr>
<td><code>\G</code></td>
<td>匹配最后匹配完成的位置。</td>
</tr>
<tr>
<td><code>\b</code></td>
<td>匹配一个单词边界，也就是指单词和空格间的位置。例如， <code>&#39;er\b&#39;</code> 可以匹配<code>&quot;never&quot;</code> 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。</td>
</tr>
<tr>
<td><code>\B</code></td>
<td>匹配非单词边界。<code>&#39;er\B&#39;</code> 能匹配 <code>&quot;verb&quot;</code> 中的 <code>&#39;er&#39;</code>，但不能匹配 <code>&quot;never&quot;</code> 中的 <code>&#39;er&#39;</code>。</td>
</tr>
<tr>
<td><code>\n, \t</code> 等</td>
<td>匹配一个换行符。匹配一个制表符。等</td>
</tr>
<tr>
<td><code>\1...\9</code></td>
<td>匹配第n个分组的内容。</td>
</tr>
<tr>
<td><code>\10</code></td>
<td>匹配第n个分组的内容，如果它经匹配。否则指的是八进制字符码的表达式。</td>
</tr>
</tbody></table>
<h3 id="正则表达式实例"><a href="#正则表达式实例" class="headerlink" title="正则表达式实例"></a>正则表达式实例</h3><h4 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h4><table>
<thead>
<tr>
<th>实例</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>[Pp]ython</code></td>
<td>匹配 <code>&quot;Python&quot;</code> 或 <code>&quot;python&quot;</code></td>
</tr>
<tr>
<td><code>rub[ye]</code></td>
<td>匹配 <code>&quot;ruby&quot;</code> 或 <code>&quot;rube&quot;</code></td>
</tr>
<tr>
<td><code>[aeiou]</code></td>
<td>匹配中括号内的任意一个字母</td>
</tr>
<tr>
<td><code>[0-9]</code></td>
<td>匹配任何数字。类似于 <code>[0123456789]</code></td>
</tr>
<tr>
<td><code>[a-z]</code></td>
<td>匹配任何小写字母</td>
</tr>
<tr>
<td><code>[A-Z]</code></td>
<td>匹配任何大写字母</td>
</tr>
<tr>
<td><code>[a-zA-Z0-9]</code></td>
<td>匹配任何字母及数字</td>
</tr>
<tr>
<td><code>[^aeiou]</code></td>
<td>除了<code>aeiou</code>字母以外的所有字符</td>
</tr>
<tr>
<td><code>[^0-9]</code></td>
<td>匹配除了数字外的字符</td>
</tr>
</tbody></table>
<h4 id="特殊字符类"><a href="#特殊字符类" class="headerlink" title="特殊字符类"></a>特殊字符类</h4><table>
<thead>
<tr>
<th>实例</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>.</code></td>
<td>匹配除 <code>&quot;\n&quot;</code> 之外的任何单个字符。要匹配包括 <code>&#39;\n&#39;</code> 在内的任何字符，请使用象 <code>&#39;[.\n]&#39;</code> 的模式。</td>
</tr>
<tr>
<td><code>\d</code></td>
<td>匹配一个数字字符。等价于 <code>[0-9]</code>。</td>
</tr>
<tr>
<td><code>\D</code></td>
<td>匹配一个非数字字符。等价于 <code>[^0-9]</code>。</td>
</tr>
<tr>
<td><code>\s</code></td>
<td>匹配任何空白字符，包括空格、制表符、换页符等等。等价于 <code>[ \f\n\r\t\v]</code>。</td>
</tr>
<tr>
<td><code>\S</code></td>
<td>匹配任何非空白字符。等价于 <code>[^ \f\n\r\t\v]</code>。</td>
</tr>
<tr>
<td><code>\w</code></td>
<td>匹配包括下划线的任何单词字符。等价于<code>&#39;[A-Za-z0-9_]&#39;</code>。</td>
</tr>
<tr>
<td><code>\W</code></td>
<td>匹配任何非单词字符。等价于 <code>&#39;[^A-Za-z0-9_]&#39;</code>。</td>
</tr>
</tbody></table>
<ul>
<li>正则表达式符号使用小总结：<ul>
<li><code>[ ]</code>：方括号。匹配需要的字符集合，如[1-3]或[123]都是匹配1、2或者3。</li>
<li><code>^</code>：脱字符号。方括号中加入脱字符号，就是匹配未列出的所有其他字符，如<code>[^a]</code>匹配除a以外的所有其他字符。</li>
<li><code>\</code>：反斜杠。和<code>python</code>字符串使用规则一样，可以匹配特殊字符本身，如<code>\d</code>表示匹配0到9的任意一个数字字符，而<code>\\d</code>则表示匹配<code>\</code>d本身。</li>
<li><code>*</code>：星号。匹配前一个字符0到n次，如<code>pytho*n</code>可以匹配<code>pythn</code>、<code>pytoon</code>、<code>pythooooon</code>等。还有其它匹配重复字符的如<code>？、+</code>或<code>&#123;m,n&#125;</code>，其中<code>&#123;n,m&#125;</code>可以灵活使用，它表示匹配n次到m次</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python编程之Tkinter的使用01</title>
    <url>/post/b8a3c83b.html</url>
    <content><![CDATA[<p><img data-src="https://upload-images.jianshu.io/upload_images/4122543-1342b3e94cfe5e4d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Tkinter"></p>
<span id="more"></span>


<p><code>Python</code>提供了多个图形开发界面的库，几个常用<code>Python GUI</code>库如下：</p>
<ul>
<li><code>Tkinter</code>：<code>Tkinter</code>模块(Tk 接口)是<code>Python</code>的标准 Tk GUI 工具包的接口<code>.Tk</code>和<code>Tkinter</code>可以在大多数的<code>Unix</code>平台下使用, 同样可以应用在<code>Windows</code>和<code>Macintosh</code>系统里。<code>Tk8.0</code>的后续版本可以实现本地窗口风格,并良好地运行在绝大多数平台中。</li>
<li><code>wxPython</code>：<code>wxPython</code>是一款开源软件，是<code>Python</code>语言的一套优秀的<code>GUI</code>图形库，允许<code>Python</code>程序员很方便的创建完整的、功能健全的<code>GUI</code>用户界面。</li>
<li><code>Jython</code>：<code>Jython</code>程序可以和<code>Java</code>无缝集成。除了一些标准模块，<code>Jython</code>使用<code>Java</code>的模块。<code>Jython</code> 几乎拥有标准的<code>Python</code>中不依赖于<code>C</code> 语言的全部模块。比如，<code>Jython</code>的用户界面将使用 <code>Swing</code>，<code>AWT</code>或者<code>SWT</code>。<code>Jython</code> 可以被动态或静态地编译成<code>Java</code>字节码</li>
</ul>
<h2 id="Tkinter介绍"><a href="#Tkinter介绍" class="headerlink" title="Tkinter介绍"></a><code>Tkinter</code>介绍</h2><ul>
<li><code>Tkinter</code>是<code>Python</code>的标准<code>GUI</code>库。<code>Python</code>使用 <code>Tkinter</code>可以快速的创建<code>GUI</code>应用程序。</li>
<li>由于<code>Tkinter</code>是内置到<code>python</code>的安装包中、只要安装好<code>Python</code>之后就能<code>import Tkinter</code>库、而且<code>IDLE</code>也是用<code>Tkinter</code>编写而成、对于简单的图形界面<code>Tkinter</code>还是能应付自如</li>
</ul>
<div class='note warning'><p>需要注意: `Python3.x`版本使用的库名为 `tkinter`,即首写字母`T`为小写 </p></div>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tkinter</span><br></pre></td></tr></table></figure>

<ul>
<li>创建一个GUI程序<ul>
<li>1、导入<code>tkinter</code>模块</li>
<li>2、创建控件</li>
<li>3、指定这个控件的<code>master</code>，即这个控件属于哪一个</li>
<li>4、告诉<code>GM(geometry manager)</code>有一个控件产生了</li>
</ul>
</li>
</ul>
<h3 id="主窗口"><a href="#主窗口" class="headerlink" title="主窗口"></a>主窗口</h3><ul>
<li>在<code>iOS</code>中每一个<code>APP</code>都有一个主窗口<code>window</code>, 该<code>window</code>就是所有视图嘴地城最基础的视图<code>View</code></li>
<li>在<code>Python</code>中童谣也会有一个主窗口, 下面看一下<code>tkinter</code>生成主窗口的方法</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 主窗口</span></span><br><span class="line"><span class="keyword">import</span> tkinter</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建主窗口</span></span><br><span class="line">window = tkinter.Tk()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置标题</span></span><br><span class="line">window.title(<span class="string">&#x27;Titanjun&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置窗口大小</span></span><br><span class="line">window.geometry(<span class="string">&#x27;400x400&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入消息循环</span></span><br><span class="line">window.mainloop()</span><br></pre></td></tr></table></figure>

<div class="note success"><p>效果如下</p></div>

<p><img data-src="https://upload-images.jianshu.io/upload_images/4122543-b245c99575e6a003.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="window"></p>
<p>主窗口除了上述方法之外还有以下方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 框体大小的可调性, 分别表示x, y方向的可变性</span></span><br><span class="line">window.resizable(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 退出</span></span><br><span class="line">window.quit()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 刷新页面</span></span><br><span class="line">window.update()</span><br></pre></td></tr></table></figure>

<h2 id="Tkinter组件"><a href="#Tkinter组件" class="headerlink" title="Tkinter组件"></a><code>Tkinter</code>组件</h2><ul>
<li><code>Tkinter</code>的提供各种控件，如按钮，标签和文本框，一个<code>GUI</code>应用程序中使用, 这些控件通常被称为控件或者部件</li>
<li>目前有15种Tkinter的部件, 下面是对这些部件以及一个简短的介绍</li>
</ul>
<table>
<thead>
<tr>
<th>控件</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>Label</code></td>
<td>标签控件, 可以显示文本和位图</td>
</tr>
<tr>
<td><code>Button</code></td>
<td>按钮控件, 在程序中显示按钮</td>
</tr>
<tr>
<td><code>Entry</code></td>
<td>输入控件；用于显示简单的文本内容</td>
</tr>
<tr>
<td><code>Checkbutton</code></td>
<td>多选框控件；用于在程序中提供多项选择框</td>
</tr>
<tr>
<td><code>Frame</code></td>
<td>框架控件；在屏幕上显示一个矩形区域，多用来作为容器</td>
</tr>
<tr>
<td><code>Canvas</code></td>
<td>画布控件；显示图形元素如线条或文本</td>
</tr>
<tr>
<td><code>Listbox</code></td>
<td>列表框控件；在<code>Listbox</code>窗口小部件是用来显示一个字符串列表给用户</td>
</tr>
<tr>
<td><code>Menubutton</code></td>
<td>菜单按钮控件，由于显示菜单项。</td>
</tr>
<tr>
<td><code>Menu</code></td>
<td>菜单控件；显示菜单栏,下拉菜单和弹出菜单</td>
</tr>
<tr>
<td><code>Message</code></td>
<td>消息控件；用来显示多行文本，与<code>label</code>比较类似</td>
</tr>
<tr>
<td><code>Radiobutton</code></td>
<td>单选按钮控件；显示一个单选的按钮状态</td>
</tr>
<tr>
<td><code>Scale</code></td>
<td>范围控件；显示一个数值刻度，为输出限定范围的数字区间</td>
</tr>
<tr>
<td><code>Scrollbar</code></td>
<td>滚动条控件，当内容超过可视化区域时使用，如列表框</td>
</tr>
<tr>
<td><code>Text</code></td>
<td>文本控件；用于显示多行文本</td>
</tr>
<tr>
<td><code>Spinbox</code></td>
<td>输入控件；与<code>Entry</code>类似，但是可以指定输入范围值</td>
</tr>
<tr>
<td><code>PanedWindow</code></td>
<td>一个窗口布局管理的插件，可以包含一个或者多个子控件</td>
</tr>
<tr>
<td><code>LabelFrame</code></td>
<td>一个简单的容器控件, 常用与复杂的窗口布局</td>
</tr>
<tr>
<td><code>tkMessageBox</code></td>
<td>用于显示你应用程序的消息框</td>
</tr>
</tbody></table>
<blockquote>
<p>如果之前做过H5前端开发或者iOS等页面相关开发工作的, 应该能到, 其实这些组件和其他开发语言提供的组件功能相似, 属性也类似, 下面我们先看一下一些通用的属性介绍</p>
</blockquote>
<table>
<thead>
<tr>
<th>属性值</th>
<th>属性描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>bg</code></td>
<td>控件的背景颜色</td>
</tr>
<tr>
<td><code>fg</code></td>
<td>组件中的字体颜色</td>
</tr>
<tr>
<td><code>font</code></td>
<td>设置文本的字体样式和字号</td>
</tr>
<tr>
<td><code>height</code></td>
<td>设置控件高度</td>
</tr>
<tr>
<td><code>width</code></td>
<td>设置控件宽度</td>
</tr>
<tr>
<td><code>bd</code></td>
<td>设置控件边框的大小, 默认2个像素</td>
</tr>
<tr>
<td><code>relief</code></td>
<td>设置边框样式, 有falt, sunken, raised, groove, ridge, 默认flat</td>
</tr>
<tr>
<td><code>text</code></td>
<td>设置文本内容</td>
</tr>
<tr>
<td><code>anchor</code></td>
<td>瞄点, 控制文本的位置, 默认居中(可选: n北, e东, s南, w西, center居中, ne   se, sw, nw)</td>
</tr>
<tr>
<td><code>justify</code></td>
<td>显示多行文本的时候,设置不同行之间的对齐方式(left, right, center)</td>
</tr>
<tr>
<td><code>wraplength</code></td>
<td>根据宽度限制控件每行显示的字符的数量</td>
</tr>
<tr>
<td><code>underline</code></td>
<td>下划线, 默认没有; 取值就是带下划线的字符串索引，为 0 时，第一个字符带下划线</td>
</tr>
<tr>
<td><code>padx</code></td>
<td>在x轴方向上的内边距(padding)，是指控件的内容与控件边缘的距离</td>
</tr>
<tr>
<td><code>pady</code></td>
<td>在y轴方向上的内边距(padding)</td>
</tr>
</tbody></table>
<h3 id="Label控件"><a href="#Label控件" class="headerlink" title="Label控件"></a><code>Label</code>控件</h3><ul>
<li><code>Label</code>控件用以显示文字和图片. </li>
<li><code>Label</code>通常被用来展示信息, 而非与用户交互</li>
<li><code>Label</code>也可以绑定点击等事件, 只是通常不这么用</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">label = tkinter.Label(window,</span><br><span class="line">                      text=<span class="string">&quot;我是一只小鸭子&quot;</span>,</span><br><span class="line">                      bg=<span class="string">&#x27;#999999&#x27;</span>,</span><br><span class="line">                      fg=<span class="string">&#x27;white&#x27;</span>,</span><br><span class="line">                      font=(<span class="string">&#x27;黑体&#x27;</span>, <span class="number">13</span>),</span><br><span class="line">                      justify=<span class="string">&#x27;center&#x27;</span>,</span><br><span class="line">                      height=<span class="number">5</span>,</span><br><span class="line">                      width=<span class="number">30</span>,</span><br><span class="line">                      anchor=<span class="string">&#x27;n&#x27;</span>,</span><br><span class="line">                      <span class="comment"># wraplength=30</span></span><br><span class="line">                      underline=<span class="number">3</span>,</span><br><span class="line">                      bd=<span class="number">3</span>,</span><br><span class="line">                      relief=<span class="string">&#x27;flat&#x27;</span></span><br><span class="line">                      )</span><br><span class="line"><span class="comment">#显示出来</span></span><br><span class="line">label.pack()</span><br></pre></td></tr></table></figure>

<div class='note success'><p>显示效果</p></div>

<p><img data-src="https://upload-images.jianshu.io/upload_images/4122543-67e48b535206d7eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Label"></p>
<div class='note info'><p>部分属性介绍</p></div>

<ul>
<li><code>anchor</code>: 文本在空间中的显示位置(按上北下南, 左西右东规则), 可选值有(n北  e东  s南  w西  center居中  ne西北   se东南   sw西南   nw东北)方向</li>
<li><code>image</code>: 显示的图片</li>
</ul>
<h3 id="Button控件"><a href="#Button控件" class="headerlink" title="Button控件"></a><code>Button</code>控件</h3><ul>
<li><code>Button</code>控件是一个标准的<code>Tkinter</code>小部件，用于各种按钮, 如果用鼠标点击按钮，可能会开始一些操作</li>
<li><code>Button</code>可以显示文本和图片</li>
<li>按钮只能以单一字体显示文本, 文本可以跨越多行</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置标题</span></span><br><span class="line">window.title(<span class="string">&#x27;Titanjun&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置窗口大小</span></span><br><span class="line">window.geometry(<span class="string">&#x27;400x400&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建按钮</span></span><br><span class="line">button1 = tkinter.Button(window,</span><br><span class="line">                         text=<span class="string">&#x27;按钮1&#x27;</span>,</span><br><span class="line">                         bg=<span class="string">&#x27;orange&#x27;</span>,</span><br><span class="line">                         height=<span class="number">3</span>,</span><br><span class="line">                         width=<span class="number">20</span>,</span><br><span class="line">                         bd=<span class="number">3</span>,</span><br><span class="line">                         relief=<span class="string">&#x27;sunken&#x27;</span>,</span><br><span class="line">                         activebackground=<span class="string">&#x27;orange&#x27;</span>,</span><br><span class="line">                         activeforeground=<span class="string">&#x27;white&#x27;</span>,</span><br><span class="line">                         command=action1</span><br><span class="line">                         )</span><br><span class="line">button1.pack()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">button2 = tkinter.Button(window, text=<span class="string">&#x27;Titanjun&#x27;</span>, height=<span class="number">3</span>, command=window.quit())</span><br><span class="line">button2.pack()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入消息循环</span></span><br><span class="line">window.mainloop()</span><br></pre></td></tr></table></figure>

<div class='note success'><p>效果样式</p></div>

<p><img data-src="https://upload-images.jianshu.io/upload_images/4122543-7b2bd64d446e59bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Button"></p>
<div class='note info'><p>部分属性介绍</p></div>

<ul>
<li><code>activebackground</code>: 当鼠标放上去时，按钮的背景色</li>
<li><code>activeforeground</code>: 当鼠标放上去时，按钮的文本颜色</li>
<li><code>highlightcolor</code>: 要高亮的颜色</li>
<li><code>image</code>: 按钮上要显示的图片</li>
<li><code>state</code>: 设置按钮组件状态,可选的有(normal(默认), active, disabled)</li>
<li><code>command</code>: 按钮的绑定函数方法, 接受一个函数名，注意函数名不要加引号</li>
</ul>
<h3 id="Entry输入"><a href="#Entry输入" class="headerlink" title="Entry输入"></a><code>Entry</code>输入</h3><p>输入控件, 用于显示简单的文本内容, 和<code>iOS</code>中的<code>UITextField</code>一样, 示例如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">vari = tkinter.Variable()</span><br><span class="line">entry = tkinter.Entry(window, textvariable=vari)</span><br><span class="line">entry.pack()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置值</span></span><br><span class="line">vari.<span class="built_in">set</span>(<span class="string">&#x27;very good&#x27;</span>)</span><br><span class="line"><span class="comment"># 取值</span></span><br><span class="line"><span class="built_in">print</span>(vari.get())</span><br><span class="line"><span class="built_in">print</span>(entry.get())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只读输入框</span></span><br><span class="line">vari2 = tkinter.Variable()</span><br><span class="line">entry2 = tkinter.Entry(window, textvariable=vari2, state=<span class="string">&#x27;disabled&#x27;</span>)</span><br><span class="line">entry2.pack()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置值</span></span><br><span class="line">vari2.<span class="built_in">set</span>(<span class="string">&#x27;very bad&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(vari2.get())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 密码输入框, 无论输入什么都显示密文</span></span><br><span class="line">vari3 = tkinter.Variable()</span><br><span class="line">entry3 = tkinter.Entry(window, textvariable=vari3, show=<span class="string">&#x27;@&#x27;</span>, bg=<span class="string">&#x27;red&#x27;</span>, fg=<span class="string">&#x27;white&#x27;</span>)</span><br><span class="line">entry3.pack()</span><br></pre></td></tr></table></figure>

<div class='note success'><p>效果样式</p></div>

<p><img data-src="https://upload-images.jianshu.io/upload_images/4122543-863839a486d3360a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Button"></p>
<div class='note info'><p>监听输入框内文字的改变</p></div>

<ul>
<li>这里我们需要通过设置一下三个选项</li>
<li><code>validate</code>: 设置输入框的监听状态<ul>
<li><code>focus</code>:当<code>Entry</code>组件获得或失去焦点的时候验证 </li>
<li><code>focusin</code>: 当<code>Entry</code>组件获得焦点的时候验证 </li>
<li><code>focusout</code>: 当<code>Entry</code>组件失去焦点的时候验证 </li>
<li><code>key</code>:当输入框被编辑的时候验证 </li>
<li><code>all</code>: 当出现上边任何一种情况的时候验证</li>
</ul>
</li>
<li><code>validatecommand</code>: 接受一个判断输入框内的文字是否符合要求的函数, 该函数只能返回 True 或 False 表示验证的结果</li>
<li><code>invalidcommand</code>: 指定的函数只有在<code>validatecommand</code>的返回值为<code>False</code>的时候才被调用</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 主窗口</span></span><br><span class="line"><span class="keyword">import</span> tkinter</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证输入的文字</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">varileText</span>():</span><br><span class="line">    text = entry4.get()</span><br><span class="line">    <span class="keyword">if</span> text == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;对喽&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;错漏&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">testInvaild</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;invaildCommanf被调用&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建主窗口</span></span><br><span class="line">window = tkinter.Tk()</span><br><span class="line"><span class="comment"># 设置标题</span></span><br><span class="line">window.title(<span class="string">&#x27;Titanjun&#x27;</span>)</span><br><span class="line"><span class="comment"># 设置窗口大小</span></span><br><span class="line">window.geometry(<span class="string">&#x27;400x400&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证输入的内容是否符合要求</span></span><br><span class="line">vari4 = tkinter.Variable()</span><br><span class="line">entry4 = tkinter.Entry(window, textvariable=vari4, validate=<span class="string">&#x27;key&#x27;</span>, validatecommand=varileText, invalidcommand=testInvaild)</span><br><span class="line">entry4.pack()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入消息循环</span></span><br><span class="line">window.mainloop()</span><br></pre></td></tr></table></figure>

<h3 id="Text多行文本"><a href="#Text多行文本" class="headerlink" title="Text多行文本"></a><code>Text</code>多行文本</h3><ul>
<li><code>Text</code>文本组件用于显示和处理多行文本。</li>
<li>在<code>Tkinter</code>的所有组件中，<code>Text</code>组件显得异常强大和灵活，它适用于处理多任务</li>
<li>当创建一个<code>Text</code>组件的时候里面是没有内容的。为了给其插入内容，可以使用<code>insert()</code>以及<code>INSERT</code>或<code>END</code>索引号</li>
</ul>
<h4 id="插入文本-x2F-控件-x2F-图片"><a href="#插入文本-x2F-控件-x2F-图片" class="headerlink" title="插入文本&#x2F;控件&#x2F;图片"></a>插入文本&#x2F;控件&#x2F;图片</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">text = Text(window, bg=<span class="string">&#x27;yellow&#x27;</span>, width=<span class="number">40</span>, height=<span class="number">10</span>)</span><br><span class="line"><span class="comment">#INSERT索引表示在光标处插入</span></span><br><span class="line">text.insert(INSERT,<span class="string">&#x27;I Love&#x27;</span>)</span><br><span class="line"><span class="comment">#END索引号表示在最后插入</span></span><br><span class="line">text.insert(END,<span class="string">&#x27; you&#x27;</span>)</span><br><span class="line">text.pack()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;好了, 你赢了&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># text还可以插入按钮  图片等</span></span><br><span class="line">b1 = Button(text, text=<span class="string">&#x27;点我点我&#x27;</span>, command=show)</span><br><span class="line"><span class="comment"># 在text创建组件的命令</span></span><br><span class="line">text.window_create(INSERT, window=b1)</span><br></pre></td></tr></table></figure>

<h4 id="索引值"><a href="#索引值" class="headerlink" title="索引值"></a>索引值</h4><ul>
<li><code>Indexes</code>(索引)是用来指向<code>Text</code>组件中文本的位置，跟<code>python</code>的序列索引一样，<code>Text</code>的组件索引也是对应实际字符之间的位置</li>
<li>值得注意的是： 行号以1开始 列号以0开始</li>
<li>例如: 2.4表示第2行第4列的字符</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tkinter <span class="keyword">import</span> *</span><br><span class="line">root = Tk()</span><br><span class="line">text1=Text(root,width=<span class="number">30</span>,height=<span class="number">3</span>)</span><br><span class="line">text1.insert(INSERT,<span class="string">&#x27;index的练习&#x27;</span>)</span><br><span class="line"><span class="comment">#1.2到1.5的范围之间</span></span><br><span class="line"><span class="built_in">print</span>(text1.get(<span class="number">1.2</span>,<span class="number">1.5</span>))</span><br></pre></td></tr></table></figure>

<h4 id="Text中的Tags"><a href="#Text中的Tags" class="headerlink" title="Text中的Tags"></a>Text中的Tags</h4><p><code>Tags</code>通常用于改变Text组件中内容的样式和功能，你可以修改文本的字体，尺寸和颜色，另外<code>Tags</code>还允许你将文本、嵌入的组件和图片与键盘相关联，除了<code>user-defined tags</code>(用户自定义的<code>Tags</code>)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">text.insert(INSERT, <span class="string">&#x27;自定义标签的名字&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#第一个参数为自定义标签的名字</span></span><br><span class="line"><span class="comment">#第二个参数为设置的起始位置，第三个参数为结束位置</span></span><br><span class="line"><span class="comment">#第四个参数为另一个位置</span></span><br><span class="line">text.tag_add(<span class="string">&#x27;tag1&#x27;</span>, <span class="string">&#x27;1.7&#x27;</span>, <span class="string">&#x27;1.12&#x27;</span>, <span class="string">&#x27;1.14&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#用tag_config函数来设置标签的属性(这里不要用简写, 否则报错)</span></span><br><span class="line">text.tag_config(<span class="string">&#x27;tag1&#x27;</span>, font=<span class="number">17</span>, background=<span class="string">&#x27;blue&#x27;</span>, foreground=<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line"><span class="comment"># text.tag_config(&#x27;tag1&#x27;, bg=&#x27;yellow&#x27;, fg=&#x27;red&#x27;)</span></span><br><span class="line"><span class="comment">#新的tag会覆盖旧的tag</span></span><br></pre></td></tr></table></figure>

<h4 id="带滚动条"><a href="#带滚动条" class="headerlink" title="带滚动条"></a>带滚动条</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">text = Text(window, bg=<span class="string">&#x27;yellow&#x27;</span>, width=<span class="number">100</span>, height=<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 添加右侧滚动条</span></span><br><span class="line">scroll = Scrollbar()</span><br><span class="line"><span class="comment"># side放到窗体的那一侧   fill填充</span></span><br><span class="line">scroll.pack(side=RIGHT, fill=Y)</span><br><span class="line">text.pack(side=RIGHT, fill=Y)</span><br><span class="line"><span class="comment"># 两者关联</span></span><br><span class="line">scroll.config(command=text.yview)</span><br><span class="line">text.config(yscrollcommand=scroll.<span class="built_in">set</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&#x27;&#x27;&#x27;致橡树--舒婷</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">..........此处省略N个字...........</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">text.insert(INSERT, <span class="built_in">str</span>)</span><br></pre></td></tr></table></figure>

<div class='note success'><p>效果样式</p></div>

<p><img data-src="https://upload-images.jianshu.io/upload_images/4122543-6a974b78c965c1c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Button"></p>
<h3 id="Checkbutton多选按钮"><a href="#Checkbutton多选按钮" class="headerlink" title="Checkbutton多选按钮"></a>Checkbutton多选按钮</h3><ul>
<li><code>Checkbutton</code>可以表示两种状态：<code>On</code>和<code>Off</code>，可以设置回调函数，每当点击此按钮时回调函数被调用</li>
<li>这里有一个示例: 选择不同的复选框, 会有不同的文本显示</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">update</span>():</span><br><span class="line">    message = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> tag1.get() == <span class="literal">True</span>:</span><br><span class="line">        message += <span class="string">&#x27;titan \n&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> tag2.get() == <span class="literal">True</span>:</span><br><span class="line">        message += <span class="string">&#x27;jun \n&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> tag3.get() == <span class="literal">True</span>:</span><br><span class="line">        message += <span class="string">&#x27;coder \n&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#清除text中的所有内容</span></span><br><span class="line">    text.delete(<span class="number">0.0</span>, END)</span><br><span class="line">    <span class="comment"># 插入新的文本内容</span></span><br><span class="line">    text.insert(INSERT, message)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要绑定的变量</span></span><br><span class="line">tag1 = BooleanVar()</span><br><span class="line">check1 = Checkbutton(window, text = <span class="string">&#x27;Titan&#x27;</span>, variable = tag1, command = update)</span><br><span class="line">check1.pack()</span><br><span class="line"></span><br><span class="line">tag2 = BooleanVar()</span><br><span class="line">check2 = Checkbutton(window, text = <span class="string">&#x27;Juned&#x27;</span>, variable = tag2, command = update)</span><br><span class="line">check2.pack()</span><br><span class="line"></span><br><span class="line">tag3 = BooleanVar()</span><br><span class="line">check3 = Checkbutton(window, text = <span class="string">&#x27;Coder&#x27;</span>, variable = tag3, command = update)</span><br><span class="line">check3.pack()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">text = Text(window, bg = <span class="string">&#x27;orange&#x27;</span>, width = <span class="number">50</span>, height = <span class="number">5</span>)</span><br><span class="line">text.pack()</span><br></pre></td></tr></table></figure>

<div class='note success'><p>效果样式</p></div>

<p><img data-src="http://p7hfnfk6u.bkt.clouddn.com/puthon%E5%A4%8D%E9%80%89%E6%A1%86.png" alt="Checkbutton"></p>
<h3 id="Radiobutton单选框"><a href="#Radiobutton单选框" class="headerlink" title="Radiobutton单选框"></a>Radiobutton单选框</h3><p><code>Radiobutton</code>为单选按钮，即在同一组内只能有一个按钮被选中，每当选中组内的一个按钮时，其它的按钮自动改为非选中态，与其他控件不同的是：它有组的概念 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">selectorAction</span>():</span><br><span class="line">    <span class="built_in">print</span>(tag.get())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一组单选框要绑定同一个变量</span></span><br><span class="line">tag = IntVar()</span><br><span class="line">radio1 = Radiobutton(window, text = <span class="string">&#x27;one&#x27;</span>, value = <span class="number">23</span>, variable = tag, command = selectorAction)</span><br><span class="line">radio1.pack()</span><br><span class="line">radio2 = Radiobutton(window, text = <span class="string">&#x27;two&#x27;</span>, value = <span class="number">32</span>, variable = tag, command = selectorAction)</span><br><span class="line">radio2.pack()</span><br><span class="line">radio3 = Radiobutton(window, text = <span class="string">&#x27;ten&#x27;</span>, value = <span class="number">10</span>, variable = tag, command = selectorAction)</span><br><span class="line">radio3.pack()</span><br></pre></td></tr></table></figure>

<div class='note success'><p>效果样式</p></div>

<p><img data-src="https://upload-images.jianshu.io/upload_images/4122543-ef07dc16e50e97d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Checkbutton"></p>
<blockquote>
<p>未完待续, 后期会继续更新其他控件的相关介绍……….</p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Tkinter</tag>
      </tags>
  </entry>
  <entry>
    <title>Python编程之Tkinter的使用02</title>
    <url>/post/21aa9981.html</url>
    <content><![CDATA[<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-9f31000a70814ea9?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Tkinter"></p>
<span id="more"></span>




<ul>
<li><code>Tkinter</code>是<code>Python</code>的标准<code>GUI</code>库。<code>Python</code>使用 <code>Tkinter</code>可以快速的创建<code>GUI</code>应用程序。</li>
<li>由于<code>Tkinter</code>是内置到<code>python</code>的安装包中、只要安装好<code>Python</code>之后就能<code>import Tkinter</code>库、而且<code>IDLE</code>也是用<code>Tkinter</code>编写而成、对于简单的图形界面<code>Tkinter</code>还是能应付自如</li>
<li><a href="https://www.titanjun.top/2018/06/21/Python%E7%BC%96%E7%A8%8B%E4%B9%8BTkinter%E7%9A%84%E4%BD%BF%E7%94%A801/">上一篇文章</a>介绍了<code>Tkinter</code>模块和<code>Button</code>, <code>Label</code>等部分控件</li>
<li>这里主要介绍<code>Listbox</code>, <code>Scale</code>, <code>Menu</code>, <code>Frame</code>等部分控件的使用</li>
<li><a href="https://github.com/CoderTitan/PythonDemo">GitHub代码示例目地址</a></li>
</ul>
<h2 id="Listbox列表框"><a href="#Listbox列表框" class="headerlink" title="Listbox列表框"></a><code>Listbox</code>列表框</h2><p>一个可以包含一个或多个文本项的列表框，可以设置为单选或多选</p>
<h3 id="创建Listbox"><a href="#创建Listbox" class="headerlink" title="创建Listbox"></a>创建<code>Listbox</code></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lb = Listbox(window, selectmode = EXTENDED)</span><br><span class="line">lb.pack()</span><br></pre></td></tr></table></figure>

<ul>
<li><code>selectmode</code>: 设置列表框的样式(默认值-<code>BROWSE</code>), 有四个可选项<ul>
<li><code>SINGLE</code>: 单选, 不能通过鼠标的移动选中新的<code>item</code>, 只能点选</li>
<li><code>BROWSE</code>: 单选, 可以通过鼠标的移动选中新的位置(<code>item</code>并不会移动)</li>
<li><code>MULTIPLE</code>: 多选, 但是只能通过鼠标点击进行多选</li>
<li><code>EXTENDED</code>: 多选, 按住<code>Shift</code>可以实现连选, 按住<code>Control</code>可以实现多选</li>
</ul>
</li>
</ul>
<h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><ul>
<li><code>Listbox</code>使用<code>insert</code>来添加一个元素，其中参数一为添加的索引值, 参数二为要添加的元素</li>
<li>索引<code>ACTIVE</code>是向当前选中的<code>item</code>前插入一个（即使用当前选中的索引作为插入位置）</li>
<li>索引<code>END</code>是想最后添加一个元素</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> [<span class="string">&quot;good&quot;</span>, <span class="string">&quot;nice&quot;</span>, <span class="string">&quot;handsome&quot;</span>, <span class="string">&quot;vg&quot;</span>, <span class="string">&quot;vn&quot;</span>]:</span><br><span class="line">    <span class="comment"># 按顺序添加</span></span><br><span class="line">    lb.insert(END, item)</span><br><span class="line"><span class="comment"># 在开始位置添加</span></span><br><span class="line">lb.insert(ACTIVE, <span class="string">&#x27;Titn&#x27;</span>)</span><br><span class="line"><span class="comment"># 在最后添加</span></span><br><span class="line">lb.insert(END, <span class="string">&#x27;jun&#x27;</span>)</span><br><span class="line"><span class="comment"># 在具体的索引出添加元素</span></span><br><span class="line">lb.insert(<span class="number">2</span>, <span class="string">&#x27;lululu&#x27;</span>)</span><br><span class="line"><span class="comment"># 把列表当成一个元素添加</span></span><br><span class="line">lb.insert(ACTIVE, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="comment"># 添加元组</span></span><br><span class="line">lb.insert(ACTIVE, (<span class="string">&#x27;che&#x27;</span>, <span class="string">&#x27;09&#x27;</span>))</span><br></pre></td></tr></table></figure>

<h3 id="删除-x2F-选中"><a href="#删除-x2F-选中" class="headerlink" title="删除&#x2F;选中"></a>删除&#x2F;选中</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">selection_set</span>(<span class="params">self, first, last=<span class="literal">None</span></span>):</span><br></pre></td></tr></table></figure>

<ul>
<li>该函数为选中操作的函数, 需要两个参数, 其中</li>
<li>参数1: 开始的索引值</li>
<li>参数2: 结束的索引值(可选值, 可不指定)</li>
<li>若不指定参数2, 则函数只对参数1的索引值进行操作</li>
<li>删除&#x2F;取消选中&#x2F;取值等函数类似</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#删除  参数1为开始的索引，参数2为结束的索引，如果不指定参数2，只删除第一个索引处的内容</span></span><br><span class="line"><span class="comment"># lb.delete(1, 2)</span></span><br><span class="line"><span class="comment"># lb.delete(1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#选中   参数1为开始的索引，参数2为结束的索引，如果不指定参数2，只选中第一个索引处的内容</span></span><br><span class="line">lb.selection_set(<span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line">lb.selection_set(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取消</span></span><br><span class="line">lb.selection_clear(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">lb.selection_clear(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取到列表中的元素的个数</span></span><br><span class="line"><span class="built_in">print</span>(lb.size())</span><br><span class="line"></span><br><span class="line"><span class="comment">#从列表中取值  参数1为开始的索引，参数2为结束的索引，如果不指定参数2，只获取第一个索引处的内容</span></span><br><span class="line"><span class="built_in">print</span>(lb.get(<span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(lb.get(<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#返回当前的索引项，不是item元素</span></span><br><span class="line"><span class="built_in">print</span>(lb.curselection())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断某选项是否被选中</span></span><br><span class="line"><span class="built_in">print</span>(lb.selection_includes(<span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(lb.selection_includes(<span class="number">5</span>))</span><br></pre></td></tr></table></figure>

<h3 id="变量和事件绑定"><a href="#变量和事件绑定" class="headerlink" title="变量和事件绑定"></a>变量和事件绑定</h3><ul>
<li>变量绑定和之前的控件帮定变量一样</li>
<li><code>Listbox</code>不支持<code>command</code>属性来设置回调函数了，使用<code>bind</code>来指定回调函数</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 绑定变量</span></span><br><span class="line">lbv = StringVar()</span><br><span class="line">lb = Listbox(window, selectmode = SINGLE, listvariable = lbv)</span><br><span class="line">lb.pack()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> [<span class="string">&quot;good&quot;</span>, <span class="string">&quot;nice&quot;</span>, <span class="string">&quot;handsome&quot;</span>, <span class="string">&quot;jun&quot;</span>, <span class="string">&quot;titan&quot;</span>]:</span><br><span class="line">    lb.insert(END, item)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印当前列表中的选项</span></span><br><span class="line"><span class="built_in">print</span>(lbv.get())</span><br><span class="line"><span class="built_in">print</span>(lb.get(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置选项(所有重新赋值)</span></span><br><span class="line"><span class="comment"># lbv.set((1, 2, 3))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绑定事件</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">listboxAction</span>(<span class="params">event</span>):</span><br><span class="line">    <span class="built_in">print</span>(lb.get(lb.curselection()))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一个参数表示操作样式, 这里是双击操作, 1代表鼠标左键</span></span><br><span class="line">lb.bind(<span class="string">&#x27;&lt;Double-Button-1&gt;&#x27;</span>, listboxAction)</span><br></pre></td></tr></table></figure>

<h3 id="滚动显示"><a href="#滚动显示" class="headerlink" title="滚动显示"></a>滚动显示</h3><p><code>Listbox</code>的内容超过所容纳范围时, 内容需要滚动显示, 类似上文中提到的<code>Text</code>文本的多行显示, 这里就需要添加滚动条</p>
<div class="note success"><p>效果图如下</p></div>

<p><img data-src="https://upload-images.jianshu.io/upload_images/4122543-1c7d4716c89a76f5.gif?imageMogr2/auto-orient/strip" alt="Listbox"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 滚动</span></span><br><span class="line">lb = Listbox(window, selectmode=EXTENDED)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> [<span class="string">&quot;good&quot;</span>, <span class="string">&quot;nice&quot;</span>, <span class="string">&quot;handsome&quot;</span>, <span class="string">&quot;from&quot;</span>, <span class="string">&quot;thinter&quot;</span>,<span class="string">&quot;good1&quot;</span>, <span class="string">&quot;nice1&quot;</span>, <span class="string">&quot;handsome1&quot;</span>, <span class="string">&quot;vg1&quot;</span>, <span class="string">&quot;vn1&quot;</span>,<span class="string">&quot;good3&quot;</span>, <span class="string">&quot;nice3&quot;</span>, <span class="string">&quot;handsome3&quot;</span>, <span class="string">&quot;vg3&quot;</span>, <span class="string">&quot;vn3&quot;</span>]:</span><br><span class="line">    lb.insert(END, item)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 滚动条</span></span><br><span class="line">sc = Scrollbar(window)</span><br><span class="line">sc.pack(side = RIGHT, fill = Y)</span><br><span class="line">lb.configure(yscrollcommand = sc.<span class="built_in">set</span>)</span><br><span class="line">lb.pack(side = LEFT, fill = BOTH)</span><br><span class="line"><span class="comment"># 额外给属性赋值</span></span><br><span class="line">sc[<span class="string">&quot;command&quot;</span>] = lb.yview</span><br></pre></td></tr></table></figure>

<h2 id="Scale拽指示器"><a href="#Scale拽指示器" class="headerlink" title="Scale拽指示器"></a><code>Scale</code>拽指示器</h2><p>供用户通过拖拽指示器改变变量的值，可以水平，也可以竖直, 下面是相关属性介绍</p>
<ul>
<li><code>from_</code>: 设置最小值</li>
<li><code>to</code>: 设置最大值</li>
<li><code>resolution</code>: 步距, 每次移动增加的最小单位</li>
<li><code>orient</code>: 显示方向(水平-<code>HORIZONTAL</code>, 垂直-<code>Variable</code>)</li>
<li><code>variable</code>: 绑定变量</li>
<li><code>command</code>: 绑定回调函数</li>
<li><code>length</code>: 控件的长度(垂直方向上则是高度)</li>
<li><code>digits</code>: 控制显示的数字位数</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">scale = Scale(window, from_ = <span class="number">0</span>, to = <span class="number">100</span>, orient = HORIZONTAL, length = <span class="number">200</span>, label=<span class="string">&#x27;choice:&#x27;</span>)</span><br><span class="line">scale.pack()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置初始值</span></span><br><span class="line">scale.<span class="built_in">set</span>(<span class="number">34</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取值</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">showNumber</span>(<span class="params">event</span>):</span><br><span class="line">    <span class="built_in">print</span>(scale.get())</span><br><span class="line"></span><br><span class="line">scale[<span class="string">&quot;command&quot;</span>] = showNumber</span><br></pre></td></tr></table></figure>

<div class="note success"><p>效果图如下</p></div>

<p><img data-src="https://upload-images.jianshu.io/upload_images/4122543-2ebac66c4a3c2535.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Scale"></p>
<h2 id="Spinbox数值范围控制器"><a href="#Spinbox数值范围控制器" class="headerlink" title="Spinbox数值范围控制器"></a><code>Spinbox</code>数值范围控制器</h2><ul>
<li>组件<code>Spinbox</code>和组件<code>Scale</code>类似, 都是根据需求显示一个范围内的内容</li>
<li>区别: <code>Spinbox</code>去能拖拽, 只能点击增加或减少; <code>Scale</code>可以拖拽选择</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 绑定变量</span></span><br><span class="line">spinStr = StringVar()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 事件监听</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">updateAction</span>():</span><br><span class="line">    <span class="comment"># 在最后拼接上&#x27;12&#x27;</span></span><br><span class="line">    <span class="comment"># spin1.insert(END, 12)</span></span><br><span class="line">    <span class="built_in">print</span>(spinStr.get())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;属性介绍:</span></span><br><span class="line"><span class="string">from_: 起始值</span></span><br><span class="line"><span class="string">to: 最大值</span></span><br><span class="line"><span class="string">increment: 步长</span></span><br><span class="line"><span class="string">textvariable: 绑定变量</span></span><br><span class="line"><span class="string">command: 绑定函数, 事件监听</span></span><br><span class="line"><span class="string">values: 设置后, 每次更新值将使用values指定的值</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># spin = Spinbox(window, from_ = 0, to = 100, increment = 10, textvariable = spinStr, command = updateAction)</span></span><br><span class="line"><span class="comment"># spin.pack()</span></span><br><span class="line"></span><br><span class="line">spin1 = Spinbox(window, values=[<span class="number">0</span>, <span class="number">10</span>, <span class="number">30</span>, <span class="number">50</span>, <span class="number">80</span>, -<span class="number">9</span>], increment = <span class="number">10</span>, textvariable = spinStr, command = updateAction, bg=<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">spin1.pack()</span><br></pre></td></tr></table></figure>


<div class="note success"><p>效果图如下</p></div>

<p><img data-src="https://upload-images.jianshu.io/upload_images/4122543-e44e2db53b0e111e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Spinbox"></p>
<h2 id="Menu菜单"><a href="#Menu菜单" class="headerlink" title="Menu菜单"></a><code>Menu</code>菜单</h2><p><code>Menu</code>是被用来显示在标题栏&#x2F;窗口或者其他顶层窗口上的菜单栏</p>
<h3 id="顶层菜单"><a href="#顶层菜单" class="headerlink" title="顶层菜单"></a>顶层菜单</h3><p>添加菜单项, 单纯的添加之后没有任何效果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 菜单条</span></span><br><span class="line">menubar = Menu(window)</span><br><span class="line">window.configure(menu=menubar)</span><br></pre></td></tr></table></figure>

<p>下面给菜单添加菜单列表选项, 添加之后只有菜单列表, 但是每一个菜单却没有下拉列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个菜单选项</span></span><br><span class="line">menu1 = Menu(menubar, tearoff=<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># 想菜单条上添加菜单选项</span></span><br><span class="line">menubar.add_cascade(label=<span class="string">&#x27;语言&#x27;</span>, menu=menu1)</span><br><span class="line"></span><br><span class="line">menu2 = Menu(menubar, tearoff=<span class="literal">False</span>)</span><br><span class="line">menubar.add_cascade(label=<span class="string">&#x27;颜色&#x27;</span>, menu=menu2)</span><br></pre></td></tr></table></figure>

<p>给每一个菜单添加下拉列表和监听事件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">menuAction1</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;menubar&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 菜单条</span></span><br><span class="line">menubar = Menu(window)</span><br><span class="line">window.configure(menu=menubar)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个菜单选项</span></span><br><span class="line">menu1 = Menu(menubar, tearoff=<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># 菜单选项添加内容</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> [<span class="string">&#x27;Python&#x27;</span>, <span class="string">&#x27;PHP&#x27;</span>, <span class="string">&#x27;CPP&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;Java&#x27;</span>, <span class="string">&#x27;JavaScript&#x27;</span>, <span class="string">&#x27;VBScript&#x27;</span>, <span class="string">&#x27;Exit&#x27;</span>]:</span><br><span class="line">    <span class="keyword">if</span> item == <span class="string">&#x27;Exit&#x27;</span>:</span><br><span class="line">        <span class="comment"># 添加分割线</span></span><br><span class="line">        menu1.add_separator()</span><br><span class="line">        menu1.add_command(label=item, command=window.quit)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        menu1.add_command(label=item, command=menuAction1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 想菜单条上添加菜单选项</span></span><br><span class="line">menubar.add_cascade(label=<span class="string">&#x27;语言&#x27;</span>, menu=menu1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 菜单2的事件处理</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">menuAction2</span>():</span><br><span class="line">    <span class="built_in">print</span>(menuStr.get())</span><br><span class="line"></span><br><span class="line">menuStr = StringVar()</span><br><span class="line"></span><br><span class="line">menu2 = Menu(menubar, tearoff=<span class="literal">True</span>)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;gray&#x27;</span>]:</span><br><span class="line">    menu2.add_radiobutton(label=item, variable=menuStr, command=menuAction2)</span><br><span class="line"><span class="comment"># 添加到菜单列表</span></span><br><span class="line">menubar.add_cascade(label=<span class="string">&#x27;颜色&#x27;</span>, menu=menu2)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<div class="note success"><p>效果图如下</p></div>

<p><img data-src="https://upload-images.jianshu.io/upload_images/4122543-402ad8e39826b41b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Menu"></p>
<div class="note warning"><p>tearoff 属性介绍</p></div>

<ul>
<li><code>tearoff</code>是控制菜单能否独立出来的属性, 取值有<code>True</code>和<code>False</code></li>
<li><code>tearoff</code>设置为<code>True</code>以后，就是表明这个菜单是可以独立出来的，如果是<code>False</code>的话就不可以独立出来</li>
<li>我在<code>Mac</code>中尝试了一下, 发现没有什么效果; 在<code>Windows</code>系统中会有一条虚线, 点击虚线, 会跳出一个悬浮菜单; 有<code>Windows</code>系统的童鞋可以试一下</li>
</ul>
<h3 id="右键菜单"><a href="#右键菜单" class="headerlink" title="右键菜单"></a>右键菜单</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 鼠标右键菜单</span></span><br><span class="line">menubar2 = Menu(window)</span><br><span class="line"></span><br><span class="line">menu3 = Menu(menubar2, tearoff=<span class="literal">False</span>)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> [<span class="string">&#x27;Python&#x27;</span>, <span class="string">&#x27;PHP&#x27;</span>, <span class="string">&#x27;CPP&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;Java&#x27;</span>, <span class="string">&#x27;JavaScript&#x27;</span>, <span class="string">&#x27;VBScript&#x27;</span>, <span class="string">&#x27;Exit&#x27;</span>]:</span><br><span class="line">    menu3.add_command(label=item)</span><br><span class="line"></span><br><span class="line">menubar2.add_cascade(label=<span class="string">&#x27;开发语言&#x27;</span>, menu=menu3)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用于显示菜单</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">showMenu</span>(<span class="params">event</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;window&#x27;</span>)</span><br><span class="line">    <span class="comment"># 鼠标点击处的坐标</span></span><br><span class="line">    menubar2.post(event.x_root, event.y_root)</span><br><span class="line"></span><br><span class="line"><span class="comment"># window绑定鼠标事件</span></span><br><span class="line">window.bind(<span class="string">&quot;&lt;Button-2&gt;&quot;</span>, showMenu)</span><br></pre></td></tr></table></figure>


<div class="note success"><p>效果图如下</p></div>

<p><img data-src="https://upload-images.jianshu.io/upload_images/4122543-ceec7101898afb22.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Menu"></p>
<h3 id="添加删除菜单"><a href="#添加删除菜单" class="headerlink" title="添加删除菜单"></a>添加删除菜单</h3><p>菜单中每一项的删除和添加都是根据索引操作的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加/删除菜单</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">menuClick</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;menu3&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加command项</span></span><br><span class="line">menu3.insert_command(<span class="number">1</span>, label=<span class="string">&#x27;command&#x27;</span>, command=menuClick)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加radiobutton项</span></span><br><span class="line">menu3.insert_radiobutton(<span class="number">3</span>, label=<span class="string">&#x27;radiobutton&#x27;</span>, command=menuClick)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加checkbutton项</span></span><br><span class="line">menu3.insert_checkbutton(<span class="number">5</span>, label=<span class="string">&#x27;checkbutton&#x27;</span>, command=menuClick)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加分割线</span></span><br><span class="line">menu3.insert_separator(<span class="number">4</span>)</span><br><span class="line"><span class="comment"># menu3.insert_separator(0)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除</span></span><br><span class="line"><span class="comment"># 两个参数: 参数1为开始的索引，参数2为结束的索引，如果不指定参数2，只获取第一个索引处的内容</span></span><br><span class="line">menu3.delete(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">menu3.delete(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h2 id="Combobox下拉控件"><a href="#Combobox下拉控件" class="headerlink" title="Combobox下拉控件"></a><code>Combobox</code>下拉控件</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 绑定变量</span></span><br><span class="line">cv = StringVar()</span><br><span class="line">combo = ttk.Combobox(window, textvariable=cv)</span><br><span class="line">combo.pack()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置下拉菜单数据(元组数据)</span></span><br><span class="line">combo[<span class="string">&#x27;value&#x27;</span>] = (<span class="string">&#x27;杭州&#x27;</span>, <span class="string">&#x27;湖州&#x27;</span>, <span class="string">&#x27;温州&#x27;</span>, <span class="string">&#x27;嘉兴&#x27;</span>, <span class="string">&#x27;舟山&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置默认值</span></span><br><span class="line">combo.current(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绑定事件</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">comboboxClick</span>(<span class="params">event</span>):</span><br><span class="line">    <span class="built_in">print</span>(cv.get())</span><br><span class="line">    <span class="built_in">print</span>(combo.get())</span><br><span class="line"></span><br><span class="line">combo.bind(<span class="string">&#x27;&lt;&lt;ComboboxSelected&gt;&gt;&#x27;</span>, comboboxClick)</span><br></pre></td></tr></table></figure>

<div class="note success"><p>效果图如下</p></div>

<p><img data-src="https://upload-images.jianshu.io/upload_images/4122543-4c8b49d99080812a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Combobox"></p>
<h2 id="Frame布局"><a href="#Frame布局" class="headerlink" title="Frame布局"></a><code>Frame</code>布局</h2><p><code>Frame</code>就是屏幕上的一块矩形区域，多是用来作为容器（<code>container</code>）来布局窗体</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第一层容器</span></span><br><span class="line">frame = Frame(window)</span><br><span class="line">frame.pack()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 左边容器</span></span><br><span class="line">leftFrame = Frame(frame)</span><br><span class="line">Label(leftFrame, text=<span class="string">&#x27;左上位置&#x27;</span>, bg=<span class="string">&#x27;red&#x27;</span>, height=<span class="number">5</span>, width=<span class="number">10</span>).pack(side=TOP)</span><br><span class="line">Label(leftFrame, text=<span class="string">&#x27;左下位置&#x27;</span>, bg=<span class="string">&#x27;yellow&#x27;</span>, height=<span class="number">5</span>, width=<span class="number">10</span>).pack(side=TOP)</span><br><span class="line">leftFrame.pack(side=LEFT)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 右边容器</span></span><br><span class="line">rightFrame = Frame(frame)</span><br><span class="line">Label(rightFrame, text=<span class="string">&#x27;右上位置&#x27;</span>, bg=<span class="string">&#x27;orange&#x27;</span>, height=<span class="number">5</span>, width=<span class="number">10</span>).pack(side=TOP)</span><br><span class="line">Label(rightFrame, text=<span class="string">&#x27;右下位置&#x27;</span>, bg=<span class="string">&#x27;blue&#x27;</span>, height=<span class="number">5</span>, width=<span class="number">10</span>).pack(side=TOP)</span><br><span class="line">rightFrame.pack(side=RIGHT)</span><br></pre></td></tr></table></figure>

<div class="note success"><p>效果图如下</p></div>

<p><img data-src="https://upload-images.jianshu.io/upload_images/4122543-3b01984505b9a763.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Combobox"></p>
<ul>
<li>至此, <code>Tkinter</code>的大部分组件已经基本都介绍完了</li>
<li>接下来将会介绍一些<code>Tkinter</code>涉及到的数据类型和布局方式</li>
<li>以及鼠标的点按事件和一些特殊的事件操作</li>
<li>未完待续………….</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Tkinter</tag>
      </tags>
  </entry>
  <entry>
    <title>R.Swift高效引用资源文件</title>
    <url>/post/9adb52b8.html</url>
    <content><![CDATA[<ul>
<li>在iOS中当我们引用一张图片的时候, 我们需要创建一个<code>UIImage</code>对象去引用图片</li>
<li>当我们需要解析<code>json</code>或者<code>plist</code>文件的时候, 通常以<code>Bundle.main</code>的方式去解析</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> oldImage <span class="operator">=</span> <span class="type">UIImage</span>(named: <span class="string">&quot;yellow-image&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> jsonData <span class="operator">=</span> <span class="type">Bundle</span>.main.path(forResource: <span class="string">&quot;menuList&quot;</span>, ofType: <span class="string">&quot;json&quot;</span>)</span><br></pre></td></tr></table></figure>



<span id="more"></span>



<ul>
<li>这里得到的<code>oldImage</code>和<code>jsonData</code>都是<code>Optional</code>类型, 那么这样就会有一个问题: 如果以上文件名字修改了或者输错了, 那么得到的结果就是空的, 后期处理的时候就可能会程序崩溃或者没有数据</li>
<li>而且类似方法接受的都是字符串对象, 所以即使传入的错误的字符串, 编译程序的时候也不会报错</li>
<li>为了完美的解决上面的问题, 这里介绍一个搞笑引用资源文件的框架<a href="https://github.com/mac-cain13/R.swift"><code>R.Swift</code></a></li>
</ul>
<h3 id="什么是R-Swift"><a href="#什么是R-Swift" class="headerlink" title="什么是R.Swift"></a>什么是<code>R.Swift</code></h3><ul>
<li><a href="https://github.com/mac-cain13/R.swift"><code>R.Swift</code></a>是一款基于<code>Swift</code>平台，针对<code>iOS</code>以及<code>tvOS</code>开发的资源引用框架</li>
<li>它所针对的问题，就是类似于上面提到的一样，避免使用字符串来构造某些资源实例</li>
<li><code>R.Swift</code>能够使用类似语法<code>R.资源类型.资源名称</code>来对某资源进行引用构建</li>
<li><code>R.Swift</code>有着动态生成代码的机制, 它具有以下优点：<ul>
<li>代码自动补全：就像输入其他的代码一样，<code>R.Swift</code>支持<code>IDE</code>的代码自动补全</li>
<li>自动检测: 可以自动检测代码是否存在问题, 当我们的资源文件名修改的时候, 这是就会提示资源引用错误</li>
</ul>
</li>
</ul>
<h3 id="安装和配置R-Swift"><a href="#安装和配置R-Swift" class="headerlink" title="安装和配置R.Swift"></a>安装和配置<a href="https://github.com/mac-cain13/R.swift"><code>R.Swift</code></a></h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><ul>
<li>使用<code>CocoaPods</code>来对<code>R.Swift</code>进行安装</li>
<li>在你的<code>Podfile</code>文件中添加如下代码, 并在终端运行<code>pod install</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pod &#x27;R.swift&#x27;</span><br></pre></td></tr></table></figure>

<h4 id="配置信息"><a href="#配置信息" class="headerlink" title="配置信息"></a>配置信息</h4><ol>
<li>如下图所示, 添加一个<code>New Run Script Phase</code></li>
</ol>
<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-ff2333e6b4159280.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<ol start="2">
<li>将<code>Run Script</code>拖动到<code>Check Pods Manifest.lock</code>的下面, 并添加脚本</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;$PODS_ROOT/R.swift/rswift&quot; generate &quot;$SRCROOT&quot;</span><br></pre></td></tr></table></figure>


<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-37ec65a7e32ca6c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<ol start="3">
<li><code>Command+B</code>编译项目，在项目代码目录下，会生成一个<code>R.generated.swift</code> 的文件，将它拖如项目中</li>
</ol>
<div class="note warning"><p>注意：</p></div>

<ul>
<li>不要勾选<code>Copy items if needed</code>选项，因为每次编译都会生成新的<code>R.generated.swift</code>文件，<code>copy</code>的话，旧的<code>R.generated.swift</code>将不会被覆盖</li>
<li>每当我们修改了资源，我们需要<code>Command + B</code>来编译一下项目从而让<code>R.Swift</code>自动进行配置更新</li>
<li>这里是坐着录得一个如何导入和配置<code>R.Swift</code>的<a href="https://vimeo.com/122888912">视频教程</a></li>
</ul>
<ol start="4">
<li>配置到此完成，这里我们可以看一下<code>R.generated.swift</code>文件的基本内容, 下面我们可以构建自己的项目了</li>
</ol>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">R</span>: <span class="title class_">Rswift</span>.<span class="title class_">Validatable</span> &#123;</span><br><span class="line">  <span class="keyword">fileprivate</span> <span class="keyword">static</span> <span class="keyword">let</span> applicationLocale <span class="operator">=</span> hostingBundle.preferredLocalizations.first.flatMap(<span class="type">Locale</span>.<span class="keyword">init</span>) <span class="operator">??</span> <span class="type">Locale</span>.current</span><br><span class="line">  <span class="keyword">fileprivate</span> <span class="keyword">static</span> <span class="keyword">let</span> hostingBundle <span class="operator">=</span> <span class="type">Bundle</span>(for: <span class="type">R</span>.<span class="type">Class</span>.<span class="keyword">self</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">validate</span>() <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> intern.validate()</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="comment">/// This `R.file` struct is generated, and contains static references to 1 files.</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">file</span> &#123;</span><br><span class="line">    <span class="comment">/// Resource file `menuList.json`.</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> menuListJson <span class="operator">=</span> <span class="type">Rswift</span>.<span class="type">FileResource</span>(bundle: <span class="type">R</span>.hostingBundle, name: <span class="string">&quot;menuList&quot;</span>, pathExtension: <span class="string">&quot;json&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// `bundle.url(forResource: &quot;menuList&quot;, withExtension: &quot;json&quot;)`</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">menuListJson</span>(<span class="keyword">_</span>: <span class="type">Void</span> <span class="operator">=</span> ()) -&gt; <span class="type">Foundation</span>.<span class="type">URL</span>? &#123;</span><br><span class="line">      <span class="keyword">let</span> fileResource <span class="operator">=</span> <span class="type">R</span>.file.menuListJson</span><br><span class="line">      <span class="keyword">return</span> fileResource.bundle.url(forResource: fileResource)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">init</span>() &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="comment">/// This `R.image` struct is generated, and contains static references to 3 images.</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">image</span> &#123;</span><br><span class="line">    <span class="comment">/// Image `blueimage`.</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> blueimage <span class="operator">=</span> <span class="type">Rswift</span>.<span class="type">ImageResource</span>(bundle: <span class="type">R</span>.hostingBundle, name: <span class="string">&quot;blueimage&quot;</span>)</span><br><span class="line">    <span class="comment">/// Image `computers`.</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> computers <span class="operator">=</span> <span class="type">Rswift</span>.<span class="type">ImageResource</span>(bundle: <span class="type">R</span>.hostingBundle, name: <span class="string">&quot;computers&quot;</span>)</span><br><span class="line">    <span class="comment">/// Image `yellow-image`.</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> yellowImage <span class="operator">=</span> <span class="type">Rswift</span>.<span class="type">ImageResource</span>(bundle: <span class="type">R</span>.hostingBundle, name: <span class="string">&quot;yellow-image&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// `UIImage(named: &quot;blueimage&quot;, bundle: ..., traitCollection: ...)`</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">blueimage</span>(<span class="params">compatibleWith</span> <span class="params">traitCollection</span>: <span class="type">UIKit</span>.<span class="type">UITraitCollection</span>? <span class="operator">=</span> <span class="literal">nil</span>) -&gt; <span class="type">UIKit</span>.<span class="type">UIImage</span>? &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="type">UIKit</span>.<span class="type">UIImage</span>(resource: <span class="type">R</span>.image.blueimage, compatibleWith: traitCollection)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// `UIImage(named: &quot;computers&quot;, bundle: ..., traitCollection: ...)`</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">computers</span>(<span class="params">compatibleWith</span> <span class="params">traitCollection</span>: <span class="type">UIKit</span>.<span class="type">UITraitCollection</span>? <span class="operator">=</span> <span class="literal">nil</span>) -&gt; <span class="type">UIKit</span>.<span class="type">UIImage</span>? &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="type">UIKit</span>.<span class="type">UIImage</span>(resource: <span class="type">R</span>.image.computers, compatibleWith: traitCollection)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// `UIImage(named: &quot;yellow-image&quot;, bundle: ..., traitCollection: ...)`</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">yellowImage</span>(<span class="params">compatibleWith</span> <span class="params">traitCollection</span>: <span class="type">UIKit</span>.<span class="type">UITraitCollection</span>? <span class="operator">=</span> <span class="literal">nil</span>) -&gt; <span class="type">UIKit</span>.<span class="type">UIImage</span>? &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="type">UIKit</span>.<span class="type">UIImage</span>(resource: <span class="type">R</span>.image.yellowImage, compatibleWith: traitCollection)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">init</span>() &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// This `R.nib` struct is generated, and contains static references to 2 nibs.</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">nib</span> &#123;</span><br><span class="line">    <span class="comment">/// Nib `ImageFontController`.</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> imageFontController <span class="operator">=</span> _R.nib._ImageFontController()</span><br><span class="line">    <span class="comment">/// Nib `NibTableViewCell`.</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> nibTableViewCell <span class="operator">=</span> _R.nib._NibTableViewCell()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// `UINib(name: &quot;ImageFontController&quot;, in: bundle)`</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">imageFontController</span>(<span class="keyword">_</span>: <span class="type">Void</span> <span class="operator">=</span> ()) -&gt; <span class="type">UIKit</span>.<span class="type">UINib</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="type">UIKit</span>.<span class="type">UINib</span>(resource: <span class="type">R</span>.nib.imageFontController)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// `UINib(name: &quot;NibTableViewCell&quot;, in: bundle)`</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">nibTableViewCell</span>(<span class="keyword">_</span>: <span class="type">Void</span> <span class="operator">=</span> ()) -&gt; <span class="type">UIKit</span>.<span class="type">UINib</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="type">UIKit</span>.<span class="type">UINib</span>(resource: <span class="type">R</span>.nib.nibTableViewCell)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">init</span>() &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="comment">/// This `R.storyboard` struct is generated, and contains static references to 3 storyboards.</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">storyboard</span> &#123;</span><br><span class="line">    <span class="comment">/// Storyboard `LaunchScreen`.</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> launchScreen <span class="operator">=</span> _R.storyboard.launchScreen()</span><br><span class="line">    <span class="comment">/// Storyboard `Main`.</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> main <span class="operator">=</span> _R.storyboard.main()</span><br><span class="line">    <span class="comment">/// Storyboard `NibHome`.</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> nibHome <span class="operator">=</span> _R.storyboard.nibHome()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// `UIStoryboard(name: &quot;LaunchScreen&quot;, bundle: ...)`</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">launchScreen</span>(<span class="keyword">_</span>: <span class="type">Void</span> <span class="operator">=</span> ()) -&gt; <span class="type">UIKit</span>.<span class="type">UIStoryboard</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="type">UIKit</span>.<span class="type">UIStoryboard</span>(resource: <span class="type">R</span>.storyboard.launchScreen)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// `UIStoryboard(name: &quot;Main&quot;, bundle: ...)`</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">main</span>(<span class="keyword">_</span>: <span class="type">Void</span> <span class="operator">=</span> ()) -&gt; <span class="type">UIKit</span>.<span class="type">UIStoryboard</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="type">UIKit</span>.<span class="type">UIStoryboard</span>(resource: <span class="type">R</span>.storyboard.main)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// `UIStoryboard(name: &quot;NibHome&quot;, bundle: ...)`</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">nibHome</span>(<span class="keyword">_</span>: <span class="type">Void</span> <span class="operator">=</span> ()) -&gt; <span class="type">UIKit</span>.<span class="type">UIStoryboard</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="type">UIKit</span>.<span class="type">UIStoryboard</span>(resource: <span class="type">R</span>.storyboard.nibHome)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">init</span>() &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">fileprivate</span> <span class="keyword">init</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="R-Swift的使用"><a href="#R-Swift的使用" class="headerlink" title="R.Swift的使用"></a><code>R.Swift</code>的使用</h3><h4 id="Images-图片"><a href="#Images-图片" class="headerlink" title="Images - 图片"></a><code>Images</code> - 图片</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//传统方式</span></span><br><span class="line"><span class="keyword">let</span> oldImage <span class="operator">=</span> <span class="type">UIImage</span>(named: <span class="string">&quot;yellow-image&quot;</span>)</span><br><span class="line">oldImageView.image <span class="operator">=</span> oldImage</span><br><span class="line"></span><br><span class="line"><span class="comment">//R.Swift方式</span></span><br><span class="line"><span class="keyword">let</span> newImage <span class="operator">=</span> <span class="type">R</span>.image.yellowImage()</span><br><span class="line">newImageView.image <span class="operator">=</span> newImage</span><br></pre></td></tr></table></figure>

<h4 id="Custom-fonts-字体"><a href="#Custom-fonts-字体" class="headerlink" title="Custom fonts - 字体"></a><code>Custom fonts</code> - 字体</h4><p>这里需要注意的一点是, 字体的引用需要引入一个<code>ttf</code>格式的字体文件, 不然无法编译除类似<code>acmeLight</code>的函数</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//传统方式</span></span><br><span class="line"><span class="keyword">let</span> lightFontTitle <span class="operator">=</span> <span class="type">UIFont</span>(name: <span class="string">&quot;Acme-Light&quot;</span>, size: <span class="number">22</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//R.Swift方式</span></span><br><span class="line"><span class="keyword">let</span> lightFontTitle <span class="operator">=</span> <span class="type">R</span>.font.acmeLight(size: <span class="number">22</span>)</span><br></pre></td></tr></table></figure>


<h4 id="Resource-files-数据文件"><a href="#Resource-files-数据文件" class="headerlink" title="Resource files - 数据文件"></a><code>Resource files</code> - 数据文件</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//传统方式</span></span><br><span class="line"><span class="keyword">let</span> jsonData <span class="operator">=</span> <span class="type">Bundle</span>.main.path(forResource: <span class="string">&quot;menuList&quot;</span>, ofType: <span class="string">&quot;json&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> jsonUrl1 <span class="operator">=</span> <span class="type">Bundle</span>.main.url(forResource: <span class="string">&quot;menuList&quot;</span>, withExtension: <span class="string">&quot;json&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//R.Swift方式</span></span><br><span class="line"><span class="keyword">let</span> jsonData2 <span class="operator">=</span> <span class="type">R</span>.file.menuListJson.path()</span><br><span class="line"><span class="keyword">let</span> newUrl <span class="operator">=</span> <span class="type">R</span>.file.menuListJson()</span><br></pre></td></tr></table></figure>



<h4 id="Storyboards"><a href="#Storyboards" class="headerlink" title="Storyboards"></a><code>Storyboards</code></h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//传统方式</span></span><br><span class="line"><span class="keyword">let</span> nibVC1 <span class="operator">=</span> <span class="type">UIStoryboard</span>(name: <span class="string">&quot;NibHome&quot;</span>, bundle: <span class="literal">nil</span>).instantiateInitialViewController() <span class="operator">??</span> <span class="type">UIViewController</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> storyboard <span class="operator">=</span> <span class="type">UIStoryboard</span>(name: <span class="string">&quot;Main&quot;</span>, bundle: <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">let</span> initialTabBarController <span class="operator">=</span> storyboard.instantiateInitialViewController() <span class="keyword">as?</span> <span class="type">UITabBarController</span></span><br><span class="line"><span class="keyword">let</span> settingsController <span class="operator">=</span> storyboard.instantiateViewController(withIdentifier: <span class="string">&quot;settingsController&quot;</span>) <span class="keyword">as?</span> <span class="type">SettingsControllerSettingsController</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//R.Swift方式</span></span><br><span class="line"><span class="keyword">let</span> nibVC <span class="operator">=</span> <span class="type">R</span>.storyboard.nibHome().instantiateInitialViewController() <span class="operator">??</span> <span class="type">UIViewController</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> storyboard <span class="operator">=</span> <span class="type">R</span>.storyboard.main()</span><br><span class="line"><span class="keyword">let</span> initialTabBarController <span class="operator">=</span> <span class="type">R</span>.storyboard.main.initialViewController()</span><br><span class="line"><span class="keyword">let</span> settingsController <span class="operator">=</span> <span class="type">R</span>.storyboard.main.settingsController()</span><br></pre></td></tr></table></figure>



<h4 id="Nibs"><a href="#Nibs" class="headerlink" title="Nibs"></a><code>Nibs</code></h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//传统方式</span></span><br><span class="line"><span class="keyword">let</span> nameOfNib <span class="operator">=</span> <span class="string">&quot;CustomView&quot;</span></span><br><span class="line"><span class="keyword">let</span> customViewNib <span class="operator">=</span> <span class="type">UINib</span>(nibName: <span class="string">&quot;CustomView&quot;</span>, bundle: <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">let</span> rootViews <span class="operator">=</span> customViewNib.instantiate(withOwner: <span class="literal">nil</span>, options: <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">let</span> customView <span class="operator">=</span> rootViews[<span class="number">0</span>] <span class="keyword">as?</span> <span class="type">CustomView</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> viewControllerWithNib <span class="operator">=</span> <span class="type">CustomViewController</span>(nibName: <span class="string">&quot;CustomView&quot;</span>, bundle: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//R.Swift方式</span></span><br><span class="line"><span class="keyword">let</span> nameOfNib <span class="operator">=</span> <span class="type">R</span>.nib.customView.name</span><br><span class="line"><span class="keyword">let</span> customViewNib <span class="operator">=</span> <span class="type">R</span>.nib.customView()</span><br><span class="line"><span class="keyword">let</span> rootViews <span class="operator">=</span> <span class="type">R</span>.nib.customView.instantiate(withOwner: <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">let</span> customView <span class="operator">=</span> <span class="type">R</span>.nib.customView.firstView(owner: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> viewControllerWithNib <span class="operator">=</span> <span class="type">CustomViewController</span>(nib: <span class="type">R</span>.nib.customView)</span><br></pre></td></tr></table></figure>



<h4 id="Reusable-table-view-cells-cell复用"><a href="#Reusable-table-view-cells-cell复用" class="headerlink" title="Reusable table view cells - cell复用"></a><code>Reusable table view cells</code> - cell复用</h4><p>这里是<code>UITableViewCell</code>的注册和使用为例, <code>UICollectionViewCell</code>亦同理</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//传统方式</span></span><br><span class="line"><span class="keyword">let</span> cellNib <span class="operator">=</span> <span class="type">UINib</span>(nibName: <span class="string">&quot;NibTableViewCell&quot;</span>, bundle: <span class="literal">nil</span>)</span><br><span class="line">tableView.register(cellNib, forCellReuseIdentifier: <span class="string">&quot;NibTableViewCell&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">tableView</span>(<span class="keyword">_</span> <span class="params">tableView</span>: <span class="type">UITableView</span>, <span class="params">cellForRowAt</span> <span class="params">indexPath</span>: <span class="type">IndexPath</span>) -&gt; <span class="type">UITableViewCell</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> cell <span class="operator">=</span> tableView.dequeueReusableCell(withIdentifier: <span class="string">&quot;NibTableViewCell&quot;</span>, for: indexPath)</span><br><span class="line">    cell<span class="operator">?</span>.leftLabel.text <span class="operator">=</span> dataArr[indexPath.row]</span><br><span class="line">    <span class="keyword">return</span> cell <span class="operator">??</span> <span class="type">UITableViewCell</span>()</span><br><span class="line">&#125;</span><br><span class="line">         </span><br><span class="line"></span><br><span class="line"><span class="comment">//R.Swift方式</span></span><br><span class="line">tableView.register(<span class="type">R</span>.nib.nibTableViewCell(), forCellReuseIdentifier: <span class="type">R</span>.nib.nibTableViewCell.name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">tableView</span>(<span class="keyword">_</span> <span class="params">tableView</span>: <span class="type">UITableView</span>, <span class="params">cellForRowAt</span> <span class="params">indexPath</span>: <span class="type">IndexPath</span>) -&gt; <span class="type">UITableViewCell</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> cell <span class="operator">=</span> tableView.dequeueReusableCell(withIdentifier: <span class="type">R</span>.nib.nibTableViewCell.name, for: indexPath) <span class="keyword">as?</span> <span class="type">NibTableViewCell</span></span><br><span class="line">    cell<span class="operator">?</span>.leftLabel.text <span class="operator">=</span> dataArr[indexPath.row]</span><br><span class="line">    <span class="keyword">return</span> cell <span class="operator">??</span> <span class="type">UITableViewCell</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>更多关于<code>R.Swift</code>的使用可参考<a href="https://github.com/mac-cain13/R.swift/blob/master/Documentation/Examples.md#images">官方文档<code>Examples.md</code></a></p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>iOS组件库</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>R.Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>React Native之导航组件NavigatorIOS和Navigator</title>
    <url>/post/64007fb7.html</url>
    <content><![CDATA[<h2 id="NavigatorIOS"><a href="#NavigatorIOS" class="headerlink" title="NavigatorIOS"></a>NavigatorIOS</h2><ul>
<li><code>NavigatorIOS</code>是一个包装<code>UINavigationController</code>，能够实现一个导航堆栈, 且只能在iOS上使用的组件</li>
<li>它的工作原理与使用本地应用程序<code>UINavigationController</code>的效果完全相同，从<code>UIKIt</code>提供相同的动画和行为<span id="more"></span></li>
</ul>
<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-d1e3e673185be43f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/200" alt="Navigator.png"></p>
<h3 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//样式, 必须设置&#123;flex:1&#125;, 否则看不到子控件</span></span><br><span class="line">style=&#123;&#123;flex:<span class="number">1</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//导航条的背景颜色</span></span><br><span class="line">barTintColor=<span class="string">&#x27;yellow&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//为true , 隐藏导航栏</span></span><br><span class="line">navigationBarHidden=&#123;<span class="literal">false</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//是否隐藏阴影，true／false。</span></span><br><span class="line">shadowHidden=&#123;<span class="literal">false</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//导航栏上按钮的颜色设置</span></span><br><span class="line">tintColor=<span class="string">&#x27;black&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//导航栏上标题的颜色设置</span></span><br><span class="line">titleTextColor=<span class="string">&#x27;blue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//导航栏是否是半透明的，true／false。</span></span><br><span class="line">translucent=&#123;<span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="NavigatorIOS的使用"><a href="#NavigatorIOS的使用" class="headerlink" title="NavigatorIOS的使用"></a>NavigatorIOS的使用</h3><ul>
<li>必须初始化路由: <code>initialRoute&#123;&#125;</code></li>
<li>注意:<code>component</code>，需要传入组件，自定义组件</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用于初始化路由。其参数对象中的各个属性如下：</span></span><br><span class="line">initialRoute：</span><br><span class="line"> &#123;</span><br><span class="line">  component: function, <span class="comment">//加载的视图组件</span></span><br><span class="line">  title: string, <span class="comment">//当前视图的标题</span></span><br><span class="line">  passPros: object, <span class="comment">//传递的数据</span></span><br><span class="line">  backButtonIcon: Image.propTypes.source, <span class="comment">// 后退按钮图标</span></span><br><span class="line">  backButtonTitle: string, <span class="comment">//后退按钮标题</span></span><br><span class="line">  leftButtonIcon: Image.propTypes.soruce, <span class="comment">// 左侧按钮图标</span></span><br><span class="line">  leftButtonTitle: string, <span class="comment">//左侧按钮标题</span></span><br><span class="line">  onLeftButtonPress: function, <span class="comment">//左侧按钮点击事件</span></span><br><span class="line">  rightButtonIcon: Image.propTypes.soruce, <span class="comment">// 右侧按钮图标</span></span><br><span class="line">  rightButtonTitle: string, <span class="comment">//右侧按钮标题</span></span><br><span class="line">  onRightButtonPress: function, <span class="comment">//右侧按钮点击事件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>使用示例</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">&lt;NavigatorIOS initialRoute=&#123;</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">//JunNavigatorView: 为自定义的组件</span></span><br><span class="line">            component:JunNavigatorView,</span><br><span class="line">            title: <span class="string">&#x27;首页&#x27;</span>,</span><br><span class="line">            leftButtonTitle:<span class="string">&#x27;左按钮&#x27;</span>,</span><br><span class="line">            rightButtonTitle:<span class="string">&#x27;跳转&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>

<h3 id="页面间的跳转"><a href="#页面间的跳转" class="headerlink" title="页面间的跳转"></a>页面间的跳转</h3><ul>
<li>获取Navigator，只有它才能跳转</li>
<li>只要是导航控制器下的组件，都可以通过props获取</li>
<li><code>this.props.navigator</code></li>
<li>界面跳转方法</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">pust(route)：<span class="comment">//加载一个新的页面（视图或者路由）并且路由到该页面。</span></span><br><span class="line">pop()：<span class="comment">//返回到上一个页面。</span></span><br><span class="line">popN(n)：<span class="comment">//一次性返回N个页面。当 N=1 时，相当于 pop() 方法的效果。</span></span><br><span class="line">replace(route)：<span class="comment">//替换当前的路由。</span></span><br><span class="line">replacePrevious（route）：<span class="comment">//替换前一个页面的视图并且回退过去。</span></span><br><span class="line">resetTo(route)：<span class="comment">//取代最顶层的路由并且回退过去。</span></span><br><span class="line">popToTop()：<span class="comment">//回到最上层视图。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>使用示例</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">&lt;Text onPress=&#123;()=&gt;&#123;</span><br><span class="line">    <span class="variable language_">this</span>.props.navigator.push(&#123;</span><br><span class="line">        component:JunTwoView,</span><br><span class="line">        title:<span class="string">&#x27;第二页面&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;&#125;</span><br><span class="line">&gt;点击跳转到第二个页面&lt;/Text&gt;</span><br></pre></td></tr></table></figure>

<h2 id="Navigator"><a href="#Navigator" class="headerlink" title="Navigator"></a>Navigator</h2><ul>
<li><code>Navigator</code>很好解决了<code>NavigatorIOS</code>不能跨平台和自定义的问题</li>
<li>RN开发中通常使用<code>Navigator</code></li>
<li>Navigator作用：只提供跳转功能，支持iOS,安卓</li>
<li>导航条需要自定义，需要导航条的界面，自己添加<br>只要一个控件，包装成Navigator就能获取跳转功能</li>
</ul>
<h3 id="Navigator导入问题"><a href="#Navigator导入问题" class="headerlink" title="Navigator导入问题"></a>Navigator导入问题</h3><ul>
<li>在0,43版本之前(包括0.43), <code>Navigator</code>在<code>react-native</code>库中</li>
<li>从0.44版本开始<code>Navigator</code>就被移入了<code>react-native-deprecated-custom-components</code>库中</li>
<li>使用前,先进入当前项目文件，安装Navigator所在的库</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//终端输入</span></span><br><span class="line">yarn add react-native-deprecated-custom-components</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面方法可能已经失效(亲测失败)</span></span><br><span class="line">npm install react-native-deprecated-custom-components --save</span><br></pre></td></tr></table></figure>
<ul>
<li>下载完成后，导入<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123;Navigator&#125; from &#x27;react-native-deprecated-custom-components&#x27;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Navigator的使用"><a href="#Navigator的使用" class="headerlink" title="Navigator的使用"></a>Navigator的使用</h3><h4 id="initialRoute：初始化路由"><a href="#initialRoute：初始化路由" class="headerlink" title="initialRoute：初始化路由"></a><code>initialRoute</code>：初始化路由</h4><ul>
<li>定义启动时加载的路由</li>
<li>路由是导航栏用来识别渲染场景的一个对象</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">&lt;Navigator initialRoute=&#123;&#123;component: JunOneView&#125;&#125;/&gt;</span><br></pre></td></tr></table></figure>

<h4 id="配置场景动画和手势"><a href="#配置场景动画和手势" class="headerlink" title="配置场景动画和手势"></a>配置场景动画和手势</h4><ul>
<li>可选的函数, 设置跳转方向</li>
<li>会带有两个参数调用，一个是当前的路由，一个是当前的路由栈</li>
<li>返回一个场景配置对象</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">_configureScene(route, routeStack) &#123;</span><br><span class="line">    <span class="keyword">return</span> Navigator.SceneConfigs.PushFromLeft;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>其他跳转方向参数</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Navigator.SceneConfigs.PushFromRight (默认)</span><br><span class="line">Navigator.SceneConfigs.FloatFromRight</span><br><span class="line">Navigator.SceneConfigs.FloatFromLeft</span><br><span class="line">Navigator.SceneConfigs.FloatFromBottom</span><br><span class="line">Navigator.SceneConfigs.FloatFromBottomAndroid</span><br><span class="line">Navigator.SceneConfigs.FadeAndroid</span><br><span class="line">Navigator.SceneConfigs.HorizontalSwipeJump</span><br><span class="line">Navigator.SceneConfigs.HorizontalSwipeJumpFromRight</span><br><span class="line">Navigator.SceneConfigs.VerticalUpSwipeJump</span><br><span class="line">Navigator.SceneConfigs.VerticalDownSwipeJump</span><br></pre></td></tr></table></figure>

<h4 id="渲染指定路由的场景"><a href="#渲染指定路由的场景" class="headerlink" title="渲染指定路由的场景"></a>渲染指定路由的场景</h4><ul>
<li>必要参数, 调用的参数是路由和导航器</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">_renderScene(route, navigator) &#123;</span><br><span class="line">        <span class="comment">// ...扩展符, 作用:如果是对象,就获取对象中所有值,如果是数组,就获取数组中所有值</span></span><br><span class="line">    <span class="keyword">return</span> (&lt;route.component navigator=&#123;navigator&#125; &#123;... route.props&#125;/&gt;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="设置导航尺寸"><a href="#设置导航尺寸" class="headerlink" title="设置导航尺寸"></a>设置导航尺寸</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">style=&#123;&#123;flex:<span class="number">1</span>&#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="其他属性或方法"><a href="#其他属性或方法" class="headerlink" title="其他属性或方法"></a>其他属性或方法</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">onDidFocus function </span><br><span class="line"><span class="comment">//每当导航切换完成或初始化之后，调用此回调，参数为新场景的路由。</span></span><br><span class="line"></span><br><span class="line">onWillFocus function </span><br><span class="line"><span class="comment">//会在导航切换之前调用，参数为目标路由。</span></span><br></pre></td></tr></table></figure>

<h2 id="延展符"><a href="#延展符" class="headerlink" title="延展符"></a>延展符</h2><ul>
<li>文中用到了一个操作符: <code>...</code>即为延展符</li>
<li>延展符的作用<ul>
<li>遍历数组</li>
<li>遍历对象的属性,一个一个传值给下一个控件</li>
</ul>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">var arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">var arr2 = [<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">arr2.push(...arr1)</span><br><span class="line">console.log(arr2)</span><br><span class="line"><span class="comment">//输出结果: [0, 1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>作用等同于<code>JavaScript</code>数组中的concat方法</li>
<li>区别在于<code>concat</code>只能作用于数组</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">var arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">var arr2 = [<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr2.push(...arr1)</span></span><br><span class="line">arr2 = arr2.concat(arr1)</span><br><span class="line">console.log(arr2)</span><br><span class="line"><span class="comment">//输出结果: [0, 1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<h4 id="关于JavaScript的数组语法-请查看我的另一篇文章JavaScript基本语法01"><a href="#关于JavaScript的数组语法-请查看我的另一篇文章JavaScript基本语法01" class="headerlink" title="关于JavaScript的数组语法, 请查看我的另一篇文章JavaScript基本语法01"></a>关于<code>JavaScript</code>的数组语法, 请查看我的另一篇文章<a href="https://www.titanjun.top/2017/08/09/JavaScript%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%9501/">JavaScript基本语法01</a></h4></blockquote>
]]></content>
      <categories>
        <category>ReactNaive</category>
      </categories>
      <tags>
        <tag>Navigator</tag>
      </tags>
  </entry>
  <entry>
    <title>ReactNaive之CSS和Flex布局</title>
    <url>/post/19ce3e28.html</url>
    <content><![CDATA[<p>ReactNaive之CSS和Flex布局</p>
<span id="more"></span>

<h2 id="和-的使用"><a href="#和-的使用" class="headerlink" title="{}和()的使用"></a>{}和()的使用</h2><h3 id="的使用"><a href="#的使用" class="headerlink" title="{}的使用"></a>{}的使用</h3><h4 id="ReactNative中，使用表达式的时候需要用-包住"><a href="#ReactNative中，使用表达式的时候需要用-包住" class="headerlink" title="ReactNative中，使用表达式的时候需要用{}包住"></a>ReactNative中，使用表达式的时候需要用{}包住</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">style=&#123;styles.mainStyle&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ReactNative中-在字符串中使用变量的时候，需要用-包住"><a href="#ReactNative中-在字符串中使用变量的时候，需要用-包住" class="headerlink" title="ReactNative中,在字符串中使用变量的时候，需要用{}包住"></a>ReactNative中,在字符串中使用变量的时候，需要用{}包住</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">var str = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">&lt;Text&gt;&#123;str&#125;&lt;/Text&gt;</span><br></pre></td></tr></table></figure>

<h4 id="ReactNative中，对象，字典需要用-包住"><a href="#ReactNative中，对象，字典需要用-包住" class="headerlink" title="ReactNative中，对象，字典需要用{}包住"></a>ReactNative中，对象，字典需要用{}包住</h4><ul>
<li><code>style = &#123;&#125;</code>,最外层表达式，用{}包住</li>
<li><code>&#123;flex:1&#125;</code>,对象，用{}包住</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">&lt;View style=&#123;&#123;flex:<span class="number">1</span>&#125;&#125;&gt;&lt;/View&gt;</span><br></pre></td></tr></table></figure>
<h3 id="的使用-1"><a href="#的使用-1" class="headerlink" title="()的使用"></a>()的使用</h3><ul>
<li>创建组件<code>&lt;View&gt;&lt;/View&gt;</code>，必须要用()包住<ul>
<li>因此只要返回组件，都需要用()</li>
</ul>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">render()&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;View style=&#123;styles.mainStyle&#125;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/View&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ReactNative之CSS布局"><a href="#ReactNative之CSS布局" class="headerlink" title="ReactNative之CSS布局"></a>ReactNative之CSS布局</h2><ul>
<li>ReactNative支持CSS中的布局属性，因此可以使用CSS布局属性</li>
<li>CSS颜色大全，下面会用到，点击这<a href="http://www.cnblogs.com/axing/archive/2011/04/09/CSS.html">CSS颜色代码大全</a></li>
</ul>
<h3 id="视图边框"><a href="#视图边框" class="headerlink" title="视图边框"></a>视图边框</h3><ul>
<li>什么时候使用？想设置自己周边有边框的时候</li>
<li>注意点：<em><strong>一定要设置边框宽度</strong></em></li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">borderBottomWidth number <span class="comment">//底部边框宽度</span></span><br><span class="line">borderLeftWidth number <span class="comment">//左边框宽度</span></span><br><span class="line">borderRightWidth number <span class="comment">//右边框宽度</span></span><br><span class="line">borderTopWidth number <span class="comment">//顶部边框宽度</span></span><br><span class="line">borderWidth number <span class="comment">//边框宽度</span></span><br><span class="line">border&lt;Bottom|Left|Right|Top&gt;Color <span class="comment">//各方向边框的颜色,&lt;&gt;表示连着一起，例如borderBottomColor</span></span><br><span class="line">borderColor <span class="comment">//边框颜色</span></span><br></pre></td></tr></table></figure>

<h3 id="尺寸"><a href="#尺寸" class="headerlink" title="尺寸"></a>尺寸</h3><h4 id="设置宽高"><a href="#设置宽高" class="headerlink" title="设置宽高"></a>设置宽高</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">width number</span><br><span class="line">height number</span><br></pre></td></tr></table></figure>

<h4 id="外边距"><a href="#外边距" class="headerlink" title="外边距"></a>外边距</h4><ul>
<li>设置组件与组件之间的间距<ul>
<li>注意：第一个组件比较特殊，参照父组件，与父控件之间的间距。</li>
<li>其他组件间距，相对于上一个组件</li>
</ul>
</li>
<li>什么时候使用？想设置自己在父控件的位置的时候使用</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">margin number 外边距</span><br><span class="line">marginBottom number 下外边距</span><br><span class="line">marginHorizontal number 左右外边距</span><br><span class="line">marginLeft number 左外边距</span><br><span class="line">marginRight number 右外边距</span><br><span class="line">marginTop number 上外边距</span><br><span class="line">marginVertical number 上下外边距</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意marginRight和width冲突，如果设置了width，marginRight无效。</span></span><br></pre></td></tr></table></figure>

<h4 id="内边距"><a href="#内边距" class="headerlink" title="内边距"></a>内边距</h4><ul>
<li>设置子控件与当前控件的位置</li>
<li>什么时候使用？想设置自己的子控件相对自己的位置的时候使用</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">padding number 内边距</span><br><span class="line">paddingBottom number 下内边距</span><br><span class="line">paddingHorizontal number 左右内边距</span><br><span class="line">paddingLeft number 做内边距</span><br><span class="line">paddingRight number 右内边距</span><br><span class="line">paddingTop number 上内边距</span><br><span class="line">paddingVertical number 上下内边距</span><br></pre></td></tr></table></figure>

<h4 id="相对定位和绝对定位"><a href="#相对定位和绝对定位" class="headerlink" title="相对定位和绝对定位"></a>相对定位和绝对定位</h4><h4 id="边缘"><a href="#边缘" class="headerlink" title="边缘"></a>边缘</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">left   number  左边缘。</span><br><span class="line">right  number  右边缘。</span><br><span class="line">top    number  顶部边缘。</span><br><span class="line">bottom number  底部边缘。</span><br></pre></td></tr></table></figure>

<h4 id="定位-position"><a href="#定位-position" class="headerlink" title="定位(position):"></a>定位(position):</h4><ul>
<li>通过 <code>left</code>, <code>top</code>, <code>right</code> 以及 <code>bottom</code> 边缘属性进行定位。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">absolute：绝对定位，参照父控件位置定位</span><br><span class="line">relative：相对定位，参照当前控件原始位置定位</span><br></pre></td></tr></table></figure>
<ul>
<li>什么时候使用绝对定位，当想把一个已经设置了宽度的控件快速的放在左下角，右下角的时候，可以使用绝对定位</li>
<li>什么时候使用相对定位，当想相对自己做出一些改变的时候，采用相对定位,比如相对自己，往下移动一点</li>
</ul>
<h2 id="ReactNative之Flex布局"><a href="#ReactNative之Flex布局" class="headerlink" title="ReactNative之Flex布局"></a>ReactNative之Flex布局</h2><ul>
<li>一般使用ReactNative开发App,一般都采用Flex布局，使用这套布局就非常快。</li>
</ul>
<h3 id="Flex简介"><a href="#Flex简介" class="headerlink" title="Flex简介"></a>Flex简介</h3><ul>
<li>Flex又叫弹性布局，会把当前组件看做一个容器，他的所有子组件都是他容器中的成员，通过Flex，就能迅速的布局容器中的成员。</li>
<li>使用场景：当想快速布局一个组件中所有子组件的时候，可以使用Flex布局</li>
</ul>
<h3 id="Flex主轴和侧轴"><a href="#Flex主轴和侧轴" class="headerlink" title="Flex主轴和侧轴"></a>Flex主轴和侧轴</h3><ul>
<li>Flex中有两个主要的概念：主轴和侧轴</li>
<li>主轴与侧轴的关系：相互垂直的。</li>
<li>主轴：决定容器中子组件默认的布局方向：水平，垂直</li>
<li>侧轴：决定容器中子组件与主轴垂直的布局方向<ul>
<li>比如主轴水平，那么子组件默认就是水平布局排布，侧轴就是控制子组件在垂直方向的布局</li>
</ul>
</li>
</ul>
<h3 id="flexDirection属性"><a href="#flexDirection属性" class="headerlink" title="flexDirection属性"></a>flexDirection属性</h3><ul>
<li>flexDirection:决定主轴的方向，水平或者垂直，这样子组件就会水平排布或者垂直排布</li>
<li>flexDirection共有四个值，在RN中默认为column。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">row（默认值）：主轴为水平方向，从左向右。依次排列</span><br><span class="line">row-reverse：主轴为水平方向，从右向左依次排列</span><br><span class="line">column：主轴为垂直方向，默认的排列方式，从上向下排列</span><br><span class="line">column-reverse：主轴为垂直方向，从下向上排列</span><br></pre></td></tr></table></figure>

<h3 id="flexWrap属性"><a href="#flexWrap属性" class="headerlink" title="flexWrap属性"></a>flexWrap属性</h3><ul>
<li>flexWrap:决定子控件在父视图内是否允许多行排列。</li>
<li>flexWrap共有两个值，默认为nowrap。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">nowrap 组件只排列在一行上，可能导致溢出。</span><br><span class="line">wrap   组件在一行排列不下时，就进行多行排列</span><br></pre></td></tr></table></figure>

<h3 id="justifyContent"><a href="#justifyContent" class="headerlink" title="justifyContent"></a>justifyContent</h3><ul>
<li><code>justifyContent</code>:决定子组件在主轴中具体布局，是靠左，还是居中等</li>
<li><code>justifyContent</code>共有五个值，默认为<code>flex-start</code></li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">flex-start: <span class="comment">//子组件向主轴起点对齐，如果主轴水平，从左开始，主轴垂直，从上开始。</span></span><br><span class="line">flex-end:  <span class="comment">//子组件向主轴终点对齐，如果主轴水平，从右开始，主轴垂直，从下开始。</span></span><br><span class="line">center: <span class="comment">//居中显示，注意：并不是让某一个子组件居中，而是整体有居中效果</span></span><br><span class="line">space-between: <span class="comment">//均匀分配,相邻元素间距离相同。每行第一个组件与行首对齐，每行最后一个组件与行尾对齐。</span></span><br><span class="line">space-around: <span class="comment">//均匀分配,相邻元素间距离相同。每行第一个组件到行首的距离和每行最后一个组件到行尾的距离将会是相邻元素之间距离的一半</span></span><br></pre></td></tr></table></figure>

<h3 id="alignItems"><a href="#alignItems" class="headerlink" title="alignItems"></a>alignItems</h3><ul>
<li><code>alignItems</code>:决定子组件在测轴中具体布局<br>一直都没有管过侧轴，如果侧轴垂直，决定子组件在上，还是下，或者居中</li>
<li><code>alignItems</code>共有四个值，默认为<code>stretch</code>。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">flex-start 子组件向侧轴起点对齐。</span><br><span class="line">flex-end 子组件向侧轴终点对齐。</span><br><span class="line">center 子组件在侧轴居中。</span><br><span class="line">stretch 子组件在侧轴方向被拉伸到与容器相同的高度或宽度。</span><br></pre></td></tr></table></figure>

<h3 id="alignSelf"><a href="#alignSelf" class="headerlink" title="alignSelf"></a>alignSelf</h3><ul>
<li><code>alignSelf</code>:自定义自己的侧轴布局，用于一个子组件设置。</li>
<li>注意：当某个子组件不想参照默认的<code>alignItems</code>时，可以设置<code>alignSelf</code>，自定义自己的侧轴布局。</li>
<li><code>alignSelf</code>共有五个值，默认为<code>auto</code>。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">auto 继承它的父容器的alignItems属性。如果没有父容器则为 <span class="string">&quot;stretch&quot;</span></span><br><span class="line">flex-start 子组件向侧轴起点对齐。</span><br><span class="line">flex-end 子组件向侧轴终点对齐。</span><br><span class="line">center 子组件在侧轴居中。</span><br><span class="line">stretch 子组件在侧轴方向被拉伸到与容器相同的高度或宽度。</span><br></pre></td></tr></table></figure>

<h3 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h3><ul>
<li><code>flex</code>: 决定子控件在主轴中占据几等分。</li>
<li><code>flex</code>: 任意数字，所有子控件<code>flex</code>相加，自己<code>flex</code>占总共多少，就有多少宽度.</li>
</ul>
<h2 id="ReactNative之组件属性-Props、State"><a href="#ReactNative之组件属性-Props、State" class="headerlink" title="ReactNative之组件属性(Props、State)"></a>ReactNative之组件属性(Props、State)</h2><ul>
<li>在App开发中，少不了组件之间的传值，在RN中组件之间通信需要用到Props和State。</li>
</ul>
<h3 id="Props-属性"><a href="#Props-属性" class="headerlink" title="Props(属性)"></a>Props(属性)</h3><ul>
<li>什么是Props？一般用于自定义组件，大多数组件在创建时就可以使用各种参数来进行定制，用于定制的这些参数就称为props（属性）。</li>
<li>props不能在自己的组件中修改, 只能在父组件中修改</li>
<li>如果想在自己的组件中修改属性, 需要用state</li>
<li><code>name</code>:就是<code>Props</code>，通过<code>this.props.name</code>访问</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">&lt;Room name=<span class="string">&quot;小码哥&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：props是在父组件中指定，而且一经指定，在整个组件的生命周期中都不再改变。</p>
</blockquote>
<h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><ul>
<li>State：如果以后想修改某个属性，就修改界面，就需要用state。</li>
<li>注意:State属性一般在constructor中声明(ES6)，在setState中修改数据.</li>
<li>定义state属性</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.state = &#123;</span><br><span class="line">    num:<span class="number">1</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改state属性</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.setState(&#123;</span><br><span class="line">    num : number</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>ReactNaive</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>ReactNaive之ScrollView和ListView</title>
    <url>/post/d9c2daec.html</url>
    <content><![CDATA[<ul>
<li>记住ScrollView必须有一个确定的高度才能正常工作，因为它实际上所做的就是将一系列不确定高度的子组件装进一个确定高度的容器（通过滚动操作）</li>
<li>要给一个ScrollView确定一个高度的话，要么直接给它设置高度（不建议），要么确定所有的父容器都有确定的高度</li>
</ul>
<span id="more"></span>

<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-45456c9ba9799576.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/200" alt="ListView.png"></p>
<h2 id="ScrollView"><a href="#ScrollView" class="headerlink" title="ScrollView"></a>ScrollView</h2><h3 id="ScrollView常用的属性"><a href="#ScrollView常用的属性" class="headerlink" title="ScrollView常用的属性"></a>ScrollView常用的属性</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">horizontal <span class="type">bool</span></span><br><span class="line"><span class="comment">//当此属性为true的时候，所有的子视图会在水平方向上排成一行，而不是默认的在垂直方向上排成一列。默认值为false。</span></span><br><span class="line"></span><br><span class="line">showsHorizontalScrollIndicator <span class="type">bool</span></span><br><span class="line"><span class="comment">//当此属性为true的时候，显示一个水平方向的滚动条。</span></span><br><span class="line">showsVerticalScrollIndicator <span class="type">bool</span></span><br><span class="line"><span class="comment">//当此属性为true的时候，显示一个垂直方向的滚动条。</span></span><br><span class="line"></span><br><span class="line">alwaysBounceHorizontal <span class="type">bool</span></span><br><span class="line"><span class="comment">//当此属性为true时，水平方向即使内容比滚动视图本身还要小，也可以弹性地拉动一截。当horizontal=&#123;true&#125;时默认值为true，否则为false。</span></span><br><span class="line"></span><br><span class="line">refreshControl element</span><br><span class="line"><span class="comment">//指定RefreshControl组件，用于为ScrollView提供下拉刷新功能</span></span><br><span class="line"></span><br><span class="line">(ios) alwaysBounceVertical <span class="type">bool</span></span><br><span class="line"><span class="comment">//当此属性为true时，垂直方向即使内容比滚动视图本身还要小，也可以弹性地拉动一截。</span></span><br><span class="line"><span class="comment">//当horizontal=&#123;true&#125;时默认值为false，否则为true。</span></span><br><span class="line"></span><br><span class="line">(ios) automaticallyAdjustContentInsets <span class="type">bool</span></span><br><span class="line"><span class="comment">//当滚动视图放在一个导航条或者工具条后面的时候，iOS系统是否要自动调整内容的范围。默认值为true。（译注：如果你的ScrollView或ListView的头部出现莫名其妙的空白，尝试将此属性置为false）</span></span><br><span class="line"></span><br><span class="line">(ios) bounces <span class="type">bool</span></span><br><span class="line"><span class="comment">//当值为true时，如果内容范围比滚动视图本身大，在到达内容末尾的时候，可以弹性地拉动一截。如果为false，尾部的所有弹性都会被禁用，即使alwaysBounce*属性为true。默认值为true。</span></span><br><span class="line"></span><br><span class="line">(ios) bouncesZoom <span class="type">bool</span></span><br><span class="line"><span class="comment">//当值为true时，使用手势缩放内容可以超过min/max的限制，然后在手指抬起之后弹回min/max的缩放比例。否则的话，缩放不能超过限制。</span></span><br><span class="line"></span><br><span class="line">(ios) contentInset &#123;top: number, left: number, bottom: number, right: number&#125;</span><br><span class="line"><span class="comment">//内容范围相对滚动视图边缘的坐标。默认为&#123;0, 0, 0, 0&#125;</span></span><br><span class="line"></span><br><span class="line">(ios) contentOffset PointPropType</span><br><span class="line"><span class="comment">//用来手动设置初始的滚动坐标。默认值为&#123;x: 0, y: 0&#125;</span></span><br><span class="line"></span><br><span class="line">pagingEnabled <span class="type">bool</span></span><br><span class="line"><span class="comment">//当值为true时，滚动条会停在滚动视图的尺寸的整数倍位置。这个可以用在水平分页上。默认值为false。</span></span><br><span class="line"></span><br><span class="line">scrollEnabled <span class="type">bool</span></span><br><span class="line"><span class="comment">//当值为false的时候，内容不能滚动，默认值为true。</span></span><br><span class="line"></span><br><span class="line">(ios) scrollEventThrottle number</span><br><span class="line"><span class="comment">//这个属性控制在滚动过程中，scroll事件被调用的频率（单位是每秒事件数量）。更大的数值能够更及时的跟踪滚动位置，不过可能会带来性能问题，因为更多的信息会通过bridge传递。默认值为0，意味着每次视图被滚动，scroll事件只会被调用一次。</span></span><br><span class="line"></span><br><span class="line">(ios)scrollIndicatorInsets &#123;top: number, left: number, bottom: number, right: number&#125;</span><br><span class="line"><span class="comment">//决定滚动条距离视图边缘的坐标。这个值应该和contentInset一样。默认值为&#123;0, 0, 0, 0&#125;。</span></span><br><span class="line"></span><br><span class="line">(ios) scrollsToTop <span class="type">bool</span></span><br><span class="line"><span class="comment">//当此值为true时，点击状态栏的时候视图会滚动到顶部。默认值为true。</span></span><br><span class="line"></span><br><span class="line">stickyHeaderIndices [number]</span><br><span class="line"><span class="comment">//一个子视图下标的数组，用于决定哪些成员会在滚动之后固定在屏幕顶端。</span></span><br><span class="line"><span class="comment">//举个例子，传递stickyHeaderIndices=&#123;[0]&#125;会让第一个成员固定在滚动视图顶端。</span></span><br><span class="line"><span class="comment">//这个属性不能和horizontal=&#123;true&#125;一起使用。</span></span><br><span class="line"></span><br><span class="line">(ios) maximumZoomScale number</span><br><span class="line"><span class="comment">//允许的最大缩放比例。默认值为1.0。</span></span><br><span class="line"></span><br><span class="line">(ios) minimumZoomScale number</span><br><span class="line"><span class="comment">//允许的最小缩放比例。默认值为1.0。</span></span><br></pre></td></tr></table></figure>

<h3 id="ScrollView常用的方法"><a href="#ScrollView常用的方法" class="headerlink" title="ScrollView常用的方法"></a>ScrollView常用的方法</h3><ul>
<li>开发中，常需要在滚动的时候做事情，那怎么监听ScrollView滚动</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 监听滚动开始</span></span><br><span class="line">onMomentumScrollBegin=&#123;<span class="variable language_">this</span>._onMomentumScrollBegin.bind(<span class="variable language_">this</span>)&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听滚动结束</span></span><br><span class="line">onMomentumScrollEnd=&#123;<span class="variable language_">this</span>._onMomentumScrollEnd.bind(<span class="variable language_">this</span>)&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听开始拖拽</span></span><br><span class="line">onScrollBeginDrag=&#123;<span class="variable language_">this</span>._onScrollBeginDrag.bind(<span class="variable language_">this</span>)&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听结束拖拽</span></span><br><span class="line">onScrollEndDrag=&#123;<span class="variable language_">this</span>._onScrollEndDrag.bind(<span class="variable language_">this</span>)&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听滚动动画完成</span></span><br><span class="line">onScrollAnimationEnd=&#123;<span class="variable language_">this</span>._onScrollAnimationEnd.bind(<span class="variable language_">this</span>)&#125;</span><br><span class="line"></span><br><span class="line">onMomentumScrollStart?: function</span><br><span class="line"><span class="comment">//滚动动画开始时调用此函数。</span></span><br><span class="line"></span><br><span class="line">onMomentumScrollEnd?: function</span><br><span class="line"><span class="comment">//滚动动画结束时调用此函数。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听滚动的时候</span></span><br><span class="line">onScroll=&#123;<span class="variable language_">this</span>._onScroll.bind(<span class="variable language_">this</span>)&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置滚动频率,一滚动就监听,需要和onScroll配套使用</span></span><br><span class="line">scrollEventThrottle=&#123;<span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">scrollTo(y: number | &#123; x?: number, y?: number, animated?: boolean &#125;, x: number, animated: boolean)</span><br><span class="line"><span class="comment">//滚动到指定的x, y偏移处。第三个参数为是否启用平滑滚动动画。</span></span><br><span class="line"><span class="comment">//使用示例:</span></span><br><span class="line">scrollTo(&#123;x: <span class="number">0</span>, y: <span class="number">0</span>, animated: <span class="literal">true</span>&#125;)</span><br><span class="line"></span><br><span class="line">scrollToEnd(options?)</span><br><span class="line"><span class="comment">//滚动到视图底部（水平方向的视图则滚动到最右边）。</span></span><br><span class="line"><span class="comment">//加上动画参数 scrollToEnd(&#123;animated: true&#125;)则启用平滑滚动动画，或是调用 scrollToEnd(&#123;animated: false&#125;)来立即跳转。如果不使用参数，则animated选项默认启用。</span></span><br></pre></td></tr></table></figure>

<h3 id="获取原生事件"><a href="#获取原生事件" class="headerlink" title="获取原生事件"></a>获取原生事件</h3><ul>
<li>滚动的时候,会传入一个合成事件作为监听滚动方法的参数，每个方法都会有这个合成事件</li>
<li>通过合成事件能获取原生事件<code>nativeEvent</code>,原生事件<code>nativeEvent</code>会有我们想要的信息.</li>
<li>什么是合成事件：在RN中，事件的处理由其内部自己实现的事件系统完成，触发的事件都叫做 合成事件（<code>SyntheticEven</code>t）</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 滚动完成的时候调用</span></span><br><span class="line">_onMomentumScrollEnd(e)&#123;</span><br><span class="line">    <span class="comment">// 获取原生事件</span></span><br><span class="line">    var nativeEvent = e.nativeEvent</span><br><span class="line">    <span class="comment">//获取当前偏移量</span></span><br><span class="line">    var contentX = nativeEvent.contentOffset.x</span><br><span class="line">    <span class="comment">//当前页</span></span><br><span class="line">    var page = contentX / kScreenWidth</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.setState(&#123;</span><br><span class="line">        currentPage:page</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="ListView"><a href="#ListView" class="headerlink" title="ListView"></a>ListView</h2><ul>
<li>官方文档提示: 在0.46版本开始此组件已过期, 并推荐使用<code>FlatList</code>或<code>SectionList</code>替代, 但是在0.51版本依然可以使用</li>
<li><code>ListView</code>: 一个核心组件，用于高效地显示一个可以垂直滚动的变化的数据列表</li>
<li>ListView内部是通过<code>ListViewDataSource</code>这个对象，显示数据，因此使用ListView必须先创建<code>ListViewDataSource</code>对象。</li>
<li><code>ListViewDataSource</code>构造方法(创建对象):可选择性传入4个参数,描述怎么提取数据，怎么刷新cell</li>
<li>这些参数：都是函数，当产生对应的事件的时候，会自动执行这些函数.</li>
</ul>
<h3 id="ListView常用的属性和方法"><a href="#ListView常用的属性和方法" class="headerlink" title="ListView常用的属性和方法"></a>ListView常用的属性和方法</h3><ul>
<li>ListView可以使用所有ScrollView的属性。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">initialListSize number</span><br><span class="line"><span class="comment">//指定在组件刚挂载的时候渲染多少行数据。用这个属性来确保首屏显示合适数量的数据，而不是花费太多帧逐步显示出来</span></span><br><span class="line"></span><br><span class="line">dataSource ListViewDataSource</span><br><span class="line"><span class="comment">//ListView.DataSource实例（列表依赖的数据源）</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>ListViewDataSource</code>构造函数可以接受下列四种参数（都是可选）：</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">getRowData(dataBlob, sectionID, rowID);</span><br><span class="line"><span class="comment">//怎么获取行数据</span></span><br><span class="line">getSectionHeaderData(dataBlob, sectionID);</span><br><span class="line"><span class="comment">//怎么获取每一组头部数据</span></span><br><span class="line">rowHasChanged(prevRowData, nextRowData);</span><br><span class="line"><span class="comment">//决定什么情况行数据才发生改变，当行数据发生改变，就会绘制下一行cell</span></span><br><span class="line">sectionHeaderHasChanged(prevSectionData, nextSectionData);</span><br><span class="line"><span class="comment">//决定什么情况头部数据才发生改变，当行数据发生改变，就会绘制下一行cell</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>ListViewDataSource</code>为<code>ListView</code>组件提供高性能的数据处理和访问。我们需要调用clone方法从原始输入数据中抽取数据来创建<code>ListViewDataSource</code>对象。</li>
<li>要更新<code>datasource</code>中的数据，请（每次都重新）调用<code>cloneWithRows</code>方法（如果用到了section，则对应<code>cloneWithRowsAndSections</code>方法）clone方法会自动提取新数据并进行逐行对比（使用<code>rowHasChanged</code>方法中的策略），这样<code>ListView</code>就知道哪些行需要重新渲染了</li>
<li>注意：初始化<code>ListViewDataSource</code>的时候，如果不需要修改提取数据的方式，只需要实现<code>rowHasChanged</code>，告诉什么时候刷新下一行数据.</li>
<li>注意：默认<code>ListViewDataSource</code>有提取数据方式，可以使用默认的提取方式.</li>
</ul>
<h3 id="ListView使用步骤"><a href="#ListView使用步骤" class="headerlink" title="ListView使用步骤"></a>ListView使用步骤</h3><ul>
<li>1). 创建数据源</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 创建数据源对象</span></span><br><span class="line">var datas = new ListView.DataSource(&#123;</span><br><span class="line">    <span class="comment">//设置数据改变的时候刷新下一行数据</span></span><br><span class="line">    rowHasChanged: (r1, r2)=&gt;&#123;r1 != r2&#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 请求数据&#x27;</span></span><br><span class="line">var foodArr = require(<span class="string">&#x27;./Resource/food.json&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 设置数据</span></span><br><span class="line">datas = datas.cloneWithRows(foodArr)</span><br><span class="line"></span><br><span class="line"><span class="comment">//5. 保存数据源</span></span><br><span class="line"><span class="variable language_">this</span>.state = &#123;</span><br><span class="line">    dataArr: datas</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>2). ListView实现</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">&lt;ListView style=&#123;&#123;backgroundColor:<span class="string">&#x27;white&#x27;</span>, marginTop:<span class="number">20</span>&#125;&#125;</span><br><span class="line">    <span class="comment">//设置数据源</span></span><br><span class="line">          dataSource=&#123;<span class="variable language_">this</span>.state.dataArr&#125;</span><br><span class="line">    <span class="comment">//渲染哪一行(设置cell样式)</span></span><br><span class="line">          renderRow=&#123;<span class="variable language_">this</span>._renderRow.bind(<span class="variable language_">this</span>)&#125;</span><br><span class="line">          <span class="comment">//设置头部样式</span></span><br><span class="line">          renderHeader=&#123;<span class="variable language_">this</span>._renderHeader.bind(<span class="variable language_">this</span>)&#125;</span><br><span class="line">          <span class="comment">//设置section的头部样式</span></span><br><span class="line">          renderSectionHeader=&#123;<span class="variable language_">this</span>._renderSectionHeader.bind(<span class="variable language_">this</span>)&#125;</span><br><span class="line">          <span class="comment">//设置尾部样式</span></span><br><span class="line">          renderFooter=&#123;<span class="variable language_">this</span>._renderFooter.bind(<span class="variable language_">this</span>)&#125;</span><br><span class="line">          <span class="comment">//设置分割线样式</span></span><br><span class="line">          renderSeparator=&#123;<span class="variable language_">this</span>._renderSeparator.bind(<span class="variable language_">this</span>)&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>3). 相关属性方法介绍<ul>
<li>renderRow: 设置每行cell样式</li>
</ul>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现数据源方法,设置每行cell样式</span></span><br><span class="line"><span class="comment">/*这个方法会自动传入四个参数(rowData,sectionID,rowID,highlightRow)</span></span><br><span class="line"><span class="comment">rowData:当前行数据</span></span><br><span class="line"><span class="comment">sectionID:当前行所在组ID</span></span><br><span class="line"><span class="comment">rowID：哪一行的角标</span></span><br><span class="line"><span class="comment">highlightRow:高亮函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    _renderRow(rowData, sectionID, rowID, highlightRow) &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;View&gt;</span><br><span class="line">                &lt;Text&gt;&#123;rowData&#125;&lt;/Text&gt;</span><br><span class="line">            &lt;/View&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>ListView头部和尾部视图</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//头部视图</span></span><br><span class="line"> _renderHeader() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;View&gt;</span><br><span class="line">                &lt;Text&gt;头部视图&lt;/Text&gt;</span><br><span class="line">            &lt;/View&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//尾部视图</span></span><br><span class="line"> _renderFooter() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;View&gt;</span><br><span class="line">                &lt;Text&gt;尾部视图&lt;/Text&gt;</span><br><span class="line">            &lt;/View&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>renderSectionHeader: 设置每一个section的头部样式</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//sectionData: 每一组的头部数据</span></span><br><span class="line"><span class="comment">//sectionID: 组ID</span></span><br><span class="line">_renderSectionHeader(sectionData, sectionID)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>ListView分割线</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 哪一组,哪一行,相邻行是否高亮</span></span><br><span class="line">   _renderSeparator(sectionID, rowID, adjacentRowHighlighted)  &#123;</span><br><span class="line">       console.log(sectionID,rowID,adjacentRowHighlighted);</span><br><span class="line">       <span class="keyword">return</span> (</span><br><span class="line">           &lt;View style=&#123;&#123;height:<span class="number">1</span>,backgroundColor:<span class="string">&#x27;black&#x27;</span>&#125;&#125;&gt;&lt;/View&gt;</span><br><span class="line">       )</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="SectionList"><a href="#SectionList" class="headerlink" title="SectionList"></a>SectionList</h3><p>高性能的分组(section)列表组件，支持下面这些常用的功能：</p>
<ul>
<li>完全跨平台。</li>
<li>行组件显示或隐藏时可配置回调事件。</li>
<li>支持单独的头部组件。</li>
<li>支持单独的尾部组件。</li>
<li>支持自定义行间分隔线。</li>
<li>支持分组的头部组件。</li>
<li>支持多种数据源结构</li>
<li>支持下拉刷新。</li>
<li>支持上拉加载。</li>
</ul>
<p>如果你的列表不需要分组(section)，那么可以使用结构更简单的<FlatList></p>
]]></content>
      <categories>
        <category>ReactNaive</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>ReactNative之AsyncStorage本地存储</title>
    <url>/post/b2044ec2.html</url>
    <content><![CDATA[<ul>
<li>在RN开发中，持久化存储数据，可以使用<code>AsyncStorage</code>，对原生的API进行了一层封装</li>
<li><code>AsyncStorage</code>是一个简单的、异步的、持久化的<code>Key-Value</code>存储系统，它对于<code>App</code>来说是全局性的</li>
</ul>
<span id="more"></span>

<blockquote>
<h2 id="AsyncStorage原理和使用"><a href="#AsyncStorage原理和使用" class="headerlink" title="AsyncStorage原理和使用"></a><code>AsyncStorage</code>原理和使用</h2></blockquote>
<ul>
<li><code>AsyncStorage</code>存储数据，在iOS中，底层会把数据保存到沙盒中的<code>Documents</code>中,并生成<code>manifest.json</code>文件。保存的数据都在<code>manifest.json</code>中。</li>
<li><code>AsyncStorage</code>删除数据，也仅仅是删除<code>manifest.json</code>文件中的数据，并不是删除<code>manifest.json</code>文件</li>
<li>唯有<code>clear</code>方法是将文件删除</li>
</ul>
<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-59ec94ecc769d233.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt="数据持久化.jpg"></p>
<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-296bd2a19ea5dc90.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="json文件内容.jpg"></p>
<h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> setItem(key: string, value: string, callback?: ?(error: ?Error) =&gt; <span class="type">void</span>) </span><br><span class="line"><span class="comment">//将key字段的值设置成value，并在完成后调用callback函数。如果有任何错误发生，则会传递一个Error对象作为第一个参数。返回一个Promise对象</span></span><br></pre></td></tr></table></figure>

<ul>
<li>注意：<code>AsyncStorage</code>只能存储字符串，需要把对象转换为字符串才行</li>
<li>具体使用</li>
<li></li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//key值</span></span><br><span class="line">var key = <span class="string">&#x27;per&#x27;</span></span><br><span class="line">var person = &#123;</span><br><span class="line">    name:<span class="string">&#x27;jun&#x27;</span>,</span><br><span class="line">    age:<span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//json转成字符串</span></span><br><span class="line">var jsonStr = JSON.stringify(person)</span><br><span class="line"></span><br><span class="line"><span class="comment">//存储</span></span><br><span class="line">AsyncStorage.setItem(<span class="string">&#x27;person&#x27;</span>, jsonStr, function (error) &#123;</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        alert(<span class="string">&#x27;存储失败&#x27;</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        alert(<span class="string">&#x27;存储完成&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h2><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> getItem(key: string, callback?: ?(error: ?Error, result: ?string) =&gt; <span class="type">void</span>) </span><br><span class="line"><span class="comment">//读取key字段并将结果作为第二个参数传递给callback。如果有任何错误发生，则会传递一个Error对象作为第一个参数。返回一个Promise对象。</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用方法</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//读取</span></span><br><span class="line">_readData()&#123;</span><br><span class="line">    console.log(<span class="string">&#x27;读取&#x27;</span>)</span><br><span class="line">    AsyncStorage.getItem(<span class="string">&#x27;per&#x27;</span>, function (error, result) &#123;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            alert(<span class="string">&#x27;读取失败&#x27;</span>)</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            console.log(result)</span><br><span class="line">            alert(<span class="string">&#x27;读取完成&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> removeItem(key: string, callback?: ?(error: ?Error) =&gt; <span class="type">void</span>) </span><br><span class="line"><span class="comment">//删除一个字段。返回一个Promise对象。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> clear(callback?: ?(error: ?Error) =&gt; <span class="type">void</span>) </span><br><span class="line"><span class="comment">//删除全部的AsyncStorage数据，即直接删除该缓存文件</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>函数用法</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除</span></span><br><span class="line">_deleteData()&#123;</span><br><span class="line">    console.log(<span class="string">&#x27;删除&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除一条数据</span></span><br><span class="line">    AsyncStorage.removeItem(<span class="string">&#x27;per&#x27;</span>, function (error) &#123;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            alert(<span class="string">&#x27;删除失败&#x27;</span>)</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            alert(<span class="string">&#x27;删除完成&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除json文件</span></span><br><span class="line">    AsyncStorage.clear(function (error) &#123;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            alert(<span class="string">&#x27;文件删除失败&#x27;</span>)</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            alert(<span class="string">&#x27;文件删除完成&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="其他用法"><a href="#其他用法" class="headerlink" title="其他用法"></a>其他用法</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> mergeItem(key: string, value: string, callback?: ?(error: ?Error) =&gt; <span class="type">void</span>) </span><br><span class="line"><span class="comment">//假设已有的值和新的值都是字符串化的JSON，则将两个值合并。返回一个Promise对象。还没有被所有原生实现都支持</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> getAllKeys(callback?: ?(error: ?Error, keys: ?Array&lt;string&gt;) =&gt; <span class="type">void</span>) </span><br><span class="line"><span class="comment">//获取所有本应用可以访问到的数据，不论来自什么库或调用者。返回一个Promise对象。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> flushGetRequests() </span><br><span class="line"><span class="comment">//清除所有进行中的查询操作。</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>ReactNaive</category>
      </categories>
  </entry>
  <entry>
    <title>ReactNative之TabBariOS和TabNavigator</title>
    <url>/post/60a392e1.html</url>
    <content><![CDATA[<p>目前<code>React Native</code>提供的官方的<code>Tab Bar</code>主要是<code>TabBarIOS</code>, 但是该控件目前只支持IOS端</p>
<span id="more"></span>

<blockquote>
<p>效果图</p>
</blockquote>
<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-ecacb6e40602657c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/200" alt="底部选项条.png"></p>
<h2 id="TabBarIOS"><a href="#TabBarIOS" class="headerlink" title="TabBarIOS"></a>TabBarIOS</h2><ul>
<li>底部选项条, 不能跨平台,只能iOS端使用</li>
<li>添加如下代码, 就会出现底部选项条</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> (</span><br><span class="line">    &lt;TabBarIOS&gt;&lt;/TabBarIOS&gt;</span><br><span class="line">)        </span><br></pre></td></tr></table></figure>

<h3 id="相关属性"><a href="#相关属性" class="headerlink" title="相关属性"></a>相关属性</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">barTintColor=<span class="string">&#x27;yellow&#x27;</span></span><br><span class="line"><span class="comment">//标签栏的背景颜色</span></span><br><span class="line"></span><br><span class="line">tintColor=<span class="string">&#x27;#ed7f30&#x27;</span></span><br><span class="line"><span class="comment">//当前被选中的标签图标的颜色</span></span><br><span class="line"></span><br><span class="line">unselectedItemTintColor=<span class="string">&#x27;#a19a9a&#x27;</span></span><br><span class="line"><span class="comment">//当前没有被选中的标签图标的颜色。仅在iOS 10及以上版本有效</span></span><br><span class="line"></span><br><span class="line">translucent=&#123;<span class="literal">false</span>&#125; </span><br><span class="line"><span class="comment">//一个布尔值，决定标签栏是否需要半透明化</span></span><br><span class="line"><span class="comment">//默认为true, 有透明效果</span></span><br></pre></td></tr></table></figure>

<h2 id="选项卡-TabBarIOS-Item"><a href="#选项卡-TabBarIOS-Item" class="headerlink" title="选项卡: TabBarIOS.Item"></a>选项卡: <code>TabBarIOS.Item</code></h2><ul>
<li><code>TabBarIOS</code>: 只是表示底部的一个选项条</li>
<li><code>TabBarIOS.Item</code>: 才代表每一个选项卡</li>
<li><code>TabBarIOS.Item</code>必须包装一个View,作为点击tabBar按钮，切换的View</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">&lt;TabBarIOS.Item title=<span class="string">&#x27;首页&#x27;</span></span><br><span class="line">                icon=&#123;&#123;uri:<span class="string">&#x27;btn_home_normal&#x27;</span>&#125;&#125;</span><br><span class="line">                selectedIcon=&#123;&#123;uri:<span class="string">&#x27;btn_home_selected&#x27;</span>&#125;&#125;</span><br><span class="line">                onPress=&#123;()=&gt;&#123;</span><br><span class="line">                    <span class="variable language_">this</span>.setState(&#123;</span><br><span class="line">                        selectedIndex:<span class="number">0</span></span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;&#125;</span><br><span class="line">                selected=&#123;<span class="variable language_">this</span>.state.selectedIndex == <span class="number">0</span>&#125;</span><br><span class="line">&gt;</span><br><span class="line">    &lt;View style=&#123;&#123;backgroundColor:<span class="string">&#x27;red&#x27;</span>, flex:<span class="number">1</span>&#125;&#125;/&gt;</span><br><span class="line">&lt;/TabBarIOS.Item&gt;</span><br></pre></td></tr></table></figure>

<h3 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">badge string, number </span><br><span class="line">badge=<span class="string">&#x27;我&#x27;</span></span><br><span class="line">badge=&#123;<span class="number">12</span>&#125;</span><br><span class="line"><span class="comment">//在图标右上角显示一个红色的气泡, 可接受string和number类型</span></span><br><span class="line"></span><br><span class="line">title string </span><br><span class="line"><span class="comment">//在图标下面显示的标题文字。如果定义了systemIcon属性，这个属性会被忽略。</span></span><br><span class="line"></span><br><span class="line">icon Image.propTypes.source </span><br><span class="line"><span class="comment">//给当前标签指定一个自定义的图标。如果定义了systemIcon属性， 这个属性会被忽略。</span></span><br><span class="line"></span><br><span class="line">selectedIcon Image.propTypes.source </span><br><span class="line"><span class="comment">//当标签被选中的时候显示的自定义图标。如果定义了systemIcon属性，这个属性会被忽略。如果定义了icon而没定义这个属性，在选中的时候图标会染上蓝色。</span></span><br><span class="line"></span><br><span class="line">onPress function </span><br><span class="line"><span class="comment">//当此标签被选中时调用。你应该修改组件的状态来使得selected属性为true</span></span><br><span class="line"></span><br><span class="line">selected <span class="type">bool</span> </span><br><span class="line"><span class="comment">//这个属性决定了子视图是否可见。如果你看到一个空白的页面，很可能是没有选中任何一个标签</span></span><br><span class="line"></span><br><span class="line">systemIcon <span class="keyword">enum</span>(<span class="string">&#x27;bookmarks&#x27;</span>, <span class="string">&#x27;contacts&#x27;</span>, <span class="string">&#x27;downloads&#x27;</span>, <span class="string">&#x27;favorites&#x27;</span>, <span class="string">&#x27;featured&#x27;</span>, <span class="string">&#x27;history&#x27;</span>, <span class="string">&#x27;more&#x27;</span>, <span class="string">&#x27;most-recent&#x27;</span>, <span class="string">&#x27;most-viewed&#x27;</span>, <span class="string">&#x27;recents&#x27;</span>, <span class="string">&#x27;search&#x27;</span>, <span class="string">&#x27;top-rated&#x27;</span>) </span><br><span class="line"><span class="comment">//一些预定义的系统图标。注意如果你使用了此属性，标题和自定义图标都会被覆盖为系统定义的值。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>只要设置对应的tabBarItem的selected为true,就会自动跳转到对应界面<ul>
<li>注意：tabBarItem的selected属性不能写死，可以搞个角标记录当前选中那个角标</li>
</ul>
</li>
<li>监听tabBarItem的点击，修改selected属性</li>
<li>相关示例代码</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> App extends Component&lt;&#123;&#125;&gt; &#123;</span><br><span class="line">    constructor(props)&#123;</span><br><span class="line">        <span class="variable language_">super</span>(props)</span><br><span class="line">        <span class="variable language_">this</span>.state = &#123;</span><br><span class="line">            selectedIndex:<span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当一个组件要显示的时候,就会自动调用render,渲染组件</span></span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;TabBarIOS tintColor=<span class="string">&#x27;#ed7f30&#x27;</span>&gt;</span><br><span class="line">                &lt;TabBarIOS.Item title=<span class="string">&#x27;首页&#x27;</span></span><br><span class="line">                         icon=&#123;&#123;uri:<span class="string">&#x27;btn_home_normal&#x27;</span>&#125;&#125;</span><br><span class="line">                                selectedIcon=&#123;&#123;uri:<span class="string">&#x27;btn_home_selected&#x27;</span>&#125;&#125;</span><br><span class="line">                                badge=<span class="string">&#x27;我&#x27;</span></span><br><span class="line">                                onPress=&#123;()=&gt;&#123;</span><br><span class="line">                                    <span class="variable language_">this</span>.setState(&#123;</span><br><span class="line">                                        selectedIndex:<span class="number">0</span></span><br><span class="line">                                    &#125;)</span><br><span class="line">                                &#125;&#125;</span><br><span class="line">                                selected=&#123;<span class="variable language_">this</span>.state.selectedIndex == <span class="number">0</span>&#125;</span><br><span class="line">                &gt;</span><br><span class="line">                    &lt;View style=&#123;&#123;backgroundColor:<span class="string">&#x27;red&#x27;</span>, flex:<span class="number">1</span>&#125;&#125;/&gt;</span><br><span class="line">                &lt;/TabBarIOS.Item&gt;</span><br><span class="line"></span><br><span class="line">                &lt;TabBarIOS.Item title=<span class="string">&#x27;直播&#x27;</span></span><br><span class="line">                                icon=&#123;&#123;uri:<span class="string">&#x27;btn_column_normal&#x27;</span>&#125;&#125;</span><br><span class="line">                                selectedIcon=&#123;&#123;uri:<span class="string">&#x27;btn_column_selected&#x27;</span>&#125;&#125;</span><br><span class="line">                                badge=&#123;<span class="number">12</span>&#125;</span><br><span class="line">                                onPress=&#123;()=&gt;&#123;</span><br><span class="line">                                    <span class="variable language_">this</span>.setState(&#123;</span><br><span class="line">                                        selectedIndex:<span class="number">1</span></span><br><span class="line">                                    &#125;)</span><br><span class="line">                                &#125;&#125;</span><br><span class="line">                                selected=&#123;<span class="variable language_">this</span>.state.selectedIndex == <span class="number">1</span>&#125;</span><br><span class="line">                &gt;</span><br><span class="line">                    &lt;View style=&#123;&#123;backgroundColor:<span class="string">&#x27;yellow&#x27;</span>, flex:<span class="number">1</span>&#125;&#125;/&gt;</span><br><span class="line">                &lt;/TabBarIOS.Item&gt;</span><br><span class="line">            &lt;/TabBarIOS&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="TabNavigator"><a href="#TabNavigator" class="headerlink" title="TabNavigator"></a>TabNavigator</h2><ul>
<li>TabBarIOS只能用于iOS平台，如果在安卓上也需要有TabBar,就不能使用TabBarIOS。</li>
<li>TabNavigator:一个跨平台的TabBar第三方框架组件，可以用于iOS和安卓平台</li>
<li><a href="https://github.com/expo/react-native-tab-navigator">TabNavigator地址</a></li>
</ul>
<h3 id="安装和导入"><a href="#安装和导入" class="headerlink" title="安装和导入"></a>安装和导入</h3><h4 id="安装第三方框架"><a href="#安装第三方框架" class="headerlink" title="安装第三方框架"></a>安装第三方框架</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">yarn add react-native-tab-navigator</span><br></pre></td></tr></table></figure>
<h4 id="导入框架"><a href="#导入框架" class="headerlink" title="导入框架"></a>导入框架</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">import TabNavigator from <span class="string">&#x27;react-native-tab-navigator&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="TabNavigator常用属性"><a href="#TabNavigator常用属性" class="headerlink" title="TabNavigator常用属性"></a>TabNavigator常用属性</h3><table>
<thead>
<tr>
<th>属性</th>
<th>默认值</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>sceneStyle</td>
<td>inherited</td>
<td>object (style)</td>
<td>定义渲染的场景</td>
</tr>
<tr>
<td>tabBarStyle</td>
<td>inherited</td>
<td>object (style)</td>
<td>为TabBar定义样式</td>
</tr>
<tr>
<td>tabBarShadowStyle</td>
<td>inherited</td>
<td>object (style)</td>
<td>为TabBar定义阴影样式</td>
</tr>
<tr>
<td>hidesTabTouch</td>
<td>false</td>
<td>boolean</td>
<td>禁用选项卡的onPress</td>
</tr>
</tbody></table>
<h3 id="TabNavigator-Item常用属性"><a href="#TabNavigator-Item常用属性" class="headerlink" title="TabNavigator.Item常用属性"></a>TabNavigator.Item常用属性</h3><table>
<thead>
<tr>
<th>属性</th>
<th>默认值</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>renderIcon</td>
<td>none</td>
<td>function</td>
<td>选项卡图标</td>
</tr>
<tr>
<td>renderSelectedIcon</td>
<td>none</td>
<td>function</td>
<td>选项卡选中状态图标</td>
</tr>
<tr>
<td>badgeText</td>
<td>none</td>
<td>string or number</td>
<td>图标右上角显示</td>
</tr>
<tr>
<td>title</td>
<td>none</td>
<td>string</td>
<td>tabbar标题</td>
</tr>
<tr>
<td>titleStyle</td>
<td>inherited</td>
<td>style</td>
<td>标题样式</td>
</tr>
<tr>
<td>selectedTitleStyle</td>
<td>inherited</td>
<td>style</td>
<td>选中状态标题样式</td>
</tr>
<tr>
<td>tabStyle</td>
<td>inherited</td>
<td>style</td>
<td>选项卡样式</td>
</tr>
<tr>
<td>hidesTabTouch</td>
<td>false</td>
<td>boolean</td>
<td>是否选中该tabbar</td>
</tr>
<tr>
<td>onPress</td>
<td>none</td>
<td>function</td>
<td>选项卡的点击方法</td>
</tr>
<tr>
<td>allowFontScaling</td>
<td>false</td>
<td>boolean</td>
<td>允许标题的字体缩放</td>
</tr>
</tbody></table>
<ul>
<li>使用示例</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;TabNavigator&gt;</span><br><span class="line">                &lt;TabNavigator.Item title=<span class="string">&#x27;首页&#x27;</span></span><br><span class="line">                                   selected=&#123;<span class="variable language_">this</span>.state.selectedIndex == <span class="number">0</span>&#125;</span><br><span class="line">                                   titleStyle=&#123;&#123;color:<span class="string">&#x27;#9d9d9d&#x27;</span>&#125;&#125;</span><br><span class="line">                                   selectedTitleStyle=&#123;&#123;color:<span class="string">&#x27;#ed7f30&#x27;</span>&#125;&#125;</span><br><span class="line">                                   badgeText=<span class="string">&#x27;首页&#x27;</span></span><br><span class="line">                                   allowFontScaling=&#123;<span class="literal">false</span>&#125;</span><br><span class="line">                                   renderIcon=&#123;()=&gt;</span><br><span class="line">                                       &lt;Image source=&#123;&#123;uri:<span class="string">&#x27;btn_home_normal&#x27;</span>&#125;&#125; style=&#123;styles.iconStyle&#125;/&gt;</span><br><span class="line">                                   &#125;</span><br><span class="line">                                   renderSelectedIcon=&#123;()=&gt;</span><br><span class="line">                                       &lt;Image source=&#123;&#123;uri:<span class="string">&#x27;btn_home_selected&#x27;</span>&#125;&#125; style=&#123;styles.iconStyle&#125;/&gt;</span><br><span class="line">                                   &#125;</span><br><span class="line">                                   onPress=&#123;()=&gt;</span><br><span class="line">                                       <span class="variable language_">this</span>.setState(&#123;</span><br><span class="line">                                           selectedIndex:<span class="number">0</span></span><br><span class="line">                                       &#125;)</span><br><span class="line">                                   &#125;</span><br><span class="line">                &gt;</span><br><span class="line">                    &lt;View style=&#123;[styles.viewStyle, &#123;backgroundColor:<span class="string">&#x27;red&#x27;</span>&#125;]&#125;&gt;</span><br><span class="line">                        &lt;Text&gt;首页&lt;/Text&gt;</span><br><span class="line">                    &lt;/View&gt;</span><br><span class="line">                &lt;/TabNavigator.Item&gt;</span><br><span class="line"></span><br><span class="line">                &lt;TabNavigator.Item title=<span class="string">&#x27;我的&#x27;</span></span><br><span class="line">                                   selected=&#123;<span class="variable language_">this</span>.state.selectedIndex == <span class="number">1</span>&#125;</span><br><span class="line">                                   titleStyle=&#123;&#123;color:<span class="string">&#x27;#9d9d9d&#x27;</span>&#125;&#125;</span><br><span class="line">                                   selectedTitleStyle=&#123;&#123;color:<span class="string">&#x27;#ed7f30&#x27;</span>&#125;&#125;</span><br><span class="line">                                   badgeText=&#123;<span class="number">10</span>&#125;</span><br><span class="line">                                   renderIcon=&#123;()=&gt;</span><br><span class="line">                                       &lt;Image source=&#123;&#123;uri:<span class="string">&#x27;btn_user_normal&#x27;</span>&#125;&#125; style=&#123;styles.iconStyle&#125;/&gt;</span><br><span class="line">                                   &#125;</span><br><span class="line">                                   renderSelectedIcon=&#123;()=&gt;</span><br><span class="line">                                       &lt;Image source=&#123;&#123;uri:<span class="string">&#x27;btn_user_selected&#x27;</span>&#125;&#125; style=&#123;styles.iconStyle&#125;/&gt;</span><br><span class="line">                                   &#125;</span><br><span class="line">                                   onPress=&#123;()=&gt;</span><br><span class="line">                                       <span class="variable language_">this</span>.setState(&#123;</span><br><span class="line">                                           selectedIndex:<span class="number">1</span></span><br><span class="line">                                       &#125;)</span><br><span class="line">                                   &#125;</span><br><span class="line">                &gt;</span><br><span class="line">                    &lt;View style=&#123;[styles.viewStyle, &#123;backgroundColor:<span class="string">&#x27;green&#x27;</span>&#125;]&#125;&gt;</span><br><span class="line">                        &lt;Text&gt;我的&lt;/Text&gt;</span><br><span class="line">                    &lt;/View&gt;</span><br><span class="line"></span><br><span class="line">                &lt;/TabNavigator.Item&gt;</span><br><span class="line">            &lt;/TabNavigator&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ReactNaive</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>ReactNative之iOS原生和JavaScript的交互</title>
    <url>/post/4c196968.html</url>
    <content><![CDATA[<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/ReactNative/rn-js-ios.png?x-oss-process=style/titanjun" alt="js-ios"></p>
<span id="more"></span>


<p>在<code>ReactNative</code>开发中, 在<code>JavaScript</code>语法无法实现的时候会涉及到一些原生开发, 既然是混合开发就会涉及到一些<code>iOS</code>和<code>ReactNative</code>之间通讯的问题, 这里就涉及到两种方式:</p>
<ul>
<li><code>RN</code>调用原生的方法, 给原生发送数据</li>
<li>原生给<code>RN</code>回传数据, 或者给<code>RN</code>发送通知</li>
<li>下面就简单记录下这两种方式的实现</li>
</ul>
<h2 id="JS调用原生"><a href="#JS调用原生" class="headerlink" title="JS调用原生"></a>JS调用原生</h2><ul>
<li>这里要讲的交互场景是<code>JS</code>调用原生方法，最后由原生方法将结果回调到JS里面</li>
<li><code>react-native</code>是在原生的基础上，将接口调用统一为<code>js</code></li>
<li>也就是说，<code>react-native</code>调起原生的能力非常重要</li>
</ul>
<h3 id="js调用模块"><a href="#js调用模块" class="headerlink" title="js调用模块"></a>js调用模块</h3><p>在原生需要创建一个继承自<code>NSObject</code>的类(模块)</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="comment">// 需要导入头文件</span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;React/RCTBridgeModule.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 必须遵循RCTBridgeModule协议</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AppEventMoudle</span> : <span class="title">NSObject</span> &lt;<span class="title">RCTBridgeModule</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>在<code>AppEventMoudle.m</code>文件件中需要导出改模块, 并将创建的方法导出</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;AppEventMoudle.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;React/RCTBridge.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AppEventMoudle</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出桥接模块, 参数传空或者当前class的类名</span></span><br><span class="line"><span class="comment">// 参数若为空, 默认模块名为当前class类名即AppEventMoudle</span></span><br><span class="line">RCT_EXPORT_MODULE(AppEventMoudle);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带有参数</span></span><br><span class="line">RCT_EXPORT_METHOD(OpenView:(<span class="built_in">NSDictionary</span> *)params)&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 因为是显示页面，所以让原生接口运行在主线程</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 在这里可以写需要原生处理的UI或者逻辑</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;params = %@&quot;</span>, params);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 带有回调</span></span><br><span class="line">RCT_EXPORT_METHOD(OpenView:(<span class="built_in">NSDictionary</span> *)params, callback:(RCTResponseSenderBlock)callback)&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 因为是显示页面，所以让原生接口运行在主线程</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 在这里可以写需要原生处理的UI或者逻辑</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;params = %@&quot;</span>, params);</span><br><span class="line">        <span class="keyword">if</span> (callback) &#123;</span><br><span class="line">            callback(@[params]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<div class="note warning"><p>上面代码需要注意的是</p></div>

<ul>
<li>桥接到<code>Javascript</code>的方法返回值类型必须是<code>void</code></li>
<li><code>React Native</code>的桥接操作是异步的，在<code>queue</code>里面异步执行，所以如果要返回结果给<code>Javascript</code>，就必须通过回调或者触发事件来进行</li>
<li>这里的回调对应于<code>iOS</code>端就是通过<code>block</code>来回调的</li>
</ul>
<h3 id="RCTBridge"><a href="#RCTBridge" class="headerlink" title="RCTBridge"></a>RCTBridge</h3><ul>
<li><code>RCTBridge</code>可以说是一个封装类,封装了<code>RCTCxxBridge</code></li>
<li>我们先看这个文件提供的一些变量和方法</li>
<li><code>RCTModuleClasses</code>: 主要储存的是我们注册的<code>module</code>, 所有用宏<code>RCT_EXPORT_MODULE()</code>注册的<code>module</code>都会存入这个变量.</li>
<li><code>RCTGetModuleClasses</code>: 获取<code>RCTModuleClasses</code>里面所有注册的<code>module</code>类</li>
<li><code>RCTBridgeModuleNameForClass</code>: 从一个类获取这个类的名字</li>
<li><code>RCTVerifyAllModulesExported</code>: 验证我们所写的所有遵守<code>RCTBridgeModule</code>协议的类是否都在我们的管理中</li>
</ul>
<h3 id="RCTResponseSenderBlock"><a href="#RCTResponseSenderBlock" class="headerlink" title="RCTResponseSenderBlock"></a>RCTResponseSenderBlock</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> (^RCTResponseSenderBlock)(<span class="built_in">NSArray</span> *response);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>RCTResponseSenderBlock</code>是<code>RCTBridgeModule</code>里面提供的<code>block</code></li>
<li>这个<code>block</code>接受一个数组参数, 代表原生方法的返回结果</li>
</ul>
<h3 id="线程问题"><a href="#线程问题" class="headerlink" title="线程问题"></a>线程问题</h3><ul>
<li>js代码的执行是在js线程里面，原生模块的执行默认是在一个串行的<code>queue</code>里面异步执行的</li>
<li>对于原生模块的执行来说，默认一个串行的<code>queue</code>是不够的，我们有时候需要指定模块所有任务执行所在的<code>queue</code></li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">RCT_EXPORT_METHOD(OpenView:(<span class="built_in">NSDictionary</span> *)params)&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 因为是显示页面，所以让原生接口运行在主线程</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 在这里可以写需要原生处理的UI或者逻辑</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;params = %@&quot;</span>, params);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="原生向RN发送监听"><a href="#原生向RN发送监听" class="headerlink" title="原生向RN发送监听"></a>原生向RN发送监听</h2><ul>
<li>例如: 项目中的<code>H5</code>页面, 通过原生的<code>Webview</code>实现, 并且监听<code>url</code>的变化, 并通知<code>js</code>做相关操作</li>
<li>这样我们就要在<code>url</code>变化的时候, 给<code>JavaScript</code>发送监听通知</li>
<li>并且不能使用<code>RCTResponseSenderBlock</code>进行回调, <code>block</code>回调只能执行一次, 并不能不断的执行</li>
</ul>
<h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><ul>
<li>我们需要创建一个<code>WebViewController</code>的控制器, 在该控制器内添加<code>UIWebView</code>的UI和逻辑的实现</li>
<li>在<code>UIWebViewDelegate</code>的协议方法中监听<code>webview</code>的<code>url</code>的变化, 并发送通知</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)webView:(<span class="built_in">UIWebView</span> *)webView shouldStartLoadWithRequest:(<span class="built_in">NSURLRequest</span> *)request navigationType:(<span class="built_in">UIWebViewNavigationType</span>)navigationType &#123;</span><br><span class="line">  <span class="built_in">NSString</span> *url= request.URL.absoluteString;</span><br><span class="line">  <span class="keyword">if</span> (url &amp;&amp; ![url isEqualToString:<span class="string">@&quot;&quot;</span>]) &#123;</span><br><span class="line">    <span class="comment">// 发送通知</span></span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:<span class="string">@&quot;urlChange&quot;</span> object:url];</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="keyword">self</span> clickAction:url];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>需要在<code>js</code>调用的方法中接受上述代码中发送的通知, 如下</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">RCT_EXPORT_METHOD(OpenWebView:(<span class="built_in">NSDictionary</span> *)params)&#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="comment">// 接受通知监听</span></span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(urlChange:) name:<span class="string">@&quot;urlChange&quot;</span> object:<span class="literal">nil</span>];</span><br><span class="line">        </span><br><span class="line">        WebViewController *webView = [WebViewController new];</span><br><span class="line">        webView.params = params;</span><br><span class="line">        <span class="built_in">UINavigationController</span> *navi = [[<span class="built_in">UINavigationController</span> alloc] initWithRootViewController:webView];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">UIViewController</span> *rootVC = [<span class="built_in">UIApplication</span> sharedApplication].keyWindow.rootViewController;</span><br><span class="line">        [rootVC presentViewController:navi animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h3><p>实现监听方法, 并给<code>JavaScript</code>发送消息通知</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)urlChange:(<span class="built_in">NSNotification</span> *)notification&#123;</span><br><span class="line">  [<span class="keyword">self</span>.bridge.eventDispatcher sendAppEventWithName:<span class="string">@&quot;NativeWebView&quot;</span></span><br><span class="line">                                               body:@&#123;<span class="string">@&quot;url&quot;</span>:(<span class="built_in">NSString</span> *)notification.object&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要获取<code>self.bridge</code>属性, 需要遵循<code>RCTBridgeModule</code>协议, 并加上如下代码</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@synthesize</span> bridge = _bridge;</span><br></pre></td></tr></table></figure>

<p>最后不要忘记移除该通知</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">  [[<span class="built_in">NSNotificationCenter</span> defaultCenter] removeObserver:<span class="keyword">self</span> name:<span class="string">@&quot;urlChange&quot;</span> object:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h3><p>在<code>JavaScript</code>中接受<code>iOS</code>原生发送的消息通知</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">webViewListener</span> = <span class="title class_">NativeAppEventEmitter</span>.<span class="title function_">addListener</span>(<span class="string">&#x27;NativeWebView&#x27;</span>, <span class="function"><span class="params">message</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="title function_">handleMessageFromNative</span>(message)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 并在对应的位置销毁即可</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">webViewListener</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">webViewListener</span>.<span class="title function_">remove</span>()</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">webViewListener</span> = <span class="literal">null</span></span><br></pre></td></tr></table></figure>


<h2 id="原生给js发送事件"><a href="#原生给js发送事件" class="headerlink" title="原生给js发送事件"></a>原生给js发送事件</h2><ul>
<li>上面提到的那种方式都是<code>js</code>调用<code>iOS</code>原生代码后, 用<code>iOS</code>原生在给<code>js</code>发送事件监听</li>
<li>那么如果需要<code>iOS</code>原生主动给<code>js</code>发送监听事件呢, 类似场景: 比如在<code>AppDelegate</code>中给<code>js</code>发送事件通知有改如何实现</li>
<li>之前遇到过这样一个需求: 需要监听<code>APP</code>进入后台和<code>APP</code>从后台进入前台的事件, 并在<code>JavaScript</code>中做相关操作</li>
<li>不能像之前那种, 定义一个<code>_bridge</code>, 并遵循<code>RCTBridgeModule</code>协议, 就可以使用下面代码发送监听事件了, 加断点可以发现, 下面获取的<code>self.bridge</code>为<code>nil</code></li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">-(<span class="type">void</span>)applicationDidEnterBackground:(<span class="built_in">UIApplication</span> *)application &#123;</span><br><span class="line">    <span class="comment">// 这里的self.bridge为nil</span></span><br><span class="line">  [<span class="keyword">self</span>.bridge.eventDispatcher sendAppEventWithName:<span class="string">@&quot;NativeWebView&quot;</span></span><br><span class="line">                                               body:@&#123;<span class="string">@&quot;url&quot;</span>:(<span class="built_in">NSString</span> *)notification.object&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>下面先介绍一个消息监听的实例类</p>
<h3 id="RCTEventEmitter"><a href="#RCTEventEmitter" class="headerlink" title="RCTEventEmitter"></a>RCTEventEmitter</h3><p><code>RCTEventEmitter</code>是一个基类, 用于发出<code>JavaScript</code>需要监听的事件, 提供了一下属性和方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RCTEventEmitter</span> : <span class="title">NSObject</span> &lt;<span class="title">RCTBridgeModule</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) RCTBridge *bridge;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回你将要发送的消息的name, 如果有未添加的, 运行时将会报错</span></span><br><span class="line">- (<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)supportedEvents;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于发送消息事件</span></span><br><span class="line">- (<span class="type">void</span>)sendEventWithName:(<span class="built_in">NSString</span> *)name body:(<span class="type">id</span>)body;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在子类中重写此方法, 用于发送/移除消息通知</span></span><br><span class="line">- (<span class="type">void</span>)startObserving;</span><br><span class="line">- (<span class="type">void</span>)stopObserving;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加监听和移除监听</span></span><br><span class="line">- (<span class="type">void</span>)addListener:(<span class="built_in">NSString</span> *)eventName;</span><br><span class="line">- (<span class="type">void</span>)removeListeners:(<span class="type">double</span>)count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>具体的使用示例, 可继续向下看</p>
<h3 id="第一步-1"><a href="#第一步-1" class="headerlink" title="第一步"></a>第一步</h3><p>创建一个继承自<code>RCTEventEmitter</code>的类, 并遵循协议<code>&lt;RCTBridgeModule&gt;</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;React/RCTBridgeModule.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_BEGIN</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AppEventManager</span> : <span class="title">RCTEventEmitter</span> &lt;<span class="title">RCTBridgeModule</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_END</span></span><br></pre></td></tr></table></figure>


<h3 id="第二步-1"><a href="#第二步-1" class="headerlink" title="第二步"></a>第二步</h3><p>再具体的<code>iOS</code>原生代码中发送消息通知</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;AppEventManager.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AppEventManager</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出该模块</span></span><br><span class="line">RCT_EXPORT_MODULE();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回sendEventWithName中监听的name, 如果有监听, 但是为在该方法中添加的, 运行时会报错</span></span><br><span class="line">- (<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)supportedEvents &#123;</span><br><span class="line">    <span class="keyword">return</span> @[<span class="string">@&quot;DidEnterBackground&quot;</span>, <span class="string">@&quot;DidBecomeActive&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加观察者事件, 重写该方法中, 并在该方法中接受消息通知</span></span><br><span class="line">- (<span class="type">void</span>)startObserving &#123;</span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(applicationDidEnterBackground:) name:<span class="string">@&quot;DidEnterBackground&quot;</span> object:<span class="literal">nil</span>];</span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(applicationDidBecomeActive:) name:<span class="string">@&quot;DidBecomeActive&quot;</span> object:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除观察者</span></span><br><span class="line">- (<span class="type">void</span>)stopObserving &#123;</span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] removeObserver:<span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)applicationDidEnterBackground:(<span class="built_in">NSNotification</span> *)notification&#123;</span><br><span class="line">    <span class="comment">// 在此处向JavaScript发送监听事件</span></span><br><span class="line">    [<span class="keyword">self</span> sendEventWithName:<span class="string">@&quot;DidEnterBackground&quot;</span> body: notification.object];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)applicationDidBecomeActive:(<span class="built_in">NSNotification</span> *)notification&#123;</span><br><span class="line">    <span class="comment">// 在此处向JavaScript发送监听事件</span></span><br><span class="line">    [<span class="keyword">self</span> sendEventWithName:<span class="string">@&quot;DidBecomeActive&quot;</span> body: notification.object];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note warning"><p>注意的是</p></div>

<ul>
<li>一旦<code>RCT_EXPORT_MODULE()</code>声明该类是<code>EXPORT_MODULE</code>, 那么该类的实例已经创建好了</li>
<li>如果你在其他地方创建这个类的实例(<code>alloc</code> 或 <code>new</code>), 会导致,<code>ReactNative</code>不能正确识别该类的实例</li>
</ul>
<h3 id="第三步-1"><a href="#第三步-1" class="headerlink" title="第三步"></a>第三步</h3><p>在<code>ReactNative</code>中引用该模块, 并添加对对应事件的监听即可</p>
<p>先导出<code>iOS</code>原生定义的模块</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AppEventManager为原生中创建的类名</span></span><br><span class="line"><span class="keyword">const</span> appEventMan = <span class="keyword">new</span> <span class="title class_">NativeEventEmitter</span>(<span class="title class_">NativeModules</span>.<span class="property">AppEventManager</span>)</span><br></pre></td></tr></table></figure>

<p>使用<code>appEventMan</code>在对应的地方添加监听即可</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">didEnterBackground</span> = appEventMan.<span class="title function_">addListener</span>(<span class="string">&#x27;DidEnterBackground&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`APP开始进入后台---------------`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">didBecomeActive</span> = appEventMan.<span class="title function_">addListener</span>(<span class="string">&#x27;DidBecomeActive&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`APP开始从后台进入前台----------`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>但是也不要忘记在对应的地方移除该监听</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">componentWillUnmount () &#123;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">didEnterBackground</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">didEnterBackground</span>.<span class="title function_">remove</span>()</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">didEnterBackground</span> = <span class="literal">null</span></span><br><span class="line">	</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">didBecomeActive</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">didBecomeActive</span>.<span class="title function_">remove</span>()</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">didBecomeActive</span> = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success"><p>O(∩_∩)O哈哈~</p></div>

<p>至此, 在<code>ReactNative</code>中<code>JavaScript</code>和<code>iOS</code>原生的交互基本就结束了, O(∩_∩)O哈哈~</p>
<hr>
]]></content>
      <categories>
        <category>ReactNaive</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>JavaScript</tag>
        <tag>ReactNative</tag>
      </tags>
  </entry>
  <entry>
    <title>ReactNative之基本组件</title>
    <url>/post/de78254.html</url>
    <content><![CDATA[<ul>
<li>本文主要总结的是ReactNative的一些简单语法, 大部分内容总结自<a href="http://www.jianshu.com/u/b09c3959ab3b">袁大神</a>的文章</li>
<li>这里主要简单介绍以下几个控件:</li>
<li><code>View</code> 和 <code>Text</code></li>
<li><code>Button</code> 和 <code>Image</code></li>
<li><code>TextInput</code></li>
</ul>
<span id="more"></span>


<h2 id="View"><a href="#View" class="headerlink" title="View"></a>View</h2><ul>
<li>RN中的View组件类似于iOS中的UIView<ul>
<li>一般常用于容器，往里面添加子控件,任何子组件都可以，View里面也可以在放View.</li>
<li>可设置样式: 背景颜色, 宽高等属性</li>
<li>没有点击事件，不能监听点击</li>
<li>如需要添加监听事件, 这里需要用到<code>TouchableOpacity</code>组件</li>
</ul>
</li>
</ul>
<h2 id="TouchableOpacity"><a href="#TouchableOpacity" class="headerlink" title="TouchableOpacity"></a><code>TouchableOpacity</code></h2><ul>
<li><code>TouchableOpacity</code>点击控件<ul>
<li>如果想让一个没有点击事件的组件，能点击，就需要在外层包装一个<code>TouchableOpacity</code>，这个View,就能点击了。</li>
<li>注意：<code>TouchableOpacity</code>默认点击区域，就是所有子控件的区域,因为默认一个组件的尺寸由子控件绝对，因此<code>TouchableOpacity</code>也是一样</li>
</ul>
</li>
</ul>
<h3 id="activeOpacity属性"><a href="#activeOpacity属性" class="headerlink" title="activeOpacity属性"></a><code>activeOpacity</code>属性</h3><ul>
<li><code>activeOpacity</code>: 不透明度<ul>
<li>一个View,被<code>TouchableOpacity</code>包装后，点击这个<code>View</code>,就会有透明效果，这个效果可以通过<code>activeOpacity</code>属性调整</li>
<li>取值: 0~1，1表示不透明，点击就没透明效果了。</li>
</ul>
</li>
<li>使用示例:</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">&lt;TouchableOpacity activeOpacity=&#123;<span class="number">0.7</span>&#125;&gt;</span><br><span class="line">    &lt;View style=&#123;styles.junViewStyle&#125;&gt;</span><br><span class="line">    &lt;/View&gt;</span><br><span class="line">&lt;/TouchableOpacity&gt;</span><br></pre></td></tr></table></figure>

<h3 id="disabled属性"><a href="#disabled属性" class="headerlink" title="disabled属性"></a>disabled属性</h3><ul>
<li>如果设为true，则禁止此组件的一切交互</li>
<li>通过disabled，可以控制一个被<code>TouchableOpacity</code>包装的组件什么时候能点击。</li>
</ul>
<h3 id="监听的几种手势"><a href="#监听的几种手势" class="headerlink" title="监听的几种手势"></a>监听的几种手势</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">onLongPress function ：长按的时候调用</span><br><span class="line"></span><br><span class="line">onPress function ：点击的时候调用</span><br><span class="line"></span><br><span class="line">onPressIn function ：手指按下的时候调用</span><br><span class="line"></span><br><span class="line">onPressOut function ：手指抬起的时候调用</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意的是: <code>onPress</code>与<code>onPressIn</code>，<code>onPressOut</code>，有冲突，不要同时实现</p>
</blockquote>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">&lt;TouchableOpacity activeOpacity=&#123;<span class="number">0.7</span>&#125;</span><br><span class="line">                   onPress=&#123;()=&gt;&#123;</span><br><span class="line">                       alert(<span class="string">&#x27;点击&#x27;</span>)</span><br><span class="line">                   &#125;&#125;</span><br><span class="line">                   onLongPress=&#123;()=&gt;&#123;</span><br><span class="line">                       alert(<span class="string">&#x27;长按&#x27;</span>)</span><br><span class="line">                   &#125;&#125;</span><br><span class="line"> &gt;</span><br><span class="line">     &lt;View style=&#123;styles.junViewStyle&#125;&gt;</span><br><span class="line">     &lt;/View&gt;</span><br><span class="line"></span><br><span class="line"> &lt;/TouchableOpacity&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="Text"><a href="#Text" class="headerlink" title="Text"></a>Text</h2><p>Text: 用于展示一段文字</p>
<h3 id="属性介绍"><a href="#属性介绍" class="headerlink" title="属性介绍"></a>属性介绍</h3><ul>
<li><code>adjustsFontSizeToFit</code>: 指定字体是否随着给定样式的限制而自动缩放(默认false), 为true时: 会自动改变字体大小</li>
<li><code>allowFontScaling</code>: 控制字体是否要根据系统的“字体大小”辅助选项来进行缩放。</li>
<li><code>minimumFontScale</code>: 当adjustsFontSizeToFit开启时，指定最小的缩放比（即不能低于这个值）。可设定的值为0.01 - 1.0</li>
<li><code>numberOfLines</code>:最大行数，超出最大行数，就不会完全显示，超出部分显示…</li>
<li><code>selectable</code>:决定用户是否可以长按选择文本，以便复制和粘贴,默认false</li>
<li><code>suppressHighlighting</code>: 默认情况下，文本被按下时会有一个灰色的阴影，如果想取消就设置为true</li>
<li><code>onPress</code>: 监听文本点击的操作</li>
<li><code>onLongPress</code>: 当文本被长按以后调用此回调函数</li>
</ul>
<h3 id="常用样式属性"><a href="#常用样式属性" class="headerlink" title="常用样式属性"></a>常用样式属性</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">color: <span class="string">&#x27;yellow&#x27;</span> <span class="comment">//字体颜色</span></span><br><span class="line">fontSize: <span class="number">20</span>,  <span class="comment">//字体大小</span></span><br><span class="line">fontStyle: <span class="string">&#x27;italic&#x27;</span> <span class="comment">//字体样式(&#x27;normal&#x27;: 正常字体, &#x27;italic&#x27;: 斜体)</span></span><br><span class="line"></span><br><span class="line">fontWeight:<span class="string">&#x27;bold&#x27;</span>, <span class="comment">//指定字体的粗细</span></span><br><span class="line"><span class="comment">//大多数字体都支持&#x27;normal&#x27;和&#x27;bold&#x27;值。并非所有字体都支持所有的数字值。如果某个值不支持，则会自动选择最接近的值</span></span><br><span class="line"><span class="comment">//enum(&#x27;normal&#x27;, &#x27;bold&#x27;, &#x27;100&#x27;, &#x27;200&#x27;, &#x27;300&#x27;, &#x27;400&#x27;, &#x27;500&#x27;, &#x27;600&#x27;, &#x27;700&#x27;, &#x27;800&#x27;, &#x27;900&#x27;)</span></span><br><span class="line"></span><br><span class="line">lineHeight:<span class="number">50</span>, <span class="comment">//字体的高度(如字体需要垂直居中, 可设置与控件的高度相同即可)</span></span><br><span class="line">textAlign:<span class="string">&#x27;center&#x27;</span> <span class="comment">//文字排列方式(&#x27;auto&#x27;, &#x27;left&#x27;, &#x27;right&#x27;, &#x27;center&#x27;, &#x27;justify&#x27;(iOS支持))</span></span><br></pre></td></tr></table></figure>

<p>示例使用</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">&lt;View style=&#123;styles.mainStyle&#125;&gt;</span><br><span class="line">    &lt;Text style=&#123;styles.textStyle&#125;</span><br><span class="line">          numberOfLines=&#123;<span class="number">1</span>&#125;</span><br><span class="line">          selectable=&#123;<span class="literal">true</span>&#125;</span><br><span class="line">          adjustsFontSizeToFit=&#123;<span class="literal">true</span>&#125;</span><br><span class="line">          minimumFontScale=&#123;<span class="number">0.5</span>&#125;</span><br><span class="line">    &gt;</span><br><span class="line">        我是iOS开发工程师</span><br><span class="line">    &lt;/Text&gt;</span><br><span class="line">&lt;/View&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Button"><a href="#Button" class="headerlink" title="Button"></a>Button</h2><ul>
<li>Button:按钮,当一个文字想要点击效果，可以使用按钮</li>
<li>注意：Button没有样式，设置样式无效，最大的弊端，开发中一般不使用，一般自定义按钮，自己包装一个Text用于按钮.</li>
<li>常用属性</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">title=<span class="string">&#x27;Button&#x27;</span> <span class="comment">//按钮文字</span></span><br><span class="line">color=<span class="string">&quot;green&quot;</span>  <span class="comment">//按钮文字颜色</span></span><br><span class="line">onPress=&#123;()=&gt;&#123; <span class="comment">//点击事件</span></span><br><span class="line">    alert(<span class="string">&#x27;点击了Button&#x27;</span>)</span><br><span class="line">&#125;&#125;</span><br><span class="line">disabled=&#123;<span class="literal">true</span>&#125; <span class="comment">//是否允许点击, 为true时不可点击</span></span><br></pre></td></tr></table></figure>

<p>代码示例</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">&lt;View style=&#123;styles.mainStyle&#125;&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;Button</span><br><span class="line">        title=<span class="string">&#x27;Button&#x27;</span></span><br><span class="line">        color=<span class="string">&quot;green&quot;</span></span><br><span class="line">        onPress=&#123;()=&gt;&#123;</span><br><span class="line">            alert(<span class="string">&#x27;点击了Button&#x27;</span>)</span><br><span class="line">        &#125;&#125;</span><br><span class="line">        disabled=&#123;<span class="literal">true</span>&#125;</span><br><span class="line">    /&gt;</span><br><span class="line">&lt;/View&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="TextInput"><a href="#TextInput" class="headerlink" title="TextInput"></a>TextInput</h2><ul>
<li><code>TextInput</code>: 文本输入框, 支持样式设置</li>
<li><code>TextInput</code>默认没有边框，需要自己添加<code>borderWidth</code></li>
<li><code>TextInput</code>是一个允许用户在应用中通过键盘输入文本的基本组件。本组件的属性提供了多种特性的配置，譬如自动完成、自动大小写、占位文字，以及多种不同的键盘类型（如纯数字键盘）等等。</li>
</ul>
<h3 id="常用属性介绍"><a href="#常用属性介绍" class="headerlink" title="常用属性介绍"></a>常用属性介绍</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">placeholder=<span class="string">&#x27;请输入账号&#x27;</span> <span class="comment">//占位文字</span></span><br><span class="line">placeholderTextColor=<span class="string">&#x27;#e1e1e1&#x27;</span> <span class="comment">//占位字符串显示的文字颜色</span></span><br><span class="line"></span><br><span class="line">selectionColor=<span class="string">&#x27;green&#x27;</span> <span class="comment">//设置光标颜色</span></span><br><span class="line">caretHidden=&#123;<span class="literal">true</span>&#125;  <span class="comment">//如果为true，则隐藏光标。默认值为false</span></span><br><span class="line"></span><br><span class="line">autoFocus=&#123;<span class="literal">true</span>&#125;  <span class="comment">//自动获取焦点,如果为true，在componentDidMount后会获得焦点。默认值为false</span></span><br><span class="line"></span><br><span class="line">blurOnSubmit=&#123;<span class="literal">true</span>&#125;  <span class="comment">//点击键盘，右下角return,或者按回车的时候，是否自动退出键盘，true:是。注意：键盘必须是英文输入键盘，数字键盘无效.</span></span><br><span class="line"></span><br><span class="line">editable=&#123;<span class="literal">false</span>&#125;  <span class="comment">//文本框是否可以编辑，默认值为true，如果为false，文本框是不可编辑的</span></span><br><span class="line">secureTextEntry=&#123;<span class="literal">true</span>&#125;  <span class="comment">//是否是密文效果,注意：多行无效果</span></span><br><span class="line"></span><br><span class="line">secureTextEntry=&#123;<span class="literal">false</span>&#125;  <span class="comment">//是否是多行输入框，默认文本输入框只能一行，true,就能多行输入</span></span><br><span class="line">maxLength=&#123;<span class="number">15</span>&#125;  <span class="comment">//最大字符数，显示输入文本长度</span></span><br><span class="line"></span><br><span class="line">clearTextOnFocus=&#123;<span class="literal">true</span>&#125;  <span class="comment">//每次重新输入文本框，是否清空之前的文本</span></span><br><span class="line">enablesReturnKeyAutomatically=&#123;<span class="literal">true</span>&#125;  <span class="comment">//如果为true，键盘会在文本框内没有文字的时候禁用确认按钮。默认值为false</span></span><br><span class="line"></span><br><span class="line">autoCorrect=&#123;<span class="literal">true</span>&#125;  <span class="comment">//如果为false，会关闭拼写自动修正。默认值是true。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在安卓机上, 输入框下面默认会多出一个下划线, 可设置成透明色</span></span><br><span class="line">underlineColorAndroid=<span class="string">&quot;transparent&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>autoCapitalize</code>: 控制TextInput是否要自动将特定字符切换为大写</p>
</li>
<li><p>enum(‘none’, ‘sentences’, ‘words’, ‘characters’) </p>
<ul>
<li><code>characters</code>: 所有的字符。</li>
<li><code>words</code>: 每个单词的第一个字符。</li>
<li><code>sentences</code>: 每句话的第一个字符（默认）。</li>
<li><code>none</code>: 不自动切换任何字符为大写。</li>
</ul>
</li>
<li><p>键盘类型<code>keyboardType</code></p>
</li>
<li><p><code>keyboardType=&#39;number-pad&#39;</code></p>
<ul>
<li><code>default</code>: 默认键盘</li>
<li><code>numeric</code>: 带有小数点的数字键盘</li>
<li><code>email-address</code>: 有@符的字母键盘</li>
<li><code>ascii-capable</code>: 纯字母键盘</li>
<li><code>numbers-and-punctuation</code></li>
<li><code>url</code></li>
<li><code>number-pad</code></li>
<li><code>phone-pad</code></li>
<li><code>name-phone-pad</code></li>
<li><code>decimal-pad</code></li>
<li><code>twitter</code></li>
<li><code>web-search</code></li>
</ul>
</li>
<li><p>returnKeyType: 决定键盘右下角按钮显示的内容</p>
<ul>
<li><code> enum(&#39;done&#39;, &#39;go&#39;, &#39;next&#39;, &#39;search&#39;, &#39;send&#39;, &#39;none&#39;, &#39;previous&#39;, &#39;default&#39;, &#39;emergency-call&#39;, &#39;google&#39;, &#39;join&#39;, &#39;route&#39;, &#39;yahoo&#39;)</code></li>
</ul>
</li>
<li><p>clearButtonMode: 是否要在文本框右侧显示“清除”按钮</p>
<ul>
<li><code>never</code>: 不显示</li>
<li><code>while-editing</code>: 编辑的时候显示</li>
<li><code>always</code></li>
<li><code>unless-editing</code></li>
</ul>
</li>
</ul>
<h3 id="常用的监听事件"><a href="#常用的监听事件" class="headerlink" title="常用的监听事件"></a>常用的监听事件</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">onBlur function </span><br><span class="line"><span class="comment">//当文本框失去焦点的时候调用此回调函数。</span></span><br><span class="line"></span><br><span class="line">onChange function </span><br><span class="line"><span class="comment">//当文本框内容变化时调用此回调函数。</span></span><br><span class="line"></span><br><span class="line">onChangeText function </span><br><span class="line"><span class="comment">//当文本框内容变化时调用此回调函数。改变后的文字内容会作为参数传递。</span></span><br><span class="line"></span><br><span class="line">onEndEditing function </span><br><span class="line"><span class="comment">//当文本输入结束后调用此回调函数。</span></span><br><span class="line"></span><br><span class="line">onFocus function </span><br><span class="line"><span class="comment">//当文本框获得焦点的时候调用此回调函数。</span></span><br><span class="line"></span><br><span class="line">onLayout function </span><br><span class="line"><span class="comment">//当组件挂载或者布局变化的时候调用，参数为&#123;x, y, width, height&#125;。</span></span><br><span class="line"></span><br><span class="line">onScroll function </span><br><span class="line"><span class="comment">//在内容滚动时持续调用，传回参数的格式形如&#123; nativeEvent: &#123; contentOffset: &#123; x, y &#125; &#125; &#125;。 也可能包含其他和滚动事件相关的参数</span></span><br><span class="line"></span><br><span class="line">onSelectionChange function </span><br><span class="line"><span class="comment">//长按选择文本时，选择范围变化时调用此函数，传回参数的格式形如 &#123; nativeEvent: &#123; selection: &#123; start, end &#125; &#125; &#125;。</span></span><br><span class="line"></span><br><span class="line">onSubmitEditing function </span><br><span class="line"><span class="comment">//此回调函数当软键盘的确定/提交按钮被按下的时候调用此函数。如果multiline=&#123;true&#125;，此函数不可用。</span></span><br><span class="line"></span><br><span class="line">onKeyPress function </span><br><span class="line"><span class="comment">//当一个键被按下的时候调用此回调。传递给回调函数的参数为&#123; nativeEvent: &#123; key: keyValue &#125; &#125;，其中keyValue即为被按下的键。会在onChange之前调用。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">isFocused(): boolean </span><br><span class="line"><span class="comment">//返回值表明当前输入框是否获得了焦点。</span></span><br><span class="line"></span><br><span class="line">clear() </span><br><span class="line"><span class="comment">//清空输入框的内容。</span></span><br></pre></td></tr></table></figure>

<h2 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h2><ul>
<li><code>Image</code>:用于加载图片<ul>
<li>图片可以是本地图片也可以是网络中的图片</li>
</ul>
</li>
</ul>
<h3 id="加载图片的方式"><a href="#加载图片的方式" class="headerlink" title="加载图片的方式"></a>加载图片的方式</h3><ul>
<li>首先看一下图片的三种存放方式<ul>
<li>图片存放到RN项目中</li>
<li>图片存放到iOS项目中</li>
<li>图片存放到安卓项目中</li>
</ul>
</li>
</ul>
<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-fb4d14710cbd2852.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="RN项目中的图片.png"></p>
<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-c0c5932f82858f27.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="iOS中的图片.png"></p>
<ul>
<li>如何加载图片<ul>
<li>RN中加载资源:require(文件路径),用于加载RN中的资源，不管是图片，还是json都是一样的</li>
<li>uri:指定一个资源路径，就会自动加载</li>
<li>uri加载注意：通过uri加载资源，必须设置图片尺寸，否则不显示</li>
<li>如果网络加载http图片，iOS默认不支持，需要在info.plist中做配置</li>
</ul>
</li>
<li>各种图片加载方式</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">&lt;View style=&#123;styles.mainStyle&#125;&gt;</span><br><span class="line">      &#123;<span class="comment">/*组件*/</span>&#125;</span><br><span class="line">      &lt;Text&gt;<span class="number">1.</span> 加载RN项目中的资源&lt;/Text&gt;</span><br><span class="line">      &lt;Image</span><br><span class="line">          style=&#123;styles.imageStyle&#125;</span><br><span class="line">          source=&#123;require(<span class="string">&#x27;./BenzImage/Benz-GLA1.jpg&#x27;</span>)&#125;</span><br><span class="line">      /&gt;</span><br><span class="line"></span><br><span class="line">      &lt;Text&gt;<span class="number">2.</span> 加载iOS项目中的资源&lt;/Text&gt;</span><br><span class="line">      &lt;Image</span><br><span class="line">          style=&#123;styles.imageStyle&#125;</span><br><span class="line">          source=&#123;&#123;uri: <span class="string">&#x27;Benz-GLA2&#x27;</span>&#125;&#125;</span><br><span class="line">      /&gt;</span><br><span class="line"></span><br><span class="line">      &lt;Text&gt;<span class="number">3.</span> 加载https网络资源&lt;/Text&gt;</span><br><span class="line">      &lt;Image</span><br><span class="line">          style=&#123;styles.imageStyle&#125;</span><br><span class="line">          source=&#123;&#123;uri: <span class="string">&#x27;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1513422273696&amp;di=4d6b5ad6af91e9dfc5df8dbcdc068ed6&amp;imgtype=0&amp;src=http%3A%2F%2Fimg6.taoche.cn%2F1b%2F021701pc9d.jpg&#x27;</span>&#125;&#125;</span><br><span class="line">      /&gt;</span><br><span class="line"></span><br><span class="line">      &lt;Text&gt;<span class="number">4.</span> 加载http网络资源&lt;/Text&gt;</span><br><span class="line">      &lt;Image</span><br><span class="line">          style=&#123;styles.imageStyle&#125;</span><br><span class="line">          source=&#123;&#123;uri: <span class="string">&#x27;http://upload-images.jianshu.io/upload_images/4122543-ae133247aa24204e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/620&#x27;</span>&#125;&#125;</span><br><span class="line">      /&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/View&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="相关属性介绍"><a href="#相关属性介绍" class="headerlink" title="相关属性介绍"></a>相关属性介绍</h3><ul>
<li><code>source</code>: 设置Image图片资源<ul>
<li><code>source=&#123;uri: &#39;Benz-GLA2&#39;&#125;</code></li>
</ul>
</li>
<li><code>blurRadius</code>: 设置图片模糊状态<ul>
<li><code>blurRadius=&#123;10&#125;</code></li>
<li>值越大,模糊状态越明显</li>
</ul>
</li>
<li><code>resizeMode</code>: 决定当组件尺寸和图片尺寸不成比例的时候如何调整图片的大小<ul>
<li><code>resizeMode=&#39;cover&#39;</code></li>
<li><code>cover</code>: 在保持图片宽高比的前提下缩放图片，直到宽度和高度都大于等于容器视图的尺寸（如果容器有padding内衬的话，则相应减去）<ul>
<li>译注：这样图片完全覆盖甚至超出容器，容器中不留任何空白。</li>
</ul>
</li>
<li><code>contain</code>: 在保持图片宽高比的前提下缩放图片，直到宽度和高度都小于等于容器视图的尺寸（如果容器有<code>padding</code>内衬的话，则相应减去）<ul>
<li>译注：这样图片完全被包裹在容器中，容器中可能留有空白</li>
</ul>
</li>
<li><code>stretch</code>: 拉伸图片且不维持宽高比，直到宽高都刚好填满容器。</li>
<li><code>repeat</code>: 重复平铺图片直到填满容器。图片会维持原始尺寸。仅iOS可用。</li>
<li><code>center</code>: 居中不拉伸</li>
</ul>
</li>
<li><code>defaultSource</code>: 在读取图片时默认显示的加载提示图片<ul>
<li><code>defaultSource=&#123;uri: &#39;Benz-GLA2&#39;, scale: 1.0&#125;</code></li>
<li><code>uri</code>: 是一个表示图片的资源标识的字符串，它可以是一个http地址或是一个本地文件路径（使用<code>require</code>(相对路径)来引用）。</li>
<li><code>width, height</code>:  如果你知道图片的尺寸，那么可以在这里指定。这一尺寸会被用作<code>&lt;Image/&gt;</code>组件的默认尺寸。</li>
<li><code>scale</code>: 图片的缩放系数。默认是1.0，意味着每一个图片像素都对应一个设备独立像素（DIP）。</li>
<li><code>number</code>: 本地图片引用语法<code>require(&#39;./image.jpg&#39;)</code>所返回的内部资源id</li>
</ul>
</li>
</ul>
<h3 id="监听图片加载方法"><a href="#监听图片加载方法" class="headerlink" title="监听图片加载方法"></a>监听图片加载方法</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">onLayout function </span><br><span class="line"><span class="comment">//当元素挂载或者布局改变的时候调用，参数为：&#123;nativeEvent: &#123;layout: &#123;x, y, width, height&#125;&#125;&#125;.</span></span><br><span class="line"></span><br><span class="line">onLoad function </span><br><span class="line"><span class="comment">//加载成功完成时调用此回调函数。</span></span><br><span class="line"></span><br><span class="line">onLoadStart function </span><br><span class="line"><span class="comment">//加载开始时调用</span></span><br><span class="line"></span><br><span class="line">onLoadEnd function </span><br><span class="line"><span class="comment">//加载结束后，不论成功还是失败，调用此回调函数。</span></span><br><span class="line"></span><br><span class="line">onError function </span><br><span class="line"><span class="comment">//当加载错误的时候调用此回调函数，参数为&#123;nativeEvent: &#123;error&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">onPartialLoad  function </span><br><span class="line"><span class="comment">//如果图片本身支持逐步加载，则逐步加载的过程中会调用此方法。“逐步加载”的具体定义与具体的标准和实现有关。</span></span><br><span class="line"></span><br><span class="line">onProgress function </span><br><span class="line"><span class="comment">//在加载过程中不断调用，参数为&#123;nativeEvent: &#123;loaded, total&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="Image类方法"><a href="#Image类方法" class="headerlink" title="Image类方法"></a>Image类方法</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> getSize(uri: string, success: (width: number, height: number) =&gt; <span class="type">void</span>, failure: (error: any) =&gt; <span class="type">void</span>) </span><br></pre></td></tr></table></figure>
<ul>
<li>一般在<code>componentDidMount</code>调用，先获取图片尺寸，然后在设置图片尺寸。</li>
<li>在显示图片前获取图片的宽高(以像素为单位)。如果图片地址不正确或下载失败,此方法也会失败。</li>
<li>要获取图片的尺寸,首先需要加载或下载图片(同时会被缓存起来)。</li>
<li>这意味着理论上你可以用这个方法来预加载图片，虽然此方法并没有针对这一用法进行优化，而且将来可能会换一些实现方案使得并不需要完整下载图片即可获取尺寸。</li>
<li>所以更好的预加载方案是使用下面那个专门的预加载方法。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> prefetch(url: string) </span><br><span class="line"><span class="comment">//预加载一个远程图片(将其下载到本地磁盘缓存)。</span></span><br></pre></td></tr></table></figure>

<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> App extends Component&lt;&#123;&#125;&gt; &#123;</span><br><span class="line">    constructor(props)&#123;</span><br><span class="line">        <span class="variable language_">super</span>(props)</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">this</span>.state = &#123;</span><br><span class="line">            wid: <span class="number">100</span>,</span><br><span class="line">            hei: <span class="number">100</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">        Image.getSize(<span class="string">&#x27;http://upload-images.jianshu.io/upload_images/4122543-ae133247aa24204e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/620&#x27;</span>, (width, height)=&gt;&#123;</span><br><span class="line">            <span class="variable language_">this</span>.setState(&#123;</span><br><span class="line">                wid:width,</span><br><span class="line">                hei:height</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;, (error)=&gt;&#123;</span><br><span class="line">            alert(error)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当一个组件要显示的时候,就会自动调用render,渲染组件</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;View style=&#123;styles.mainStyle&#125;&gt;</span><br><span class="line">                &lt;Text&gt;加载iOS项目中的资源&lt;/Text&gt;</span><br><span class="line">                &lt;Image</span><br><span class="line">                    style=&#123;[styles.imageStyle, &#123;width: <span class="variable language_">this</span>.state.wid, height: <span class="variable language_">this</span>.state.hei&#125;]&#125;</span><br><span class="line">                    source=&#123;&#123;uri: <span class="string">&#x27;http://upload-images.jianshu.io/upload_images/4122543-ae133247aa24204e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/620&#x27;</span>&#125;&#125;</span><br><span class="line">                    blurRadius=&#123;<span class="number">0</span>&#125;</span><br><span class="line">                    resizeMode=<span class="string">&#x27;contain&#x27;</span></span><br><span class="line">                    <span class="comment">// defaultSource=&#123;&#123;uri: &#x27;Benz-GLA2&#x27;, scale: 1.0&#125;&#125;</span></span><br><span class="line">                    onLoad=&#123;()=&gt;&#123;</span><br><span class="line">                        console.log(<span class="string">&quot;图片加载完成&quot;</span>)</span><br><span class="line">                    &#125;&#125;</span><br><span class="line">                    onLoadStart=&#123;()=&gt;&#123;</span><br><span class="line">                        console.log(<span class="string">&#x27;图片开始加载&#x27;</span>)</span><br><span class="line">                    &#125;&#125;</span><br><span class="line">                    onLoadEnd=&#123;()=&gt;&#123;</span><br><span class="line">                        console.log(<span class="string">&#x27;图片加载结束&#x27;</span>)</span><br><span class="line">                    &#125;&#125;</span><br><span class="line">                    onProgress=&#123;(progress)=&gt;&#123;</span><br><span class="line">                        console.log(progress.nativeEvent.total)</span><br><span class="line">                        console.log(progress.nativeEvent.loaded)</span><br><span class="line">                    &#125;&#125;</span><br><span class="line">                    onError=&#123;()=&gt;&#123;</span><br><span class="line">                        alert(<span class="string">&#x27;图片加载错误&#x27;</span>)</span><br><span class="line">                    &#125;&#125;</span><br><span class="line">                /&gt;</span><br><span class="line">            &lt;/View&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.样式表 组件外观 尺寸,颜色</span></span><br><span class="line"><span class="keyword">const</span> styles = StyleSheet.create(&#123;</span><br><span class="line">    mainStyle:&#123;</span><br><span class="line">        flex:<span class="number">1</span>,</span><br><span class="line">        backgroundColor: <span class="string">&#x27;white&#x27;</span>,</span><br><span class="line">        justifyContent:<span class="string">&#x27;center&#x27;</span>,</span><br><span class="line">        alignItems:<span class="string">&#x27;center&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    imageStyle:&#123;</span><br><span class="line">        width:<span class="number">150</span>,</span><br><span class="line">        height:<span class="number">150</span>,</span><br><span class="line">        backgroundColor:<span class="string">&#x27;yellow&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>ReactNaive</category>
      </categories>
  </entry>
  <entry>
    <title>ReactNative之基本组件02</title>
    <url>/post/8b290237.html</url>
    <content><![CDATA[<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/ReactNative/ReactNative.jpeg?x-oss-process=style/titanjun" alt="ReactNative"></p>
<span id="more"></span>


<ul>
<li>原文博客: <a href="https://www.titanjun.top/categories/ReactNaive/">ReactNative相关文章</a></li>
<li>之前的文章只是记录了一些常用的组件, 现在记录一些偶尔会用到的一些组件</li>
</ul>
<h2 id="Slider"><a href="#Slider" class="headerlink" title="Slider"></a>Slider</h2><p><code>Slider</code>用于选择一个范围值的组件</p>
<h3 id="相关属性"><a href="#相关属性" class="headerlink" title="相关属性"></a>相关属性</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 滑块的初始值。这个值应该在最小值和最大值之间，默认值是0</span></span><br><span class="line">value=&#123;<span class="number">4</span>&#125;</span><br><span class="line"><span class="comment">// 滑块的最小值（当滑块滑到最左侧时表示的值），默认为0</span></span><br><span class="line">minimumValue=&#123;<span class="number">1</span>&#125;</span><br><span class="line"><span class="comment">// 滑块的最大值（当滑块滑到最右端时表示的值），默认为1</span></span><br><span class="line">maximumValue=&#123;<span class="number">10</span>&#125;</span><br><span class="line"><span class="comment">// 滑块的最小步长，这个值应该在0到(最大值-最小值)之间，默认值为0</span></span><br><span class="line">step=&#123;<span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 滑块左侧轨道的颜色。在iOS上默认为一个蓝色的渐变色</span></span><br><span class="line"><span class="comment">// ios：滑块右侧区域的颜色。android：滑块左侧区域的颜色 </span></span><br><span class="line">minimumTrackTintColor=&#123;<span class="string">&#x27;red&#x27;</span>&#125;</span><br><span class="line"><span class="comment">// ios：滑块左侧区域的颜色。android：滑块右侧区域的颜色</span></span><br><span class="line">minimumTrackTintColor=&#123;<span class="string">&#x27;yellow&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<h4 id="仅IOS支持："><a href="#仅IOS支持：" class="headerlink" title="仅IOS支持："></a>仅IOS支持：</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 给滑块设置一张图片，只支持静态图片</span></span><br><span class="line">thumbImage=&#123;<span class="built_in">require</span>(<span class="string">&#x27;./image/slider.png&#x27;</span>)&#125;</span><br><span class="line"><span class="comment">// 给轨道设置一张背景图。只支持静态图片。图片最中央的像素会被平铺直至填满轨道</span></span><br><span class="line">trackImage=&#123;<span class="built_in">require</span>(<span class="string">&#x27;./image/slider1.png&#x27;</span>)&#125;</span><br><span class="line"><span class="comment">// 指定一个滑块左侧轨道背景图，仅支持静态图片。图片最右边的像素会被平铺直至填满轨道</span></span><br><span class="line">minimumTrackImage=&#123;<span class="built_in">require</span>(<span class="string">&#x27;./image/left.png&#x27;</span>)&#125;</span><br><span class="line"><span class="comment">// 指定一个滑块右侧轨道背景图，仅支持静态图片。图片最左边的像素会被平铺直至填满轨道</span></span><br><span class="line">maximumTrackImage=&#123;<span class="built_in">require</span>(<span class="string">&#x27;./image/right.png&#x27;</span>)&#125;</span><br></pre></td></tr></table></figure>

<h4 id="仅android支持"><a href="#仅android支持" class="headerlink" title="仅android支持"></a>仅android支持</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 滑块颜色</span></span><br><span class="line">thumbTintColor=&#123;<span class="string">&#x27;orange&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用户松开滑块的时候调用此回调，无论值是否变化。回调值为当前值</span></span><br><span class="line">onSlidingComplete=&#123;<span class="function">() =&gt;</span> &#123;&#125;&#125;</span><br><span class="line"></span><br><span class="line">在用户拖动滑块的过程中不断调用此回调</span><br><span class="line">onValueChange=&#123;<span class="function">() =&gt;</span> &#123;&#125;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="StatusBar"><a href="#StatusBar" class="headerlink" title="StatusBar"></a>StatusBar</h2><ul>
<li>控制应用状态栏的组件</li>
<li>由于StatusBar可以在任意视图中加载，且后加载的设置会覆盖先前的设置。因此在配合导航器使用时，请务必考虑清楚StatusBar的放置顺序</li>
<li>有些场景并不适合使用组件，因此StatusBar也暴露了一个静态API。然而不推荐大家同时通过静态API和组件来定义相同的属性，因为静态API定义的属性值在后续的渲染中会被组件中定义的值所覆盖</li>
</ul>
<h3 id="相关属性介绍"><a href="#相关属性介绍" class="headerlink" title="相关属性介绍"></a>相关属性介绍</h3><h4 id="通用属性"><a href="#通用属性" class="headerlink" title="通用属性"></a>通用属性</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指定状态栏的变化是否应以动画形式呈现。目前支持这几种样式：backgroundColor, barStyle和hidden</span></span><br><span class="line">animated bool</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否隐藏状态栏</span></span><br><span class="line">hidden bool</span><br></pre></td></tr></table></figure>

<h4 id="仅支持iOS"><a href="#仅支持iOS" class="headerlink" title="仅支持iOS"></a>仅支持iOS</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置状态栏文本的颜色, 可选值: enum(&#x27;default&#x27;, &#x27;light-content&#x27;, &#x27;dark-content&#x27;)</span></span><br><span class="line">barStyle=&#123;<span class="string">&#x27;light-content&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设定网络活动指示器(就是那个菊花)是否显示在状态栏</span></span><br><span class="line">networkActivityIndicatorVisible=&#123;<span class="literal">true</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 hidden 属性来显示或隐藏状态栏时所使用的动画效果，有两种选择：fade（默认值）、slide</span></span><br><span class="line">showHideTransition=&#123;<span class="string">&#x27;fade&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<h4 id="仅支持Android"><a href="#仅支持Android" class="headerlink" title="仅支持Android"></a>仅支持Android</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Android 设备上状态栏的背景颜色</span></span><br><span class="line">backgroundColor=&#123;<span class="string">&#x27;blue&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<h5 id="translucent"><a href="#translucent" class="headerlink" title="translucent"></a>translucent</h5><ul>
<li>设置状态栏是否为透明。</li>
<li>当状态栏的值为<code>true</code>的时候，应用将会在状态栏下面进行绘制显示。</li>
<li>这样在&#96;Android平台上面就是沉浸式的效果，可以达到 Android 和 iOS 应用显示效果的一致性。</li>
<li>该值常常同配置半透明效果的状态栏颜色一起使用。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">translucent=&#123;<span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure>



<h5 id="currentHeight"><a href="#currentHeight" class="headerlink" title="currentHeight"></a>currentHeight</h5><ul>
<li><code>React Native</code>在<code>Android</code>平台为<code>StatusBar</code>组件提供了一个静态常量<code>currentHeight</code>，我们可以通过读取这个常量来得到<code>Android</code>手机状态栏的高度。</li>
<li>注意：<code>currentHeight</code>不是一个属性，我们直接访问<code>StatusBar.currentHeight</code>就可以了</li>
</ul>
<h2 id="Alert"><a href="#Alert" class="headerlink" title="Alert"></a>Alert</h2><ul>
<li>启动一个提示对话框，包含对应的标题和信息。</li>
<li>默认情况下，对话框会仅有一个’确定’按钮</li>
<li>在 iOS 上你可以指定任意数量的按钮。每个按钮还都可以指定自己的样式，此外还可以指定提示的类别</li>
<li>在 Android 上<ul>
<li>最多能指定三个按钮，这三个按钮分别具有“中间态”、“消极态”和“积极态”的概念：</li>
<li>如果你只指定一个按钮，则它具有“积极态”的属性（比如“确定”）；两个按钮，则分别是“消极态”和“积极态”（比如“取消”和“确定”）；三个按钮则意味着“中间态”、“消极态”和“积极态”（比如“稍候再说”，“取消”，“确定”）</li>
<li>默认情况下点击提示框的外面会自动取消提示框<ul>
<li>可以提供一个额外参数来处理这一事件：<code>&#123; onDismiss: () =&gt; &#123;&#125; &#125;</code></li>
<li>也可以用一个参数来阻止提示框被自动取消，即<code>&#123; cancelable: false &#125;</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="alert"><a href="#alert" class="headerlink" title="alert()"></a>alert()</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 显示弹窗的方法</span></span><br><span class="line"><span class="keyword">static</span> <span class="title function_">alert</span>(title, message?, buttons?, options?, type?)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示弹窗</span></span><br><span class="line"><span class="title function_">_shwoAlert</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">Alert</span>.<span class="title function_">alert</span>(</span><br><span class="line">        <span class="string">&#x27;标题&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;弹窗提示信息&#x27;</span>,</span><br><span class="line">        [</span><br><span class="line">            &#123;<span class="attr">text</span>: <span class="string">&#x27;稍后再说&#x27;</span>, <span class="attr">onPress</span>: <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;稍后再说&#x27;</span>), <span class="attr">style</span>: <span class="string">&#x27;default&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="attr">text</span>: <span class="string">&#x27;取消&#x27;</span>, <span class="attr">onPress</span>: <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;取消&#x27;</span>), <span class="attr">style</span>: <span class="string">&#x27;cancel&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="attr">text</span>: <span class="string">&#x27;确定&#x27;</span>, <span class="attr">onPress</span>: <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;确定&#x27;</span>), <span class="attr">style</span>: <span class="string">&#x27;destructive&#x27;</span>&#125;</span><br><span class="line">        ],</span><br><span class="line">        &#123; <span class="attr">cancelable</span>: <span class="literal">false</span> &#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="按钮样式"><a href="#按钮样式" class="headerlink" title="按钮样式"></a>按钮样式</h3><table>
<thead>
<tr>
<th><code>value</code></th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>default</code></td>
<td>默认</td>
</tr>
<tr>
<td><code>cancel</code></td>
<td>取消样式</td>
</tr>
<tr>
<td><code>destructive</code></td>
<td>红色确定样式</td>
</tr>
</tbody></table>
<h2 id="BackHandler"><a href="#BackHandler" class="headerlink" title="BackHandler"></a>BackHandler</h2><ul>
<li><code>Android</code>：监听后退按钮事件。如果没有添加任何监听函数，或者所有的监听函数都返回<code>false</code>，则会执行默认行为，退出应用</li>
<li><code>tvOS</code>(即<code>Apple TV</code>机顶盒)：监听遥控器上的后退按钮事件（阻止应用退出的功能尚未实现）</li>
<li><code>iOS</code>：尚无作用</li>
<li>注意: 监听函数是按倒序的顺序执行（即后添加的函数先执行）。如果某一个函数返回 true，则后续的函数都不会被调用</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 添加监听</span></span><br><span class="line">    <span class="title class_">BackHandler</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;hardwareBackPress&#x27;</span>, <span class="variable language_">this</span>.<span class="property">handleBackPress</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">componentWillUnmount</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 移除监听</span></span><br><span class="line">    <span class="title class_">BackHandler</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;hardwareBackPress&#x27;</span>, <span class="variable language_">this</span>.<span class="property">handleBackPress</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleBackPress = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">goBack</span>(); </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 退出当前应用</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">exitApp</span>()</span><br></pre></td></tr></table></figure>


<h2 id="Clipboard"><a href="#Clipboard" class="headerlink" title="Clipboard"></a>Clipboard</h2><p><code>Clipboard</code>组件可以在<code>iOS</code>和<code>Android</code>的剪贴板中读写内容</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="title function_">getString</span>()</span><br><span class="line"><span class="comment">// 获取剪贴板的文本内容。返回一个Promise，然后你可以用下面的方式来读取剪贴板内容。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="title function_">_getContent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> content = <span class="keyword">await</span> <span class="title class_">Clipboard</span>.<span class="title function_">getString</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="title function_">setString</span>(content)</span><br><span class="line"><span class="comment">// 设置剪贴板的文本内容，然后你可以用下面的方式来设置剪贴板内容。</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">_setContent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">Clipboard</span>.<span class="title function_">setString</span>(<span class="string">&#x27;hello world&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="InteractionManager"><a href="#InteractionManager" class="headerlink" title="InteractionManager"></a>InteractionManager</h2><ul>
<li><code>InteractionManager</code>可以将一些耗时较长的工作安排到所有互动或动画完成之后再进行。这样可以保证<code>JavaScript</code>动画的流畅运行。比如<code>Navigator</code>的转场动画</li>
<li>对大多数<code>React Native</code>应用来说，业务逻辑是运行在<code>JavaScript</code>线程上的。这是<code>React</code>应用所在的线程，也是发生<code>API</code>调用，以及处理触摸事件等操作的线程</li>
<li>如果你正在<code>JavaScript</code>线程处理一个跨越多个帧的工作，你可能会注意到<code>TouchableOpacity</code>的响应被延迟了。这是因为<code>JavaScript</code>线程太忙了，不能够处理主线程发送过来的原始触摸事件</li>
</ul>
<h3 id="属性方法"><a href="#属性方法" class="headerlink" title="属性方法"></a>属性方法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 静态方法,在用户交互和动画结束以后执行任务, 返回一个可取消的 promise</span><br><span class="line">runAfterInteractions(task)  </span><br><span class="line"></span><br><span class="line">// 静态方法，创建一个句柄(处理器)，通知管理器，某个动画或者交互开始了</span><br><span class="line">createInteractionHandle() </span><br><span class="line"></span><br><span class="line">// 静态方法，进行清除句柄，通知管理器，某个动画或者交互结束了。</span><br><span class="line">clearInteractionHandle(handler:Handle)  </span><br><span class="line"></span><br><span class="line">// 设置延迟时间，该会调用setTimeout方法挂起并且阻塞所有没有完成的任务，然后在eventLoopRunningTime到设定的延迟时间后，然后执行setImmediate方法进行批量执行任务</span><br><span class="line">setDeadline(deadline:number) </span><br><span class="line"></span><br><span class="line">// 事件</span><br><span class="line">Events:CallExpression</span><br><span class="line">// 监听</span><br><span class="line">addListener:CallExpression</span><br></pre></td></tr></table></figure>

<p>这里最常使用的就是<code>runAfterInteractions</code>方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">InteractionManager</span>.<span class="title function_">runAfterInteractions</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    navigator.<span class="title function_">push</span>(&#123;</span><br><span class="line">        <span class="attr">component</span>: <span class="title class_">MainPager</span>,</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;MainPager&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者设置state</span></span><br><span class="line"><span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">InteractionManager</span>.<span class="title function_">runAfterInteractions</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">renderPlaceholderOnly</span>: <span class="literal">false</span>&#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Keyboard"><a href="#Keyboard" class="headerlink" title="Keyboard"></a>Keyboard</h2><ul>
<li><code>Keyboard</code>模块用来控制键盘相关的事件</li>
<li>可以监听原生键盘事件以做出相应回应</li>
</ul>
<h3 id="相关方法"><a href="#相关方法" class="headerlink" title="相关方法"></a>相关方法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用来加载一个指定事件的事件监听器</span></span><br><span class="line"><span class="keyword">static</span> <span class="title function_">addListener</span>(eventName, callback)</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除某个类型事件的监听函数</span></span><br><span class="line"><span class="keyword">static</span> <span class="title function_">removeListener</span>(eventName, callback)</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除某个类型事件的所有监听函数</span></span><br><span class="line"><span class="keyword">static</span> <span class="title function_">removeAllListeners</span>(eventName)</span><br><span class="line"></span><br><span class="line"><span class="comment">//把弹出的键盘收回去，同时使当前的文本框失去焦点</span></span><br><span class="line"><span class="keyword">static</span> <span class="title function_">dismiss</span>()</span><br></pre></td></tr></table></figure>

<h3 id="eventName"><a href="#eventName" class="headerlink" title="eventName"></a>eventName</h3><p>上述函数中的<code>eventName</code>可以是如下值</p>
<ul>
<li><code>keyboardWillShow</code>：软键盘将要显示</li>
<li><code>keyboardDidShow</code>：软键盘显示完毕</li>
<li><code>keyboardWillHide</code>：软键盘将要收起</li>
<li><code>keyboardDidHide</code>：软键盘收起完毕</li>
<li><code>keyboardWillChangeFrame</code>：软件盘的<code>frame</code>将要改变</li>
<li><code>keyboardDidChangeFrame</code>：软件盘的<code>frame</code>改变完毕</li>
</ul>
<h3 id="event-参数值"><a href="#event-参数值" class="headerlink" title="event 参数值"></a>event 参数值</h3><p>所有的键盘事件处理函数都能收到一个<code>event</code>参数，不过在不同平台下<code>event</code>参数可以取到的值不太一样</p>
<h4 id="Android平台"><a href="#Android平台" class="headerlink" title="Android平台"></a>Android平台</h4><ul>
<li><code>event.endCoordinates.screenX</code></li>
<li><code>event.endCoordinates.screenY</code></li>
<li><code>event.endCoordinates.width</code></li>
<li><code>event.endCoordinates.height</code></li>
</ul>
<h4 id="iOS平台"><a href="#iOS平台" class="headerlink" title="iOS平台"></a>iOS平台</h4><ul>
<li><code>event.easing</code>：这个值始终是<code>keyboard</code></li>
<li><code>evnet.duration</code>：记录软键盘弹出动画的持续事件，单位是毫秒</li>
<li><code>event.startCoordinates.screenX</code></li>
<li><code>event.startCoordinates.screenY</code></li>
<li><code>event.startCoordinates.width</code></li>
<li><code>event.startCoordinates.height</code></li>
<li><code>event.endCoordinates.screenX</code></li>
<li><code>event.endCoordinates.screenY</code></li>
<li><code>event.endCoordinates.width</code></li>
<li><code>event.endCoordinates.height</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">componentWillMount() &#123;</span><br><span class="line">    // 监听键盘弹出时间</span><br><span class="line">    this.keyboardShow = Keyboard.addListener(&#x27;keyboardWillShow&#x27;, this._keyboardDidShow)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">componentWillUnmount() &#123;</span><br><span class="line">    this.keyboardShow.remove()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_keyboardDidShow = (event) =&gt; &#123;</span><br><span class="line">    console.log(event)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>ReactNaive</category>
      </categories>
  </entry>
  <entry>
    <title>ReactNative之手势识别</title>
    <url>/post/36f41dd2.html</url>
    <content><![CDATA[<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/ReactNative/ReactNative.jpeg?x-oss-process=style/titanjun" alt="ReactNative"></p>
<span id="more"></span>



<ul>
<li>移动开发中最重要的就是交互, 说到交互, 就不得不说触摸事件</li>
<li>在<code>iOS</code>中有单击, 双击, 长按, 拖拽等触摸操作</li>
<li>在<code>React Native</code>中点击手势都有其对应的组件, 每个组件都可以用来包裹视图来响应用户的点击事件</li>
</ul>
<h2 id="TouchableWithoutFeedback"><a href="#TouchableWithoutFeedback" class="headerlink" title="TouchableWithoutFeedback"></a>TouchableWithoutFeedback</h2><ul>
<li>响应用户的点击事件, 点击操作时, 组件没有任何视觉反馈,看起来像<code>Web</code>效果而不是原生的效果<code>Native</code></li>
<li>是单节点组件, 只能包含一个组件, 如果你希望包含多个子组件，用一个View来包装它们</li>
<li>该控件除非你不得不使用，否则请不要使用该组件</li>
</ul>
<h3 id="属性方法"><a href="#属性方法" class="headerlink" title="属性方法"></a>属性方法</h3><ul>
<li><p><code>accessibilityComponentType</code>:   <code>View.AccessibilityComponentType</code><br>  设置可访问的组件类型</p>
</li>
<li><p><code>accessibilityTraits</code>: <code>View.AccessibilityTraits,[View.AccessibilityTraits]</code><br>  设置访问特征</p>
</li>
<li><p><code>accessible</code>: <code>bool</code><br>  设置当前组件是否可以访问</p>
</li>
<li><p><code>delayLongPress</code>: <code>number</code><br>  设置延迟的时间，单位为毫秒。从<code>onPressIn</code>方法开始，到<code>onLongPress</code>被调用这一段时间</p>
</li>
<li><p><code>delayPressIn</code>: <code>number</code><br>  设置延迟的时间，单位为毫秒，从用户触摸控件开始到<code>onPressIn</code>被调用这一段时间</p>
</li>
<li><p><code>delayPressOut</code>: <code>number</code><br>  设置延迟的时间，单位为毫秒，从用户触摸事件释放开始到<code>onPressOut</code>被调用这一段时间</p>
</li>
<li><p><code>onLayout</code>: <code>function</code><br>  当组件加载或者改组件的布局发生变化的时候调用, 调用传入的参数为<code>&#123;nativeEvent:&#123;layout:&#123;x,y,width,height&#125;&#125;&#125;</code></p>
</li>
<li><p><code>onLongPress</code>: <code>function</code><br>  当用户长时间按压组件(长按效果)的时候调用该方法</p>
</li>
<li><p><code>onPress</code>: <code>function</code><br>  当用户点击的时候调用(触摸结束)。 但是如果事件被取消了就不会调用。(例如:当前被滑动事件所替代)</p>
</li>
<li><p><code>onPressIn</code>: <code>function</code><br>  用户开始触摸组件回调方法</p>
</li>
<li><p><code>onPressOut</code>: <code>function</code><br>  用户完成触摸组件之后回调方法</p>
</li>
<li><p><code>pressRetentionOffset</code>: <code>&#123;top:number,left:number,bottom:number,right:number&#125;</code><br>  该设置当视图滚动禁用的情况下，可以定义当手指距离组件的距离; 当大于该距离该组件会失去响应;当少于该距离的时候，该组件会重新进行响应</p>
</li>
</ul>
<blockquote>
<p>该组件我们一般不会直接进行使用，下面三种<code>Touchable*</code>系列组件对于该组件的属性方法都可以进行使用</p>
</blockquote>
<h2 id="TouchableOpacity"><a href="#TouchableOpacity" class="headerlink" title="TouchableOpacity"></a>TouchableOpacity</h2><p>该组件封装了响应触摸事件。当点击按下的时候，该组件的透明度会降低。该组件使用过程中并不会改变视图的层级关系，而且我们可以非常容易的添加到应用并且不会产生额外的异常错误</p>
<h3 id="属性方法-1"><a href="#属性方法-1" class="headerlink" title="属性方法"></a>属性方法</h3><ul>
<li><code>TouchableWithoutFeedback</code>的所有 属性，这边<code>TouchableOpacity</code>组件全部可以进行使用</li>
<li><code>activeOpacity</code>:  <code>number</code>—设置当用户触摸的时候，组件的透明度(取值0-1)</li>
</ul>
<h2 id="TouchableHighlight"><a href="#TouchableHighlight" class="headerlink" title="TouchableHighlight"></a>TouchableHighlight</h2><p>当手指点击按下的时候，该视图的不透明度会进行降低同时会看到相应的颜色(视图变暗或者变亮)。如果我们去查看该组件的源代码会发现，该底层实现是添加了一个新的视图</p>
<h3 id="属性方法-2"><a href="#属性方法-2" class="headerlink" title="属性方法"></a>属性方法</h3><ul>
<li>所有<code>TouchableWithoutFeedback</code>的属性</li>
<li><code>activeOpacity</code>: <code>number</code>—该用来设置视图在进行触摸的时候，要要显示的不透明度(通常在0-1之间)</li>
<li><code>onHideUnderlay</code>: <code>function</code>—当底层被隐藏的时候调用</li>
<li><code>onShowUnderlay</code>: <code>function</code>—当底层显示的时候调用</li>
<li><code>underlayColor</code>: 当触摸或者点击控件的时候显示出的颜色</li>
</ul>
<h2 id="TouchableNativeFeedback"><a href="#TouchableNativeFeedback" class="headerlink" title="TouchableNativeFeedback"></a>TouchableNativeFeedback</h2><ul>
<li>仅限<code>Android</code>平台</li>
<li>在<code>Android</code>设备上，这个组件利用原生状态来渲染触摸的反馈</li>
<li>目前它只支持一个单独的<code>View</code>实例作为子节点</li>
</ul>
<h3 id="属性方法-3"><a href="#属性方法-3" class="headerlink" title="属性方法"></a>属性方法</h3><ul>
<li>所有<code>TouchableWithoutFeedback</code>的属性</li>
<li><code>background</code>: 决定在触摸反馈的时候显示什么类型的背景</li>
</ul>
<h2 id="PanResponder"><a href="#PanResponder" class="headerlink" title="PanResponder"></a>PanResponder</h2><h3 id="相关介绍"><a href="#相关介绍" class="headerlink" title="相关介绍"></a>相关介绍</h3><p><code>PanResponder</code>类可以将多点触摸操作协调成一个手势。它使得一个单点触摸可以接受更多的触摸操作，也可以用于识别简单的多点触摸手势</p>
<blockquote>
<p>手势处理</p>
</blockquote>
<p><code>React Native</code>框架底层的手势响应系统提供了响应处理器，<code>PanResponder</code>将这些手势响应处理器再次进行封装，以便开发者更容易对手势进行处理，更容易预测用户的手势，对每一个手势响应处理器，<code>PanResponder</code>除了为其提供代表触摸行为的原生事件外，还提供了一个新的手势状态对象用来详细描述手势的状态</p>
<blockquote>
<p>基本思想是：</p>
</blockquote>
<p>监视屏幕上指定大小、位置的矩形区域，当用手指按压这个区域中的某点后，开发者会收到这个事件，当按压后拖动手指时，会收到手势引发的各类事件，当手指离开这个矩形区域时，开发者也会收到相应的事件</p>
<blockquote>
<p>注意事项：</p>
</blockquote>
<ul>
<li>开发者可以任意指定监视矩形区域的大小，但在这个区域里，只有第一个按下的事件会上报和继续监视处理，如果第一个手指按下还没有离开，接着第二个手指又来按下了，那么对第二个手指的各种触摸事件无法捕获</li>
<li>开发者可以在屏幕上指定多个监视矩形区域，但是不能同时监视多个矩形区域的不同触摸事件</li>
<li>监视区域会阻止被监视区域覆盖的组件接收触摸事件，比如监视区域覆盖了一个按钮，那么就无法通过按这个按钮来触发其对应的事件，只能在<code>PanResponder</code>监视器的事件处理中对触摸行为进行处理</li>
</ul>
<h3 id="使用操作"><a href="#使用操作" class="headerlink" title="使用操作"></a>使用操作</h3><p>利用<code>PanResponder</code>实现监视器有以下几个步骤：</p>
<h4 id="指定监视区域"><a href="#指定监视区域" class="headerlink" title="指定监视区域"></a>指定监视区域</h4><p>如果监视区域有多个，一定不能重叠，否则都失效</p>
<h4 id="定义监视器相关变量"><a href="#定义监视器相关变量" class="headerlink" title="定义监视器相关变量"></a>定义监视器相关变量</h4><p>指向监视器的变量（必须有）、指向监视器监视区域的变量（可以有）、记录监视区域左上角顶点坐标的两个数值变量（可以有）、上一次触摸点的横纵坐标变量（可以有）</p>
<h4 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h4><p>准备监视器的事件处理函数</p>
<h4 id="建立监视器"><a href="#建立监视器" class="headerlink" title="建立监视器"></a>建立监视器</h4><p><code>PanResponder.create(config)</code></p>
<p>相关事件监听</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回值为布尔值, 如果返回值为 true，则表示这个 View 能够响应滑动手势, 两者有一个为true即可响应</span></span><br><span class="line"><span class="attr">onMoveShouldSetPanResponder</span>: <span class="function">(<span class="params">e, gestureState</span>) =&gt;</span> &#123;...&#125;</span><br><span class="line"><span class="attr">onMoveShouldSetPanResponderCapture</span>: <span class="function">(<span class="params">e, gestureState</span>) =&gt;</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值为布尔值, 如果返回值为 true，则表示这个 View 能够响应触摸手势, 两者有一个为true即可响应</span></span><br><span class="line"><span class="attr">onStartShouldSetPanResponder</span>: <span class="function">(<span class="params">e, gestureState</span>) =&gt;</span> &#123;...&#125;</span><br><span class="line"><span class="attr">onStartShouldSetPanResponderCapture</span>: <span class="function">(<span class="params">e, gestureState</span>) =&gt;</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前有其他的东西成为响应器并且没有释放它。如果视图正在响应，会触发该方法</span></span><br><span class="line"><span class="attr">onPanResponderReject</span>: <span class="function">(<span class="params">e, gestureState</span>) =&gt;</span> &#123;...&#125;</span><br><span class="line"><span class="comment">// 最近一次的移动距离.如:(获取x轴方向的移动距离 gestureState.dx)</span></span><br><span class="line"><span class="attr">onPanResponderGrant</span>: <span class="function">(<span class="params">e, gestureState</span>) =&gt;</span> &#123;...&#125;</span><br><span class="line"><span class="comment">// 开始按下时的响应事件</span></span><br><span class="line"><span class="attr">onPanResponderStart</span>: <span class="function">(<span class="params">e, gestureState</span>) =&gt;</span> &#123;...&#125;</span><br><span class="line"><span class="comment">// 结束按下时的响应事件</span></span><br><span class="line"><span class="attr">onPanResponderEnd</span>: <span class="function">(<span class="params">e, gestureState</span>) =&gt;</span> &#123;...&#125;</span><br><span class="line"><span class="comment">// 用户手指离开屏幕时，调用该方法</span></span><br><span class="line"><span class="attr">onPanResponderRelease</span>: <span class="function">(<span class="params">e, gestureState</span>) =&gt;</span> &#123;...&#125;</span><br><span class="line"><span class="comment">// 用户滑动手指时，调用该方法</span></span><br><span class="line"><span class="attr">onPanResponderMove</span>: <span class="function">(<span class="params">e, gestureState</span>) =&gt;</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一个组件已经成为了新的响应者，所以当前手势将被取消</span></span><br><span class="line"><span class="attr">onPanResponderTerminate</span>: <span class="function">(<span class="params">e, gestureState</span>) =&gt;</span> &#123;...&#125;</span><br><span class="line"><span class="comment">// 如果回调函数返回为 true，则表示同意释放响应者角色 同时会回调onResponderTerminate函数，通知组件事件响应处理被终止了</span></span><br><span class="line"><span class="attr">onPanResponderTerminationRequest</span>: <span class="function">(<span class="params">e, gestureState</span>) =&gt;</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个布尔值，决定当前组件是否应该阻止原生组件成为JS响应者（暂只支持android）</span></span><br><span class="line"><span class="attr">onShouldBlockNativeResponder</span>: <span class="function">(<span class="params">e, gestureState</span>) =&gt;</span> &#123;...&#125;</span><br></pre></td></tr></table></figure>


<h4 id="监视器与监视区域关联"><a href="#监视器与监视区域关联" class="headerlink" title="监视器与监视区域关联"></a>监视器与监视区域关联</h4><p><code>&#123;…this.watcher.panHandlers&#125;</code></p>
<p>实例：点击、拖动选择百分百参数 比如说播放器的音量大小</p>
<h4 id="参数event-e"><a href="#参数event-e" class="headerlink" title="参数event(e)"></a>参数<code>event</code>(<code>e</code>)</h4><p>获取触摸的位置在被响应的 View 中的相对坐标，<code>evt.nativeEvent.locationX</code></p>
<ul>
<li><code>nativeEvent</code><ul>
<li><code>changedTouches</code> - 在上一次事件之后，所有发生变化的触摸事件的数组集合（即上一次事件后，所有移动过的触摸点）</li>
<li><code>identifier</code> - 触摸点的ID</li>
<li><code>locationX</code> - 触摸点相对于父元素的横坐标</li>
<li><code>locationY</code> - 触摸点相对于父元素的纵坐标</li>
<li><code>pageX</code> - 触摸点相对于根元素的横坐标</li>
<li><code>pageY</code> - 触摸点相对于根元素的纵坐标</li>
<li><code>target</code> - 触摸点所在的元素ID</li>
<li><code>timestamp</code> - 触摸事件的时间戳，可用于移动速度的计算</li>
<li><code>touches</code> - 当前屏幕上的所有触摸点的集合</li>
</ul>
</li>
</ul>
<h4 id="gestureState对象"><a href="#gestureState对象" class="headerlink" title="gestureState对象"></a><code>gestureState</code>对象</h4><ul>
<li><code>stateID</code> – 触摸状态的ID。在屏幕上有至少一个触摸点的情况下，这个ID会一直有效。</li>
<li><code>moveX</code> - 最近一次移动时的屏幕横坐标</li>
<li><code>moveY</code> - 最近一次移动时的屏幕纵坐标</li>
<li><code>x0</code> - 当响应器产生时的屏幕坐标</li>
<li><code>y0</code> - 当响应器产生时的屏幕坐标</li>
<li><code>dx</code> - 从触摸操作开始时的累计横向路程</li>
<li><code>dy</code> - 从触摸操作开始时的累计纵向路程</li>
<li><code>vx</code> - 当前的横向移动速度</li>
<li><code>vy</code> - 当前的纵向移动速度</li>
<li><code>numberActiveTouches</code> - 当前在屏幕上的有效触摸点的数量</li>
</ul>
<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p>相关代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">MyApp</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(props)</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">            <span class="attr">backColor</span>: <span class="string">&#x27;red&#x27;</span>,</span><br><span class="line">            <span class="attr">left</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">top</span>: <span class="number">100</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">componentWillMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_panResponse</span> = <span class="title class_">PanResponder</span>.<span class="title function_">create</span>(&#123;</span><br><span class="line">            <span class="attr">onStartShouldSetPanResponder</span>: <span class="function">() =&gt;</span> <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">onStartShouldSetPanResponderCapture</span>: <span class="function">() =&gt;</span> <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">onMoveShouldSetPanResponder</span>: <span class="function">() =&gt;</span> <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">onPanResponderGrant</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">_top</span> = <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">top</span></span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">_left</span> = <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">left</span></span><br><span class="line">                <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">backColor</span>: <span class="string">&#x27;red&#x27;</span> &#125;)</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">onPanResponderMove</span>: <span class="function">(<span class="params">event, ges</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`event = <span class="subst">$&#123;event&#125;</span>, guesture = <span class="subst">$&#123;ges&#125;</span>`</span>)</span><br><span class="line">                <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">                    <span class="attr">top</span>: <span class="variable language_">this</span>.<span class="property">_top</span> + ges.<span class="property">dy</span>,</span><br><span class="line">                    <span class="attr">left</span>: <span class="variable language_">this</span>.<span class="property">_left</span> + ges.<span class="property">dx</span>,</span><br><span class="line">                    <span class="attr">backColor</span>: <span class="string">&#x27;blue&#x27;</span></span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">onPanResponderRelease</span>: <span class="function">(<span class="params">event, ges</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">                    <span class="attr">backColor</span>: <span class="string">&#x27;orange&#x27;</span></span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">View</span> <span class="attr">style</span>=<span class="string">&#123;styles.container&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">View</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                    &#123;<span class="attr">...this._panResponse.panHandlers</span>&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                    <span class="attr">style</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                        <span class="attr">position:</span> &#x27;<span class="attr">absolute</span>&#x27;,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                        <span class="attr">backgroundColor:</span> <span class="attr">this.state.backColor</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                        <span class="attr">left:</span> <span class="attr">this.state.left</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                        <span class="attr">top:</span> <span class="attr">this.state.top</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                        <span class="attr">width:</span> <span class="attr">50</span>, </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                        <span class="attr">height:</span> <span class="attr">50</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                    &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                /&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">View</span>&gt;</span></span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>ReactNaive</category>
      </categories>
  </entry>
  <entry>
    <title>ReactNative基本动画之Animated</title>
    <url>/post/e16550ba.html</url>
    <content><![CDATA[<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/ReactNative/ReactNative.jpeg?x-oss-process=style/titanjun" alt="React Native"></p>
<span id="more"></span>


<p><code>React Naticw</code>封装了两个易于使用的动画组件。用于全局的布局动画<code>LayoutAnimation</code>，和用于创建更精细的交互控制的动画<code>Animated</code></p>
<h2 id="LayoutAnimation"><a href="#LayoutAnimation" class="headerlink" title="LayoutAnimation"></a>LayoutAnimation</h2><ul>
<li>当布局变化时，自动将视图运动到它们新的位置上</li>
<li><code>LayoutAnimation</code>动画使用简单，要实现动画效果只需要在<code>setState</code>前添加<code>LayoutAnimation</code>动画方法</li>
</ul>
<h3 id="相关方法"><a href="#相关方法" class="headerlink" title="相关方法"></a>相关方法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计划下一次布局要发生的动画</span></span><br><span class="line"><span class="attr">configureNext</span>: <span class="function">(<span class="params">config: LayoutAnimationConfig, onAnimationDidEnd?: () =&gt; <span class="keyword">void</span></span>) =&gt;</span> <span class="keyword">void</span> </span><br><span class="line"><span class="comment">// config: 表示动画相应的属性</span></span><br><span class="line"><span class="comment">// onAnimationDidEnd: 当动画结束的时候被调用。只在iOS设备上支持</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用来创建 configureNext 所需的 config 参数的辅助函数</span></span><br><span class="line"><span class="attr">create</span>: <span class="function">(<span class="params">duration: number, type?: string, creationProp?: string</span>) =&gt;</span> <span class="title class_">LayoutAnimationConfig</span></span><br><span class="line"><span class="comment">// duration: 动画持续时间, 毫秒</span></span><br><span class="line"><span class="comment">// type: 类型定义在LayoutAnimation.Types中</span></span><br><span class="line"><span class="comment">// creationProp: 动画属性，定义 LayoutAnimation.Properties</span></span><br></pre></td></tr></table></figure>

<h3 id="LayoutAnimationConfig"><a href="#LayoutAnimationConfig" class="headerlink" title="LayoutAnimationConfig"></a>LayoutAnimationConfig</h3><p><code>LayoutAnimationConfig</code>的相关参数信息</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// configureNext相关参数信息</span></span><br><span class="line"><span class="keyword">export</span> interface <span class="title class_">LayoutAnimationConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 动画持续的时间, 毫秒</span></span><br><span class="line">    <span class="attr">duration</span>: number; </span><br><span class="line">    <span class="comment">// 配置创建新视图时的动画</span></span><br><span class="line">    create?: <span class="title class_">LayoutAnimationAnim</span>;  </span><br><span class="line">    <span class="comment">// 配置被更新视图时的动画</span></span><br><span class="line">    update?: <span class="title class_">LayoutAnimationAnim</span>;  </span><br><span class="line">    <span class="comment">// 配置创建删除视图时的动画</span></span><br><span class="line">    <span class="keyword">delete</span>?: <span class="title class_">LayoutAnimationAnim</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LayoutAnimationAnim"><a href="#LayoutAnimationAnim" class="headerlink" title="LayoutAnimationAnim"></a>LayoutAnimationAnim</h3><p><code>LayoutAnimationAnim</code>相关参数格式参考</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> interface <span class="title class_">LayoutAnimationAnim</span> &#123;</span><br><span class="line">    <span class="comment">// 动画持续时间, 毫秒, 会覆盖 config 中设置的 duration</span></span><br><span class="line">    duration?: number;  </span><br><span class="line">    <span class="comment">// 延迟时间执行, 毫秒</span></span><br><span class="line">    delay?: number;   </span><br><span class="line">    <span class="comment">//弹跳动画阻尼系数（配合 spring 使用）</span></span><br><span class="line">    springDamping?: number;  </span><br><span class="line">    <span class="comment">// 初始速度</span></span><br><span class="line">    initialVelocity?: number;</span><br><span class="line">    <span class="comment">// 类型定义在LayoutAnimation.Types中</span></span><br><span class="line">    type?: string; <span class="comment">//LayoutAnimationTypes</span></span><br><span class="line">    <span class="comment">// 类型定义在LayoutAnimation.Properties中</span></span><br><span class="line">    property?: string; <span class="comment">//LayoutAnimationProperties</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常用枚举值"><a href="#常用枚举值" class="headerlink" title="常用枚举值"></a>常用枚举值</h3><p><code>LayoutAnimationTypes</code>和<code>LayoutAnimationProperties</code>的取值如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> interface <span class="title class_">LayoutAnimationTypes</span> &#123;</span><br><span class="line">    <span class="attr">spring</span>: string;</span><br><span class="line">    <span class="attr">linear</span>: string;</span><br><span class="line">    <span class="attr">easeInEaseOut</span>: string;</span><br><span class="line">    <span class="attr">easeIn</span>: string;</span><br><span class="line">    <span class="attr">easeOut</span>: string;</span><br><span class="line">    <span class="attr">keyboard</span>: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> interface <span class="title class_">LayoutAnimationProperties</span> &#123;</span><br><span class="line">    <span class="attr">opacity</span>: string; <span class="comment">//透明度</span></span><br><span class="line">    <span class="attr">scaleXY</span>: string; <span class="comment">//尺寸变化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码示例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">SpingAnimated</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(props)</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">            <span class="attr">width</span>: <span class="number">50</span>,</span><br><span class="line">            <span class="attr">height</span>: <span class="number">50</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">_startAnimated</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title class_">LayoutAnimation</span>.<span class="title function_">configureNext</span>(&#123;</span><br><span class="line">            <span class="attr">duration</span>: <span class="number">500</span>,</span><br><span class="line">            <span class="attr">create</span>: &#123;<span class="attr">type</span>: <span class="string">&#x27;linear&#x27;</span>, <span class="attr">property</span>: <span class="string">&#x27;opacity&#x27;</span>&#125;,</span><br><span class="line">            <span class="attr">update</span>: &#123;<span class="attr">type</span>: <span class="string">&#x27;linear&#x27;</span>, <span class="attr">property</span>: <span class="string">&#x27;0.8&#x27;</span>&#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">            <span class="attr">width</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">width</span> + <span class="number">20</span>,</span><br><span class="line">            <span class="attr">height</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">height</span> + <span class="number">20</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">View</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">width:</span> <span class="attr">414</span>, <span class="attr">height:</span> <span class="attr">800</span>, <span class="attr">backgroundColor:</span> &#x27;<span class="attr">yellow</span>&#x27;, <span class="attr">alignItems:</span> &#x27;<span class="attr">center</span>&#x27;, <span class="attr">justifyContent:</span> &#x27;<span class="attr">center</span>&#x27; &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">                 <span class="tag">&lt;<span class="name">View</span> <span class="attr">style</span>=<span class="string">&#123;&#123;width:</span> <span class="attr">this.state.width</span>, <span class="attr">height:</span> <span class="attr">this.state.height</span>, <span class="attr">backgroundColor:</span> &#x27;<span class="attr">red</span>&#x27;&#125;&#125;/&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">TouchableOpacity</span> <span class="attr">style</span>=<span class="string">&#123;&#123;position:</span>&#x27;<span class="attr">absolute</span>&#x27;, <span class="attr">bottom:</span> <span class="attr">50</span>&#125;&#125; <span class="attr">onPress</span>=<span class="string">&#123;this._startAnimated.bind(this)&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">Text</span> <span class="attr">style</span>=<span class="string">&#123;&#123;width:200,height:100,textAlign:</span>&#x27;<span class="attr">center</span>&#x27;,<span class="attr">lineHeight:100</span>&#125;&#125;&gt;</span>点击开始动画<span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">TouchableOpacity</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">View</span>&gt;</span></span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>







<h2 id="Animated"><a href="#Animated" class="headerlink" title="Animated"></a>Animated</h2><ul>
<li><p><code>Animated</code>库用于创建更精细的交互控制的动画，它使得开发者可以非常容易地实现各种各样的动画和交互方式，并且具备极高的性能</p>
</li>
<li><p><code>Animated</code>提供了两种类型的值：</p>
<ul>
<li><code>Animated.Value()</code>用于单个值</li>
<li><code>Animated.ValueXY()</code>用于矢量值</li>
<li><code>Animated.Value</code>可以绑定到样式或是其他属性上，也可以进行插值运算, 单个<code>Animated.Value</code>可以用在任意多个属性上</li>
</ul>
</li>
</ul>
<h3 id="配置动画"><a href="#配置动画" class="headerlink" title="配置动画"></a>配置动画</h3><p><code>Animated</code>提供了三种动画类型。每种动画类型都提供了特定的函数曲线，用于控制动画值从初始值变化到最终值的变化过程:</p>
<ul>
<li><code>Animated.timing()</code>：最常用的动画类型，使一个值按照一个过渡曲线而随时间变化。</li>
<li><code>Animated.spring()</code>：弹簧效果，基础的单次弹跳物理模型实现的 spring 动画。</li>
<li><code>Animated.decay()</code>：衰变效果，以一个初始的速度和一个衰减系数逐渐减慢变为0</li>
</ul>
<h3 id="组合动画"><a href="#组合动画" class="headerlink" title="组合动画"></a>组合动画</h3><p><code>Animated</code>实现组合动画的主要方式：</p>
<ul>
<li><code>Animated.parallel</code>：同时开始一个动画数组里的全部动画。默认情况下，如果有任何一个动画停止了，其余的也会被停止。可以通过<code>stopTogether</code>选项设置为<code>false</code>来取消这种关联。</li>
<li><code>Animated.sequence</code>：按顺序执行一个动画数组里的动画，等待一个完成后再执行下一个。如果当前的动画被中止，后面的动画则不会继续执行</li>
<li><code>Animated.stagger</code>：一个动画数组，传入一个时间参数来设置队列动画间的延迟，即在前一个动画开始之后，隔一段指定时间才开始执行下一个动画里面的动画，并不关心前一个动画是否已经完成，所以有可能会出现同时执行（重叠）的情况</li>
</ul>
<h3 id="自定义动画组件"><a href="#自定义动画组件" class="headerlink" title="自定义动画组件"></a>自定义动画组件</h3><p>组件必须经过特殊处理才能用于动画。所谓的特殊处理主要是指把动画值绑定到属性上，并且在一帧帧执行动画时避免反应重新渲染和重新调和的开销。此外还得在组件卸载时做一些清理工作，使得这些组件在使用时是安全的</p>
<blockquote>
<p><code>createAnimatedComponent()</code>方法正是用来处理组件，使其可以用于动画</p>
</blockquote>
<p><code>Animated</code>中默认导出了以下这些可以直接使用的动画组件，当然它们都是通过使用上面这个方法进行了封装：</p>
<ul>
<li><code>Animated.Image</code></li>
<li><code>Animated.ScrollView</code></li>
<li><code>Animated.Text</code></li>
<li><code>Animated.View</code></li>
</ul>
<h3 id="合成动画值"><a href="#合成动画值" class="headerlink" title="合成动画值"></a>合成动画值</h3><p>你可以使用加减乘除以及取余等运算来把两个动画值合成为一个新的动画值。</p>
<ul>
<li><code>Animated.add()</code></li>
<li><code>Animated.divide()</code></li>
<li><code>Animated.modulo()</code></li>
<li><code>Animated.multiply()</code></li>
</ul>
<h2 id="timing动画"><a href="#timing动画" class="headerlink" title="timing动画"></a>timing动画</h2><p>常用的线性动画, 使组件随时间变化从一个<code>fromValue</code>按照一个过渡曲线变化到一个<code>toValue</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">timing</span>: <span class="function">(<span class="params">value: AnimatedValue | AnimatedValueXY, config: TimingAnimationConfig</span>) =&gt;</span> <span class="title class_">CompositeAnimation</span>;</span><br></pre></td></tr></table></figure>

<p><code>config</code>参数介绍</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface <span class="title class_">TimingAnimationConfig</span> <span class="keyword">extends</span> <span class="title class_">AnimationConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 终点值</span></span><br><span class="line">    <span class="attr">toValue</span>: number | <span class="title class_">AnimatedValue</span> | &#123; <span class="attr">x</span>: number; <span class="attr">y</span>: number &#125; | <span class="title class_">AnimatedValueXY</span>;</span><br><span class="line">    <span class="comment">// 渐变函数</span></span><br><span class="line">    easing?: <span class="function">(<span class="params">value: number</span>) =&gt;</span> number;</span><br><span class="line">    <span class="comment">// 动画持续时间</span></span><br><span class="line">    duration?: number;</span><br><span class="line">    <span class="comment">// 延迟时间</span></span><br><span class="line">    delay?: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码示例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Animation</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">   <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">       <span class="variable language_">super</span>(props)</span><br><span class="line"></span><br><span class="line">       <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">           <span class="attr">fadeOutOpacity</span>: <span class="keyword">new</span> <span class="title class_">Animated</span>.<span class="title class_">Value</span>(<span class="number">1</span>),</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="variable language_">this</span>.<span class="property">fadeOutAnimated</span> = <span class="title class_">Animated</span>.<span class="title function_">timing</span>(</span><br><span class="line">           <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">fadeOutOpacity</span>,</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="attr">toValue</span>: <span class="number">0</span>,  <span class="comment">//透明度动画最终值</span></span><br><span class="line">               <span class="attr">duration</span>: <span class="number">3000</span>,   <span class="comment">//动画时长3000毫秒</span></span><br><span class="line">               <span class="attr">easing</span>: <span class="title class_">Easing</span>.<span class="property">linear</span>,</span><br><span class="line">           &#125;</span><br><span class="line">       );</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="title function_">_startAnimated</span>(<span class="params"></span>) &#123;</span><br><span class="line">       <span class="variable language_">this</span>.<span class="property">fadeOutAnimated</span>.<span class="title function_">start</span>(<span class="function">() =&gt;</span> <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">fadeOutOpacity</span>.<span class="title function_">setValue</span>(<span class="number">1</span>));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> (</span><br><span class="line">           <span class="language-xml"><span class="tag">&lt;<span class="name">View</span> <span class="attr">style</span>=<span class="string">&#123;&#123;flex:</span> <span class="attr">1</span>, <span class="attr">backgroundColor:</span> &#x27;#<span class="attr">f7f7f7</span>&#x27;, <span class="attr">marginTop:</span> <span class="attr">88</span>, <span class="attr">marginBottom:</span> <span class="attr">34</span>&#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">Animated.View</span> <span class="attr">style</span>=<span class="string">&#123;&#123;marginTop:</span> <span class="attr">100</span>,<span class="attr">width:</span> <span class="attr">200</span>, <span class="attr">height:</span> <span class="attr">200</span>, <span class="attr">opacity:</span> <span class="attr">this.state.fadeOutOpacity</span>&#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">                   <span class="tag">&lt;<span class="name">View</span> <span class="attr">style</span>=<span class="string">&#123;&#123;width:200,height:200,backgroundColor:</span> &#x27;<span class="attr">red</span>&#x27;&#125;&#125;/&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">Animated.View</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">               <span class="tag">&lt;<span class="name">TouchableOpacity</span> <span class="attr">style</span>=<span class="string">&#123;&#123;marginLeft:</span> <span class="attr">50</span>&#125;&#125; <span class="attr">onPress</span>=<span class="string">&#123;this._startAnimated.bind(this)&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                   <span class="tag">&lt;<span class="name">Text</span> <span class="attr">style</span>=<span class="string">&#123;&#123;width:200,height:100,textAlign:</span>&#x27;<span class="attr">center</span>&#x27;,<span class="attr">lineHeight:100</span>&#125;&#125;&gt;</span>点击开始动画<span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">               <span class="tag">&lt;/<span class="name">TouchableOpacity</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">           <span class="tag">&lt;/<span class="name">View</span>&gt;</span></span></span><br><span class="line">       );</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="spring"><a href="#spring" class="headerlink" title="spring"></a>spring</h2><p>弹簧动画, 基础的单词弹跳物理模型实现的<code>spring</code>动画</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">spring</span>(<span class="params">value: AnimatedValue | AnimatedValueXY, config: SpringAnimationConfig</span>): <span class="title class_">CompositeAnimation</span>;</span><br></pre></td></tr></table></figure>

<p><code>config</code>参数格式介绍</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface <span class="title class_">SpringAnimationConfig</span> <span class="keyword">extends</span> <span class="title class_">AnimationConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 目标值</span></span><br><span class="line">    <span class="attr">toValue</span>: number | <span class="title class_">AnimatedValue</span> | &#123; <span class="attr">x</span>: number; <span class="attr">y</span>: number &#125; | <span class="title class_">AnimatedValueXY</span>;</span><br><span class="line">    <span class="comment">// 反弹系数，默认为8</span></span><br><span class="line">    bounciness?: number;</span><br><span class="line">    <span class="comment">// 控制动画的速度，默认为12</span></span><br><span class="line">    speed?: number;</span><br><span class="line">    <span class="comment">// 控制速度，默认为40</span></span><br><span class="line">    tension?: number;</span><br><span class="line">    <span class="comment">// 控制“弹跳系数”、夸张系数，默认为7</span></span><br><span class="line">    friction?: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">SpingAnimated</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(props)</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">            <span class="attr">springValue</span>: <span class="keyword">new</span> <span class="title class_">Animated</span>.<span class="title class_">Value</span>(<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">springAnimated</span> = <span class="title class_">Animated</span>.<span class="title function_">spring</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">springValue</span>, &#123;</span><br><span class="line">            <span class="attr">toValue</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">duration</span>: <span class="number">2000</span>,</span><br><span class="line">            <span class="attr">tension</span>: <span class="number">10</span>,</span><br><span class="line">            <span class="attr">friction</span>: <span class="number">2</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">_startAnimated</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">springValue</span>.<span class="title function_">setValue</span>(<span class="number">0.1</span>);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">springAnimated</span>.<span class="title function_">start</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">View</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">width:</span> <span class="attr">414</span>, <span class="attr">height:</span> <span class="attr">800</span>, <span class="attr">backgroundColor:</span> &#x27;<span class="attr">yellow</span>&#x27;, <span class="attr">alignItems:</span> &#x27;<span class="attr">center</span>&#x27;, <span class="attr">justifyContent:</span> &#x27;<span class="attr">center</span>&#x27; &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">Animated.View</span> <span class="attr">style</span>=<span class="string">&#123;&#123;width:</span> <span class="attr">100</span>, <span class="attr">height:</span> <span class="attr">100</span>, <span class="attr">backgroundColor:</span> &#x27;<span class="attr">red</span>&#x27;, <span class="attr">transform:</span> [&#123;<span class="attr">scale:</span> <span class="attr">this.state.springValue</span>&#125;]&#125;&#125;/&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">TouchableOpacity</span> <span class="attr">style</span>=<span class="string">&#123;&#123;position:</span>&#x27;<span class="attr">absolute</span>&#x27;, <span class="attr">bottom:</span> <span class="attr">50</span>&#125;&#125; <span class="attr">onPress</span>=<span class="string">&#123;this._startAnimated.bind(this)&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">Text</span> <span class="attr">style</span>=<span class="string">&#123;&#123;width:200,height:100,textAlign:</span>&#x27;<span class="attr">center</span>&#x27;,<span class="attr">lineHeight:100</span>&#125;&#125;&gt;</span>点击开始动画<span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">TouchableOpacity</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">View</span>&gt;</span></span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>






]]></content>
      <categories>
        <category>ReactNaive</category>
      </categories>
      <tags>
        <tag>ReactNative</tag>
        <tag>Animated</tag>
      </tags>
  </entry>
  <entry>
    <title>ReactiveCocoa 的一些高级用法</title>
    <url>/post/e1fe9ce0.html</url>
    <content><![CDATA[<ul>
<li>之前已经有两篇文章介绍了<code>ReactiveCocoa</code>的一些见解和用法, 这里也就不再作介绍了</li>
<li>其中第一篇文章介绍了<a href="http://www.titanjun.top/2018/03/19/ReactiveCocoa%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A301/">ReactiveCocoa关于RACSingle的使用详解</a></li>
<li>第二篇文章介绍了<a href="http://www.titanjun.top/2018/03/21/ReactiveCocoa%E4%B9%8B%E9%9B%86%E5%90%88%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A302/">ReactiveCocoa之集合使用详解</a></li>
<li>有兴趣的可以先去看看这两篇文章</li>
<li>接下来我们就着重介绍一些<code>Map</code>, <code>concat</code>等高级用法</li>
</ul>
<span id="more"></span>

<h2 id="ReactiveCocoa常见操作介绍"><a href="#ReactiveCocoa常见操作介绍" class="headerlink" title="ReactiveCocoa常见操作介绍"></a>ReactiveCocoa常见操作介绍</h2><h3 id="ReactiveCocoa操作须知"><a href="#ReactiveCocoa操作须知" class="headerlink" title="ReactiveCocoa操作须知"></a>ReactiveCocoa操作须知</h3><ul>
<li>所有的信号<code>RACSignal</code>都可以进行操作处理，因为所有操作方法都定义在RACStream.h中，因此只要继承RACStream就有了操作处理方法。</li>
</ul>
<h3 id="ReactiveCocoa操作思想"><a href="#ReactiveCocoa操作思想" class="headerlink" title="ReactiveCocoa操作思想"></a>ReactiveCocoa操作思想</h3><ul>
<li>运用的是Hook（钩子）思想，Hook是一种用于改变API(应用程序编程接口：方法)执行结果的技术.</li>
<li>Hook用处：截获API调用的技术。</li>
<li>Hook原理：在每次调用一个API返回结果之前，先执行你自己的方法，改变结果的输出</li>
</ul>
<h2 id="高级操作"><a href="#高级操作" class="headerlink" title="高级操作"></a>高级操作</h2><h3 id="ReactiveCocoa核心方法bind"><a href="#ReactiveCocoa核心方法bind" class="headerlink" title="ReactiveCocoa核心方法bind"></a>ReactiveCocoa核心方法bind</h3><ul>
<li><code>ReactiveCocoa</code>操作的核心方法是<code>bind</code>（绑定）,而且RAC中核心开发方式，也是绑定，之前的开发方式是赋值，而用RAC开发，应该把重心放在绑定，也就是可以在创建一个对象的时候，就绑定好以后想要做的事情，而不是等赋值之后在去做事情。</li>
<li>在开发中很少使用bind方法，bind属于RAC中的底层方法，RAC已经封装了很多好用的其他方法，底层都是调用bind，用法比bind简单.</li>
<li>bind方法简单介绍和使用<ul>
<li>需求: 监听文本框的内容, 每次输出的时候, 在内容后面品尚字符串<code>&quot;jun&quot;</code>, 并显示在<code>label</code>上</li>
</ul>
</li>
</ul>
<p>方式一: 在返回结果后, 拼接字符串</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">@weakify(<span class="keyword">self</span>)</span><br><span class="line">[_textField.rac_textSignal subscribeNext:^(<span class="built_in">NSString</span> * _Nullable x) &#123;</span><br><span class="line">    @strongify(<span class="keyword">self</span>)</span><br><span class="line">    <span class="keyword">self</span>.showLabel.text = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@+%@&quot;</span>, x, <span class="string">@&quot;jun&quot;</span>];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>方式二: 在返回结果前, 拼接字符串, 用bind方法操作</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[[_textField.rac_textSignal bind:^RACSignalBindBlock _Nonnull&#123;</span><br><span class="line">    <span class="keyword">return</span> ^RACSignal *(<span class="type">id</span> value, <span class="type">BOOL</span> *stop)&#123;</span><br><span class="line">        <span class="keyword">return</span> [RACReturnSignal <span class="keyword">return</span>:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;输出: %@&quot;</span>, value]];</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;] subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<ul>
<li><code>bind</code>方法介绍<ul>
<li><code>bind</code>方法参数:需要传入一个返回值是<code>RACStreamBindBlock</code>的<code>block</code>参数</li>
<li><code>RACStreamBindBlock</code>是一个<code>block</code>的类型，返回值是信号，参数<code>（value,stop）</code>，因此参数的<code>block</code>返回值也是一个<code>block</code></li>
<li>如下:</li>
</ul>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> RACSignal * _Nullable (^RACSignalBindBlock)(ValueType _Nullable value, <span class="type">BOOL</span> *stop);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><code>RACStreamBindBlock</code>:<ul>
<li>参数一(value): 表示接收到信号的原始值，还没做处理</li>
<li>参数二<code>*stop</code>: 用来控制绑定<code>Block</code>，如果<code>*stop</code> &#x3D; yes,那么就会结束绑定。</li>
<li>返回值：信号，做好处理，在通过这个信号返回出去，一般使用<code>RACReturnSignal</code>,需要手动导入头文件<code>RACReturnSignal.h</code></li>
</ul>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RACReturnSignal</span>&lt;<span class="title">__covariant</span> <span class="title">ValueType</span>&gt; : <span class="title">RACSignal</span>&lt;<span class="title">ValueType</span>&gt;</span></span><br><span class="line"></span><br><span class="line">+ (RACSignal&lt;ValueType&gt; *)<span class="keyword">return</span>:(ValueType)value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<ul>
<li>bind方法使用步骤:<ul>
<li>传入一个返回值<code>RACStreamBindBlock</code>的<code>block</code></li>
<li>描述一个<code>RACStreamBindBlock</code>类型的<code>bindBlock</code>作为<code>block</code>的返回值。</li>
<li>描述一个返回结果的信号，作为<code>bindBlock</code>的返回值。</li>
<li>注意：在<code>bindBlock</code>中做信号结果的处理</li>
</ul>
</li>
<li>bind底层实现:<ul>
<li>源信号调用bind,会重新创建一个绑定信号。</li>
<li>当绑定信号被订阅，就会调用绑定信号中的<code>didSubscribe</code>，生成一个<code>bindingBlock</code>。</li>
<li>当源信号有内容发出，就会把内容传递到<code>bindingBlock</code>处理，调用<code>bindingBlock(value,stop)</code></li>
<li>调用<code>bindingBlock(value,stop)</code>，会返回一个内容处理完成的信号<code>（RACReturnSignal）</code>。</li>
<li>订阅<code>RACReturnSignal</code>，就会拿到绑定信号的订阅者，把处理完成的信号内容发送出来</li>
</ul>
</li>
</ul>
<h3 id="映射-flattenMap-Map"><a href="#映射-flattenMap-Map" class="headerlink" title="映射(flattenMap,Map)"></a>映射(flattenMap,Map)</h3><ul>
<li><code>flattenMap</code>，<code>Map</code>用于把源信号内容映射成新的内容</li>
<li>在<code>Swift</code>中系统API就已经有了这些函数的用法, 详情可参考我的这篇文章<a href="http://www.titanjun.top/2017/05/19/Swift%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B9%8BMap&Reduce&Filter/">Swift函数式编程之Map&amp;Reduce&amp;Filter</a></li>
</ul>
<h4 id="flattenMap"><a href="#flattenMap" class="headerlink" title="flattenMap"></a><code>flattenMap</code></h4><p>把源信号的内容映射成一个新的信号，信号可以是任意类型</p>
<ul>
<li><code>flattenMap</code>使用步骤:<ul>
<li>传入一个<code>block</code>，<code>block</code>类型是返回值<code>RACStream</code>，参数<code>value</code></li>
<li>参数<code>value</code>就是源信号的内容，拿到源信号的内容做处理</li>
<li>包装成<code>RACReturnSignal</code>信号，返回出去</li>
</ul>
</li>
<li><code>flattenMap</code>底层实现:<ul>
<li>0.<code>flattenMap</code>内部调用<code>bind</code>方法实现的,<code>flattenMap</code>中<code>block</code>的返回值，会作为<code>bind</code>中<code>bindBlock</code>的返回值。</li>
<li>1.当订阅绑定信号，就会生成<code>bindBlock</code>。</li>
<li>2.当源信号发送内容，就会调用<code>bindBlock(value, *stop)</code></li>
<li>3.调用<code>bindBlock</code>，内部就会调用<code>flattenMap</code>的<code>block</code>，<code>flattenMap</code>的<code>block</code>作用：就是把处理好的数据包装成信号</li>
<li>4.返回的信号最终会作为<code>bindBlock</code>中的返回信号，当做<code>bindBlock</code>的返回信号。</li>
<li>5.订阅<code>bindBlock</code>的返回信号，就会拿到绑定信号的订阅者，把处理完成的信号内容发送出来</li>
</ul>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (__kindof RACStream *)flattenMap:(__kindof RACStream * (^)(<span class="type">id</span> value))block &#123;</span><br><span class="line">	Class <span class="keyword">class</span> = <span class="keyword">self</span>.class;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> [[<span class="keyword">self</span> bind:^&#123;</span><br><span class="line">		<span class="keyword">return</span> ^(<span class="type">id</span> value, <span class="type">BOOL</span> *stop) &#123;</span><br><span class="line">			<span class="type">id</span> stream = block(value) ?: [<span class="keyword">class</span> empty];</span><br><span class="line">			<span class="built_in">NSCAssert</span>([stream isKindOfClass:RACStream.class], <span class="string">@&quot;Value returned from -flattenMap: is not a stream: %@&quot;</span>, stream);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> stream;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;] setNameWithFormat:<span class="string">@&quot;[%@] -flattenMap:&quot;</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单使用</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">@weakify(<span class="keyword">self</span>)</span><br><span class="line">[[_textField.rac_textSignal flattenMap:^__kindof RACSignal * _Nullable(<span class="built_in">NSString</span> * _Nullable value) &#123;</span><br><span class="line">    <span class="comment">//源信号发出的时候，就会调用这个block。</span></span><br><span class="line">    <span class="comment">// 返回值：绑定信号的内容.</span></span><br><span class="line">    <span class="keyword">return</span> [RACReturnSignal <span class="keyword">return</span>:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;flat输出: %@&quot;</span>, value]];</span><br><span class="line">&#125;] subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    @strongify(<span class="keyword">self</span>)</span><br><span class="line">    <span class="comment">//订阅绑定信号, 每当原信号发送内容, 处理后, 就会调用这个black</span></span><br><span class="line">    <span class="keyword">self</span>.showLabel.text = x;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p>Map作用:把源信号的值映射成一个新的值</p>
<ul>
<li><code>Map</code>使用步骤:<ul>
<li>传入一个<code>block</code>,类型是返回对象，参数是<code>value</code></li>
<li><code>value</code>就是源信号的内容，直接拿到源信号的内容做处理</li>
<li>把处理好的内容，直接返回就好了，不用包装成信号，返回的值，就是映射的值。</li>
</ul>
</li>
<li><code>Map</code>底层实现:<ul>
<li><code>Map</code>底层其实是调用<code>flatternMap</code>, Map中<code>block</code>中的返回的值会作为<code>flatternMap</code>中block中的值。</li>
<li>当订阅绑定信号，就会生成<code>bindBlock</code>。</li>
<li>当源信号发送内容，就会调用<code>bindBlock(value, *stop)</code></li>
<li>调用<code>bindBlock</code>，内部就会调用<code>flattenMap</code>的<code>block</code></li>
<li><code>flattenMap</code>的<code>block</code>内部会调用<code>Map</code>中的<code>block</code>，把Map中的<code>block</code>返回的内容包装成返回的信号。</li>
<li>返回的信号最终会作为<code>bindBlock</code>中的返回信号，当做<code>bindBlock</code>的返回信号。</li>
<li>订阅<code>bindBlock</code>的返回信号，就会拿到绑定信号的订阅者，把处理完成的信号内容发送出来</li>
</ul>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (__kindof RACStream *)map:(<span class="type">id</span> (^)(<span class="type">id</span> value))block &#123;</span><br><span class="line">	<span class="built_in">NSCParameterAssert</span>(block != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">	Class <span class="keyword">class</span> = <span class="keyword">self</span>.class;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> [[<span class="keyword">self</span> flattenMap:^(<span class="type">id</span> value) &#123;</span><br><span class="line">		<span class="keyword">return</span> [<span class="keyword">class</span> <span class="keyword">return</span>:block(value)];</span><br><span class="line">	&#125;] setNameWithFormat:<span class="string">@&quot;[%@] -map:&quot;</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单使用</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Map</span></span><br><span class="line">[[_textField.rac_textSignal map:^<span class="type">id</span> _Nullable(<span class="built_in">NSString</span> * _Nullable value) &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;map输出: %@&quot;</span>, value];</span><br><span class="line">&#125;] subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    @strongify(<span class="keyword">self</span>)</span><br><span class="line">    <span class="keyword">self</span>.showLabel.text = x;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">//对数组的处理</span></span><br><span class="line"><span class="built_in">NSArray</span> *arr = @[<span class="string">@&quot;2&quot;</span>, <span class="string">@&quot;3&quot;</span>, <span class="string">@&quot;a&quot;</span>, <span class="string">@&quot;g&quot;</span>];</span><br><span class="line">RACSequence *sequence = [arr.rac_sequence map:^<span class="type">id</span> _Nullable(<span class="type">id</span>  _Nullable value) &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;-%@-&quot;</span>, value];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, [sequence array]);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*输出: </span></span><br><span class="line"><span class="comment">2018-03-24 14:13:32.421337+0800 ReactiveObjc[9043:492929] (</span></span><br><span class="line"><span class="comment">    &quot;-2-&quot;,</span></span><br><span class="line"><span class="comment">    &quot;-3-&quot;,</span></span><br><span class="line"><span class="comment">    &quot;-a-&quot;,</span></span><br><span class="line"><span class="comment">    &quot;-g-&quot;</span></span><br><span class="line"><span class="comment">)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="FlatternMap-和-Map的区别"><a href="#FlatternMap-和-Map的区别" class="headerlink" title="FlatternMap 和 Map的区别"></a><code>FlatternMap</code> 和 <code>Map</code>的区别</h4><ul>
<li><code>FlatternMap</code>中的<code>Block</code>返回信号。</li>
<li><code>Map</code>中的<code>Block</code>返回对象。</li>
<li>开发中，如果信号发出的值不是信号，映射一般使用<code>Map</code></li>
<li>开发中，如果信号发出的值是信号，映射一般使用<code>FlatternMap</code></li>
<li>信号中信号<ul>
<li>当一个信号需要返回另一个信号中的值的时候</li>
<li>让我们来看看下面这个例子</li>
</ul>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> 信号中信号</span></span><br><span class="line">- (<span class="type">void</span>)singleAndSingle &#123;</span><br><span class="line">    <span class="comment">//创建信号中信号</span></span><br><span class="line">    RACSubject *sonSingle = [RACSubject subject];</span><br><span class="line">    RACSubject *single = [RACSubject subject];</span><br><span class="line">    </span><br><span class="line">    [[sonSingle flattenMap:^__kindof RACSignal * _Nullable(<span class="type">id</span>  _Nullable value) &#123;</span><br><span class="line">        <span class="comment">//sonSingle发送信号时, 才会调用</span></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;] subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="comment">//只有sonSingle的子信号, 大宋消息时, 才会调用</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;输出: %@&quot;</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//信号中信号发送子信号</span></span><br><span class="line">    [sonSingle sendNext:single];</span><br><span class="line">    <span class="comment">//子信号发送内容</span></span><br><span class="line">    [single sendNext:@<span class="number">123</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><h4 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h4><p>按照某一固定顺序拼接信号，当多个信号发出的时候，有顺序的接收信号</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//让我们先看一下一般的正常操作</span></span><br><span class="line">- (<span class="type">void</span>)setConcatAction &#123;</span><br><span class="line">    <span class="comment">//当需要按顺序执行的时候: 先执行A, 在执行B</span></span><br><span class="line">    RACSubject *subjectA = [RACSubject subject];</span><br><span class="line">    RACSubject *subjectB = [RACReplaySubject subject];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSMutableArray</span> *array = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//订阅信号</span></span><br><span class="line">    [subjectA subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">        [array addObject:x];</span><br><span class="line">    &#125;];</span><br><span class="line">    [subjectB subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">        [array addObject:x];</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//发送信号</span></span><br><span class="line">    [subjectB sendNext:<span class="string">@&quot;B&quot;</span>];</span><br><span class="line">    [subjectA sendNext:<span class="string">@&quot;A&quot;</span>];</span><br><span class="line">    [subjectA sendCompleted];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//输出: [B, A]</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, array);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>很明显, 上述的结果并未达到我们的需求: 限制性A, 在执行B</li>
<li>下面我们看看使用<code>concat</code>后的执行情况</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)setConcatAction &#123;</span><br><span class="line">    <span class="comment">//当需要按顺序执行的时候: 先执行A, 在执行B</span></span><br><span class="line">    RACSubject *subC = [RACSubject subject];</span><br><span class="line">    RACSubject *subD = [RACReplaySubject subject];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSMutableArray</span> *array2 = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//订阅信号</span></span><br><span class="line">    [[subC concat:subD] subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">        [array2 addObject:x];</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//发送信号</span></span><br><span class="line">    [subD sendNext:<span class="string">@&quot;D&quot;</span>];</span><br><span class="line">    [subC sendNext:<span class="string">@&quot;C&quot;</span>];</span><br><span class="line">    [subC sendCompleted];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//输出: [C, D]</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, array2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>可以看到, 输出的结果和我们预想的一样, 顺序输出</li>
<li>那么, <code>concat</code>的底层到底是如何实现的呢?</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (RACSignal *)concat:(RACSignal *)signal &#123;</span><br><span class="line">	<span class="keyword">return</span> [[RACSignal createSignal:^(<span class="type">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">		RACCompoundDisposable *compoundDisposable = [[RACCompoundDisposable alloc] init];</span><br><span class="line"></span><br><span class="line">		RACDisposable *sourceDisposable = [<span class="keyword">self</span> subscribeNext:^(<span class="type">id</span> x) &#123;</span><br><span class="line">			[subscriber sendNext:x];</span><br><span class="line">		&#125; error:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">			[subscriber sendError:error];</span><br><span class="line">		&#125; completed:^&#123;</span><br><span class="line">			RACDisposable *concattedDisposable = [signal subscribe:subscriber];</span><br><span class="line">			[compoundDisposable addDisposable:concattedDisposable];</span><br><span class="line">		&#125;];</span><br><span class="line"></span><br><span class="line">		[compoundDisposable addDisposable:sourceDisposable];</span><br><span class="line">		<span class="keyword">return</span> compoundDisposable;</span><br><span class="line">	&#125;] setNameWithFormat:<span class="string">@&quot;[%@] -concat: %@&quot;</span>, <span class="keyword">self</span>.name, signal];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>concat</code>底层实现:<ul>
<li>当拼接信号被订阅，就会调用拼接信号的<code>didSubscribe</code></li>
<li><code>didSubscribe</code>中，会先订阅第一个源信号<code>subjectA</code></li>
<li>会执行第一个源信号<code>subjectA</code>的<code>didSubscribe</code></li>
<li>第一个源信号<code>subjectA</code>的<code>didSubscribe</code>中发送值，就会调用第一个源信号<code>subjectA</code>订阅者的<code>nextBlock</code>, 通过拼接信号的订阅者把值发送出来.</li>
<li>第一个源信号<code>subjectA</code>的<code>didSubscribe</code>中发送完成，就会调用第一个源信号<code>subjectA</code>订阅者的<code>completedBlock</code>,订阅第二个源信号<code>subjectB</code>这时候才激活<code>subjectB</code></li>
<li>订阅第二个源信号<code>subjectB</code>,执行第二个源信<code>subjectB</code>号的<code>didSubscribe</code></li>
<li>第二个源信号<code>subjectB</code>的<code>didSubscribe</code>中发送值,就会通过拼接信号的订阅者把值发送出来.</li>
</ul>
</li>
</ul>
<h4 id="then"><a href="#then" class="headerlink" title="then"></a>then</h4><p>用于连接两个信号，当第一个信号完成，才会连接then返回的信号</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (RACSignal *)then:(RACSignal * (^)(<span class="type">void</span>))block &#123;</span><br><span class="line">	<span class="built_in">NSCParameterAssert</span>(block != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> [[[<span class="keyword">self</span></span><br><span class="line">		ignoreValues]</span><br><span class="line">		concat:[RACSignal defer:block]]</span><br><span class="line">		setNameWithFormat:<span class="string">@&quot;[%@] -then:&quot;</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ignoreValues底层实现</span></span><br><span class="line">- (RACSignal *)ignoreValues &#123;</span><br><span class="line">	<span class="keyword">return</span> [[<span class="keyword">self</span> filter:^(<span class="type">id</span> _) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">	&#125;] setNameWithFormat:<span class="string">@&quot;[%@] -ignoreValues&quot;</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>实现原理<ul>
<li>底层会调用<code>filter</code>过滤掉本身信号发出的值(<code>filter</code>后面会讲到)</li>
<li>然后再使用<code>concat</code>连接<code>then</code>返回的信号</li>
<li>下面是测试用例</li>
</ul>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)setThenAction &#123;</span><br><span class="line">    RACSubject *subjectA = [RACReplaySubject subject];</span><br><span class="line">    RACSubject *subjectB = [RACReplaySubject subject];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//发送信号</span></span><br><span class="line">    [subjectA sendNext:<span class="string">@&quot;A&quot;</span>];</span><br><span class="line">    [subjectA sendCompleted];</span><br><span class="line">    [subjectB sendNext:<span class="string">@&quot;B&quot;</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//订阅信号</span></span><br><span class="line">    [[subjectA then:^RACSignal * _Nonnull&#123;</span><br><span class="line">        <span class="keyword">return</span> subjectB;</span><br><span class="line">    &#125;] subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这里只会输出: B</span></span><br><span class="line">    <span class="comment">//不会输出: A</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h4><p>把多个信号合并为一个信号，任何一个信号有新值的时候就会调用</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (RACSignal *)merge:(RACSignal *)signal &#123;</span><br><span class="line">	<span class="keyword">return</span> [[RACSignal</span><br><span class="line">		merge:@[ <span class="keyword">self</span>, signal ]]</span><br><span class="line">		setNameWithFormat:<span class="string">@&quot;[%@] -merge: %@&quot;</span>, <span class="keyword">self</span>.name, signal];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (RACSignal *)merge:(<span class="type">id</span>&lt;<span class="built_in">NSFastEnumeration</span>&gt;)signals &#123;</span><br><span class="line">	<span class="built_in">NSMutableArray</span> *copiedSignals = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">	<span class="keyword">for</span> (RACSignal *signal <span class="keyword">in</span> signals) &#123;</span><br><span class="line">		[copiedSignals addObject:signal];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> [[[RACSignal</span><br><span class="line">		createSignal:^ RACDisposable * (<span class="type">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">			<span class="keyword">for</span> (RACSignal *signal <span class="keyword">in</span> copiedSignals) &#123;</span><br><span class="line">				[subscriber sendNext:signal];</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			[subscriber sendCompleted];</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">		&#125;]</span><br><span class="line">		flatten]</span><br><span class="line">		setNameWithFormat:<span class="string">@&quot;+merge: %@&quot;</span>, copiedSignals];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>底层实现<ul>
<li>1.合并信号被订阅的时候，就会遍历所有信号，并且发出这些信号。</li>
<li>2.每发出一个信号，这个信号就会被订阅</li>
<li>3.也就是合并信号一被订阅，就会订阅里面所有的信号。</li>
<li>4.只要有一个信号被发出就会被监听。</li>
</ul>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)setMergeAction &#123;</span><br><span class="line">    <span class="comment">// 只要想无序的整合信号数据</span></span><br><span class="line">    RACSubject *subjectA = [RACSubject subject];</span><br><span class="line">    RACSubject *subjectB = [RACSubject subject];</span><br><span class="line">    RACSubject *subjectC = [RACSubject subject];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//合并信号</span></span><br><span class="line">    RACSignal *single = [[subjectA merge:subjectB] merge:subjectC];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//订阅信号</span></span><br><span class="line">    [single subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//发出消息</span></span><br><span class="line">    [subjectA sendNext:<span class="string">@&quot;A&quot;</span>];</span><br><span class="line">    [subjectC sendNext:<span class="string">@&quot;C&quot;</span>];</span><br><span class="line">    [subjectB sendNext:<span class="string">@&quot;B&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果(分别输出): A, C, B</span></span><br></pre></td></tr></table></figure>

<h4 id="zipWith"><a href="#zipWith" class="headerlink" title="zipWith"></a>zipWith</h4><p>把两个信号压缩成一个信号，只有当两个信号同时发出信号内容时，并且把两个信号的内容合并成一个元组，才会触发压缩流的next事件</p>
<ul>
<li>底层实现:<ul>
<li>1.定义压缩信号，内部就会自动订阅<code>subjectA</code>，<code>subjectB</code></li>
<li>2.每当<code>subjectA</code>或者<code>subjectB</code>发出信号，就会判断<code>subjectA</code>，<code>subjectB</code>有没有发出个信号，有就会把最近发出的信号都包装成元组发出。</li>
</ul>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)setZipwithAction &#123;</span><br><span class="line">    <span class="comment">// 只要想无序的整合信号数据</span></span><br><span class="line">    RACSubject *subjectA = [RACSubject subject];</span><br><span class="line">    RACSubject *subjectB = [RACSubject subject];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//合并信号</span></span><br><span class="line">    RACSignal *single = [subjectA zipWith:subjectB];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//订阅信号</span></span><br><span class="line">    [single subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//发出消息</span></span><br><span class="line">    [subjectA sendNext:<span class="string">@&quot;A&quot;</span>];</span><br><span class="line">    [subjectB sendNext:<span class="string">@&quot;B&quot;</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 输出:</span></span><br><span class="line"><span class="comment">     (A, B)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="combineLatest"><a href="#combineLatest" class="headerlink" title="combineLatest"></a>combineLatest</h4><ul>
<li>将多个信号合并起来，并且拿到各个信号的最新的值</li>
<li>必须每个合并的信号至少都有过一次<code>sendNext</code>，才会触发合并的信号</li>
<li>这里我们考虑这样一个需求: 在登录页面, 只有在账号密码都输入的情况下, 登录按钮才可点击, 否则不可点击</li>
<li>正常情况下我们需要监听每一个文本框的输入</li>
<li>下面我们来看一下<code>combineLatest</code>控制登录按钮是否可点击</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)setCombineLatest &#123;</span><br><span class="line">    <span class="comment">//把两个信号组合成一个信号,跟zip一样，没什么区别</span></span><br><span class="line">    RACSignal *single = [_accountText.rac_textSignal combineLatestWith:_passwordText.rac_textSignal];</span><br><span class="line">    </span><br><span class="line">    [single subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">        RACTupleUnpack(<span class="built_in">NSString</span> *account, <span class="built_in">NSString</span> *password) = x;</span><br><span class="line">        </span><br><span class="line">        _loginButton.enabled = account.length &gt; <span class="number">0</span> &amp;&amp; password.length &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>底层实现：<ul>
<li>1.当组合信号被订阅，内部会自动订阅两个信号,必须两个信号都发出内容，才会被触发。(而zip, 是两个信号同事发出内容, 才会触发)</li>
<li>2.把两个信号组合成元组发出。</li>
</ul>
</li>
</ul>
<h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h4><p>聚合:用于信号发出是元组的内容，把信号发出元组的值聚合成一个值</p>
<blockquote>
<p>这里我们把上面的代码, 使用<code>RACSingle</code>的一个类方法优化一下</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)setReduceAction &#123;</span><br><span class="line">    <span class="comment">// reduce:把多个信号的值,聚合为一个值</span></span><br><span class="line">    RACSignal *single = [RACSignal combineLatest:@[_accountText.rac_textSignal, _passwordText.rac_textSignal] reduce:^<span class="type">id</span> (<span class="built_in">NSString</span> *account, <span class="built_in">NSString</span> *password)&#123;</span><br><span class="line">        <span class="keyword">return</span> @(account.length &gt; <span class="number">0</span> &amp;&amp; password.length &gt; <span class="number">0</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [single subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">        _loginButton.enabled = [x boolValue];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>RACSingle</code>类方法<ul>
<li>参数一: <code>(id&lt;NSFastEnumeration&gt;)</code>类型   <ul>
<li><code>NSFastEnumeration</code>我们在上一篇文章<a href="https://www.titanjun.top/2018/03/21/ReactiveCocoa%E4%B9%8B%E9%9B%86%E5%90%88%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A302/">ReactiveCocoa之集合使用详解02</a>中简单介绍过</li>
<li><code>NSFastEnumeration</code>: 是一个协议, 所有遵循该协议的类, 均可视为一个数组, 例如<code>NSArray</code></li>
<li>故这里, 应该传一个包含<code>RACSingle</code>信号的数组</li>
</ul>
</li>
<li>参数二: <code>(RACGenericReduceBlock)reduceBlock</code>是一个<code>black</code></li>
</ul>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> ValueType _Nonnull (^RACGenericReduceBlock)();</span><br><span class="line"></span><br><span class="line"><span class="comment">//reduceblcok中的参数，有多少信号组合，reduceblcok就有多少参数，每个参数就是之前信号发出的内容</span></span><br></pre></td></tr></table></figure>

<p>这里用一个宏, 急需将上面的代码简化一下</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)setReduceAction &#123;</span><br><span class="line"></span><br><span class="line">    RAC(_loginButton, enabled) = [RACSignal combineLatest:@[_accountText.rac_textSignal, _passwordText.rac_textSignal] reduce:^<span class="type">id</span> (<span class="built_in">NSString</span> *account, <span class="built_in">NSString</span> *password)&#123;</span><br><span class="line">        <span class="keyword">return</span> @(account.length &gt; <span class="number">0</span> &amp;&amp; password.length &gt; <span class="number">0</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面用到了一个宏<code>RAC</code>, 这里暂不赘述, 以后会集中整理一下 RAC中的宏, 具体实现如下</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RAC(TARGET, ...) \</span></span><br><span class="line"><span class="meta">    metamacro_if_eq(1, metamacro_argcount(__VA_ARGS__)) \</span></span><br><span class="line"><span class="meta">        (RAC_(TARGET, __VA_ARGS__, nil)) \</span></span><br><span class="line"><span class="meta">        (RAC_(TARGET, __VA_ARGS__))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// Do not use this directly. Use the RAC macro above.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RAC_(TARGET, KEYPATH, NILVALUE) \</span></span><br><span class="line"><span class="meta">    [[RACSubscriptingAssignmentTrampoline alloc] initWithTarget:(TARGET) nilValue:(NILVALUE)][@keypath(TARGET, KEYPATH)]</span></span><br></pre></td></tr></table></figure>

<h3 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h3><h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><p>过滤信号, 过滤掉不符合条件的信号</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>) filterAction&#123;</span><br><span class="line">    <span class="comment">//filter</span></span><br><span class="line">    <span class="comment">//截取等于11位的字符</span></span><br><span class="line">    [[_accountText.rac_textSignal filter:^<span class="type">BOOL</span>(<span class="built_in">NSString</span> * _Nullable value) &#123;</span><br><span class="line">        <span class="comment">//类似手机号的输入, 只有等于11位的时候才返回true</span></span><br><span class="line">        <span class="keyword">return</span> value.length == <span class="number">11</span>;</span><br><span class="line">    &#125;]subscribeNext:^(<span class="built_in">NSString</span> * _Nullable x) &#123;</span><br><span class="line">        <span class="comment">//这里只会返回等于11位的字符</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;filter = %@&quot;</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>filter</code>底层是调用的<code>flatMap</code>方法, 如下:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (__kindof RACStream *)filter:(<span class="type">BOOL</span> (^)(<span class="type">id</span> value))block &#123;</span><br><span class="line">	<span class="built_in">NSCParameterAssert</span>(block != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">	Class <span class="keyword">class</span> = <span class="keyword">self</span>.class;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> [[<span class="keyword">self</span> flattenMap:^ <span class="type">id</span> (<span class="type">id</span> value) &#123;</span><br><span class="line">		<span class="keyword">if</span> (block(value)) &#123;</span><br><span class="line">			<span class="keyword">return</span> [<span class="keyword">class</span> <span class="keyword">return</span>:value];</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">class</span>.empty;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;] setNameWithFormat:<span class="string">@&quot;[%@] -filter:&quot;</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ignore"><a href="#ignore" class="headerlink" title="ignore"></a>ignore</h4><p>忽略掉某些特定值的信号</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)setIgnoreAction &#123;</span><br><span class="line">    <span class="comment">///ignore</span></span><br><span class="line">    <span class="comment">//这里的测试只有第一个字符位: m的时候能看到效果</span></span><br><span class="line">    [[_accountText.rac_textSignal ignore:<span class="string">@&quot;m&quot;</span>] subscribeNext:^(<span class="built_in">NSString</span> * _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;ignore = %@&quot;</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//ignoreValues: 忽略所有信号</span></span><br><span class="line">    [[_passwordText.rac_textSignal ignoreValues] subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;allIgnore = %@&quot;</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ignore</code>方法的底层都是调用的<code>filter</code>方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ignore</span></span><br><span class="line">- (__kindof RACStream *)ignore:(<span class="type">id</span>)value &#123;</span><br><span class="line">	<span class="keyword">return</span> [[<span class="keyword">self</span> filter:^ <span class="type">BOOL</span> (<span class="type">id</span> innerValue) &#123;</span><br><span class="line">		<span class="keyword">return</span> innerValue != value &amp;&amp; ![innerValue isEqual:value];</span><br><span class="line">	&#125;] setNameWithFormat:<span class="string">@&quot;[%@] -ignore: %@&quot;</span>, <span class="keyword">self</span>.name, RACDescription(value)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ignoreValues</span></span><br><span class="line">- (RACSignal *)ignoreValues &#123;</span><br><span class="line">	<span class="keyword">return</span> [[<span class="keyword">self</span> filter:^(<span class="type">id</span> _) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">	&#125;] setNameWithFormat:<span class="string">@&quot;[%@] -ignoreValues&quot;</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="distinctUntilChanged"><a href="#distinctUntilChanged" class="headerlink" title="distinctUntilChanged"></a>distinctUntilChanged</h4><ul>
<li>当上一次的值和当前的值有明显的变化就会发出信号，否则会被忽略掉。</li>
<li>在开发中，刷新UI经常使用，只有两次数据不一样才需要刷新</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//distinctUntilChanged</span></span><br><span class="line">- (<span class="type">void</span>)setdistinctUntilChanged &#123;</span><br><span class="line">    <span class="comment">//创建信号</span></span><br><span class="line">    RACSubject *subject = [RACSubject subject];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//订阅</span></span><br><span class="line">    [[subject distinctUntilChanged] subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;distinctUntilChanged = %@&quot;</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [subject sendNext:@<span class="number">12</span>];</span><br><span class="line">    [subject sendNext:@<span class="number">12</span>];</span><br><span class="line">    [subject sendNext:@<span class="number">23</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*输出结果:只会输出两次</span></span><br><span class="line"><span class="comment">     distinctUntilChanged = 12</span></span><br><span class="line"><span class="comment">     distinctUntilChanged = 23</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>distinctUntilChanged</code>底层是调用的<code>bind</code>高级用法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (__kindof RACStream *)distinctUntilChanged &#123;</span><br><span class="line">	Class <span class="keyword">class</span> = <span class="keyword">self</span>.class;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> [[<span class="keyword">self</span> bind:^&#123;</span><br><span class="line">		__block <span class="type">id</span> lastValue = <span class="literal">nil</span>;</span><br><span class="line">		__block <span class="type">BOOL</span> initial = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> ^(<span class="type">id</span> x, <span class="type">BOOL</span> *stop) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!initial &amp;&amp; (lastValue == x || [x isEqual:lastValue])) <span class="keyword">return</span> [<span class="keyword">class</span> empty];</span><br><span class="line"></span><br><span class="line">			initial = <span class="literal">NO</span>;</span><br><span class="line">			lastValue = x;</span><br><span class="line">			<span class="keyword">return</span> [<span class="keyword">class</span> <span class="keyword">return</span>:x];</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;] setNameWithFormat:<span class="string">@&quot;[%@] -distinctUntilChanged&quot;</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="take"><a href="#take" class="headerlink" title="take"></a>take</h4><p>从开始一共取N次的信号, 当遇到<code>sendCompleted</code>语句执行时, 会提前停止发送信号</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)setTakeAndTakeLast &#123;</span><br><span class="line">    <span class="comment">//take</span></span><br><span class="line">    RACSubject *subject1 = [RACSubject subject];</span><br><span class="line">    [[subject1 take:<span class="number">2</span>] subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [subject1 sendNext:@<span class="number">1</span>];</span><br><span class="line">    [subject1 sendNext:@<span class="number">2</span>];</span><br><span class="line">    [subject1 sendCompleted];</span><br><span class="line">    [subject1 sendNext:@<span class="number">3</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//分别输出: 1, 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果上面发送信号的代码调整为</span></span><br><span class="line">    [subject1 sendNext:@<span class="number">1</span>];</span><br><span class="line">    [subject1 sendCompleted];</span><br><span class="line">    [subject1 sendNext:@<span class="number">2</span>];</span><br><span class="line">    [subject1 sendNext:@<span class="number">3</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//那么输出结果将会,只输出: 1</span></span><br></pre></td></tr></table></figure>

<h4 id="takeLast"><a href="#takeLast" class="headerlink" title="takeLast"></a>takeLast</h4><p>取调用<code>sendCompleted</code>之前的N次信号,前提条件，订阅者必须调用<code>sendCompleted</code>，否则不会执行任何操作</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)setTakeAndTakeLast &#123;</span><br><span class="line">    <span class="comment">//takeLast</span></span><br><span class="line">    RACSubject *subject1 = [RACSubject subject];</span><br><span class="line">    [[subject1 takeLast:<span class="number">2</span>] subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [subject1 sendNext:@<span class="number">1</span>];</span><br><span class="line">    [subject1 sendNext:@<span class="number">2</span>];</span><br><span class="line">    [subject1 sendNext:@<span class="number">3</span>];</span><br><span class="line">    [subject1 sendCompleted];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="takeUntil"><a href="#takeUntil" class="headerlink" title="takeUntil"></a>takeUntil</h4><p>只要传入的信号发送完成或者<code>subject2</code>开始发送信号的时候,就不会再接收信号的内容</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)setTakeAndTakeLast &#123;</span><br><span class="line">    <span class="comment">//takeUntil</span></span><br><span class="line">    RACSubject *subject1 = [RACSubject subject];</span><br><span class="line">    RACSubject *subject2 = [RACSubject subject];</span><br><span class="line">    </span><br><span class="line">    [[subject1 takeUntil:subject2] subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [subject1 sendNext:@<span class="number">11</span>];</span><br><span class="line">    [subject1 sendNext:@<span class="number">12</span>];</span><br><span class="line"><span class="comment">//    [subject1 sendCompleted];</span></span><br><span class="line">    [subject1 sendNext:@<span class="number">13</span>];</span><br><span class="line">    [subject2 sendNext:<span class="string">@&quot;21&quot;</span>];</span><br><span class="line">    [subject2 sendNext:<span class="string">@&quot;22&quot;</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这样会输出: 11, 12, 13</span></span><br><span class="line">    <span class="comment">//当sendCompleted取消注释的时候, 只会输出: 11, 12</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="switchToLatest"><a href="#switchToLatest" class="headerlink" title="switchToLatest"></a>switchToLatest</h4><ul>
<li>主要用于信号的信号, 有时候也会发出信号, 会在信号的信号中获取其发送的最新的信号</li>
<li>方法的底层是调用了<code>flattenMap</code>方法</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (RACSignal *)switchToLatest &#123;</span><br><span class="line">	<span class="keyword">return</span> [[RACSignal createSignal:^(<span class="type">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">		RACMulticastConnection *connection = [<span class="keyword">self</span> publish];</span><br><span class="line"></span><br><span class="line">		RACDisposable *subscriptionDisposable = [[connection.signal</span><br><span class="line">			flattenMap:^(RACSignal *x) &#123;</span><br><span class="line">				<span class="built_in">NSCAssert</span>(x == <span class="literal">nil</span> || [x isKindOfClass:RACSignal.class], <span class="string">@&quot;-switchToLatest requires that the source signal (%@) send signals. Instead we got: %@&quot;</span>, <span class="keyword">self</span>, x);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// -concat:[RACSignal never] prevents completion of the receiver from</span></span><br><span class="line">				<span class="comment">// prematurely terminating the inner signal.</span></span><br><span class="line">				<span class="keyword">return</span> [x takeUntil:[connection.signal concat:[RACSignal never]]];</span><br><span class="line">			&#125;]</span><br><span class="line">			subscribe:subscriber];</span><br><span class="line"></span><br><span class="line">		RACDisposable *connectionDisposable = [connection connect];</span><br><span class="line">		<span class="keyword">return</span> [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">			[subscriptionDisposable dispose];</span><br><span class="line">			[connectionDisposable dispose];</span><br><span class="line">		&#125;];</span><br><span class="line">	&#125;] setNameWithFormat:<span class="string">@&quot;[%@] -switchToLatest&quot;</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面我们看一下具体的使用示例</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)setswitchToLatest &#123;</span><br><span class="line">    <span class="comment">//信号的信号</span></span><br><span class="line">    RACSubject *subject1 = [RACSubject subject];</span><br><span class="line">    RACSubject *subject2 = [RACSubject subject];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取信号中信号最近发出信号，订阅最近发出的信号</span></span><br><span class="line">    [[subject1 switchToLatest] subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//发送信号</span></span><br><span class="line">    [subject1 sendNext:subject2];</span><br><span class="line">    [subject2 sendNext:<span class="string">@&quot;信号中信号&quot;</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//最终结果输出: &quot;信号中信号&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="skip"><a href="#skip" class="headerlink" title="skip"></a>skip</h4><p>跳过N个信号后, 再开始订阅信号</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)setSkipAction &#123;</span><br><span class="line">    <span class="comment">//创建信号</span></span><br><span class="line">    RACSubject *subject = [RACSubject subject];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//订阅信号</span></span><br><span class="line">    <span class="comment">//要求跳过2个信号</span></span><br><span class="line">    [[subject skip:<span class="number">2</span>] subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//发送信号</span></span><br><span class="line">    [subject sendNext:@<span class="number">1</span>];</span><br><span class="line">    [subject sendNext:@<span class="number">2</span>];</span><br><span class="line">    [subject sendNext:@<span class="number">3</span>];</span><br><span class="line">    [subject sendNext:@<span class="number">4</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//因为上面跳过了两个信号, 所以这里只会输出: 3, 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定时操作"><a href="#定时操作" class="headerlink" title="定时操作"></a>定时操作</h3><h4 id="interval"><a href="#interval" class="headerlink" title="interval"></a>interval</h4><p>定时器, 每隔一段时间发出信号</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//RAC定时器, 每隔一段时间执行一次</span></span><br><span class="line">[[RACSignal interval:<span class="number">1</span> onScheduler:[RACScheduler mainThreadScheduler]] subscribeNext:^(<span class="built_in">NSDate</span> * _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;定时器&quot;</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>其中<code>RACScheduler</code>是<code>RAC</code>中管理线程的类</p>
<h4 id="delay"><a href="#delay" class="headerlink" title="delay"></a>delay</h4><p>延迟一段时间都发送信号</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//delay: 延迟执行</span></span><br><span class="line">[[[RACSignal createSignal:^RACDisposable * _Nullable(<span class="type">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:<span class="string">@&quot;delay&quot;</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;] delay:<span class="number">2</span>] subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<h4 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a>timeout</h4><p>超时, 可以让一个信号在一定时间后自动报错</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//timeout: 超时, 可以让一个信号在一定时间后自动报错</span></span><br><span class="line">RACSignal *single = [[RACSignal createSignal:^RACDisposable * _Nullable(<span class="type">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;] timeout:<span class="number">2</span> onScheduler:[RACScheduler currentScheduler]];</span><br><span class="line"></span><br><span class="line">[single subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, x);</span><br><span class="line">&#125; error:^(<span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">    <span class="comment">//2秒后自动调用</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, error);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<h3 id="重复操作"><a href="#重复操作" class="headerlink" title="重复操作"></a>重复操作</h3><h4 id="retry"><a href="#retry" class="headerlink" title="retry"></a>retry</h4><p>重试 ：只要失败，就会重新执行创建信号中的block,直到成功.</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)setResertAction &#123;</span><br><span class="line">    <span class="comment">//retry</span></span><br><span class="line">    __block <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    [[[RACSignal createSignal:^RACDisposable * _Nullable(<span class="type">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">5</span>) &#123;</span><br><span class="line">            [subscriber sendNext:@<span class="number">12</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;发生错误&quot;</span>);</span><br><span class="line">            [subscriber sendError:<span class="literal">nil</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;] retry] subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, x);</span><br><span class="line">    &#125; error:^(<span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, error);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*输出结果</span></span><br><span class="line"><span class="comment">     2018-03-30 15:44:08.412860+0800 ReactiveObjc[4125:341376] 发生错误</span></span><br><span class="line"><span class="comment">     2018-03-30 15:44:08.461105+0800 ReactiveObjc[4125:341376] 发生错误</span></span><br><span class="line"><span class="comment">     2018-03-30 15:44:08.461897+0800 ReactiveObjc[4125:341376] 发生错误</span></span><br><span class="line"><span class="comment">     2018-03-30 15:44:08.462478+0800 ReactiveObjc[4125:341376] 发生错误</span></span><br><span class="line"><span class="comment">     2018-03-30 15:44:08.462913+0800 ReactiveObjc[4125:341376] 发生错误</span></span><br><span class="line"><span class="comment">     2018-03-30 15:44:08.463351+0800 ReactiveObjc[4125:341376] 12</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="replay"><a href="#replay" class="headerlink" title="replay"></a>replay</h4><p>重放：当一个信号被多次订阅,反复播放内容</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//replay</span></span><br><span class="line">RACSignal *single = [[RACSignal createSignal:^RACDisposable * _Nullable(<span class="type">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:@<span class="number">23</span>];</span><br><span class="line">    [subscriber sendNext:@<span class="number">34</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;] replay];</span><br><span class="line"></span><br><span class="line">[single subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;第一次订阅-%@&quot;</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[single subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;第二次订阅-%@&quot;</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*输出结果:</span></span><br><span class="line"><span class="comment"> 2018-03-30 15:51:20.115052+0800 ReactiveObjc[4269:361568] 第一次订阅-23</span></span><br><span class="line"><span class="comment"> 2018-03-30 15:51:20.115195+0800 ReactiveObjc[4269:361568] 第一次订阅-34</span></span><br><span class="line"><span class="comment"> 2018-03-30 15:51:20.115278+0800 ReactiveObjc[4269:361568] 第二次订阅-23</span></span><br><span class="line"><span class="comment"> 2018-03-30 15:51:20.115352+0800 ReactiveObjc[4269:361568] 第二次订阅-34</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h4 id="throttle"><a href="#throttle" class="headerlink" title="throttle"></a>throttle</h4><p>节流:当某个信号发送比较频繁时，可以使用节流, 在一定时间（1秒）内，不接收任何信号内容，过了这个时间（1秒）获取最后发送的信号内容发出。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">RACSubject *subject = [RACSubject subject];</span><br><span class="line"></span><br><span class="line">[[subject throttle:<span class="number">0.001</span>] subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[subject sendNext:@<span class="number">10</span>];</span><br><span class="line">[subject sendNext:@<span class="number">11</span>];</span><br><span class="line">[subject sendNext:@<span class="number">12</span>];</span><br><span class="line">[subject sendNext:@<span class="number">13</span>];</span><br><span class="line">[subject sendNext:@<span class="number">14</span>];</span><br><span class="line">[subject sendNext:@<span class="number">15</span>];</span><br><span class="line">[subject sendNext:@<span class="number">16</span>];</span><br><span class="line">[subject sendNext:@<span class="number">17</span>];</span><br><span class="line">[subject sendNext:@<span class="number">18</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里因为执行的速度非常快, 所以这里输出的结果只有最后一个: 18</span></span><br></pre></td></tr></table></figure>


<ul>
<li>以上就是RAC中的一些常用的高级用用法具体讲解和使用示例</li>
<li>如有不足之处, 还请多多指教, 后期会持续更新相关知识点</li>
<li>下面是RAC相关的两篇文章<ul>
<li><a href="http://www.titanjun.top/2018/03/19/ReactiveCocoa%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A301/">ReactiveCocoa使用详解01</a></li>
<li><a href="http://www.titanjun.top/2018/03/21/ReactiveCocoa%E4%B9%8B%E9%9B%86%E5%90%88%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A302/">ReactiveCocoa之集合使用详解02</a></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>iOS组件库</category>
      </categories>
      <tags>
        <tag>ReactiveCocoa</tag>
        <tag>函数式</tag>
        <tag>响应式</tag>
      </tags>
  </entry>
  <entry>
    <title>ReactiveCocoa之集合使用详解02</title>
    <url>/post/1a5a7051.html</url>
    <content><![CDATA[<ul>
<li>上一篇<a href="https://www.titanjun.top/2018/03/19/ReactiveCocoa%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A301/">ReactiveCocoa使用详解01</a>提到了, <code>RACStream</code>中有两个子类——<code>RACSignal</code> 和 <code>RACSequence</code></li>
<li>上一篇文章中只介绍了, 关于<code>RACSignal</code>的使用和底层实现原理</li>
<li>这里我们就主要学习一下<code>RACSequence</code>的使用和底层实现</li>
<li>GitHub上的<a href="https://github.com/CoderTitan/RACObjcDemo">Demo地址</a></li>
</ul>
<span id="more"></span>

<h2 id="关于RACTuple"><a href="#关于RACTuple" class="headerlink" title="关于RACTuple"></a>关于RACTuple</h2><ul>
<li>这里在介绍<code>RACSequence</code>之前，我们先来看看<code>RACTuple</code>的介绍和实现吧! 在RAC中<code>RACTuple</code>是<code>ReactiveCocoa</code>的元组类</li>
<li>在Swift中, 元组类是一种很重要也很常用的类型, 是一种以下标访问成员变量的类型</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//swift中的元组</span></span><br><span class="line">let tuple = (<span class="number">3</span>, <span class="number">2</span>, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">print(tuple)</span><br><span class="line"><span class="comment">//输出: (3, 2, &quot;a&quot;)</span></span><br><span class="line"></span><br><span class="line">let tuple1 = tuple<span class="number">.0</span></span><br><span class="line">let tuple2 = tuple<span class="number">.2</span></span><br><span class="line">print(tuple1, tuple2)</span><br><span class="line"><span class="comment">//输出: 3 a</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="RAC中的元组–RACTuple"><a href="#RAC中的元组–RACTuple" class="headerlink" title="RAC中的元组–RACTuple"></a>RAC中的元组–<code>RACTuple</code></h3><p>在RAC中<code>RACTuple</code>是继承自<code>NSObject</code>, 并遵循协议<code>NSCoding</code>, <code>NSCopying</code>, <code>NSFastEnumeration</code>的类, 如下</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RACTuple</span> : <span class="title">NSObject</span> &lt;<span class="title">NSCoding</span>, <span class="title">NSCopying</span>, <span class="title">NSFastEnumeration</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//元组成员的个数</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSUInteger</span> count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">nullable</span>) <span class="type">id</span> first;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">nullable</span>) <span class="type">id</span> second;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">nullable</span>) <span class="type">id</span> third;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">nullable</span>) <span class="type">id</span> fourth;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">nullable</span>) <span class="type">id</span> fifth;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">nullable</span>) <span class="type">id</span> last;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用参考</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">RACTuple *tuple = RACTuplePack(@<span class="number">1</span>, @<span class="number">2</span>, <span class="string">@&quot;32&quot;</span>, @<span class="number">23</span>, <span class="string">@&quot;jun&quot;</span>, @<span class="number">2.3</span>, @<span class="number">4.56</span>, @<span class="number">100</span>);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%lu&quot;</span>, (<span class="type">unsigned</span> <span class="type">long</span>)tuple.count);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@--%@--%@&quot;</span>, tuple.first, tuple.last, tuple[<span class="number">6</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*输出:</span></span><br><span class="line"><span class="comment">2018-03-19 20:19:49.139932+0800 ReactiveObjc[23307:1441026] 8</span></span><br><span class="line"><span class="comment">2018-03-19 20:19:49.140112+0800 ReactiveObjc[23307:1441026] 1--100--4.56</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<p><code>RACTuple</code>透过底层看上去, 其实就是一个<code>NSArray</code>在进行操作, 无非是针对该数组进行了一些不同的封装和处理</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RACTuple</span> ()</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithBackingArray:(<span class="built_in">NSArray</span> *)backingArray <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span> *backingArray;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>下面我们看一下<code>RACTuple</code>提供的类方法和实例方法</li>
<li>一共3个实例方法, 3个类方法, 如下</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 类方法</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)tupleWithObjectsFromArray:(<span class="built_in">NSArray</span> *)array;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)tupleWithObjectsFromArray:(<span class="built_in">NSArray</span> *)array convertNullsToNils:(<span class="type">BOOL</span>)convert;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)tupleWithObjects:(<span class="type">id</span>)object, ... <span class="built_in">NS_REQUIRES_NIL_TERMINATION</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 实例方法</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="type">id</span>)objectAtIndex:(<span class="built_in">NSUInteger</span>)index;</span><br><span class="line">- (<span class="built_in">NSArray</span> *)allObjects;</span><br><span class="line">- (__kindof RACTuple *)tupleByAddingObject:(<span class="keyword">nullable</span> <span class="type">id</span>)obj;</span><br></pre></td></tr></table></figure>

<ul>
<li>下面我们一个一个简单介绍下</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)tupleWithObjectsFromArray:(<span class="built_in">NSArray</span> *)array &#123;</span><br><span class="line">	<span class="keyword">return</span> [<span class="keyword">self</span> tupleWithObjectsFromArray:array convertNullsToNils:<span class="literal">NO</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)tupleWithObjectsFromArray:(<span class="built_in">NSArray</span> *)array convertNullsToNils:(<span class="type">BOOL</span>)convert &#123;</span><br><span class="line">	<span class="keyword">if</span> (!convert) &#123;</span><br><span class="line">		<span class="keyword">return</span> [[<span class="keyword">self</span> alloc] initWithBackingArray:array];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">NSMutableArray</span> *newArray = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:array.count];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">id</span> object <span class="keyword">in</span> array) &#123;</span><br><span class="line">		[newArray addObject:(object == <span class="built_in">NSNull</span>.null ? RACTupleNil.tupleNil : object)];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> [[<span class="keyword">self</span> alloc] initWithBackingArray:newArray];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这两个方法都是根据传入的array初始化为<code>RACTuple</code>内部的<code>NSArray</code></li>
<li>然而这两个初始化方法唯一的不同点就在于<code>convert</code>参数, 区别在于是否把<code>NSNull</code>转换成<code>RACTupleNil</code>类型</li>
<li>这里还有一个需要注意的就是<code>RACTupleNil</code>, 是一个单例</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (RACTupleNil *)tupleNil &#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">	<span class="keyword">static</span> RACTupleNil *tupleNil = <span class="literal">nil</span>;</span><br><span class="line">	<span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">		tupleNil = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">	&#125;);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> tupleNil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后一个类方法, 与NSArray的类方法相同, 如下:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)arrayWithObjects:(ObjectType)firstObj, ... <span class="built_in">NS_REQUIRES_NIL_TERMINATION</span>;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)tupleWithObjects:(<span class="type">id</span>)object, ... <span class="built_in">NS_REQUIRES_NIL_TERMINATION</span>;</span><br></pre></td></tr></table></figure>

<p>简单使用:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">    <span class="built_in">NSArray</span> *arr = [<span class="built_in">NSArray</span> arrayWithObjects:@<span class="number">1</span>, <span class="built_in">NSNull</span>.null, @<span class="number">2</span>, <span class="string">@&quot;jun&quot;</span>, <span class="literal">nil</span>];</span><br><span class="line">    RACTuple *tuple1 = [RACTuple tupleWithObjectsFromArray:arr];</span><br><span class="line">    RACTuple *tuple2 = [RACTuple tupleWithObjectsFromArray:arr convertNullsToNils:<span class="literal">YES</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, tuple1.second);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, tuple2.second);</span><br><span class="line">    </span><br><span class="line">    RACTuple *tuple3 = [RACTuple tupleWithObjects:@<span class="number">1</span>, @<span class="number">3.4</span>, <span class="string">@&quot;jun&quot;</span>, <span class="literal">nil</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%lu&quot;</span>, (<span class="type">unsigned</span> <span class="type">long</span>)tuple3.count);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*输出结果:</span></span><br><span class="line"><span class="comment">2018-03-19 20:59:14.995245+0800 ReactiveObjc[24150:1545073] &lt;null&gt;</span></span><br><span class="line"><span class="comment">2018-03-19 20:59:14.995557+0800 ReactiveObjc[24150:1545073] (null)</span></span><br><span class="line"><span class="comment">2018-03-19 20:59:14.995866+0800 ReactiveObjc[24150:1545073] 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="RACTuple的相关类–RACTupleUnpackingTrampoline"><a href="#RACTuple的相关类–RACTupleUnpackingTrampoline" class="headerlink" title="RACTuple的相关类–RACTupleUnpackingTrampoline"></a><code>RACTuple</code>的相关类–<code>RACTupleUnpackingTrampoline</code></h3><p>关于<code>RACTuple</code>还有2个相关的类，<code>RACTupleUnpackingTrampoline</code>和<code>RACTupleSequence</code></p>
<p>这里我们先看一下, 该类的属性和方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RACTupleUnpackingTrampoline</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)trampoline;</span><br><span class="line">- (<span class="type">void</span>)setObject:(<span class="keyword">nullable</span> RACTuple *)tuple forKeyedSubscript:(<span class="built_in">NSArray</span> *)variables;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>可以看到只有一个单例和一个示例方法, 下面看依稀阿底层的具体实现</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)trampoline &#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">id</span> trampoline = <span class="literal">nil</span>;</span><br><span class="line">	<span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">		trampoline = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">	&#125;);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> trampoline;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)setObject:(RACTuple *)tuple forKeyedSubscript:(<span class="built_in">NSArray</span> *)variables &#123;</span><br><span class="line">	<span class="built_in">NSCParameterAssert</span>(variables != <span class="literal">nil</span>);</span><br><span class="line">	</span><br><span class="line">	[variables enumerateObjectsUsingBlock:^(<span class="built_in">NSValue</span> *value, <span class="built_in">NSUInteger</span> index, <span class="type">BOOL</span> *stop) &#123;</span><br><span class="line">		__<span class="keyword">strong</span> <span class="type">id</span> *ptr = (__<span class="keyword">strong</span> <span class="type">id</span> *)value.pointerValue;</span><br><span class="line">		*ptr = tuple[index];</span><br><span class="line">	&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该实例方法会遍历传入的<code>NSArray</code>数组, 然后依次取出每一个<code>value</code>的指针, 用这个指针又赋值给了tuple[index], 下面我们就看一下这个方法的具体使用方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)setUnpackingTrampoline &#123;</span><br><span class="line">    RACTupleUnpackingTrampoline *line = [RACTupleUnpackingTrampoline trampoline];</span><br><span class="line">    <span class="built_in">NSString</span> *str1;</span><br><span class="line">    <span class="built_in">NSString</span> *str2;</span><br><span class="line">    <span class="built_in">NSString</span> *str3;</span><br><span class="line">    <span class="built_in">NSArray</span> *arr = [<span class="built_in">NSArray</span> arrayWithObjects:[<span class="built_in">NSValue</span> valueWithPointer:&amp;str1], [<span class="built_in">NSValue</span> valueWithPointer:&amp;str2], [<span class="built_in">NSValue</span> valueWithPointer:&amp;str3], <span class="literal">nil</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;处理之前: str1 = %@, str2 = %@, str3 = %@&quot;</span>, str1, str2, str3);</span><br><span class="line">    [line setObject:RACTuplePack(<span class="string">@&quot;tian&quot;</span>, @<span class="number">23</span>, @<span class="number">3.45</span>) forKeyedSubscript:arr];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;处理之后: str1 = %@, str2 = %@, str3 = %@&quot;</span>, str1, str2, str3);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*输出结果:</span></span><br><span class="line"><span class="comment">     2018-03-20 15:43:28.785571+0800 ReactiveObjc[7074:641560] 处理之前: str1 = (null), str2 = (null), str3 = (null)</span></span><br><span class="line"><span class="comment">     2018-03-20 15:43:28.786078+0800 ReactiveObjc[7074:641560] 处理之后: str1 = tian, str2 = 23, str3 = 3.45</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法的作用类似于, 把封装好的<code>RACTuple</code>对象, 一个一个的把它的成员变量解析出来, 说到这里我们就不得不提及两个宏</p>
<h3 id="RACTuple中的宏"><a href="#RACTuple中的宏" class="headerlink" title="RACTuple中的宏"></a><code>RACTuple</code>中的宏</h3><p>一般使用用两个宏，<code>RACTupleUnpack( )</code> 用来解包，<code>Rc( )</code> 用来装包</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RACTuplePack(...) \</span></span><br><span class="line"><span class="meta">    RACTuplePack_(__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面RACTuplePack_底层的调用</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RACTuplePack_(...) \</span></span><br><span class="line"><span class="meta">    ([RACTuplePack_class_name(__VA_ARGS__) tupleWithObjectsFromArray:@[ metamacro_foreach(RACTuplePack_object_or_ractuplenil,, __VA_ARGS__) ]])</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面RACTupleUnpack_底层的调用</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RACTupleUnpack_(...) \</span></span><br><span class="line"><span class="meta">    metamacro_foreach(RACTupleUnpack_decl,, __VA_ARGS__) \</span></span><br><span class="line"><span class="meta">    \</span></span><br><span class="line"><span class="meta">    int RACTupleUnpack_state = 0; \</span></span><br><span class="line"><span class="meta">    \</span></span><br><span class="line"><span class="meta">    RACTupleUnpack_after: \</span></span><br><span class="line"><span class="meta">        ; \</span></span><br><span class="line"><span class="meta">        metamacro_foreach(RACTupleUnpack_assign,, __VA_ARGS__) \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (RACTupleUnpack_state != 0) RACTupleUnpack_state = 2; \</span></span><br><span class="line"><span class="meta">        \</span></span><br><span class="line"><span class="meta">        while (RACTupleUnpack_state != 2) \</span></span><br><span class="line"><span class="meta">            <span class="keyword">if</span> (RACTupleUnpack_state == 1) &#123; \</span></span><br><span class="line"><span class="meta">                goto RACTupleUnpack_after; \</span></span><br><span class="line"><span class="meta">            &#125; <span class="keyword">else</span> \</span></span><br><span class="line"><span class="meta">                for (; RACTupleUnpack_state != 1; RACTupleUnpack_state = 1) \</span></span><br><span class="line"><span class="meta">                    [RACTupleUnpackingTrampoline trampoline][ @[ metamacro_foreach(RACTupleUnpack_value,, __VA_ARGS__) ] ]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>这里的解包的宏的底层实现就是上面说到的<code>RACTupleUnpackingTrampoline</code>的实例方法</li>
<li>关于<code>ACTuplePack</code>的使用这里也不在多说了, 下面主要看一下用于解包的宏, 看一下主要用法, 上代码</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//宏的使用</span></span><br><span class="line">RACTuple *tuple4 = RACTuplePack(<span class="string">@&quot;tian&quot;</span>, @<span class="number">23</span>);</span><br><span class="line">RACTupleUnpack(<span class="built_in">NSString</span> *str1, <span class="built_in">NSNumber</span> *num1) = tuple4;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@--%d&quot;</span>, str1, num1.intValue);</span><br><span class="line"><span class="comment">///输出: tian--23</span></span><br><span class="line"></span><br><span class="line">RACTuple *tuple3 = [RACTuple tupleWithObjects:<span class="string">@&quot;jun&quot;</span>, @<span class="number">3.4</span>, <span class="literal">nil</span>];</span><br><span class="line">RACTupleUnpack(<span class="built_in">NSString</span> *str2, <span class="built_in">NSNumber</span> *num2) = tuple3;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@--%.2f&quot;</span>, str2, num2.floatValue);</span><br><span class="line"><span class="comment">///输出: jun--3.40</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 上面的两种做法等同于下面这种做法</span></span><br><span class="line"><span class="built_in">NSString</span> *str3 = tuple3[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">NSNumber</span> *num3 = tuple3[<span class="number">1</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@--%.2f&quot;</span>, str3, num3.floatValue);</span><br><span class="line"><span class="comment">///输出: jun--3.40</span></span><br></pre></td></tr></table></figure>

<h3 id="RACTupleSequence"><a href="#RACTupleSequence" class="headerlink" title="RACTupleSequence"></a><code>RACTupleSequence</code></h3><ul>
<li>上面提到了<code>RACTuple</code>还有2个相关的类，<code>RACTupleUnpackingTrampoline</code>和<code>RACTupleSequence</code></li>
<li>而<code>RACTupleUnpackingTrampoline</code>上面我们已经介绍过了</li>
<li>这里我们来介绍一下<code>RACTupleSequence</code><ul>
<li>之所以说<code>RACTupleSequence</code>和<code>RACTuple</code>相关, 也只是因为两者的雷鸣里面都有一个<code>Tuple</code></li>
<li>实际上<code>RACTupleSequence</code>是继承自<code>RACSequence</code>的, 下面看一下定义代码, 只有一个返回值为<code>RACSequence</code>的类方法</li>
</ul>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;RACSequence.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">+ (RACSequence *)sequenceWithTupleBackingArray:(<span class="built_in">NSArray</span> *)backingArray offset:(<span class="built_in">NSUInteger</span>)offset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法的实现</span></span><br><span class="line">+ (RACSequence *)sequenceWithTupleBackingArray:(<span class="built_in">NSArray</span> *)backingArray offset:(<span class="built_in">NSUInteger</span>)offset &#123;</span><br><span class="line">	<span class="built_in">NSCParameterAssert</span>(offset &lt;= backingArray.count);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (offset == backingArray.count) <span class="keyword">return</span> <span class="keyword">self</span>.empty;</span><br><span class="line"></span><br><span class="line">	RACTupleSequence *seq = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">	seq-&gt;_tupleBackingArray = backingArray;</span><br><span class="line">	seq-&gt;_offset = offset;</span><br><span class="line">	<span class="keyword">return</span> seq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>可见:<ul>
<li><code>RACTupleSequence</code>这个类的目的就是把<code>Tuple</code>转换成<code>Sequence</code></li>
<li><code>Sequence</code>里面的数组就是<code>Tuple</code>内部的<code>backingArra</code>y。</li>
<li><code>offset</code>从0开始</li>
</ul>
</li>
</ul>
<h2 id="RACSequence底层实现"><a href="#RACSequence底层实现" class="headerlink" title="RACSequence底层实现"></a>RACSequence底层实现</h2><p><code>RACSequence</code>是<code>RACStream</code>的子类，主要是<code>ReactiveCocoa</code>里面的集合类, 先来看看关于<code>RACSequence</code>的属性</p>
<h3 id="RACSequence的属性"><a href="#RACSequence的属性" class="headerlink" title="RACSequence的属性"></a><code>RACSequence</code>的属性</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>, <span class="keyword">nullable</span>) ValueType head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>, <span class="keyword">nullable</span>) RACSequence&lt;ValueType&gt; *tail;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;ValueType&gt; *array;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSEnumerator</span>&lt;ValueType&gt; *objectEnumerator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) RACSequence&lt;ValueType&gt; *eagerSequence;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) RACSequence&lt;ValueType&gt; *lazySequence;</span><br></pre></td></tr></table></figure>

<h4 id="于head和tail"><a href="#于head和tail" class="headerlink" title="于head和tail"></a>于<code>head</code>和<code>tail</code></h4><ul>
<li><code>RACSequence</code>的所有属性中, 最重要的莫过于<code>head</code>和<code>tail</code>两个属性了, 而<code>tail</code>又是一个<code>RACSequence</code></li>
<li>这两者就像一个人的头和身体两部分</li>
<li>测试代码如下</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">RACSequence *sequence = [RACSequence sequenceWithHeadBlock:^<span class="type">id</span> _Nullable&#123;</span><br><span class="line">    <span class="keyword">return</span> @<span class="number">12</span>;</span><br><span class="line">&#125; tailBlock:^RACSequence * _Nonnull&#123;</span><br><span class="line">    <span class="keyword">return</span> @[@<span class="number">23</span>, <span class="string">@&quot;jun&quot;</span>].rac_sequence;</span><br><span class="line">&#125;];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;sequence.head = %@ , sequence.tail =  %@&quot;</span>, sequence.head, sequence.tail);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*输出结果:</span></span><br><span class="line"><span class="comment">sequence.head = 12 , sequence.tail =  &lt;RACArraySequence: 0x6000002325a0&gt;&#123; name = , array = (</span></span><br><span class="line"><span class="comment">    23,</span></span><br><span class="line"><span class="comment">    jun</span></span><br><span class="line"><span class="comment">) &#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="objectEnumerator"><a href="#objectEnumerator" class="headerlink" title="objectEnumerator"></a>objectEnumerator</h4><p><code>objectEnumerator</code>是一个快速枚举器, 看一下底层的get方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSEnumerator</span> *)objectEnumerator &#123;</span><br><span class="line">	RACSequenceEnumerator *enumerator = [[RACSequenceEnumerator alloc] init];</span><br><span class="line">	enumerator.sequence = <span class="keyword">self</span>;</span><br><span class="line">	<span class="keyword">return</span> enumerator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>这里涉及到一个<code>RACSequenceEnumerator</code>, 底层只有一个属性</li>
<li>为了更加方便的<code>RACSequence</code>进行遍历, 重写了父类的方法</li>
<li>有了这个<code>NSEnumerator</code>，就可以从<code>RACSequence</code>的head一直遍历到tail</li>
<li>而<code>RACSequence</code>里面定义的<code>objectEnumerator</code>，就是为了取出内部的<code>RACSequenceEnumerator</code></li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RACSequenceEnumerator</span> : <span class="title">NSEnumerator</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) RACSequence *sequence;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这里重写了父类的方法</span></span><br><span class="line">- (<span class="type">id</span>)nextObject &#123;</span><br><span class="line">	<span class="type">id</span> object = <span class="literal">nil</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">		object = <span class="keyword">self</span>.sequence.head;</span><br><span class="line">		<span class="keyword">self</span>.sequence = <span class="keyword">self</span>.sequence.tail;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="array"><a href="#array" class="headerlink" title="array"></a><code>array</code></h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSArray</span> *)array &#123;</span><br><span class="line">	<span class="built_in">NSMutableArray</span> *array = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">id</span> obj <span class="keyword">in</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">		[array addObject:obj];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> [array <span class="keyword">copy</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>RACSequence</code>的定义里面还有一个<code>array</code>，这个数组就是返回一个<code>NSArray</code></li>
<li>这个数组里面装满了<code>RACSequence</code>里面所有的对象。</li>
<li>这里之所以能用<code>for-in</code>，是因为实现了<code>NSFastEnumeration</code>协议。</li>
<li>至于<code>for-in</code>的效率，完全就看重写<code>NSFastEnumeration</code>协议里面<code>countByEnumeratingWithState: objects: count:</code> 方法里面的执行效率了</li>
<li>至于剩下的两个属性, 下文中会继续说到</li>
</ul>
<h2 id="RACSequence的方法"><a href="#RACSequence的方法" class="headerlink" title="RACSequence的方法"></a>RACSequence的方法</h2><h3 id="RACSequence的初始化方法"><a href="#RACSequence的初始化方法" class="headerlink" title="RACSequence的初始化方法"></a>RACSequence的初始化方法</h3><p><code>RACSequence</code>的初始化方法有且只有一个</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (RACSequence *)sequenceWithHeadBlock:(<span class="type">id</span> (^)(<span class="type">void</span>))headBlock tailBlock:(RACSequence&lt;<span class="type">id</span>&gt; *(^)(<span class="type">void</span>))tailBlock &#123;</span><br><span class="line">	<span class="keyword">return</span> [[RACDynamicSequence sequenceWithHeadBlock:headBlock tailBlock:tailBlock] setNameWithFormat:<span class="string">@&quot;+sequenceWithHeadBlock:tailBlock:&quot;</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="RACDynamicSequence属性"><a href="#RACDynamicSequence属性" class="headerlink" title="RACDynamicSequence属性"></a><code>RACDynamicSequence</code>属性</h4><p>上面初始化方法的底层是直接调用了<code>RACDynamicSequence</code>的一个类方法, 而这个类又是<code>RACSequence</code>的子类, 看看主要属性</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RACDynamicSequence</span> () </span>&#123;</span><br><span class="line">    <span class="type">id</span> _head;</span><br><span class="line">    RACSequence *_tail;</span><br><span class="line">    <span class="type">id</span> _dependency;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="type">id</span> headBlock;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="type">id</span> tailBlock;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="type">BOOL</span> hasDependency;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="type">id</span> (^dependencyBlock)(<span class="type">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<ul>
<li>相比大家应该知道, 正常情况下我们定义的<code>block</code>都是用<code>copy</code>修饰的</li>
<li>而这里, 作者定义了三个<code>block</code>: <code>headBlock</code>, <code>tailBlock</code>，<code>dependencyBlock</code>都是用<code>strong</code>修饰的</li>
<li>关于这个问题, 可以<a href="https://github.com/ReactiveCocoa/ReactiveCocoa/issues/505">参考这里</a></li>
</ul>
<h4 id="方法的实现"><a href="#方法的实现" class="headerlink" title="方法的实现"></a>方法的实现</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (RACSequence *)sequenceWithHeadBlock:(<span class="type">id</span> (^)(<span class="type">void</span>))headBlock tailBlock:(RACSequence&lt;<span class="type">id</span>&gt; *(^)(<span class="type">void</span>))tailBlock &#123;</span><br><span class="line">	<span class="built_in">NSCParameterAssert</span>(headBlock != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">	RACDynamicSequence *seq = [[RACDynamicSequence alloc] init];</span><br><span class="line">	seq.headBlock = [headBlock <span class="keyword">copy</span>];</span><br><span class="line">	seq.tailBlock = [tailBlock <span class="keyword">copy</span>];</span><br><span class="line">	seq.hasDependency = <span class="literal">NO</span>;</span><br><span class="line">	<span class="keyword">return</span> seq;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (RACSequence *)sequenceWithLazyDependency:(<span class="type">id</span> (^)(<span class="type">void</span>))dependencyBlock headBlock:(<span class="type">id</span> (^)(<span class="type">id</span> dependency))headBlock tailBlock:(RACSequence *(^)(<span class="type">id</span> dependency))tailBlock &#123;</span><br><span class="line">	<span class="built_in">NSCParameterAssert</span>(dependencyBlock != <span class="literal">nil</span>);</span><br><span class="line">	<span class="built_in">NSCParameterAssert</span>(headBlock != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">	RACDynamicSequence *seq = [[RACDynamicSequence alloc] init];</span><br><span class="line">	seq.headBlock = [headBlock <span class="keyword">copy</span>];</span><br><span class="line">	seq.tailBlock = [tailBlock <span class="keyword">copy</span>];</span><br><span class="line">	seq.dependencyBlock = [dependencyBlock <span class="keyword">copy</span>];</span><br><span class="line">	seq.hasDependency = <span class="literal">YES</span>;</span><br><span class="line">	<span class="keyword">return</span> seq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>hasDependency</code>这个变量是代表是否有<code>dependencyBlock</code>。这个函数里面就只把<code>headBlock</code>和<code>tailBlock</code>保存起来了</li>
<li>上面第二个方法是带有<code>dependencyBlock</code>的, 也会把<code>dependencyBlock</code>保存起来</li>
</ul>
<h2 id="积极运算和惰性求值"><a href="#积极运算和惰性求值" class="headerlink" title="积极运算和惰性求值"></a>积极运算和惰性求值</h2><ul>
<li>说到惰性求值, 就立马想到了懒加载, 就是在getter里动态返回属性, 也就是等到要用的时候才会计算</li>
<li>关于这两个概念, 推荐大家看这篇文章<a href="http://williamzang.com/blog/2016/11/07/liao-yi-liao-ioskai-fa-zhong-de-duo-xing-ji-suan/">聊一聊iOS开发中的惰性计算</a></li>
</ul>
<h3 id="积极运算"><a href="#积极运算" class="headerlink" title="积极运算"></a>积极运算</h3><p>在<code>RACSequence</code>中积极运算的代表是<code>RACSequence</code>的一个子类<code>RACArraySequence</code>的子类——<code>RACEagerSequence</code>。它的积极运算表现在其bind函数上</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (RACSequence *)bind:(RACSequenceBindBlock (^)(<span class="type">void</span>))block &#123;</span><br><span class="line">	<span class="built_in">NSCParameterAssert</span>(block != <span class="literal">nil</span>);</span><br><span class="line">	RACStreamBindBlock bindBlock = block();</span><br><span class="line">	<span class="built_in">NSArray</span> *currentArray = <span class="keyword">self</span>.array;</span><br><span class="line">	<span class="built_in">NSMutableArray</span> *resultArray = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:currentArray.count];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">id</span> value <span class="keyword">in</span> currentArray) &#123;</span><br><span class="line">		<span class="type">BOOL</span> stop = <span class="literal">NO</span>;</span><br><span class="line">		RACSequence *boundValue = (<span class="type">id</span>)bindBlock(value, &amp;stop);</span><br><span class="line">		<span class="keyword">if</span> (boundValue == <span class="literal">nil</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">id</span> x <span class="keyword">in</span> boundValue) &#123;</span><br><span class="line">			[resultArray addObject:x];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (stop) <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> [[<span class="keyword">self</span>.class sequenceWithArray:resultArray offset:<span class="number">0</span>] setNameWithFormat:<span class="string">@&quot;[%@] -bind:&quot;</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>可以看到, 该方法内部执行了两层<code>for-in</code>循环<ul>
<li>第一层循环遍历的自己<code>RACSequence</code>中的值，然后拿到这个值传入闭包<code>bindBlock()</code>中，返回一个<code>RACSequence</code>，最后用一个<code>NSMutableArray</code>依次把每个<code>RACSequence</code>里面的值都装起来</li>
<li>第二层循环是在遍历<code>RACSequence</code>，之所以可以用<code>for-in</code>的方式遍历就是因为实现了<code>NSFastEnumeration</code>协议，实现了<code>countByEnumeratingWithState: objects: count: </code>方法</li>
</ul>
</li>
<li>这里就是一个积极运算的例子,在每次循环中都会把闭包<code>block()</code>的值计算出来。值得说明的是，最后返回的<code>RACSequence</code>的类型是<code>self.class</code>类型的，即还是<code>RACEagerSequence</code>类型的</li>
</ul>
<h3 id="惰性计算"><a href="#惰性计算" class="headerlink" title="惰性计算"></a>惰性计算</h3><p>等到需要用到的时候才会计算, 我们看一下在<code>RACSequence</code>中，bind函数的实现</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (RACSequence *)bind:(RACSequenceBindBlock (^)(<span class="type">void</span>))block &#123;</span><br><span class="line">	RACSequenceBindBlock bindBlock = block();</span><br><span class="line">	<span class="keyword">return</span> [[<span class="keyword">self</span> bind:bindBlock passingThroughValuesFromSequence:<span class="literal">nil</span>] setNameWithFormat:<span class="string">@&quot;[%@] -bind:&quot;</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (RACSequence *)bind:(RACSequenceBindBlock)bindBlock passingThroughValuesFromSequence:(RACSequence *)passthroughSequence &#123;</span><br><span class="line">	__block RACSequence *valuesSeq = <span class="keyword">self</span>;</span><br><span class="line">	__block RACSequence *current = passthroughSequence;</span><br><span class="line">	__block <span class="type">BOOL</span> stop = <span class="literal">NO</span>;</span><br><span class="line"></span><br><span class="line">	RACSequence *sequence = [RACDynamicSequence sequenceWithLazyDependency:^ <span class="type">id</span> &#123;</span><br><span class="line">		<span class="keyword">while</span> (current.head == <span class="literal">nil</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (stop) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">			<span class="type">id</span> value = valuesSeq.head;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (value == <span class="literal">nil</span>) &#123;</span><br><span class="line">				stop = <span class="literal">YES</span>;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			current = (<span class="type">id</span>)bindBlock(value, &amp;stop);</span><br><span class="line">			<span class="keyword">if</span> (current == <span class="literal">nil</span>) &#123;</span><br><span class="line">				stop = <span class="literal">YES</span>;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			valuesSeq = valuesSeq.tail;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">NSCAssert</span>([current isKindOfClass:RACSequence.class], <span class="string">@&quot;-bind: block returned an object that is not a sequence: %@&quot;</span>, current);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">	&#125; headBlock:^(<span class="type">id</span> _) &#123;</span><br><span class="line">		<span class="keyword">return</span> current.head;</span><br><span class="line">	&#125; tailBlock:^ <span class="type">id</span> (<span class="type">id</span> _) &#123;</span><br><span class="line">		<span class="keyword">if</span> (stop) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> [valuesSeq bind:bindBlock passingThroughValuesFromSequence:current.tail];</span><br><span class="line">	&#125;];</span><br><span class="line"></span><br><span class="line">	sequence.name = <span class="keyword">self</span>.name;</span><br><span class="line">	<span class="keyword">return</span> sequence;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在上述方法实现中, 就是用<code>sequenceWithLazyDependency: headBlock: tailBlock:</code>方法生成了一个<code>RACSequence</code>，并返回</li>
<li>通过调用<code>RACSequence</code>里面的bind操作，并没有执行3个闭包里面的值，只是保存起来了。</li>
<li>这里就是惰性求值的表现——等到要用的时候才会计算</li>
<li>下面我们看一段代码示例</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">    <span class="built_in">NSArray</span> *arr = @[@<span class="number">1</span>, @<span class="number">3</span>, @<span class="number">4</span>];</span><br><span class="line">    RACSequence *sequence1 = [arr.rac_sequence map:^<span class="type">id</span> _Nullable(<span class="type">id</span>  _Nullable value) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;sequence&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> @<span class="number">10</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    RACSequence *lazySequence = [arr.rac_sequence.lazySequence map:^<span class="type">id</span> _Nullable(<span class="type">id</span>  _Nullable value) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;lazySequence&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> @<span class="number">20</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    RACSequence *eagerSequence = [arr.rac_sequence.eagerSequence map:^<span class="type">id</span> _Nullable(<span class="type">id</span>  _Nullable value) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;eagerSequence&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> @<span class="number">30</span>;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">//    [sequence1 array];</span></span><br><span class="line"><span class="comment">//    [lazySequence array];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*输出:</span></span><br><span class="line"><span class="comment">    2018-03-21 15:53:24.562184+0800 ReactiveObjc[9109:771797] eagerSequence</span></span><br><span class="line"><span class="comment">    2018-03-21 15:53:24.562674+0800 ReactiveObjc[9109:771797] eagerSequence</span></span><br><span class="line"><span class="comment">    2018-03-21 15:53:24.562799+0800 ReactiveObjc[9109:771797] eagerSequence</span></span><br><span class="line"><span class="comment">    */</span></span><br></pre></td></tr></table></figure>

<ul>
<li>从打印结果可以看出,只有<code>eagerSequence</code>执行了三次, 而其他两个并没有输出</li>
<li>原因是因为bind闭包只在<code>eagerSequence</code>中真正被调用执行了，而在<code>lazySequence</code>中bind闭包仅仅只是被copy了</li>
<li>当吧最后两行注释打开之后</li>
<li>可见在<code>RACSequence</code>中，除去<code>RACEagerSequence</code>是积极运算，其他的<code>Sequence</code>都是惰性求值的。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-21</span> <span class="number">15</span>:<span class="number">53</span>:<span class="number">24.562184</span>+<span class="number">0800</span> ReactiveObjc[<span class="number">9109</span>:<span class="number">771797</span>] eagerSequence</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-21</span> <span class="number">15</span>:<span class="number">53</span>:<span class="number">24.562674</span>+<span class="number">0800</span> ReactiveObjc[<span class="number">9109</span>:<span class="number">771797</span>] eagerSequence</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-21</span> <span class="number">15</span>:<span class="number">53</span>:<span class="number">24.562799</span>+<span class="number">0800</span> ReactiveObjc[<span class="number">9109</span>:<span class="number">771797</span>] eagerSequence</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-21</span> <span class="number">15</span>:<span class="number">53</span>:<span class="number">24.562940</span>+<span class="number">0800</span> ReactiveObjc[<span class="number">9109</span>:<span class="number">771797</span>] sequence</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-21</span> <span class="number">15</span>:<span class="number">53</span>:<span class="number">24.563403</span>+<span class="number">0800</span> ReactiveObjc[<span class="number">9109</span>:<span class="number">771797</span>] sequence</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-21</span> <span class="number">15</span>:<span class="number">53</span>:<span class="number">24.563583</span>+<span class="number">0800</span> ReactiveObjc[<span class="number">9109</span>:<span class="number">771797</span>] sequence</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-21</span> <span class="number">15</span>:<span class="number">53</span>:<span class="number">24.563742</span>+<span class="number">0800</span> ReactiveObjc[<span class="number">9109</span>:<span class="number">771797</span>] lazySequence</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-21</span> <span class="number">15</span>:<span class="number">53</span>:<span class="number">24.563838</span>+<span class="number">0800</span> ReactiveObjc[<span class="number">9109</span>:<span class="number">771797</span>] lazySequence</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-21</span> <span class="number">15</span>:<span class="number">53</span>:<span class="number">24.563937</span>+<span class="number">0800</span> ReactiveObjc[<span class="number">9109</span>:<span class="number">771797</span>] lazySequence</span><br></pre></td></tr></table></figure>

<h2 id="RACSequence的方法-1"><a href="#RACSequence的方法-1" class="headerlink" title="RACSequence的方法"></a>RACSequence的方法</h2><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">id</span>)foldLeftWithStart:(<span class="keyword">nullable</span> <span class="type">id</span>)start reduce:(<span class="type">id</span> _Nullable (^)(<span class="type">id</span> _Nullable accumulator, ValueType _Nullable value))reduce;</span><br><span class="line"></span><br><span class="line">- (<span class="type">id</span>)foldRightWithStart:(<span class="keyword">nullable</span> <span class="type">id</span>)start reduce:(<span class="type">id</span> _Nullable (^)(<span class="type">id</span> _Nullable first, RACSequence *rest))reduce;</span><br><span class="line"></span><br><span class="line">- (<span class="type">BOOL</span>)any:(<span class="type">BOOL</span> (^)(ValueType _Nullable value))block;</span><br><span class="line"></span><br><span class="line">- (<span class="type">BOOL</span>)all:(<span class="type">BOOL</span> (^)(ValueType _Nullable value))block;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nullable</span> ValueType)objectPassingTest:(<span class="type">BOOL</span> (^)(ValueType _Nullable value))block;</span><br></pre></td></tr></table></figure>

<h3 id="折叠函数"><a href="#折叠函数" class="headerlink" title="折叠函数"></a>折叠函数</h3><p>我们先看一下他的底层实现, 函数传入了一个初始值start，然后依次循环执行reduce( )，循环之后，最终的值作为返回值返回。第一个函数就是折叠函数，从左边折叠到右边; 第二个方向是从右往左</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">id</span>)foldLeftWithStart:(<span class="type">id</span>)start reduce:(<span class="type">id</span> (^)(<span class="type">id</span>, <span class="type">id</span>))reduce &#123;</span><br><span class="line">	<span class="built_in">NSCParameterAssert</span>(reduce != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">self</span>.head == <span class="literal">nil</span>) <span class="keyword">return</span> start;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">id</span> value <span class="keyword">in</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">		start = reduce(start, value);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">id</span>)foldRightWithStart:(<span class="type">id</span>)start reduce:(<span class="type">id</span> (^)(<span class="type">id</span>, RACSequence *))reduce &#123;</span><br><span class="line">	<span class="built_in">NSCParameterAssert</span>(reduce != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">self</span>.head == <span class="literal">nil</span>) <span class="keyword">return</span> start;</span><br><span class="line">	</span><br><span class="line">	RACSequence *rest = [RACSequence sequenceWithHeadBlock:^&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">self</span>.tail) &#123;</span><br><span class="line">			<span class="keyword">return</span> [<span class="keyword">self</span>.tail foldRightWithStart:start reduce:reduce];</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> start;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; tailBlock:<span class="literal">nil</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> reduce(<span class="keyword">self</span>.head, rest);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>具体使用方法测试代码</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)setSequenceAction &#123;</span><br><span class="line">    <span class="built_in">NSArray</span> *array = @[@<span class="number">5</span>, @<span class="number">3</span>, @<span class="number">9</span>, @<span class="number">4</span>];</span><br><span class="line">    RACSequence *sequence = [array rac_sequence];</span><br><span class="line">    <span class="type">id</span> leftData = [sequence foldLeftWithStart:<span class="string">@&quot;-&quot;</span> reduce:^<span class="type">id</span> _Nullable(<span class="type">id</span>  _Nullable accumulator, <span class="type">id</span>  _Nullable value) &#123;</span><br><span class="line">        <span class="keyword">return</span> [accumulator stringByAppendingString:[value stringValue]];</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="type">id</span> rightData = [sequence foldRightWithStart:<span class="string">@&quot;:&quot;</span> reduce:^<span class="type">id</span> _Nullable(<span class="type">id</span>  _Nullable first, RACSequence * _Nonnull rest) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@-%@&quot;</span>, rest.head, first];</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;leftData = %@, rightData = %@&quot;</span>, leftData, rightData);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//输出: leftData = -5394, rightData = :-4-9-3-5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="objectPassingTest"><a href="#objectPassingTest" class="headerlink" title="objectPassingTest"></a><code>objectPassingTest</code></h3><p>函数里面会调用<code>RACStream</code>中的<code>filter:</code>函数, 如果<code>block(value)</code>为YES，就代表通过了Test，那么就会返回value的<code>sequence</code>, 取出head返回</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">id</span>)objectPassingTest:(<span class="type">BOOL</span> (^)(<span class="type">id</span>))block &#123;</span><br><span class="line">	<span class="built_in">NSCParameterAssert</span>(block != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> [<span class="keyword">self</span> filter:block].head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码如下</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *array = @[@<span class="number">5</span>, @<span class="number">3</span>, @<span class="number">9</span>, @<span class="number">4</span>];</span><br><span class="line">RACSequence *sequence = [array rac_sequence];</span><br><span class="line"><span class="type">id</span> anyData = [sequence objectPassingTest:^<span class="type">BOOL</span>(<span class="type">id</span>  _Nullable value) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, value);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, anyData);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出: 5</span></span><br></pre></td></tr></table></figure>

<h3 id="any-和-all"><a href="#any-和-all" class="headerlink" title="any: 和 all:"></a>any: 和 all:</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)any:(<span class="type">BOOL</span> (^)(<span class="type">id</span>))block &#123;</span><br><span class="line">	<span class="built_in">NSCParameterAssert</span>(block != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> [<span class="keyword">self</span> objectPassingTest:block] != <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">BOOL</span>)all:(<span class="type">BOOL</span> (^)(<span class="type">id</span>))block &#123;</span><br><span class="line">	<span class="built_in">NSCParameterAssert</span>(block != <span class="literal">NULL</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">NSNumber</span> *result = [<span class="keyword">self</span> foldLeftWithStart:@YES reduce:^(<span class="built_in">NSNumber</span> *accumulator, <span class="type">id</span> value) &#123;</span><br><span class="line">		<span class="keyword">return</span> @(accumulator.boolValue &amp;&amp; block(value));</span><br><span class="line">	&#125;];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> result.boolValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>any:</code> 会调用<code>objectPassingTest:</code>函数，如果不为nil就代表有value值通过了Test，有通过了value的就返回YES，反之返回NO</li>
<li>all:会从左往右依次对每个值进行block( ) Test，然后每个值依次进行&amp;&amp;操作</li>
<li>测试代码如下:</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *array = @[@<span class="number">5</span>, @<span class="number">3</span>, @<span class="number">9</span>, @<span class="number">4</span>];</span><br><span class="line">RACSequence *sequence = [array rac_sequence];</span><br><span class="line"></span><br><span class="line"><span class="comment">//all</span></span><br><span class="line"><span class="type">BOOL</span> anyBool = [sequence any:^<span class="type">BOOL</span>(<span class="type">id</span>  _Nullable value) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;];</span><br><span class="line"><span class="type">BOOL</span> allBool = [sequence all:^<span class="type">BOOL</span>(<span class="type">id</span>  _Nullable value) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;any = %d, all = %d&quot;</span>, anyBool, allBool);</span><br><span class="line"><span class="comment">//输出: any = 1, all = 1</span></span><br></pre></td></tr></table></figure>

<h2 id="RACSequence的子类和扩展"><a href="#RACSequence的子类和扩展" class="headerlink" title="RACSequence的子类和扩展"></a>RACSequence的子类和扩展</h2><h3 id="子类"><a href="#子类" class="headerlink" title="子类"></a>子类</h3><ul>
<li>关于<code>RACSequence</code>有以下9个子类</li>
<li>其中<code>RACEagerSequence</code>是继承自<code>RACArraySequence</code>。</li>
<li>这些子类看名字就知道<code>sequence</code>里面装的是什么类型的数据。</li>
<li><code>RACUnarySequence</code>里面装的是单元<code>sequence</code>, 它只有head值，没有tail值</li>
</ul>
<p><img data-src="https://upload-images.jianshu.io/upload_images/4122543-4ca3c41197e0fcca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="RACStream.png"></p>
<p>下面列出了每一个子类里面的方法, 前面都已经介绍过这些方法, 这里也就不在赘述</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//RACArraySequence</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RACArraySequence</span> : <span class="title">RACSequence</span></span></span><br><span class="line"></span><br><span class="line">+ (RACSequence *)sequenceWithArray:(<span class="built_in">NSArray</span> *)array offset:(<span class="built_in">NSUInteger</span>)offset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//RACDynamicSequence</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RACDynamicSequence</span> : <span class="title">RACSequence</span></span></span><br><span class="line"></span><br><span class="line">+ (RACSequence *)sequenceWithLazyDependency:(<span class="type">id</span> (^)(<span class="type">void</span>))dependencyBlock headBlock:(<span class="type">id</span> (^)(<span class="type">id</span> dependency))headBlock tailBlock:(RACSequence *(^)(<span class="type">id</span> dependency))tailBlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//RACEmptySequence</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RACEmptySequence</span> : <span class="title">RACSequence</span></span></span><br><span class="line"><span class="comment">//单例</span></span><br><span class="line">+ (RACEmptySequence *)empty;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//RACIndexSetSequence</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RACIndexSetSequence</span> : <span class="title">RACSequence</span></span></span><br><span class="line"></span><br><span class="line">+ (RACSequence *)sequenceWithIndexSet:(<span class="built_in">NSIndexSet</span> *)indexSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//RACSignalSequence</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RACSignalSequence</span> : <span class="title">RACSequence</span></span></span><br><span class="line"></span><br><span class="line">+ (RACSequence *)sequenceWithSignal:(RACSignal *)signal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//RACStringSequence</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RACStringSequence</span> : <span class="title">RACSequence</span></span></span><br><span class="line"></span><br><span class="line">+ (RACSequence *)sequenceWithString:(<span class="built_in">NSString</span> *)string offset:(<span class="built_in">NSUInteger</span>)offset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//RACTupleSequence</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RACTupleSequence</span> : <span class="title">RACSequence</span></span></span><br><span class="line"></span><br><span class="line">+ (RACSequence *)sequenceWithTupleBackingArray:(<span class="built_in">NSArray</span> *)backingArray offset:(<span class="built_in">NSUInteger</span>)offset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//RACUnarySequence</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RACUnarySequence</span> : <span class="title">RACSequence</span></span></span><br><span class="line"></span><br><span class="line">+ (RACUnarySequence *)<span class="keyword">return</span>:(<span class="type">id</span>)value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p><code>RACSequenceAdditions</code> 总共有7个<code>Category</code>。这7个<code>Category</code>分别对iOS 里面的集合类进行了<code>RACSequence</code>的扩展，使我们能更加方便的使用<code>RACSequence</code></p>
<p><img data-src="https://upload-images.jianshu.io/upload_images/4122543-aa6185bb24ec0073.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt="RACSequenceAdditions.png"></p>
<h4 id="NSArray-RACSequenceAdditions"><a href="#NSArray-RACSequenceAdditions" class="headerlink" title="NSArray+RACSequenceAdditions"></a><code>NSArray+RACSequenceAdditions</code></h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSArray</span>&lt;<span class="title">__covariant</span> <span class="title">ObjectType</span>&gt; (<span class="title">RACSequenceAdditions</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) RACSequence&lt;ObjectType&gt; *rac_sequence;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>把任意一个<code>NSArray</code>数组转换成<code>RACSequence</code>, 底层是<code>RACArraySequence</code>调用 <code>sequenceWithArray</code>方法, 将<code>NSArray</code>对象转成<code>RACArraySequence</code>对象</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (RACSequence *)rac_sequence &#123;</span><br><span class="line">	<span class="keyword">return</span> [RACArraySequence sequenceWithArray:<span class="keyword">self</span> offset:<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="NSDictionary-RACSequenceAdditions"><a href="#NSDictionary-RACSequenceAdditions" class="headerlink" title="NSDictionary+RACSequenceAdditions"></a><code>NSDictionary+RACSequenceAdditions</code></h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSDictionary</span>&lt;<span class="title">__covariant</span> <span class="title">KeyType</span>, <span class="title">__covariant</span> <span class="title">ObjectType</span>&gt; (<span class="title">RACSequenceAdditions</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) RACSequence&lt;RACTwoTuple&lt;KeyType, ObjectType&gt; *&gt; *rac_sequence;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) RACSequence&lt;KeyType&gt; *rac_keySequence;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) RACSequence&lt;ObjectType&gt; *rac_valueSequence;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>把任意一个<code>NSDictionary</code>字典转换成<code>RACSequence</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (RACSequence *)rac_sequence &#123;</span><br><span class="line">	<span class="built_in">NSDictionary</span> *immutableDict = [<span class="keyword">self</span> <span class="keyword">copy</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> First class support for dictionary sequences.</span></span><br><span class="line">	<span class="keyword">return</span> [immutableDict.allKeys.rac_sequence map:^(<span class="type">id</span> key) &#123;</span><br><span class="line">		<span class="type">id</span> value = immutableDict[key];</span><br><span class="line">		<span class="keyword">return</span> RACTuplePack(key, value);</span><br><span class="line">	&#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (RACSequence *)rac_keySequence &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">self</span>.allKeys.rac_sequence;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (RACSequence *)rac_valueSequence &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">self</span>.allValues.rac_sequence;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>rac_sequence</code>: 通过map映射<ul>
<li>先将每一个键值对转成<code>RACTuple</code>元组对象, key对应元组的第一个, value对应第二个</li>
<li>将每一个<code>RACTuple</code>元组放在一个数组里面</li>
<li>最后把数组转成<code>RACSequence</code>对象</li>
</ul>
</li>
<li><code>rac_keySequence</code>: 把所有的key值转成<code>RACSequence</code>对象</li>
<li><code>rac_valueSequence</code>: 把所有的value值转成<code>RACSequence</code>对象</li>
</ul>
<h4 id="NSSet-RACSequenceAdditions"><a href="#NSSet-RACSequenceAdditions" class="headerlink" title="NSSet+RACSequenceAdditions"></a><code>NSSet+RACSequenceAdditions</code></h4><p>把任意一个<code>NSSet</code>对象转换成<code>RACSequence</code>对象</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSSet</span>&lt;<span class="title">__covariant</span> <span class="title">ObjectType</span>&gt; (<span class="title">RACSequenceAdditions</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) RACSequence&lt;ObjectType&gt; *rac_sequence;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//属性的getter方法</span></span><br><span class="line">- (RACSequence *)rac_sequence &#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> First class support for set sequences.</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">self</span>.allObjects.rac_sequence;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="NSString-RACSequenceAdditions"><a href="#NSString-RACSequenceAdditions" class="headerlink" title="NSString+RACSequenceAdditions"></a><code>NSString+RACSequenceAdditions</code></h4><p>把任意一个<code>NSString</code>转换成包含该字符串, 所有字符的数组对应的<code>RACSequence</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSString</span> (<span class="title">RACSequenceAdditions</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) RACSequence&lt;<span class="built_in">NSString</span> *&gt; *rac_sequence;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//属性的getter方法</span></span><br><span class="line">- (RACSequence *)rac_sequence &#123;</span><br><span class="line">	<span class="keyword">return</span> [RACStringSequence sequenceWithString:<span class="keyword">self</span> offset:<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="NSEnumerator-RACSequenceAdditions"><a href="#NSEnumerator-RACSequenceAdditions" class="headerlink" title="NSEnumerator+RACSequenceAdditions"></a><code>NSEnumerator+RACSequenceAdditions</code></h4><ul>
<li>把任意一个<code>NSEnumerator</code>转换成<code>RACSequence</code><ul>
<li>返回的<code>RACSequence</code>的head是当前的<code>sequence</code>的head</li>
<li>返回的<code>RACSequence</code>的tail是当前的<code>sequence</code>本身</li>
</ul>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSEnumerator</span>&lt;<span class="title">ObjectType</span>&gt; (<span class="title">RACSequenceAdditions</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) RACSequence&lt;ObjectType&gt; *rac_sequence;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//底层实现</span></span><br><span class="line">- (RACSequence *)rac_sequence &#123;</span><br><span class="line">	<span class="keyword">return</span> [RACSequence sequenceWithHeadBlock:^&#123;</span><br><span class="line">		<span class="keyword">return</span> [<span class="keyword">self</span> nextObject];</span><br><span class="line">	&#125; tailBlock:^&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">self</span>.rac_sequence;</span><br><span class="line">	&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="NSIndexSet-RACSequenceAdditions"><a href="#NSIndexSet-RACSequenceAdditions" class="headerlink" title="NSIndexSet+RACSequenceAdditions"></a><code>NSIndexSet+RACSequenceAdditions</code></h4><p>把任意一个<code>NSIndexSet</code>转换成<code>RACSequence</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSIndexSet</span> (<span class="title">RACSequenceAdditions</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) RACSequence&lt;<span class="built_in">NSNumber</span> *&gt; *rac_sequence;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//底层实现</span></span><br><span class="line">- (RACSequence *)rac_sequence &#123;</span><br><span class="line">	<span class="keyword">return</span> [RACIndexSetSequence sequenceWithIndexSet:<span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="NSOrderedSet-RACSequenceAdditions"><a href="#NSOrderedSet-RACSequenceAdditions" class="headerlink" title="NSOrderedSet+RACSequenceAdditions"></a><code>NSOrderedSet+RACSequenceAdditions</code></h4><p>把任意一个<code>NSOrderedSet</code>中的数组转换成<code>RACSequence</code>对象</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSOrderedSet</span>&lt;<span class="title">__covariant</span> <span class="title">ObjectType</span>&gt; (<span class="title">RACSequenceAdditions</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) RACSequence&lt;ObjectType&gt; *rac_sequence;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//底层实现</span></span><br><span class="line">- (RACSequence *)rac_sequence &#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> First class support for ordered set sequences.</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">self</span>.array.rac_sequence;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>这篇文章篇幅比较长, 都是对源码的解, 文中如有不足之处还望多多指教</li>
<li>下一篇将会着重介绍一下RAC中的一些高级用法, 敬请期待..</li>
<li>参考文章:<ul>
<li><a href="http://cocoadocs.org/docsets/ReactiveCocoa/2.1/Classes/RACSequence.html">http://cocoadocs.org/docsets/ReactiveCocoa/2.1/Classes/RACSequence.html</a></li>
<li><a href="http://williamzang.com/blog/2016/11/07/liao-yi-liao-ioskai-fa-zhong-de-duo-xing-ji-suan/">http://williamzang.com/blog/2016/11/07/liao-yi-liao-ioskai-fa-zhong-de-duo-xing-ji-suan/</a></li>
<li><a href="http://blog.csdn.net/qq_30513483/article/details/53924990">http://blog.csdn.net/qq_30513483/article/details/53924990</a></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>iOS组件库</category>
      </categories>
      <tags>
        <tag>ReactiveCocoa</tag>
        <tag>函数式</tag>
        <tag>响应式</tag>
      </tags>
  </entry>
  <entry>
    <title>ReactiveCocoa使用详解01</title>
    <url>/post/eac9a3e3.html</url>
    <content><![CDATA[<p><a href="https://github.com/ReactiveCocoa">ReactiveCocoa</a>（简称为RAC）,是由<code>Github</code>开源的一个应用于iOS和OS开发的函数式响应式编程框架，它提供了一系列用来组合和转换值流的 API</p>
<span id="more"></span>

<h2 id="什么是响应式变成思想"><a href="#什么是响应式变成思想" class="headerlink" title="什么是响应式变成思想?"></a>什么是响应式变成思想?</h2><p>学习一个框架之前, 首先要了解这个框架的编程思想, 这里在介绍响应式编程思想之前, 先介绍一下之前接触过的编程思想</p>
<h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><ul>
<li>万物皆对象<ul>
<li>是一类以对象作为基本程序结构单位的程序设计语言</li>
<li>典型的面向对象的编程语言有<code>C++</code>, <code>C#</code>, <code>Java</code>等</li>
</ul>
</li>
</ul>
<h3 id="面向过程"><a href="#面向过程" class="headerlink" title="面向过程"></a>面向过程</h3><ul>
<li>一种以过程为中心的编程思想</li>
<li>C语言就是一门面向过程的语言</li>
</ul>
<h3 id="链式编程思想"><a href="#链式编程思想" class="headerlink" title="链式编程思想"></a>链式编程思想</h3><ul>
<li>是将多个操作（多行代码）通过点号(.)链接在一起成为一句代码,使代码可读性好</li>
<li>链式编程特点：方法的返回值是block, block必须有返回值（本身对象），block参数（需要操作的值）</li>
<li>典型框架：masonry框架。</li>
</ul>
<h3 id="函数式编程思想"><a href="#函数式编程思想" class="headerlink" title="函数式编程思想"></a>函数式编程思想</h3><ul>
<li>万物皆是流<ul>
<li>不需要考虑调用顺序，只需要知道考虑结果</li>
<li>类似于蝴蝶效应，产生一个事件，会影响很多东西，这些事件像流一样的传播出去，然后影响结果</li>
<li>代表：KVO运用</li>
</ul>
</li>
</ul>
<h3 id="函数式编程思想-1"><a href="#函数式编程思想-1" class="headerlink" title="函数式编程思想"></a>函数式编程思想</h3><ul>
<li>是把操作尽量写成一系列嵌套的函数或者方法调用</li>
<li>特点: 每个方法必须有返回值（本身对象）,把函数或者Block当做参数,block参数（需要操作的值）block返回值（操作结果）</li>
<li>代表：ReactiveCocoa</li>
</ul>
<h3 id="ReactiveCocoa编程思想"><a href="#ReactiveCocoa编程思想" class="headerlink" title="ReactiveCocoa编程思想"></a><code>ReactiveCocoa</code>编程思想</h3><ul>
<li>函数式编程 <code>Functional Programming</code></li>
<li>响应式编程 <code>Reactive Programming</code></li>
</ul>
<p>所以, <code>ReactiveCocoa</code>被描述为函数响应式编程（FRP）框架, 下面具体介绍一下<code>RAC</code>的一些常见类</p>
<h2 id="RACSiganl-信号类"><a href="#RACSiganl-信号类" class="headerlink" title="RACSiganl 信号类"></a>RACSiganl 信号类</h2><ul>
<li><code>ReactiveCocoa</code> 中最核心的概念之一就是信号<code>RACStream</code>。<code>RACStream</code>中有两个子类——<code>RACSignal</code> 和 <code>RACSequence</code>; 这里我们就主要说一下<code>RACSignal</code>; </li>
<li>在<code>ReactiveCocoa</code>整个库中，<code>RACSignal</code>占据着比较重要的位置，而<code>RACSignal</code>的变换操作更是整个<code>RACStream</code>流操作核心之一</li>
<li>下面让我们俩看一下<code>RACSignal</code>被订阅的完整过程</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)test2 &#123;</span><br><span class="line">    <span class="comment">//创建信号</span></span><br><span class="line">    RACSignal *single = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="type">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">        <span class="comment">//发送消息</span></span><br><span class="line">        [subscriber sendNext:<span class="string">@&quot;a&quot;</span>];</span><br><span class="line">        [subscriber sendNext:<span class="string">@&quot;b&quot;</span>];</span><br><span class="line">        <span class="comment">//发送完成</span></span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//清空数据</span></span><br><span class="line">        <span class="keyword">return</span> [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">            <span class="comment">//当订阅者被消耗的时候就会执行</span></span><br><span class="line">            <span class="comment">//当订阅者发送完成,或者error的时候也会执行</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;RACDisposable的block&quot;</span>);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//订阅信号</span></span><br><span class="line">    RACDisposable *disposable = [single subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;value = %@&quot;</span>, x);</span><br><span class="line">    &#125; error:^(<span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;error: %@&quot;</span>, error);</span><br><span class="line">    &#125; completed:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;completed&quot;</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//释放</span></span><br><span class="line">    [disposable dispose];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>在此之前先看一下<code>RACSignal</code>的一些子类<ul>
<li><code>RACDynamicSignal</code>: 动态信号，使用一个 <code>block</code> 来实现订阅行为，我们在使用 <code>RACSignal</code> 的 <code>+createSignal:</code> 方法时创建的就是该类的实例</li>
<li><code>RACEmptySignal</code>：空信号，用来实现 <code>RACSignal</code> 的 <code>+empty</code> 方法；</li>
<li><code>RACReturnSignal</code>：一元信号，用来实现 <code>RACSignal</code> 的 <code>+return:</code>方法；</li>
<li><code>RACErrorSignal</code>：错误信号，用来实现 <code>RACSignal</code> 的 <code>+error:</code> 方法；</li>
<li><code>RACChannelTerminal</code>：通道终端，代表 <code>RACChannel</code> 的一个终端，用来实现双向绑定</li>
</ul>
</li>
</ul>
<blockquote>
<p><code>RACSignal</code>在创建信号的时候，底层会调用<code>RACDynamicSignal</code>的<code>createSignal</code>的方法, 如下:</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (RACSignal *)createSignal:(RACDisposable * (^)(<span class="type">id</span>&lt;RACSubscriber&gt; subscriber))didSubscribe &#123;</span><br><span class="line">	<span class="keyword">return</span> [RACDynamicSignal createSignal:didSubscribe];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里的block是一个 <code>id&lt;RACSubscriber&gt;</code> 类型的<code>subscriber</code>, 而这个<code>RACSubscriber</code>, 我们可以点进去看一些底层实现,  协议方法如下:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">RACSubscriber</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="keyword">@required</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// Sends the next value to subscribers.</span></span><br><span class="line">- (<span class="type">void</span>)sendNext:(<span class="keyword">nullable</span> <span class="type">id</span>)value;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Sends the error to subscribers.</span></span><br><span class="line">- (<span class="type">void</span>)sendError:(<span class="keyword">nullable</span> <span class="built_in">NSError</span> *)error;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Sends completed to subscribers.</span></span><br><span class="line">- (<span class="type">void</span>)sendCompleted;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Sends the subscriber a disposable that represents one of its subscriptions.</span></span><br><span class="line">- (<span class="type">void</span>)didSubscribeWithDisposable:(RACCompoundDisposable *)disposable;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>RACSignal底层实现：<ul>
<li>1.创建信号，首先把<code>didSubscribe</code>保存到信号中，还不会触发。</li>
<li>2.当信号被订阅，也就是调用<code>signal</code>的<code>subscribeNext:nextBlock</code><ul>
<li>2.1 <code>subscribeNext</code>内部会创建订阅者<code>subscriber</code>，并且把<code>nextBlock</code>保存到<code>subscriber</code>中。</li>
<li>2.2 <code>subscribeNext</code>内部会调用<code>siganl的didSubscribe</code></li>
<li>2.3 当信号订阅完成, 不在发送数据的时候, 最好调用完成发送的<code>[subscriber sendCompleted];</code></li>
<li>订阅完成的时候, 内部会自动调用<code>[RACDisposable disposable]</code>取消订阅信号</li>
</ul>
</li>
<li>3.<code>siganl</code>的<code>didSubscribe</code>中调用<code>[subscriber sendNext:@1];</code><ul>
<li>3.1 <code>sendNext</code>底层其实就是执行<code>subscriber</code>的<code>nextBlock</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="信号提供者-RACSubject"><a href="#信号提供者-RACSubject" class="headerlink" title="信号提供者: RACSubject"></a>信号提供者: <code>RACSubject</code></h2><ul>
<li>信号提供者，自己可以充当信号，又能发送信号</li>
<li>先订阅, 在发送信号</li>
<li>使用场景:通常用来代替代理&#x2F;通知</li>
</ul>
<h3 id="RACSubject简单使用"><a href="#RACSubject简单使用" class="headerlink" title="RACSubject简单使用"></a><code>RACSubject</code>简单使用</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)setRacSubject1 &#123;</span><br><span class="line">    <span class="comment">//先订阅, 在发送信号</span></span><br><span class="line">    <span class="comment">//1. 创建信号</span></span><br><span class="line">    RACSubject *subject = [RACSubject subject];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2. 订阅</span></span><br><span class="line">    <span class="comment">//内部创建RACSubscriber</span></span><br><span class="line">    [subject subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;第一个订阅者--%@&quot;</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [subject subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;第二个订阅者---%@&quot;</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 发送信号</span></span><br><span class="line">    <span class="comment">//遍历所有的订阅者, 执行nextBlock</span></span><br><span class="line">    [subject sendNext:@<span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 打印结果</span></span><br><span class="line"><span class="comment">     2018-03-17 20:18:19.782119+0800 ReactiveObjc[23883:1420936] 第一个订阅者--2</span></span><br><span class="line"><span class="comment">     2018-03-17 20:18:19.784715+0800 ReactiveObjc[23883:1420936] 第二个订阅者---2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>RACSubject:底层实现和RACSignal不一样 <ul>
<li>1.调用<code>subscribeNext</code>订阅信号，只是把订阅者保存起来，并且订阅者的<code>nextBlock</code>已经赋值了。</li>
<li>2.调用<code>sendNext</code>发送信号，遍历刚刚保存的所有订阅者，一个一个调用订阅者的<code>nextBlock</code></li>
</ul>
</li>
</ul>
<h3 id="RACReplaySubject简单使用"><a href="#RACReplaySubject简单使用" class="headerlink" title="RACReplaySubject简单使用"></a><code>RACReplaySubject</code>简单使用</h3><ul>
<li>重复提供信号类，RACSubject的子类</li>
<li>先发送信号，再订阅信号；</li>
<li>使用场景<ul>
<li><ol>
<li>如果一个信号每被订阅一次，就需要把之前的值重复发送一遍，使用重复提供信号类。</li>
</ol>
</li>
<li><ol start="2">
<li>可以设置<code>capacity</code>数量来限制缓存的<code>value</code>的数量，即只缓充最新的几个值</li>
</ol>
</li>
</ul>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)setReplaySubject &#123;</span><br><span class="line">    <span class="comment">//创建信号</span></span><br><span class="line">    RACReplaySubject *replySub = [RACReplaySubject subject];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//发送信号</span></span><br><span class="line">    [replySub sendNext:@<span class="number">23</span>];</span><br><span class="line">    [replySub sendNext:@<span class="number">34</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//订阅信号</span></span><br><span class="line">    <span class="comment">// 遍历值，让一个订阅者去发送多个值</span></span><br><span class="line">    <span class="comment">// 只要订阅一次，之前所有发送的值都能获取到.</span></span><br><span class="line">    [replySub subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     2018-03-19 12:01:14.112253+0800 ReactiveObjc[5130:446958] 23</span></span><br><span class="line"><span class="comment">     2018-03-19 12:01:14.112511+0800 ReactiveObjc[5130:446958] 34</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>RACReplaySubject</code>的底层实现<ul>
<li><ol>
<li>订阅信号时，内部保存了订阅者，和订阅者响应block</li>
</ol>
</li>
<li><ol start="2">
<li>当发送信号的，遍历订阅者，调用订阅者的nextBlock</li>
</ol>
</li>
<li><ol start="3">
<li>发送的信号会保存起来，当订阅者订阅信号的时，会将之前保存的信号，一个一个作用于新的订阅者，保存信号的容量由<code>capacity</code>决定，这也是有别于RACSubject的</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="替代代理-x2F-通知"><a href="#替代代理-x2F-通知" class="headerlink" title="替代代理&#x2F;通知"></a>替代代理&#x2F;通知</h3><ul>
<li>这里我们设想一个反向传值的场景, vc里面有一个自定义的view, 当点击该<code>View</code>的时候, 更换vc的背景颜色</li>
<li>通常我们的做法是使用代理&#x2F;通知&#x2F;block</li>
</ul>
<h4 id="下面看一下代理的简单使用"><a href="#下面看一下代理的简单使用" class="headerlink" title="下面看一下代理的简单使用"></a>下面看一下代理的简单使用</h4><p> 在自定义View中设置协议</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">SubjectView</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">SubjectDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@optional</span></span><br><span class="line">- (<span class="type">void</span>)viewWithTap:(SubjectView *)subView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SubjectView</span> : <span class="title">UIView</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="type">id</span>&lt;SubjectDelegate&gt; delegate;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在vc中, 遵循代理, 并实现代理方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 代理方法</span></span><br><span class="line">-(<span class="type">void</span>)viewWithTap:(SubjectView *)subView&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;完成代理, 点击了view&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIColor</span> *color = [<span class="built_in">UIColor</span> colorWithRed:(arc4random() % <span class="number">255</span>) / <span class="number">255.0</span> green:(arc4random() % <span class="number">255</span>) / <span class="number">255.0</span> blue:(arc4random() % <span class="number">255</span>) / <span class="number">255.0</span> alpha:<span class="number">1.0</span>];</span><br><span class="line">    <span class="keyword">self</span>.view.backgroundColor = color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="RACSubject代替代理"><a href="#RACSubject代替代理" class="headerlink" title="RACSubject代替代理"></a><code>RACSubject</code>代替代理</h4><p>在自定义<code>SubjectView.h</code>文件中</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;ReactiveObjC.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SubjectView</span> : <span class="title">UIView</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) RACSubject *subject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在自定义<code>SubjectView.m</code>文件中</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;SubjectView.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SubjectView</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="comment">//发送信号</span></span><br><span class="line">    [_subject sendNext:<span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>下面看一下在vc中的操作</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)setupSubjectView &#123;</span><br><span class="line">    SubjectView *subV = [[SubjectView alloc]init];</span><br><span class="line">    subV.backgroundColor = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">    subV.frame = <span class="built_in">CGRectMake</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">    RACSubject *subject = [RACSubject subject];</span><br><span class="line">    [subject subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;完成代理, 点击了view&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">UIColor</span> *color = [<span class="built_in">UIColor</span> colorWithRed:(arc4random() % <span class="number">255</span>) / <span class="number">255.0</span> green:(arc4random() % <span class="number">255</span>) / <span class="number">255.0</span> blue:(arc4random() % <span class="number">255</span>) / <span class="number">255.0</span> alpha:<span class="number">1.0</span>];</span><br><span class="line">        <span class="keyword">self</span>.view.backgroundColor = color;</span><br><span class="line">    &#125;];</span><br><span class="line">    subV.subject = subject;</span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:subV];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>相关ReactiveObjc的知识点, 后期会持续更新…</li>
<li>推荐文章: <a href="http://www.cocoachina.com/ios/20160729/17236.html">iOS ReactiveCocoa 最全常用API整理</a></li>
</ul>
]]></content>
      <categories>
        <category>iOS组件库</category>
      </categories>
      <tags>
        <tag>ReactiveCocoa</tag>
        <tag>函数式</tag>
        <tag>响应式</tag>
      </tags>
  </entry>
  <entry>
    <title>Realm在iOS中的简单使用</title>
    <url>/post/a0131d49.html</url>
    <content><![CDATA[<ul>
<li><a href="https://docs.realm.io/platform/">Realm</a>是由美国<code>YCombinator</code>孵化的创业团队历时几年打造，第一个专门针对移动平台设计的数据库</li>
<li><a href="https://docs.realm.io/platform/">Realm</a>是一个跨平台的移动数据库引擎，目前支持<code>iOS</code>、<code>Android</code>平台，同时支持<code>Objective-C</code>、<code>Swift</code>、<code>Java</code>、<code>React Native</code>、<code>Xamarin</code>等多种编程语言</li>
<li><code>Realm</code>并不是对<code>SQLite</code>或者<code>CoreData</code>的简单封装, 是由核心数据引擎<code>C++</code>打造，是拥有独立的数据库存储引擎，可以方便、高效的完成数据库的各种操作</li>
</ul>
<span id="more"></span>



<h2 id="Realm简单介绍"><a href="#Realm简单介绍" class="headerlink" title="Realm简单介绍"></a><code>Realm</code>简单介绍</h2><h3 id="Realm的优势与亮点"><a href="#Realm的优势与亮点" class="headerlink" title="Realm的优势与亮点"></a><code>Realm</code>的优势与亮点</h3><ul>
<li>开源。<code>Realm</code>移动端数据库相关代码已全部开源。数千开发者在<code>GitHub</code>上参与了相关工作。另外还有几百个<code>Realm</code>数据库相关的扩展。</li>
<li>简单易用：<code>Core Data</code>、<code>SQLite</code>庞大的学习量和繁杂的代码足以吓退绝大多数刚入门的开发者，而换用<code>Realm</code>，则可以极大地减少学习代价和学习时间，让应用及早用上数据存储功能</li>
<li>跨平台：现在绝大多数的应用开发并不仅仅只在<code>iOS</code>平台上进行开发，还要兼顾到<code>Android</code>平台的开发。为两个平台设计不同的数据库是不明智的，而使用<code>Realm</code>数据库，<code>iOS</code>和<code>Android</code>无需考虑内部数据的架构，调用<code>Realm</code>提供的<code>API</code>就可以完成数据的交换</li>
<li>线程安全。程序员无需对在不同线程中，对数据库的读取一致性做任何考虑，<code>Realm</code>会保证每次读取都得到一致的数据</li>
</ul>
<h3 id="可视化工具Realm-Browser"><a href="#可视化工具Realm-Browser" class="headerlink" title="可视化工具Realm Browser"></a>可视化工具<code>Realm Browser</code></h3><p>为了配合<code>Realm</code>的使用，<code>Realm</code>还提供了一个轻量级的数据库查看工具<code>Realm Browser</code>，借助这个工具，开发者可以查看数据库当中的内容，并执行简单的插入和删除操作。<code>Realm Browser</code>可以在<code>App Store</code>中下载安装</p>
<p><img data-src="https://user-gold-cdn.xitu.io/2018/8/10/16521ebc65be0257?w=1017&h=828&f=png&s=624540" alt="Realm Browser"></p>
<div class="note warning"><p>需要注意的是</p></div>

<p>如果需要调试, 可以通过<code>NSHomeDirectory()</code>打印出<code>Realm</code>数据库地址, 找到对应的<code>Realm</code>文件, 然后用<code>Realm Browser</code>可视化工具打开即可</p>
<h2 id="Realm的安装"><a href="#Realm的安装" class="headerlink" title="Realm的安装"></a><code>Realm</code>的安装</h2><p><a href="https://github.com/realm/realm-cocoa">Realm的Github地址</a></p>
<h3 id="手动安装"><a href="#手动安装" class="headerlink" title="手动安装"></a>手动安装</h3><p>当使用手工方式安装Realm时，可以按照如下步骤进行</p>
<ul>
<li>登录<a href="https://realm.io/docs/objc/latest/#getting-started">Realm官方网站</a>或者<a href="https://github.com/realm/realm-cocoa">Github</a>，下载<code>Realm</code>的最新版本并解压</li>
<li>将<code>Realm.framework</code>从<code>ios/static/</code>文件夹拖曳到您<code>Xcode</code>项目中的文件导航器当中, 确保<code>Copy items if needed</code>选中然后单击<code>Finish</code></li>
<li>在<code>Xcode</code>文件导航器中选择您的项目，然后选择您的应用目标，进入到<code>Build Phases</code>选项卡中。在<code>Link Binary with Libraries</code>中单击 <code>+</code> 号然后添加<code>libc++.tbd</code>以及<code>libz.tbd</code></li>
</ul>
<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-be0044738ece664b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="RealmResource"></p>
<h3 id="使用CocoaPods安装"><a href="#使用CocoaPods安装" class="headerlink" title="使用CocoaPods安装"></a>使用<code>CocoaPods</code>安装</h3><p>当使用<code>CocoaPods</code>方式安装<code>Realm</code>时，以<code>Objective-C</code>为例</p>
<ul>
<li><code>CocoaPods</code>版本要求是<code>1.1.0</code>及以上版本</li>
<li>在<code>Podfile</code>中，添加<code>pod &#39;Realm&#39;</code>，如有需要, 添加<code>pod &#39;Realm/Headers&#39;</code>到测试项目中</li>
<li>在终端运行<code>pod install</code>即可安装</li>
<li>在<code>Swift</code>中需要输入<code>pod &#39;RealmSwift&#39;</code>才可以安装</li>
<li>如果是混编项目，就需要安装OC的<code>Realm</code>, 然后要把 <a href="https://github.com/realm/realm-cocoa/blob/master/Realm/Swift/RLMSupport.swift">Swift&#x2F;RLMSupport.swift</a>文件一同编译进去</li>
</ul>
<div class="note info"><p>`RLMSupport.swift`</p></div>

<p><code>RLMSupport.swift</code>这个文件为<code>Objective-C</code>版本的<code>Realm</code>集合类型中引入了<code>Sequence</code>一致性，并且重新暴露了一些不能够从<code>Swift </code>中进行原生访问的<code>Objective-C</code>方法，例如可变参数<code>variadic arguments</code>等, 更加详细的说明见<a href="https://realm.io/docs/objc/latest/#getting-started">官方文档</a></p>
<h3 id="Xcode插件"><a href="#Xcode插件" class="headerlink" title="Xcode插件"></a>Xcode插件</h3><ul>
<li><code>Realm</code>提供了一个<code>Xcode</code>插件，来方便的创建<code>RLMObject</code>类，这需要我们首先安装相关的插件</li>
<li>打开<code>Realm</code>文件夹中的<code>plugin/RealmPlugin.xcodeproj</code>并进行编译，重启<code>Xcode</code>之后插件即可生效</li>
<li>当需要新建<code>RLMObject</code>类时，在新建类的选项中选择<code>Realm Model Object</code>即可</li>
</ul>
<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-4275bdc87fc5e24a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Realm Model"></p>
<h2 id="Realm的类定义说明"><a href="#Realm的类定义说明" class="headerlink" title="Realm的类定义说明"></a><code>Realm</code>的类定义说明</h2><p>在<code>Realm</code>框架中，定义了二十个核心类、常量、枚举类型、协议等，常用的如：<code>RLMRealm</code>类、<code>RLMObject</code>类、<code>RLMResults</code>类等, 我们可以从<code>Realm</code>的<a href="https://realm.io/docs/objc/latest/api/Constants.html">官方网站</a>上查看所有的定义以及使用说明</p>
<h3 id="RLMRealm类"><a href="#RLMRealm类" class="headerlink" title="RLMRealm类"></a>RLMRealm类</h3><ul>
<li>一个<code>RLMRealm</code>类的对象可以认为是一个<code>Realm</code>的数据库。<code>Realm</code>数据库既可以存储在硬盘上，同时也可以存储在内存中</li>
<li><code>Realm</code>是框架的核心所在，是我们构建数据库的访问点，就如同<code>Core Data</code>的管理对象上下文<code>managed object context</code>一样</li>
<li><code>RLMRealm</code>类中，常用的属性或方法如下</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取默认的Realm数据库</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)defaultRealm;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//实例化一个RLMRealm类的对象</span></span><br><span class="line"><span class="comment">//根据配置参数获得RLMRealm</span></span><br><span class="line">+ (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)realmWithConfiguration:(RLMRealmConfiguration *)configuration error:(<span class="built_in">NSError</span> **)error;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据指定持久化文件路径获得RLMRealm</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)realmWithPath:(<span class="built_in">NSString</span> *)path;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//对Realm数据库进行读写操作</span></span><br><span class="line"><span class="comment">//在Realm上开始写入事务, 每个Realm文件一次只能打开一个写事务</span></span><br><span class="line">- (<span class="type">void</span>)beginWriteTransaction;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在当前写入事务中提交所有写入操作，并结束事务</span></span><br><span class="line">- (<span class="type">void</span>)commitWriteTransaction;</span><br><span class="line"><span class="comment">//没有足够的磁盘空间来保存写入或由于意外的I / O错误，此方法可能会失败, 并返回error信息</span></span><br><span class="line">- (<span class="type">BOOL</span>)commitWriteTransaction:(<span class="built_in">NSError</span> **)error;</span><br><span class="line"><span class="comment">// 在当前写入事务中提交所有写入操作，而不收到此写入事件的特定通知</span></span><br><span class="line">- (<span class="type">BOOL</span>)commitWriteTransactionWithoutNotifying:(<span class="built_in">NSArray</span>&lt;RLMNotificationToken *&gt; *)tokens error:(<span class="built_in">NSError</span> **)error;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回滚在当前写入事务期间进行的所有写入并结束事务</span></span><br><span class="line">- (<span class="type">void</span>)cancelWriteTransaction;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行写入事务内给定块中包含的操作</span></span><br><span class="line">- (<span class="type">void</span>)transactionWithBlock:(__attribute__((noescape)) <span class="type">void</span>(^)(<span class="type">void</span>))block;</span><br><span class="line"><span class="comment">//执行写入事务内给定块中包含的操作, 如果发生错误，则返回时包含NSError描述问题的对象</span></span><br><span class="line">- (<span class="type">BOOL</span>)transactionWithBlock:(__attribute__((noescape)) <span class="type">void</span>(^)(<span class="type">void</span>))block error:(<span class="built_in">NSError</span> **)error;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//添加或更新一个对象</span></span><br><span class="line">- (<span class="type">void</span>)addObject:(RLMObject *)object;</span><br><span class="line"><span class="comment">//将现有对象添加或更新到Realm中, 有则更新没有则插入</span></span><br><span class="line">- (<span class="type">void</span>)addOrUpdateObject:(RLMObject *)object;</span><br><span class="line"><span class="comment">//添加或更新多个对象</span></span><br><span class="line">- (<span class="type">void</span>)addObjects:(<span class="type">id</span>&lt;<span class="built_in">NSFastEnumeration</span>&gt;)objects;</span><br><span class="line">- (<span class="type">void</span>)addOrUpdateObjects:(<span class="type">id</span>&lt;<span class="built_in">NSFastEnumeration</span>&gt;)objects;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除对象</span></span><br><span class="line">- (<span class="type">void</span>)deleteObject:(RLMObject *)object;</span><br><span class="line">- (<span class="type">void</span>)deleteObjects:(<span class="type">id</span>)array;</span><br><span class="line">- (<span class="type">void</span>)deleteAllObjects;</span><br></pre></td></tr></table></figure>


<h3 id="RLMObject类"><a href="#RLMObject类" class="headerlink" title="RLMObject类"></a>RLMObject类</h3><ul>
<li>在<code>Realm</code>数据库中存储的都是<code>RMObject</code>对象，<code>RLMObject</code>类是所有可以存储在<code>Realm</code>数据库中的对象的根类</li>
<li>凡是可以存储在<code>Realm</code>数据库中的对象都是<code>RLMObject</code>类或<code>RLMObject</code>类的子类</li>
<li>要创建一个数据模型，我们只需要继承<code>RLMObject</code>，然后设计我们想要存储的属性即可</li>
<li>在<code>RLMObject</code>类中，我们可以添加属性，添加的属性类型可以支持如下类型：<ul>
<li><code>NSString</code>：字符串</li>
<li><code>NSInteger</code>, <code>int</code>, <code>long</code>, <code>float</code>, <code>double</code>：数字型，注意没有<code>CGFloat</code></li>
<li><code>BOOL/bool</code>：布尔型</li>
<li><code>NSDate</code>：日期型</li>
<li><code>NSData</code>：二进制字符型</li>
<li><code>NSNumber&lt;X&gt;</code>: 其中<code>X</code>必须<code>RLMInt</code>, <code>RLMFloat</code>, <code>RLMDouble</code>或 <code>RLMBool</code>类型</li>
<li><code>RLMArray&lt;X&gt;</code>: 其中<code>X</code>必须是<code>RLMObject</code>类的子类, 用于建模多对多关系</li>
<li><code>RLMObject</code>的子类，用于建模多对一关系</li>
</ul>
</li>
<li><code>RLMObject</code>类中，比较常用如下方法：</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建Realm对象, 传入一个NSArray或NSDictionary实例来设置对象属性的值</span></span><br><span class="line">- (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)initWithValue:(<span class="keyword">nonnull</span> <span class="type">id</span>)value;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在Realm数据库中，获取该RLMObject类的所有对象</span></span><br><span class="line">+ (RLMResults *)allObjects;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据查询条件返回满足条件的所有RLMObject类的对象</span></span><br><span class="line">+ (RLMResults *)objectsWhere:(<span class="built_in">NSString</span> *)predicateFormat, ...;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用默认Realm中的给定主键检索此对象类型的单个实例</span></span><br><span class="line">+ (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)objectForPrimaryKey:(<span class="keyword">nullable</span> <span class="type">id</span>)primaryKey;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从指定的Realm返回此对象类型的所有对象</span></span><br><span class="line">+ (<span class="keyword">nonnull</span> RLMResults *)allObjectsInRealm:(<span class="keyword">nonnull</span> RLMRealm *)realm;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回与指定Realm中给定谓词匹配的此对象类型的所有对象</span></span><br><span class="line">+ (<span class="keyword">nonnull</span> RLMResults *)objectsInRealm:(<span class="keyword">nonnull</span> RLMRealm *)realm where:(<span class="keyword">nonnull</span> <span class="built_in">NSString</span> *)predicateFormat, ...;</span><br></pre></td></tr></table></figure>


<h3 id="RLMResults类"><a href="#RLMResults类" class="headerlink" title="RLMResults类"></a>RLMResults类</h3><ul>
<li>当我们执行一个查询操作后，查询出满足条件的<code>RLMObject</code>对象会存放在一个<code>RLMResults</code>对象中</li>
<li><code>RLMResults</code>类是一个数组类型的数据结构，因此在其类定义中，提供了很多与数组类似的属性和方法</li>
</ul>
<div class="note info"><p>相关属性</p></div>

<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结果集合中的对象个数</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSUInteger</span> count;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果集合中对象的类型</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) RLMPropertyType type;</span><br><span class="line"></span><br><span class="line"><span class="comment">//管理此结果集合的Realm对象</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>) RLMRealm *_Nonnull realm;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果集合中包含的对象的类名称</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">copy</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) <span class="built_in">NSString</span> *objectClassName;</span><br></pre></td></tr></table></figure>


<div class="note info"><p>相关方法</p></div>


<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回结果集合中的第一个对象</span></span><br><span class="line">- (<span class="keyword">nullable</span> RLMObjectType)firstObject;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回结果集合中的最后一个对象</span></span><br><span class="line">- (<span class="keyword">nullable</span> RLMObjectType)lastObject;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据索引index获取其中的某个对象</span></span><br><span class="line">- (RLMObjectType)objectAtIndex:(<span class="built_in">NSUInteger</span>)index;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据对象返回其索引</span></span><br><span class="line">- (<span class="built_in">NSUInteger</span>)indexOfObject:(RLMObjectArgument)object;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回与谓词匹配的结果集合中第一个对象的索引</span></span><br><span class="line">- (<span class="built_in">NSUInteger</span>)indexOfObjectWhere:(<span class="keyword">nonnull</span> <span class="built_in">NSString</span> *)predicateFormat, ...;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回与结果集合中给定谓词匹配的所有对象</span></span><br><span class="line">- (RLMResults&lt;RLMObjectType&gt; *)objectsWhere:(<span class="built_in">NSString</span> *)predicateFormat, ...;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回RLMResults从现有结果集合中排序的内容</span></span><br><span class="line">- (RLMResults&lt;RLMObjectType&gt; *)sortedResultsUsingKeyPath:(<span class="built_in">NSString</span> *)keyPath ascending:(<span class="type">BOOL</span>)ascending;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回RLMResults与现有结果集合不同的内容</span></span><br><span class="line">- (<span class="keyword">nonnull</span> RLMResults&lt;RLMObjectType&gt; *)distinctResultsUsingKeyPaths:(<span class="keyword">nonnull</span> <span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)keyPaths;</span><br></pre></td></tr></table></figure>


<div class="note warning"><p>更多相关类及其属性和方法, 可参考官方文档</p></div>

<p><a href="https://realm.io/docs/objc/latest/api/Classes.html">https://realm.io/docs/objc/latest/api/Classes.html</a></p>
<h2 id="Realm的使用"><a href="#Realm的使用" class="headerlink" title="Realm的使用"></a><code>Realm</code>的使用</h2><p><code>Realm</code>中一些常用的类及其类的属性和方法上面已经介绍了, 下面我们就介绍<code>Realm</code>的使用方法</p>
<h3 id="创建RLMObject类"><a href="#创建RLMObject类" class="headerlink" title="创建RLMObject类"></a>创建RLMObject类</h3><p>我们首先创建一个<code>Student</code>类，该类是<code>RLMObject</code>类的一个子类, 下图就是按照之前安装的<code>Xcode</code>插件创建的</p>
<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-7318cedc2fa2df2f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<ul>
<li>在<code>Student</code>添加两个属性, <code>RLMObject</code>官方建议在<code>RLMObject</code>类中添加的属性，是不需要指定属性关键字的，完全交由<code>Realm</code>处理</li>
<li>假如设置了，这些<code>attributes</code>会一直生效直到<code>RLMObject</code>被写入<code>realm</code>数据库</li>
<li><code>RLM_ARRAY_TYPE</code>宏创建了一个协议，从而允许 <code>RLMArray&lt;Car&gt;</code>语法的使用</li>
<li>如果<code>RLM_ARRAY_TYPE</code>宏没有放置在模型接口的底部的话，您或许需要提前声明该模型类</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Student</span> : <span class="title">RLMObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> <span class="type">int</span> num;</span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSString</span> *name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">RLM_ARRAY_TYPE(Student)</span><br></pre></td></tr></table></figure>



<h3 id="存储操作"><a href="#存储操作" class="headerlink" title="存储操作"></a>存储操作</h3><ul>
<li>对于<code>RLMObject</code>类型的对象，我们可以直接对创建的对象进行存储</li>
<li>第一步, 初始化对象</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式一: 接受一个数组对象</span></span><br><span class="line">Student *stu1 = [[Student alloc]initWithValue:@[@<span class="number">1</span>, <span class="string">@&quot;jun&quot;</span>]];</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二: 接受一个字典对象</span></span><br><span class="line">Student *stu2 = [[Student alloc]initWithValue:@&#123;<span class="string">@&quot;num&quot;</span>: @<span class="number">2</span>, <span class="string">@&quot;name&quot;</span>:<span class="string">@&quot;titan&quot;</span>&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式三: 属性赋值</span></span><br><span class="line">Student *stu3 = [[Student alloc]init];</span><br><span class="line">stu3.num = <span class="number">3</span>;</span><br><span class="line">stu3.name = <span class="string">@&quot;titanjun&quot;</span>;</span><br></pre></td></tr></table></figure>


<p>第二步就是把<code>RLMObject</code>对象写入<code>Realm</code>数据库, 同样有三种方式</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式一: 提交事务处理</span></span><br><span class="line"><span class="comment">//获取Realm对象</span></span><br><span class="line">RLMRealm *realm = [RLMRealm defaultRealm];</span><br><span class="line"><span class="comment">//开始写入事务</span></span><br><span class="line">[realm beginWriteTransaction];</span><br><span class="line"><span class="comment">//添加模型对象</span></span><br><span class="line">[realm addObject:stu1];</span><br><span class="line"><span class="comment">//提交写入事务</span></span><br><span class="line">[realm commitWriteTransaction];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二: 在事务中调用addObject:方法</span></span><br><span class="line">RLMRealm *realm = [RLMRealm defaultRealm];</span><br><span class="line">[realm transactionWithBlock:^&#123;</span><br><span class="line">    [realm addObject:webSite1];</span><br><span class="line">    [realm addObject:webSite2];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//方式三: 在十五中创建新的对象并添加</span></span><br><span class="line">[realm transactionWithBlock:^&#123;</span><br><span class="line">    <span class="comment">//添加模型</span></span><br><span class="line">    [Student createInRealm:realm withValue:@&#123;<span class="string">@&quot;num&quot;</span>: @<span class="number">3</span>, <span class="string">@&quot;name&quot;</span>:<span class="string">@&quot;coder&quot;</span>&#125;];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<div class="note warning"><p>一定要注意的是</p></div>

<ul>
<li>所有的必需属性都必须在对象添加到<code>Realm</code>前被赋值</li>
<li>如果在进程中存在多个写入操作的话，那么单个写入操作将会阻塞其余的写入操作，并且还会锁定该操作所在的当前线程<ul>
<li>建议常规的最佳做法：将写入操作转移到一个独立的线程中执行</li>
<li>官方给出的建议：由于<code>Realm</code>采用了<code>MVCC</code>设计架构，读取操作并不会因为写入事务正在进行而受到影响</li>
<li>除非您需要立即使用多个线程来同时执行写入操作，不然您应当采用批量化的写入事务，而不是采用多次少量的写入事务</li>
<li>下面的代码就是把写事务放到子线程中去处理</li>
</ul>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        </span><br><span class="line">    RLMRealm *realm = [RLMRealm defaultRealm];</span><br><span class="line">    [realm transactionWithBlock:^&#123;</span><br><span class="line">        [realm addObject: stu4];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<h3 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h3><ul>
<li><code>Realm</code>中也提供了功能强大的数据查询能力，如果会使用<code>SQL</code>语言的话，上手的难度更低</li>
<li>在<code>Realm</code>的查询功能中，也可以像<code>SQL</code>一样使用各种条件查询关键字，查询的结果会保存在一个<code>RLMResults</code>类的数组中</li>
<li>全量查询, 通过调用<code>allObjects</code>方法, 得到该表中的所有数据</li>
<li>条件查询，设置一些查询条件，从而查询出符合条件的对象<ul>
<li><code>Realm</code>的查询条件可以使用&#x3D;&#x3D;、&lt;&#x3D;、&lt;、&gt;&#x3D;、&gt;、!&#x3D;、BETWEEN、CONTAINS 以及 ENDSWITH等多种操作符</li>
</ul>
</li>
</ul>
<blockquote>
<p>全量查询</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 获取所有数据</span></span><br><span class="line">RLMResults *resArr = [Student allObjects];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, resArr);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 添加一条数据</span></span><br><span class="line">RLMRealm *realm = [RLMRealm defaultRealm];</span><br><span class="line">Student *stu = [[Student alloc]initWithValue:@[@<span class="number">10</span>, <span class="string">@&quot;coder&quot;</span>]];</span><br><span class="line">[realm transactionWithBlock:^&#123;</span><br><span class="line">    [realm addObject:stu];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 一旦检索执行之后, RLMResults 将随时保持更新</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, resArr);</span><br></pre></td></tr></table></figure>


<blockquote>
<p>条件查询</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//条件查询</span></span><br><span class="line">RLMResults *stuArr = [Student objectsWhere:<span class="string">@&quot;num &gt; 7&quot;</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, stuArr);</span><br><span class="line"></span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line"><span class="comment">//排序不会对原数组进行操作, 会返回一个新的数组</span></span><br><span class="line">RLMResults *stuArr2 = [stuArr sortedResultsUsingKeyPath:<span class="string">@&quot;name&quot;</span> ascending:<span class="literal">YES</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, stuArr2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//链式查询</span></span><br><span class="line">RLMResults *stuArr3 = [stuArr2 objectsWhere:<span class="string">@&quot;num &gt; 8&quot;</span>];</span><br><span class="line"><span class="comment">//可以不断的根据上一个查询结果进行查询</span></span><br><span class="line">RLMResults *stuArr4 = [stuArr3 objectsWhere:<span class="string">@&quot;num &gt; 9&quot;</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, stuArr4);</span><br></pre></td></tr></table></figure>



<h3 id="更新操作"><a href="#更新操作" class="headerlink" title="更新操作"></a>更新操作</h3><ul>
<li>需要修改的模型一定是被<code>Realm</code>所管理的模型, 而且已经和磁盘上的对象进行地址映射</li>
<li>对新添加的模型进行更新</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取Realm对象</span></span><br><span class="line">RLMRealm *realm = [RLMRealm defaultRealm];</span><br><span class="line">Student *stu4 = [[Student alloc]initWithValue:@&#123;<span class="string">@&quot;num&quot;</span>: @<span class="number">4</span>, <span class="string">@&quot;name&quot;</span>:<span class="string">@&quot;titan4&quot;</span>&#125;];</span><br><span class="line"><span class="comment">//添加数据</span></span><br><span class="line"><span class="comment">// 这个模型stu, 已经被realm 所管理, 而且, 已经和磁盘上的对象, 进行的地址映射</span></span><br><span class="line">[realm transactionWithBlock:^&#123;</span><br><span class="line">    <span class="comment">//添加模型</span></span><br><span class="line">    [realm addObject:stu4];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里修改的模型, 一定是被realm所管理的模型</span></span><br><span class="line">[realm transactionWithBlock:^&#123;</span><br><span class="line">    stu4.name = <span class="string">@&quot;coder4&quot;</span>;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>


<ul>
<li>根据查询到的数据更新指定属性的数据</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//条件查询</span></span><br><span class="line">RLMResults *results = [Student objectsWhere:<span class="string">@&quot;num = 4&quot;</span>];</span><br><span class="line">Student *stu = results.firstObject;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新指定属性的数据</span></span><br><span class="line">[realm transactionWithBlock:^&#123;</span><br><span class="line">    stu.name = <span class="string">@&quot;titanking&quot;</span>;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>


<ul>
<li>当有主键的情况下, 使用<code>Update</code>方法</li>
<li><code>addOrUpdateObject</code>会去先查找有没有传入的<code>Student</code>相同的主键，如果有，就更新该条数据</li>
<li>这里需要注意，<code>addOrUpdateObject</code>这个方法不是增量更新，所有的值都必须有，如果有哪几个值是<code>null</code>，那么就会覆盖原来已经有的值，这样就会出现数据丢失的问题</li>
<li><code>createOrUpdateInRealm:withValue</code>这个方法是增量更新的，后面传一个字典，使用这个方法的前提是有主键</li>
<li>方法会先去主键里面找有没有字典里面传入的主键的记录，如果有，就只更新字典里面的子集;如果没有，就新建一条记录</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取Realm对象</span></span><br><span class="line">RLMRealm *realm = [RLMRealm defaultRealm];</span><br><span class="line">Student *stu2 = [[Student alloc]initWithValue:@&#123;<span class="string">@&quot;num&quot;</span>: @<span class="number">12</span>, <span class="string">@&quot;name&quot;</span>:<span class="string">@&quot;titan&quot;</span>&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">//addOrUpdateObject方式</span></span><br><span class="line">[realm transactionWithBlock:^&#123;</span><br><span class="line">    [realm addOrUpdateObject:stu2];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">//createOrUpdateInRealm方式</span></span><br><span class="line">[realm transactionWithBlock:^&#123;</span><br><span class="line">    [Student createOrUpdateInRealm:realm withValue:@&#123;<span class="string">@&quot;num&quot;</span>: @<span class="number">11</span>, <span class="string">@&quot;name&quot;</span>:<span class="string">@&quot;titan11&quot;</span>&#125;];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>


<h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><ul>
<li>删除的模型, 一定要求是被<code>realm</code>所管理的已经存在的模型</li>
<li>当需要在<code>Realm</code>中删除某些对象时，需要注意的是，该方法的执行需要在一个事务中进行</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取Realm对象</span></span><br><span class="line">RLMRealm *realm = [RLMRealm defaultRealm];</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据条件删除一条数据 </span></span><br><span class="line">RLMResults *results = [Student objectsWhere:<span class="string">@&quot;name = &#x27;titanking&#x27;&quot;</span>];</span><br><span class="line">Student *titan1 = results.firstObject;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除单条记录</span></span><br><span class="line">[realm transactionWithBlock:^&#123;</span><br><span class="line">    [realm deleteObject:titan1];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除所有符合条件的数据</span></span><br><span class="line">RLMResults *results = [Student objectsWhere:<span class="string">@&quot;name = &#x27;coder&#x27;&quot;</span>];</span><br><span class="line"><span class="keyword">for</span> (Student *stu <span class="keyword">in</span> results) &#123;</span><br><span class="line">    [realm transactionWithBlock:^&#123;</span><br><span class="line">        [realm deleteObject:stu];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除表中所有的数据</span></span><br><span class="line">[realm transactionWithBlock:^&#123;</span><br><span class="line">    [realm deleteAllObjects];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*场景, 根据主键删除一个模型*/</span></span><br><span class="line"> <span class="comment">// 1. 根据主键, 查询到这个模型(这个模型, 就是被realm数据库管理的模型)</span></span><br><span class="line">Student *res = [Student objectInRealm:realm forPrimaryKey:@<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 删除该模型</span></span><br><span class="line">[realm transactionWithBlock:^&#123;</span><br><span class="line">    [realm deleteObject:res];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>


<h3 id="Realm数据库机制"><a href="#Realm数据库机制" class="headerlink" title="Realm数据库机制"></a><code>Realm</code>数据库机制</h3><ul>
<li>上面用到的获取<code>realm</code>对象的方式都是通过<code>defaultRealm</code>来获取默认配置的<code>realm</code>对象</li>
<li>当我们需要创建不同的<code>realm</code>表格时又该如何操作呢? </li>
<li>下面我们来看一下</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)setDefaultRealmForUser:(<span class="built_in">NSString</span> *)username &#123;</span><br><span class="line">    <span class="comment">//先获取默认配置</span></span><br><span class="line">    RLMRealmConfiguration *config = [RLMRealmConfiguration defaultConfiguration];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置只读数据库</span></span><br><span class="line">    <span class="comment">//config.readOnly = YES;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用默认的目录，但是使用用户名来替换默认的文件名</span></span><br><span class="line">    config.fileURL = [[[config.fileURL URLByDeletingLastPathComponent]</span><br><span class="line">                       URLByAppendingPathComponent:username]</span><br><span class="line">                      URLByAppendingPathExtension:<span class="string">@&quot;realm&quot;</span>];</span><br><span class="line">    <span class="comment">// 将这个配置应用到默认的 Realm 数据库当中</span></span><br><span class="line">    [RLMRealmConfiguration setDefaultConfiguration:config];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>做好上述配置之后, 便可创建不同的数据库了</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不同的用户, 使用不同的数据库</span></span><br><span class="line">[<span class="keyword">self</span> setDefaultRealmForUser:<span class="string">@&quot;zhangsan&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里也只需要调用默认配置即可</span></span><br><span class="line">RLMRealm *realm = [RLMRealm defaultRealm];</span><br></pre></td></tr></table></figure>


<h3 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h3><ul>
<li><code>Realm</code>实例将会在每次写入事务提交后，给其他线程上的<code>Realm</code>实例发送通知</li>
<li>一般控制器如果想一直持有这个通知，就需要申请一个属性, 强引用该属性，<code>strong</code>持有这个通知</li>
<li>集合通知是异步触发的，首先它会在初始结果出现的时候触发，随后当某个写入事务改变了集合中的所有或者某个对象的时候，通知都会再次触发</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//强引用属性</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) RLMNotificationToken *token;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)setUp &#123;</span><br><span class="line">    [<span class="variable language_">super</span> setUp];</span><br><span class="line"></span><br><span class="line">    RLMRealm *realm = [RLMRealm defaultRealm];</span><br><span class="line">    <span class="comment">// 获取 Realm 通知</span></span><br><span class="line">    <span class="keyword">self</span>.token = [realm addNotificationBlock:^(RLMNotification  _Nonnull notification, RLMRealm * _Nonnull realm) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;接收到变更通知--%@&quot;</span>, notification);</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//结束该通知</span></span><br><span class="line">    [<span class="keyword">self</span>.token stop];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)testExample &#123;</span><br><span class="line">    NoticeModel *noticeM = [[NoticeModel alloc] initWithValue:@&#123;<span class="string">@&quot;num&quot;</span>: @<span class="number">1</span>, <span class="string">@&quot;name&quot;</span>: <span class="string">@&quot;sz&quot;</span>&#125;];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加数据, 数据操作之后便会通知上述通知中心执行相应操作</span></span><br><span class="line">    RLMRealm *realm = [RLMRealm defaultRealm];</span><br><span class="line">    [realm transactionWithBlock:^&#123;</span><br><span class="line">        [realm addObject:noticeM];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="数据库迁移"><a href="#数据库迁移" class="headerlink" title="数据库迁移"></a>数据库迁移</h3><ul>
<li>数据库存储方面的增删改查应该都没有什么大问题，比较蛋疼的应该就是数据迁移了</li>
<li>在版本迭代过程中，很可能会发生表的新增，删除，或者表结构的变化，如果新版本中不做数据迁移，用户升级到新版，很可能就直接crash了</li>
<li>数据迁移一直是困扰各类型数据库的一大问题, 但是对于<code>Realm</code>来说, 却方便很多, 这也是<code>Realm</code>的优点之一<ul>
<li>新增删除表，<code>Realm</code>不需要做迁移</li>
<li>新增删除字段，<code>Realm</code>不需要做迁移; <code>Realm</code>会自行检测新增和需要移除的属性，然后自动更新硬盘上的数据库架构</li>
</ul>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//需要在以下方法中进行配置</span></span><br><span class="line">- (<span class="type">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions &#123;</span><br><span class="line">    <span class="comment">// 获取默认配置, 迁移数据结构</span></span><br><span class="line">    RLMRealmConfiguration *config = [RLMRealmConfiguration defaultConfiguration];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 设置新的架构版本。这个版本号必须高于之前所用的版本号（如果您之前从未设置过架构版本，那么这个版本号设置为 0）</span></span><br><span class="line">    <span class="type">int</span> newVersion = <span class="number">4</span>;</span><br><span class="line">    config.schemaVersion = newVersion;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 设置闭包，这个闭包将会在打开低于上面所设置版本号的 Realm 数据库的时候被自动调用</span></span><br><span class="line">    [config setMigrationBlock:^(RLMMigration *migration, uint64_t oldSchemaVersion)&#123;</span><br><span class="line">        <span class="keyword">if</span> (oldSchemaVersion &lt; newVersion) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;数据结构会自动迁移&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// enumerateObjects:block: 遍历了存储在 Realm 文件中的每一个“Person”对象</span></span><br><span class="line">            [migration enumerateObjects:<span class="string">@&quot;DataMigration&quot;</span> block:^(RLMObject * _Nullable oldObject, RLMObject * _Nullable newObject) &#123;</span><br><span class="line">                <span class="comment">// 只有当 Realm 数据库的架构版本为 0 的时候，才添加 “fullName” 属性</span></span><br><span class="line">                <span class="keyword">if</span> (oldSchemaVersion &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                    newObject[<span class="string">@&quot;fullName&quot;</span>] = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@ %@&quot;</span>, oldObject[<span class="string">@&quot;firstName&quot;</span>], oldObject[<span class="string">@&quot;lastName&quot;</span>]];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 只有当 Realm 数据库的架构版本为 0 或者 1 的时候，才添加“email”属性</span></span><br><span class="line">                <span class="keyword">if</span> (oldSchemaVersion &lt; <span class="number">2</span>) &#123;</span><br><span class="line">                    newObject[<span class="string">@&quot;email&quot;</span>] = <span class="string">@&quot;&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 替换属性名(原字段重命名)</span></span><br><span class="line">                <span class="keyword">if</span> (oldSchemaVersion &lt; <span class="number">3</span>) &#123; <span class="comment">// 重命名操作应该在调用 `enumerateObjects:` 之外完成</span></span><br><span class="line">                    [migration renamePropertyForClass:Person.className oldName:<span class="string">@&quot;yearsSinceBirth&quot;</span> newName:<span class="string">@&quot;age&quot;</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 告诉 Realm 为默认的 Realm 数据库使用这个新的配置对象</span></span><br><span class="line">    [RLMRealmConfiguration setDefaultConfiguration:config];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 现在我们已经告诉了 Realm 如何处理架构的变化，打开文件之后将会自动执行迁移</span></span><br><span class="line">    [RLMRealm defaultRealm];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>以上就是我最近学习到的关于<code>Realm</code>的部分内容, 文章不全, 有兴趣的可以参考下面的文章继续学习</li>
<li>参考文档<ul>
<li><a href="https://www.jianshu.com/p/50e0efb66bdf">Realm数据库 从入门到“放弃”</a></li>
<li><a href="https://realm.io/docs/objc/latest/api/Classes.html">Realm官方文档</a></li>
<li><a href="https://github.com/realm/realm-cocoa">Realm GitHub</a></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>数据库基础</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Realm</tag>
      </tags>
  </entry>
  <entry>
    <title>RxSwift的使用详解01</title>
    <url>/post/645b9037.html</url>
    <content><![CDATA[<ul>
<li><a href="https://github.com/ReactiveX/RxSwift">RxSwift</a>是<code>Swift</code>函数响应式编程的一个开源库，由<code>Github</code>的<a href="https://github.com/ReactiveX">ReactiveX</a>组织开发、维护</li>
<li>其他语言像C#, Java 和 JS 也有，<code>Rx.Net</code>、<code>RxJava</code>、<a href="https://github.com/ReactiveX/rxjs">rxjs</a></li>
<li><code>RxSwift</code>的目的是让数据&#x2F;事件流和异步任务能够更方便的序列化处理，能够使用<code>Swift</code>进行响应式编程</li>
</ul>
<span id="more"></span>

<h2 id="RxSwift简介"><a href="#RxSwift简介" class="headerlink" title="RxSwift简介"></a>RxSwift简介</h2><ul>
<li>推荐: <a href="https://github.com/ReactiveX/RxSwift">RxSwift官方文档</a></li>
<li>中文: <a href="https://github.com/jhw-dev/RxSwift-CN">RxSwift官方文档的中文翻译</a></li>
</ul>
<h3 id="RxSwift做了什么"><a href="#RxSwift做了什么" class="headerlink" title="RxSwift做了什么"></a><code>RxSwift</code>做了什么</h3><ul>
<li><code>RxSwift</code>把我们程序中每一个操作都看成一个事件</li>
<li>比如一个<code>TextField</code>中的文本改变，一个按钮被点击，或者一个网络请求结束等，每一个事件源就可以看成一个管道，也就是<code>sequence</code></li>
<li>比如<code>TextField</code>，当我们改变里面的文本的时候，这个<code>TextField</code>就会不断的发出事件，从他的这个<code>sequence</code>中不断的流出，我们只需要监听这个<code>sequence</code>，每流出一个事件就做相应的处理。</li>
<li>同理，<code>Button</code>也是一个<code>sequence</code>，每点击一次就流出一个事件。</li>
</ul>
<h3 id="RxSwift的核心思想"><a href="#RxSwift的核心思想" class="headerlink" title="RxSwift的核心思想"></a><code>RxSwift</code>的核心思想</h3><ul>
<li><p><code>sequence</code>，<code>Observable</code>表示可监听或者可观察，也就是说RxSwift的核心思想是可监听的序列。</p>
</li>
<li><p>并且，<code>Observable sequence</code>可以接受异步信号，也就是说，信号是可以异步给监听者的</p>
<ul>
<li><code>Observable(ObservableType)</code> 和 <code>SequenceType</code>类似</li>
<li><code>ObservableType.subscribe</code> 和 <code>SequenceType.generate</code>类似</li>
<li>由于<code>RxSwift</code>支持异步获得信号，所以用<code>ObservableType.subscribe</code>，这和<code>indexGenerator.next()</code>类似</li>
</ul>
</li>
<li><p>其中<code>SequenceType</code>是<code>Swift2.3</code>以前版本,之后的版本没有该协议)中的一个协议，比如<code>Swift</code>中的<code>Array</code>就遵循这个协议，通过这个协议，你可以这样的去操作一个Array</p>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">let array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">let array2 = array.filter(&#123;$<span class="number">0</span> &gt; <span class="number">1</span>&#125;).map(&#123;$<span class="number">0</span> * <span class="number">2</span>&#125;)<span class="comment">//4 6 8 10</span></span><br><span class="line">var indexGenerator = array2.generate()</span><br><span class="line">let fisrt = indexGenerator.next() <span class="comment">// 4</span></span><br><span class="line">let seoncd = indexGenerator.next() <span class="comment">//6 </span></span><br></pre></td></tr></table></figure>


<h3 id="ObservableType"><a href="#ObservableType" class="headerlink" title="ObservableType"></a>ObservableType</h3><p><code>RxSwift</code>中，<code>ObservableType.subscribe</code>的回调（新的信号到来）一共有三</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Event&lt;Element&gt;  &#123;</span><br><span class="line">    <span class="keyword">case</span> Next(Element)      <span class="comment">// 新的信号到来</span></span><br><span class="line">    <span class="keyword">case</span> Error(ErrorType)   <span class="comment">// 信号发生错误，序列不会再产生信号</span></span><br><span class="line">    <span class="keyword">case</span> Completed          <span class="comment">// 序列发送信号完成，不会再产生新的信号</span></span><br><span class="line">&#125;</span><br><span class="line">protocol ObserverType &#123;</span><br><span class="line">    func on(event: Event&lt;Element&gt;) <span class="comment">//监听所有的信号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="取消监听"><a href="#取消监听" class="headerlink" title="取消监听"></a>取消监听</h3><blockquote>
<p><code>Observable</code>分为两种</p>
</blockquote>
<ul>
<li>在有限的时间内会自动结束<code>Completed/Error</code>,比如一个网络请求当作一个序列，当网络请求完成的时候，<code>Observable</code>自动结束，资源会被释放</li>
<li>信号不会自己结束，最简单的比如一个Timer，每隔一段时间发送一个新的信号过来，这时候需要手动取消监听，来释放相应的资源</li>
<li>比如一个<code>label.rx.text</code>是一个<code>Obserable</code>，通常需要这样调用<code>addDisposableTo(disposeBag)</code>来让其在<code>deinit</code>，也就是所有者要释放的时候，自动取消监听</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Observable&lt;Element&gt; &#123;</span><br><span class="line">    func subscribe(observer: Observer&lt;Element&gt;) -&gt; Disposable //调用Disposable的方法来取消</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当然，除了手动释放，<code>RxSwift</code>提供了一些操作符，比如 <code>takeUntil</code>来根据条件取消</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequence</span><br><span class="line">    .takeUntil(self.rx_deallocated) //当对象要释放的时候，取消监听</span><br><span class="line">    .subscribe &#123;</span><br><span class="line">        print($0)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="RxSwift简单体验"><a href="#RxSwift简单体验" class="headerlink" title="RxSwift简单体验"></a><code>RxSwift</code>简单体验</h2><ul>
<li>首先创建<code>deinit</code>属性，也就是所有者要释放的时候，自动取消监听</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">fileprivate lazy var bag = DisposeBag()</span><br></pre></td></tr></table></figure>

<h3 id="RxSwift监听按钮的点击"><a href="#RxSwift监听按钮的点击" class="headerlink" title="RxSwift监听按钮的点击"></a><code>RxSwift</code>监听按钮的点击</h3><ul>
<li>传统方式: </li>
<li></li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">button1.addTarget(<span class="keyword">self</span>, action: <span class="meta">#selector(btn1Click(_:)), for: .touchUpInside)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>RxSwift</code>方式</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">button1.rx.tap.subscribe &#123; (event) <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">self</span>.button1.setTitle(<span class="string">&quot;按钮1&quot;</span>, <span class="keyword">for</span>: .normal)</span><br><span class="line">    print(<span class="string">&quot;button1&quot;</span>)</span><br><span class="line">&#125;.addDisposableTo(bag)</span><br><span class="line">        </span><br><span class="line">button2.rx.tap.subscribe &#123; (event) <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">self</span>.textField2.text = <span class="string">&quot;按钮2被点击了&quot;</span></span><br><span class="line">&#125;.addDisposableTo(bag)</span><br></pre></td></tr></table></figure>

<h3 id="RxSwift监听UITextField的文字改变"><a href="#RxSwift监听UITextField的文字改变" class="headerlink" title="RxSwift监听UITextField的文字改变"></a><code>RxSwift</code>监听<code>UITextField</code>的文字改变</h3><ul>
<li>传统做法,设置<code>textField2.delegate = self</code></li>
<li><code>RxSwift</code>方式</li>
</ul>
<h4 id="用on方法实现"><a href="#用on方法实现" class="headerlink" title="用on方法实现"></a>用on方法实现</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">subscribe(&lt;#T#<span class="meta">#on: (Event<span class="string">&lt;Int&gt;) -&gt; Void##(Event&lt;Int&gt;) -&gt; Void#&gt;)</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">textField1.rx.text.subscribe &#123; (event: Event&lt;String?&gt;) <span class="keyword">in</span></span><br><span class="line">    <span class="comment">//将UITextField文字改变的内容显示在Label中</span></span><br><span class="line">    <span class="keyword">self</span>.label1.text = event.element!    </span><br><span class="line">    print(event.element!!)</span><br><span class="line">&#125;.addDisposableTo(bag)</span><br><span class="line">        </span><br><span class="line">textField2.rx.text.subscribe &#123; (event: Event&lt;String?&gt;) <span class="keyword">in</span></span><br><span class="line">    print(event.element)<span class="comment">//报警告</span></span><br><span class="line">    <span class="comment">//输出: Optional(Optional(&quot;jun&quot;))</span></span><br><span class="line">&#125;.addDisposableTo(bag)</span><br></pre></td></tr></table></figure>

<h4 id="用onNext方法实现"><a href="#用onNext方法实现" class="headerlink" title="用onNext方法实现"></a>用<code>onNext</code>方法实现</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">subscribe(on: (Event&lt;Int&gt;) -&gt; Void)</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">textField1.rx.text.subscribe(onNext: &#123; (str: String?) <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">self</span>.label1.text = str!</span><br><span class="line">&#125;).addDisposableTo(bag)</span><br><span class="line">```        </span><br><span class="line"></span><br><span class="line">### `RxSwift`改变`Label`中文字</span><br><span class="line"></span><br><span class="line">```objc</span><br><span class="line">label1.rx.observe(String.self, <span class="string">&quot;text&quot;</span>).subscribe(onNext: &#123; (str: String?) <span class="keyword">in</span></span><br><span class="line">    print(str!)</span><br><span class="line">&#125;).addDisposableTo(bag)</span><br><span class="line">        </span><br><span class="line">label2.rx.observe(<span class="built_in">CGRect</span>.self, <span class="string">&quot;frame&quot;</span>).subscribe(onNext: &#123; (rect: <span class="built_in">CGRect</span>?) <span class="keyword">in</span></span><br><span class="line">    print(rect!.width)</span><br><span class="line">&#125;).addDisposableTo(bag)</span><br></pre></td></tr></table></figure>

<h3 id="RxSwift监听UIScrollView的滚动"><a href="#RxSwift监听UIScrollView的滚动" class="headerlink" title="RxSwift监听UIScrollView的滚动"></a><code>RxSwift</code>监听<code>UIScrollView</code>的滚动</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">scrollView.contentSize = <span class="built_in">CGSize</span>(width: <span class="number">1000</span>, height: <span class="number">0</span>)</span><br><span class="line">scrollView.rx.contentOffset</span><br><span class="line">            .subscribe(onNext: &#123; (point : <span class="built_in">CGPoint</span>) <span class="keyword">in</span></span><br><span class="line">                print(point)</span><br><span class="line">            &#125;).addDisposableTo(bag)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="RxSwift常见操作"><a href="#RxSwift常见操作" class="headerlink" title="RxSwift常见操作"></a><code>RxSwift</code>常见操作</h2><ul>
<li><code>addDisposableTo(disposeBag)</code>方法是让其<code>deinit</code>，也就是所有者要释放的时候，自动取消监听</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//创建bag</span><br><span class="line">let bag = DisposeBag()</span><br></pre></td></tr></table></figure>

<h3 id="never"><a href="#never" class="headerlink" title="never"></a>never</h3><ul>
<li>never就是创建一个sequence,但是不发出任何事件信号</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">let neverSqu = Observable&lt;String&gt;.never()</span><br><span class="line">neverSqu.subscribe &#123; (_) <span class="keyword">in</span></span><br><span class="line">    <span class="comment">//该语句不会执行</span></span><br><span class="line">    print(<span class="string">&quot;This will never be printed&quot;</span>)</span><br><span class="line">&#125;.addDisposableTo(bag)</span><br><span class="line"><span class="comment">//调用Disposable的方法来取消</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="empty"><a href="#empty" class="headerlink" title="empty"></a>empty</h3><ul>
<li>empty就是创建一个空的sequence,只能发出一个complected事件</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Observable&lt;Int&gt;.empty().subscribe &#123; (event) <span class="keyword">in</span></span><br><span class="line">    <span class="comment">//该语句只会执行一次</span></span><br><span class="line">    <span class="comment">//输出: completed</span></span><br><span class="line">    print(event)</span><br><span class="line">&#125;.addDisposableTo(bag)</span><br></pre></td></tr></table></figure>
<h3 id="just"><a href="#just" class="headerlink" title="just"></a>just</h3><ul>
<li><code>just</code>是创建一个<code>sequence</code>只能发出一种特定的事件，能正常结束</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Observable&lt;Int&gt;.just(<span class="number">3</span>).subscribe &#123; (event) <span class="keyword">in</span></span><br><span class="line">    print(event)</span><br><span class="line">    <span class="comment">/*该语句只会执行两次,分别输出</span></span><br><span class="line"><span class="comment">     1) next(3),语句结果</span></span><br><span class="line"><span class="comment">     2) completed, 结束事件</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;.addDisposableTo(bag)</span><br><span class="line">        </span><br><span class="line">Observable.just(<span class="string">&quot;jun&quot;</span>).subscribe &#123; (event) <span class="keyword">in</span></span><br><span class="line">    print(event)</span><br><span class="line">    <span class="comment">/*该语句只会执行两次,分别输出</span></span><br><span class="line"><span class="comment">     1) next(jun),语句结果</span></span><br><span class="line"><span class="comment">     2) completed, 结束事件</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;.addDisposableTo(bag)</span><br><span class="line">```    </span><br><span class="line">        </span><br><span class="line">##<span class="meta"># of</span></span><br><span class="line"></span><br><span class="line">- of是创建一个`sequence`能发出很多种事件信号</span><br><span class="line"></span><br><span class="line">```objc</span><br><span class="line">Observable.of(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;5.3&quot;</span>)</span><br><span class="line">    .subscribe(onNext: &#123; print($<span class="number">0</span>) &#125;)</span><br><span class="line">    .addDisposableTo(bag)</span><br><span class="line">    <span class="comment">//会分别输出 &quot;a&quot;, &quot;b&quot;, &quot;2&quot;, &quot;5.3&quot;</span></span><br><span class="line"></span><br><span class="line">Observable.of(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;5.3&quot;</span>).subscribe(onNext: &#123; (event) <span class="keyword">in</span></span><br><span class="line">    print(event)</span><br><span class="line">    <span class="comment">/*该语句只会执行4次,分别输出</span></span><br><span class="line"><span class="comment">     1) next(a),语句结果</span></span><br><span class="line"><span class="comment">     2) next(b),语句结果</span></span><br><span class="line"><span class="comment">     3) next(2),语句结果</span></span><br><span class="line"><span class="comment">     4) next(3.5),语句结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;, onError: <span class="literal">nil</span>, onCompleted: <span class="literal">nil</span>, onDisposed: <span class="literal">nil</span>).addDisposableTo(bag)</span><br><span class="line">   <span class="comment">//每一个闭包都设置设置了 一个默认值,故可以省略</span></span><br></pre></td></tr></table></figure>
<h3 id="from"><a href="#from" class="headerlink" title="from"></a>from</h3><ul>
<li>from就是从数组中创建sequence</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Observable.from([<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;5.3&quot;</span>]).subscribe &#123; (event) <span class="keyword">in</span></span><br><span class="line">    print(event)</span><br><span class="line">    <span class="comment">/*该语句只会执行5次,分别输出</span></span><br><span class="line"><span class="comment">     1) next(a),语句结果</span></span><br><span class="line"><span class="comment">     2) next(b),语句结果</span></span><br><span class="line"><span class="comment">     3) next(2),语句结果</span></span><br><span class="line"><span class="comment">     4) next(3.5),语句结果</span></span><br><span class="line"><span class="comment">     5) completed, 结束事件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;.addDisposableTo(bag)</span><br></pre></td></tr></table></figure>

<h3 id="create"><a href="#create" class="headerlink" title="create"></a>create</h3><ul>
<li>我们也可以自定义可观察的sequence，那就是使用create</li>
<li>create操作符传入一个观察者observer，然后调用observer的onNext，onCompleted和onError方法。返回一个可观察的obserable序列</li>
</ul>
<h4 id="自定义方法创建observable的creat"><a href="#自定义方法创建observable的creat" class="headerlink" title="自定义方法创建observable的creat"></a>自定义方法创建observable的creat</h4><h5 id="无参创建creat"><a href="#无参创建creat" class="headerlink" title="无参创建creat"></a>无参创建creat</h5><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">fileprivate func myobserable() -&gt; Observable&lt;Any&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> Observable.create(&#123; (observal: AnyObserver&lt;Any&gt;) -&gt; Disposable <span class="keyword">in</span></span><br><span class="line">        observal.onNext(<span class="string">&quot;abc&quot;</span>)</span><br><span class="line">        observal.onNext(<span class="string">&quot;12&quot;</span>)</span><br><span class="line">        observal.onCompleted()</span><br><span class="line">        <span class="keyword">return</span> Disposables.create()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="添加参数创建creat"><a href="#添加参数创建creat" class="headerlink" title="添加参数创建creat"></a>添加参数创建creat</h5><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">fileprivate func myJunst(element: String) -&gt; Observable&lt;String&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> Observable.create(&#123; (observal: AnyObserver&lt;String&gt;) -&gt; Disposable <span class="keyword">in</span></span><br><span class="line">        observal.onNext(element)</span><br><span class="line">        observal.onCompleted()</span><br><span class="line">        <span class="keyword">return</span> Disposables.create()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="在函数内调用自定义方法"><a href="#在函数内调用自定义方法" class="headerlink" title="在函数内调用自定义方法"></a>在函数内调用自定义方法</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">myobserable().subscribe(onNext: &#123; print($<span class="number">0</span>) &#125;).addDisposableTo(bag)</span><br><span class="line"><span class="comment">//该语句只会执行2次,分别输出&quot;abc&quot;, &quot;12&quot;</span></span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line">myJunst(element: <span class="string">&quot;jun&quot;</span>).subscribe(onNext: &#123; print($<span class="number">0</span>) &#125;).addDisposableTo(bag)</span><br><span class="line"><span class="comment">//该语句只会执行2次,分别输出&quot;jun&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="range-给定范围-依次显示"><a href="#range-给定范围-依次显示" class="headerlink" title="range(给定范围, 依次显示)"></a>range(给定范围, 依次显示)</h3><ul>
<li>range就是创建一个sequence，他会发出这个范围中的从开始到结束的所有事件</li>
<li>Observable<Int>,必须指定数据类型</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Observable&lt;Int&gt;.range(start: <span class="number">1</span>, count: <span class="number">4</span>).subscribe &#123; (event: Event&lt;Int&gt;) <span class="keyword">in</span></span><br><span class="line">    print(event)</span><br><span class="line">    <span class="comment">/*该语句只会执行5次,分别输出</span></span><br><span class="line"><span class="comment">     1) next(1),语句结果</span></span><br><span class="line"><span class="comment">     2) next(2),语句结果</span></span><br><span class="line"><span class="comment">     3) next(3),语句结果</span></span><br><span class="line"><span class="comment">     4) next(4),语句结果</span></span><br><span class="line"><span class="comment">     5) completed, 结束事件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;.addDisposableTo(bag)</span><br></pre></td></tr></table></figure>

<h3 id="repeatElement-重复执行"><a href="#repeatElement-重复执行" class="headerlink" title="repeatElement(重复执行)"></a>repeatElement(重复执行)</h3><p>创建一个sequence，发出特定的事件n次</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Observable.repeatElement(<span class="string">&quot;quanjun&quot;</span>)</span><br><span class="line">    .take(<span class="number">3</span>)</span><br><span class="line">    .subscribe(onNext: &#123; print($<span class="number">0</span>) &#125;)</span><br><span class="line">    .addDisposableTo(bag)</span><br><span class="line">    <span class="comment">//该语句只会执行3次,每次都输出&quot;quanjun&quot; </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="generate-类似于for循环"><a href="#generate-类似于for循环" class="headerlink" title="generate(类似于for循环)"></a>generate(类似于for循环)</h3><ul>
<li>generate是创建一个可观察sequence，当初始化的条件为true的时候，他就会发出所对应的事件</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">let generate = Observable.generate(initialState: <span class="number">0</span>, condition: &#123; $<span class="number">0</span> &lt; <span class="number">5</span> &#125;, iterate: &#123; $<span class="number">0</span> + <span class="number">2</span> &#125;)</span><br><span class="line">generate.subscribe(&#123; print($<span class="number">0</span>) &#125;).addDisposableTo(bag)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*1&gt; 输出顺序:</span></span><br><span class="line"><span class="comment">         next(0)</span></span><br><span class="line"><span class="comment">         next(2)</span></span><br><span class="line"><span class="comment">         next(4)</span></span><br><span class="line"><span class="comment">         completed</span></span><br><span class="line"><span class="comment">         </span></span><br><span class="line"><span class="comment">         2&gt; 以上代码可以理解为for循环处理逻辑</span></span><br><span class="line"><span class="comment">        for (Int i = 0; i &lt; 5; i++) &#123;</span></span><br><span class="line"><span class="comment">            print(i)</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br></pre></td></tr></table></figure>
<h3 id="error-发出错误信号"><a href="#error-发出错误信号" class="headerlink" title="error(发出错误信号)"></a>error(发出错误信号)</h3><ul>
<li>创建一个可观察序列，但不发出任何正常的事件，只发出error事件并结束</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"> let error = <span class="built_in">NSError</span>(domain: <span class="string">&quot;错误&quot;</span>, code: <span class="number">10</span>, userInfo: <span class="literal">nil</span>) as Error</span><br><span class="line"> Observable&lt;Any&gt;.error(error)</span><br><span class="line">            .subscribe(&#123; print($<span class="number">0</span>) &#125;)</span><br><span class="line">            .addDisposableTo(bag)</span><br><span class="line">        </span><br><span class="line"><span class="comment">//输出: error(Error Domain=错误 Code=10 &quot;(null)&quot;)</span></span><br></pre></td></tr></table></figure>


<h2 id="RxSwift中Subjects"><a href="#RxSwift中Subjects" class="headerlink" title="RxSwift中Subjects"></a>RxSwift中Subjects</h2><ul>
<li><code>Subjects</code>是什么?<ul>
<li><code>Subjet</code>是<code>observable</code>和<code>Observer</code>之间的桥梁，一个<code>Subject</code>既是一个<code>Obserable</code>也是一个<code>Observer</code>，他既可以发出事件，也可以监听事件</li>
</ul>
</li>
</ul>
<h3 id="PublishSubject"><a href="#PublishSubject" class="headerlink" title="PublishSubject"></a><code>PublishSubject</code></h3><ul>
<li>当你订阅PublishSubject的时候，你只能接收到订阅他之后发生的事件。subject.onNext()发出onNext事件，对应的还有onError()和onCompleted()事件</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">let pSubject = PublishSubject&lt;String&gt;()</span><br><span class="line">pSubject.subscribe &#123; (event: Event&lt;String&gt;) <span class="keyword">in</span></span><br><span class="line">        print(<span class="string">&quot;2--&quot;</span>, event)</span><br><span class="line">    &#125;.addDisposableTo(bag)</span><br><span class="line">print(<span class="string">&quot;1--------------&quot;</span>)</span><br><span class="line">        </span><br><span class="line">pSubject.onNext(<span class="string">&quot;T&quot;</span>)</span><br><span class="line">pSubject.onNext(<span class="string">&quot;Q&quot;</span>)</span><br><span class="line">        </span><br><span class="line">pSubject.subscribe &#123; (event: Event&lt;String&gt;) <span class="keyword">in</span></span><br><span class="line">         print(<span class="string">&quot;3--&quot;</span>, event)</span><br><span class="line">    &#125;.addDisposableTo(bag)</span><br><span class="line">pSubject.onNext(<span class="string">&quot;J&quot;</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/*输出顺序为:</span></span><br><span class="line"><span class="comment">         1--------------</span></span><br><span class="line"><span class="comment">         2-- next(T)</span></span><br><span class="line"><span class="comment">         2-- next(Q)</span></span><br><span class="line"><span class="comment">         2-- next(J)</span></span><br><span class="line"><span class="comment">         3-- next(J)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="ReplaySubject"><a href="#ReplaySubject" class="headerlink" title="ReplaySubject"></a>ReplaySubject</h3><ul>
<li>当你订阅ReplaySubject的时候，你可以接收到订阅他之后的事件，但也可以接受订阅他之前发出的事件，接受几个事件取决与bufferSize的大小</li>
<li><code>createUnbounded() </code>表示接受所有事件</li>
<li><code>create(bufferSize: 4)</code> 表示可接受到的订阅他之前的事件的个数,但是订阅他之后的事件一定会触发</li>
</ul>
<h4 id="createUnbounded-表示接受所有事件"><a href="#createUnbounded-表示接受所有事件" class="headerlink" title="createUnbounded() 表示接受所有事件"></a><code>createUnbounded() </code>表示接受所有事件</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">let rSubject = ReplaySubject&lt;String&gt;.createUnbounded()</span><br><span class="line">rSubject.onNext(<span class="string">&quot;T&quot;</span>)</span><br><span class="line">rSubject.onNext(<span class="string">&quot;Q&quot;</span>)</span><br><span class="line">rSubject.subscribe &#123; (event: Event&lt;String&gt;) <span class="keyword">in</span></span><br><span class="line">         print(<span class="string">&quot;0--&quot;</span>, event)</span><br><span class="line">    &#125;.addDisposableTo(bag)</span><br><span class="line">        </span><br><span class="line">rSubject.onNext(<span class="string">&quot;J&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*输出顺序为:</span></span><br><span class="line"><span class="comment">     0-- next(T)</span></span><br><span class="line"><span class="comment">     0-- next(Q)</span></span><br><span class="line"><span class="comment">     0-- next(J)</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure>

<h4 id="create-bufferSize-4-表示可接受到的订阅他之前的事件的个数"><a href="#create-bufferSize-4-表示可接受到的订阅他之前的事件的个数" class="headerlink" title="create(bufferSize: 4) 表示可接受到的订阅他之前的事件的个数"></a><code>create(bufferSize: 4)</code> 表示可接受到的订阅他之前的事件的个数</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">let rSubject1 = ReplaySubject&lt;String&gt;.create(bufferSize: <span class="number">1</span>)</span><br><span class="line">rSubject1.onNext(<span class="string">&quot;T&quot;</span>)</span><br><span class="line">rSubject1.onNext(<span class="string">&quot;Q&quot;</span>)</span><br><span class="line">rSubject1.subscribe &#123; (event: Event&lt;String&gt;) <span class="keyword">in</span></span><br><span class="line">            print(<span class="string">&quot;4--&quot;</span>, event)</span><br><span class="line">        &#125;.addDisposableTo(bag)</span><br><span class="line">        </span><br><span class="line">rSubject1.onNext(<span class="string">&quot;J&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*输出顺序为:</span></span><br><span class="line"><span class="comment">     4-- next(Q)</span></span><br><span class="line"><span class="comment">     4-- next(J)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<h3 id="BehaviorSubject"><a href="#BehaviorSubject" class="headerlink" title="BehaviorSubject"></a>BehaviorSubject</h3><ul>
<li>当你订阅了BehaviorSubject，你会接受到订阅之前的最后一个事件,订阅之后的事件一定会触发</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">let bSubject = BehaviorSubject(value: <span class="string">&quot;G&quot;</span>)</span><br><span class="line">bSubject.subscribe &#123; (event: Event&lt;String&gt;) <span class="keyword">in</span></span><br><span class="line">        print(<span class="string">&quot;5--&quot;</span>, event)</span><br><span class="line">    &#125;.addDisposableTo(bag)</span><br><span class="line">        </span><br><span class="line">bSubject.onNext(<span class="string">&quot;Y&quot;</span>)</span><br><span class="line">bSubject.onNext(<span class="string">&quot;Q&quot;</span>)</span><br><span class="line">        </span><br><span class="line">bSubject.subscribe &#123; (event: Event&lt;String&gt;) <span class="keyword">in</span></span><br><span class="line">        print(<span class="string">&quot;6--&quot;</span>, event)</span><br><span class="line">    &#125;.addDisposableTo(bag)</span><br><span class="line">        </span><br><span class="line">bSubject.onNext(<span class="string">&quot;J&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*输出顺序为:</span></span><br><span class="line"><span class="comment">         5-- next(G)</span></span><br><span class="line"><span class="comment">         5-- next(Y)</span></span><br><span class="line"><span class="comment">         5-- next(Q)</span></span><br><span class="line"><span class="comment">         6-- next(Q)</span></span><br><span class="line"><span class="comment">         5-- next(J)</span></span><br><span class="line"><span class="comment">         6-- next(J)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Variable"><a href="#Variable" class="headerlink" title="Variable"></a>Variable</h3><ul>
<li>Variable是BehaviorSubject一个包装箱，就像是一个箱子一样，使用的时候需要调用asObservable()拆箱，里面的value是一个BehaviorSubject，他不会发出error事件，但是会自动发出completed事件。</li>
<li>1&gt; 相当于对BehaviorSubject进行装箱</li>
<li>2&gt; 如果想将Variable当成Obserable, 让订阅者进行订阅时, 需要调用asObserable拆箱转成Obserable</li>
<li>3&gt; 如果Variable打算发出事件, 直接修改对象的value即可</li>
<li>4&gt; 当事件结束时,Variable会自动发出completed事件</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">let variable = Variable(<span class="string">&quot;S&quot;</span>)</span><br><span class="line">variable.asObservable().subscribe &#123; (event) <span class="keyword">in</span></span><br><span class="line">        print(<span class="string">&quot;7--&quot;</span>, event)</span><br><span class="line">    &#125;.addDisposableTo(bag)</span><br><span class="line">        </span><br><span class="line">variable.value = <span class="string">&quot;D&quot;</span></span><br><span class="line">variable.value = <span class="string">&quot;Q&quot;</span></span><br><span class="line">        </span><br><span class="line">variable.asObservable().subscribe &#123; (event) <span class="keyword">in</span></span><br><span class="line">        print(<span class="string">&quot;8--&quot;</span>, event)</span><br><span class="line">    &#125;.addDisposableTo(bag)</span><br><span class="line">        </span><br><span class="line">variable.value = <span class="string">&quot;j&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*输出顺序为:</span></span><br><span class="line"><span class="comment">         7-- next(S)</span></span><br><span class="line"><span class="comment">         7-- next(D)</span></span><br><span class="line"><span class="comment">         7-- next(Q)</span></span><br><span class="line"><span class="comment">         8-- next(Q)</span></span><br><span class="line"><span class="comment">         7-- next(j)</span></span><br><span class="line"><span class="comment">         8-- next(j)</span></span><br><span class="line"><span class="comment">         7-- completed</span></span><br><span class="line"><span class="comment">         8-- completed</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="RxSwift细节理解"><a href="#RxSwift细节理解" class="headerlink" title="RxSwift细节理解"></a>RxSwift细节理解</h2><h3 id="变换操作"><a href="#变换操作" class="headerlink" title="变换操作"></a>变换操作</h3><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><ul>
<li>通过传入一个函数闭包把原来的sequence转变为一个新的sequence的操作</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Observable.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">        .map(&#123; $<span class="number">0</span> * $<span class="number">0</span> &#125;)</span><br><span class="line">        .subscribe(onNext: &#123; print($<span class="number">0</span>) &#125;)</span><br><span class="line">        .addDisposableTo(bag)</span><br><span class="line">        </span><br><span class="line"><span class="comment">/* 输出顺序为:</span></span><br><span class="line"><span class="comment">    1</span></span><br><span class="line"><span class="comment">    4</span></span><br><span class="line"><span class="comment">    9</span></span><br><span class="line"><span class="comment">    16</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h4 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h4><ul>
<li>将一个sequence转换为一个sequences，当你接收一个sequence的事件，你还想接收其他sequence发出的事件的话可以使用flatMap，她会将每一个sequence事件进行处理以后，然后再以一个sequence形式发出事件</li>
</ul>
<h5 id="首先创建一个struct"><a href="#首先创建一个struct" class="headerlink" title="首先创建一个struct"></a>首先创建一个struct</h5><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> Student &#123;</span><br><span class="line">    var score: Variable&lt;Double&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="flatMap执行代码"><a href="#flatMap执行代码" class="headerlink" title="flatMap执行代码"></a>flatMap执行代码</h5><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">let stu1 = Student(score: Variable(<span class="number">80</span>))</span><br><span class="line">let stu2 = Student(score: Variable(<span class="number">100</span>))</span><br><span class="line">        </span><br><span class="line">let student = Variable(stu1)</span><br><span class="line">student.asObservable().flatMap &#123; (stu: Student) -&gt; Observable&lt;Double&gt; <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> stu.score.asObservable()</span><br><span class="line">&#125;.subscribe &#123; (event) <span class="keyword">in</span></span><br><span class="line">    print(event)</span><br><span class="line">&#125;.addDisposableTo(bag)</span><br><span class="line">        </span><br><span class="line">student.value = stu2</span><br><span class="line">stu1.score.value = <span class="number">10</span></span><br><span class="line">stu2.score.value = <span class="number">20</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">/* 输出顺序为:</span></span><br><span class="line"><span class="comment">         next(80.0)</span></span><br><span class="line"><span class="comment">         next(100.0)</span></span><br><span class="line"><span class="comment">         next(10.0)</span></span><br><span class="line"><span class="comment">         next(20.0)</span></span><br><span class="line"><span class="comment">         completed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="flatMapLatest"><a href="#flatMapLatest" class="headerlink" title="flatMapLatest"></a>flatMapLatest</h4><ul>
<li>flatMapLatest只会接收最新的value事件，将上例代码改为flatMapLatest</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">let stu3 = Student(score: Variable(<span class="number">70</span>))</span><br><span class="line">let stu4 = Student(score: Variable(<span class="number">60</span>))</span><br><span class="line"></span><br><span class="line">let student1 = Variable(stu3)</span><br><span class="line">student1.asObservable().flatMapFirst &#123; (stu) -&gt; Observable&lt;Double&gt; <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> stu.score.asObservable()</span><br><span class="line">&#125;.subscribe &#123; (event: Event&lt;Double&gt;) <span class="keyword">in</span></span><br><span class="line">    print(event)</span><br><span class="line">&#125;.addDisposableTo(bag)</span><br><span class="line">student1.value = stu4</span><br><span class="line">stu3.score.value = <span class="number">10</span></span><br><span class="line">stu4.score.value = <span class="number">20</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">/* 输出顺序为:</span></span><br><span class="line"><span class="comment">         next(70.0)</span></span><br><span class="line"><span class="comment">         next(10.0)</span></span><br><span class="line"><span class="comment">         completed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="释放资源"><a href="#释放资源" class="headerlink" title="释放资源"></a>释放资源</h3><ul>
<li>当监听一个事件序列的时候，有消息事件来了，我们做某些事情。但是这个事件序列不再发出消息了，我们的监听也就没有什么存在价值了，所以我们需要释放我们这些监听资源，其实也就是每种编程语言中的内存资源释放。</li>
<li>OC和Swift中也一样，在你不需要用某些变量的时候，你需要把这些变量所占用的内存空间释放掉。</li>
<li>释放某一个监听的时候我们可以手动调用释放方法</li>
</ul>
<h4 id="dispose"><a href="#dispose" class="headerlink" title="dispose"></a>dispose</h4><ul>
<li>相当于MRC中手动调用release操作</li>
<li>注意: 因为观察者已经销毁, 所有后面无法接受事件</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">let testVariable = Variable(<span class="string">&quot;jun&quot;</span>)</span><br><span class="line">testVariable.asObservable().subscribe &#123; (event : Event&lt;String&gt;) <span class="keyword">in</span></span><br><span class="line">    print(event)</span><br><span class="line">&#125;.dispose()</span><br><span class="line"></span><br><span class="line">testVariable.value = <span class="string">&quot;tian&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 输出顺序为:</span></span><br><span class="line"><span class="comment">         next(jun)</span></span><br><span class="line"><span class="comment">         completed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="Dispose-Bags"><a href="#Dispose-Bags" class="headerlink" title="Dispose Bags"></a>Dispose Bags</h4><ul>
<li>除了上面手动的方法，还有一种是自动的方式</li>
<li>推荐大家使用这种方式，这种方式就好像iOS中的ARC方式似得，会自动去释放资源。<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">fileprivate lazy var bag = DisposeBag()</span><br></pre></td></tr></table></figure></li>
</ul>
<p>在代码结尾调用<code>.addDisposableTo(bag)</code>方法</p>
<h3 id="UIBindingObserver"><a href="#UIBindingObserver" class="headerlink" title="UIBindingObserver"></a>UIBindingObserver</h3><ul>
<li>UIBindingObserver这个东西很有用的，创建我们自己的监听者，有时候RxCocoa(RxSwiftz中对UIKit的一个扩展库)给的扩展不够我们使用</li>
<li>比如一个UITextField有个isEnabled属性，我想把这个isEnabled变为一个observer，我们可以这样做：</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">extension Reactive where Base: <span class="built_in">UITextField</span> &#123;</span><br><span class="line">    var inputEnabled: <span class="built_in">UIBindingObserver</span>&lt;Base, Result&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">UIBindingObserver</span>(<span class="built_in">UIElement</span>: base) &#123; textFiled, result <span class="keyword">in</span></span><br><span class="line">            textFiled.isEnabled = result.isValid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>后续会继续更新相关方面知识,敬请期待</p>
</blockquote>
]]></content>
      <categories>
        <category>iOS组件库</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>RxSwift</tag>
      </tags>
  </entry>
  <entry>
    <title>RxSwift的使用详解02</title>
    <url>/post/fd52c18d.html</url>
    <content><![CDATA[<ul>
<li>上一篇: <a href="https://www.titanjun.top/2017/09/15/RxSwift%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A301/">RxSwift的使用详解01</a>主要介绍了<ul>
<li>RxSwift简单体验(在控件中的简单使用)</li>
<li>RxSwift常见操作(never, just, of, empty, creat等10个sequence的使用)</li>
<li>RxSwift中Subjects</li>
<li>变换操作(map, flatMap等)和资源释放DisposeBag</li>
<li>UIBindingObserver创建自己的监听者</li>
</ul>
</li>
<li>本文主要内容<ul>
<li>联合操作: 把多个Observable流合成单个Observable流</li>
<li>elementAt, single, skip等过滤和约束操作</li>
<li>toArray, reduce, concat等数学操作</li>
</ul>
</li>
</ul>
<hr>
<span id="more"></span>

<h2 id="联合操作"><a href="#联合操作" class="headerlink" title="联合操作"></a>联合操作</h2><ul>
<li>联合操作就是把多个Observable流合成单个Observable流</li>
</ul>
<h3 id="startWith"><a href="#startWith" class="headerlink" title="startWith"></a>startWith</h3><ul>
<li>在发出事件消息之前，先发出某个特定的事件消息。</li>
<li>比如发出事件2 ，3然后我startWith(1)，那么就会先发出1，然后2 ，3.</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//未添加startWith</span></span><br><span class="line">Observable.of(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>).subscribe(&#123; print($<span class="number">0</span>) &#125;).addDisposableTo(bag)</span><br><span class="line">    <span class="comment">/***输出顺序:</span></span><br><span class="line"><span class="comment">        next(2)</span></span><br><span class="line"><span class="comment">        next(3)</span></span><br><span class="line"><span class="comment">        completed</span></span><br><span class="line"><span class="comment">    ***/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用startWith</span></span><br><span class="line">Observable.of(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>).startWith(<span class="string">&quot;1&quot;</span>).subscribe(&#123; print($<span class="number">0</span>) &#125;).addDisposableTo(bag)</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/*输出顺序:</span></span><br><span class="line"><span class="comment">         next(1)</span></span><br><span class="line"><span class="comment">         next(2)</span></span><br><span class="line"><span class="comment">         next(3)</span></span><br><span class="line"><span class="comment">         completed</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure>

<h3 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h3><ul>
<li>合并两个Observable流合成单个Observable流，根据时间轴发出对应的事件</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">let subject1 = PublishSubject&lt;String&gt;()</span><br><span class="line">let subject2 = PublishSubject&lt;String&gt;()</span><br><span class="line">Observable.of(subject1, subject2)</span><br><span class="line">    .subscribe(&#123; print($<span class="number">0</span>) &#125;)</span><br><span class="line">    .addDisposableTo(bag)</span><br><span class="line">    </span><br><span class="line">print(<span class="string">&quot;-------------------------&quot;</span>)</span><br><span class="line"></span><br><span class="line">Observable.of(subject1, subject2)</span><br><span class="line">    .merge()</span><br><span class="line">    .subscribe(&#123; print($<span class="number">0</span>) &#125;)</span><br><span class="line">    .addDisposableTo(bag)</span><br><span class="line">        </span><br><span class="line">subject1.onNext(<span class="string">&quot;quan&quot;</span>)</span><br><span class="line">subject1.onNext(<span class="string">&quot;jun&quot;</span>)</span><br><span class="line">subject2.onNext(<span class="string">&quot;ya&quot;</span>)</span><br><span class="line">subject2.onNext(<span class="string">&quot;jie&quot;</span>)</span><br><span class="line">subject1.onNext(<span class="string">&quot;tian&quot;</span>)</span><br><span class="line">subject2.onNext(<span class="string">&quot;guo&quot;</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/*输出事件:</span></span><br><span class="line"><span class="comment">         next(quan)</span></span><br><span class="line"><span class="comment">         next(jun)</span></span><br><span class="line"><span class="comment">         next(ya)</span></span><br><span class="line"><span class="comment">         next(jie)</span></span><br><span class="line"><span class="comment">         next(tian)</span></span><br><span class="line"><span class="comment">         next(guo)</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure>

<h3 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h3><ul>
<li>绑定超过最多不超过8个的Observable流，结合在一起处理。</li>
<li>注意Zip是一个事件对应另一个流一个事件</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">let subject3 = PublishSubject&lt;String&gt;()</span><br><span class="line">let subject4 = PublishSubject&lt;String&gt;()</span><br><span class="line">Observable.zip(subject3, subject4) &#123; (sub3, sub4) -&gt; String <span class="keyword">in</span></span><br><span class="line">        sub3 + <span class="string">&quot;+&quot;</span> + sub4</span><br><span class="line">    &#125;.subscribe(&#123; print($<span class="number">0</span>) &#125;)</span><br><span class="line">    .addDisposableTo(bag)</span><br><span class="line">        </span><br><span class="line">subject3.onNext(<span class="string">&quot;quan&quot;</span>)</span><br><span class="line">subject3.onNext(<span class="string">&quot;jun&quot;</span>)</span><br><span class="line">subject4.onNext(<span class="string">&quot;ya&quot;</span>)</span><br><span class="line">subject4.onNext(<span class="string">&quot;jie&quot;</span>)</span><br><span class="line">subject3.onNext(<span class="string">&quot;tian&quot;</span>)</span><br><span class="line">subject4.onNext(<span class="string">&quot;guo&quot;</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/*输出事件:</span></span><br><span class="line"><span class="comment">         将subject3和subject4压缩到一起共同处理</span></span><br><span class="line"><span class="comment">         next(quan+ya)</span></span><br><span class="line"><span class="comment">         next(jun+jie)</span></span><br><span class="line"><span class="comment">         next(tian+guo)</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure>
<h3 id="combineLatest"><a href="#combineLatest" class="headerlink" title="combineLatest"></a>combineLatest</h3><ul>
<li>绑定超过最多不超过8个的Observable流，结合在一起处理。</li>
<li>和Zip不同的是combineLatest是一个流的事件对应另一个流的最新的事件，两个事件都会是最新的事件，可将下图与Zip的图进行对比</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">let subject5 = PublishSubject&lt;String&gt;()</span><br><span class="line">let subject6 = PublishSubject&lt;String&gt;()</span><br><span class="line">Observable.combineLatest(subject5, subject6) &#123; (sub5, sub6) -&gt; String <span class="keyword">in</span></span><br><span class="line">        sub5 + <span class="string">&quot;+&quot;</span> + sub6</span><br><span class="line">    &#125;.subscribe(&#123; print($<span class="number">0</span>) &#125;).addDisposableTo(bag)</span><br><span class="line"></span><br><span class="line">subject5.onNext(<span class="string">&quot;quan&quot;</span>)</span><br><span class="line">subject5.onNext(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">subject6.onNext(<span class="string">&quot;ya&quot;</span>)</span><br><span class="line">subject6.onNext(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">subject5.onNext(<span class="string">&quot;--&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*输出事件:</span></span><br><span class="line"><span class="comment">         将subject3的最新事件和subject4的最新事件一起处理</span></span><br><span class="line"><span class="comment">         next(1+ya)</span></span><br><span class="line"><span class="comment">         next(1+2)</span></span><br><span class="line"><span class="comment">         next(--+2)</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure>
<h3 id="switchLatest"><a href="#switchLatest" class="headerlink" title="switchLatest"></a>switchLatest</h3><ul>
<li>switchLatest可以对事件流进行转换，本来监听的subject1，我可以通过更改variable里面的value更换事件源。变成监听subject2了</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">let subject7 = BehaviorSubject(value: <span class="string">&quot;love&quot;</span>)</span><br><span class="line"><span class="comment">//BehaviorSubject: 接受订阅之前的最后一个事件</span></span><br><span class="line">let subject8 = BehaviorSubject(value: <span class="string">&quot;love to&quot;</span>)</span><br><span class="line">let variable = Variable(subject7)</span><br><span class="line">variable.asObservable()</span><br><span class="line">        .switchLatest()</span><br><span class="line">        .subscribe(&#123; print($<span class="number">0</span>) &#125;)</span><br><span class="line">        .addDisposableTo(bag)</span><br><span class="line">        </span><br><span class="line">subject7.onNext(<span class="string">&quot;ya&quot;</span>)</span><br><span class="line">subject7.onNext(<span class="string">&quot;jie&quot;</span>)</span><br><span class="line"></span><br><span class="line">variable.value = subject8</span><br><span class="line">subject7.onNext(<span class="string">&quot;quan&quot;</span>)</span><br><span class="line">subject8.onNext(<span class="string">&quot;jun&quot;</span>)</span><br><span class="line">        </span><br><span class="line">variable.value = subject7</span><br><span class="line">subject8.onNext(<span class="string">&quot;jie&quot;</span>)</span><br><span class="line">subject7.onNext(<span class="string">&quot;guo&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*输出事件:</span></span><br><span class="line"><span class="comment">         next(love)</span></span><br><span class="line"><span class="comment">         next(ya)</span></span><br><span class="line"><span class="comment">         next(jie)</span></span><br><span class="line"><span class="comment">         next(love to)</span></span><br><span class="line"><span class="comment">         next(jun)</span></span><br><span class="line"><span class="comment">         next(quan)</span></span><br><span class="line"><span class="comment">         next(guo)</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure>


<h2 id="过滤和约束"><a href="#过滤和约束" class="headerlink" title="过滤和约束"></a>过滤和约束</h2><h3 id="distinctUntilChanged"><a href="#distinctUntilChanged" class="headerlink" title="distinctUntilChanged"></a>distinctUntilChanged</h3><ul>
<li>distinctUntilChanged就是当: 下一个事件与前一个事件是不同事件的事件才进行处理操作</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Observable.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line">        .distinctUntilChanged()</span><br><span class="line">        .subscribe(&#123; print($<span class="number">0</span>) &#125;)</span><br><span class="line">        .addDisposableTo(bag)</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/*输出顺序为:</span></span><br><span class="line"><span class="comment">         next(1)</span></span><br><span class="line"><span class="comment">         next(2)</span></span><br><span class="line"><span class="comment">         next(1)</span></span><br><span class="line"><span class="comment">         next(3)</span></span><br><span class="line"><span class="comment">         next(1)</span></span><br><span class="line"><span class="comment">         completed</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure>

<h3 id="elementAt"><a href="#elementAt" class="headerlink" title="elementAt"></a>elementAt</h3><ul>
<li>只处理在指定位置的事件</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Observable.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">        .elementAt(<span class="number">3</span>)</span><br><span class="line">        .subscribe(&#123; print($<span class="number">0</span>) &#125;)</span><br><span class="line">        .addDisposableTo(bag)</span><br><span class="line">    <span class="comment">/*输出顺序为:</span></span><br><span class="line"><span class="comment">         next(4)</span></span><br><span class="line"><span class="comment">         completed</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure>

<h3 id="single"><a href="#single" class="headerlink" title="single"></a>single</h3><ul>
<li>找出在sequence只发出一次的事件，如果超过一个就会发出error错误</li>
</ul>
<h4 id="多个信号输出的情况"><a href="#多个信号输出的情况" class="headerlink" title="多个信号输出的情况"></a>多个信号输出的情况</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Observable.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">        .single()</span><br><span class="line">        .subscribe(&#123; print($<span class="number">0</span>) &#125;)</span><br><span class="line">        .addDisposableTo(bag)</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/*输出顺序为:</span></span><br><span class="line"><span class="comment">         next(1) //单一信号超过了一个,只会输出第一个,然后输出error</span></span><br><span class="line"><span class="comment">         error(Sequence contains more than one element.)</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure>
<h4 id="指定某唯一信号的情况"><a href="#指定某唯一信号的情况" class="headerlink" title="指定某唯一信号的情况"></a>指定某唯一信号的情况</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Observable.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">        .single(&#123; $<span class="number">0</span> == <span class="number">2</span> &#125;)</span><br><span class="line">        .subscribe(&#123; print($<span class="number">0</span>) &#125;)</span><br><span class="line">        .addDisposableTo(bag)</span><br><span class="line">    <span class="comment">/*输出顺序为:</span></span><br><span class="line"><span class="comment">         next(2)</span></span><br><span class="line"><span class="comment">         completed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="指定某不唯一信号的情况"><a href="#指定某不唯一信号的情况" class="headerlink" title="指定某不唯一信号的情况"></a>指定某不唯一信号的情况</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Observable.of(<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">        .single(&#123; $<span class="number">0</span> == <span class="number">4</span> &#125;)</span><br><span class="line">        .subscribe(&#123; print($<span class="number">0</span>) &#125;)</span><br><span class="line">        .addDisposableTo(bag)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*输出顺序为:</span></span><br><span class="line"><span class="comment">         next(4) //单一信号超过了一个,只会输出第一个,然后输出error</span></span><br><span class="line"><span class="comment">         error(Sequence contains more than one element.)</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure>

<h4 id="找不到该信号的情况"><a href="#找不到该信号的情况" class="headerlink" title="找不到该信号的情况"></a>找不到该信号的情况</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Observable.of(<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">        .single(&#123; $<span class="number">0</span> == <span class="number">2</span> &#125;)</span><br><span class="line">        .subscribe(&#123; print($<span class="number">0</span>) &#125;)</span><br><span class="line">        .addDisposableTo(bag)</span><br><span class="line">    <span class="comment">/*输出顺序为:</span></span><br><span class="line"><span class="comment">         没有对应的参数,然后输出error</span></span><br><span class="line"><span class="comment">         error(Sequence doesn&#x27;t contain any elements.)</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure>

<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><ul>
<li>过滤掉某些不符合要求的事件</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Observable.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">        .filter(&#123; $<span class="number">0</span> &gt; <span class="number">3</span> &#125;)</span><br><span class="line">        .subscribe(&#123; print($<span class="number">0</span>) &#125;)</span><br><span class="line">        .addDisposableTo(bag)</span><br><span class="line">    <span class="comment">/*输出顺序为:</span></span><br><span class="line"><span class="comment">         next(4)</span></span><br><span class="line"><span class="comment">         next(5)</span></span><br><span class="line"><span class="comment">         completed</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure>

<h3 id="take"><a href="#take" class="headerlink" title="take"></a>take</h3><ul>
<li>只处理前几个事件信号</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Observable.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">        .take(<span class="number">2</span>)</span><br><span class="line">        .subscribe(&#123; print($<span class="number">0</span>) &#125;)</span><br><span class="line">        .addDisposableTo(bag)</span><br><span class="line">    <span class="comment">/*输出顺序为:</span></span><br><span class="line"><span class="comment">         next(1)</span></span><br><span class="line"><span class="comment">         next(2)</span></span><br><span class="line"><span class="comment">         completed</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure>


<h3 id="takeLast"><a href="#takeLast" class="headerlink" title="takeLast"></a>takeLast</h3><ul>
<li>只处理后几个事件信号</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Observable.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">        .takeLast(<span class="number">2</span>)</span><br><span class="line">        .subscribe(&#123; print($<span class="number">0</span>) &#125;)</span><br><span class="line">        .addDisposableTo(bag)</span><br><span class="line">    <span class="comment">/*输出顺序为:</span></span><br><span class="line"><span class="comment">         next(4)</span></span><br><span class="line"><span class="comment">         next(5)</span></span><br><span class="line"><span class="comment">         completed</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure>

<h3 id="takeWhile"><a href="#takeWhile" class="headerlink" title="takeWhile"></a>takeWhile</h3><ul>
<li>当条件满足的时候进行处理</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Observable.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">        .takeWhile(&#123; $<span class="number">0</span> &gt; <span class="number">3</span> &#125;)</span><br><span class="line">        .subscribe(&#123; print($<span class="number">0</span>) &#125;)</span><br><span class="line">        .addDisposableTo(bag)</span><br><span class="line">    <span class="comment">/*输出顺序为:</span></span><br><span class="line"><span class="comment">         next(4)</span></span><br><span class="line"><span class="comment">         next(5)</span></span><br><span class="line"><span class="comment">         completed</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure>

<h3 id="takeUntil"><a href="#takeUntil" class="headerlink" title="takeUntil"></a>takeUntil</h3><ul>
<li>接收事件消息，直到另一个sequence发出事件消息的时候.停止接收消息,输出completed</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">let subject1 = PublishSubject&lt;String&gt;()</span><br><span class="line">let subject2 = PublishSubject&lt;String&gt;()</span><br><span class="line">subject1.takeUntil(subject2)</span><br><span class="line">        .subscribe(&#123; print($<span class="number">0</span>) &#125;)</span><br><span class="line">        .addDisposableTo(bag)</span><br><span class="line">subject1.onNext(<span class="string">&quot;quan&quot;</span>)</span><br><span class="line">subject1.onNext(<span class="string">&quot;jun&quot;</span>)</span><br><span class="line"></span><br><span class="line">subject2.onNext(<span class="string">&quot;ya&quot;</span>)<span class="comment">//停止接收消息</span></span><br><span class="line">        </span><br><span class="line">subject1.onNext(<span class="string">&quot;tian&quot;</span>)</span><br><span class="line">subject2.onNext(<span class="string">&quot;guo&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*输出顺序为:</span></span><br><span class="line"><span class="comment">         next(quan)</span></span><br><span class="line"><span class="comment">         next(jun)</span></span><br><span class="line"><span class="comment">         completed</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure>


<h3 id="skip"><a href="#skip" class="headerlink" title="skip"></a>skip</h3><ul>
<li>取消前几个事件</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Observable.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">        .skip(<span class="number">3</span>)</span><br><span class="line">        .subscribe(&#123; print($<span class="number">0</span>) &#125;)</span><br><span class="line">        .addDisposableTo(bag)</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/*输出顺序为:</span></span><br><span class="line"><span class="comment">         next(4)</span></span><br><span class="line"><span class="comment">         next(5)</span></span><br><span class="line"><span class="comment">         completed</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure>


<h3 id="skipWhile"><a href="#skipWhile" class="headerlink" title="skipWhile"></a>skipWhile</h3><ul>
<li>满足条件的事件消息都取消</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Observable.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">        .skipWhile(&#123; $<span class="number">0</span> &lt; <span class="number">4</span> &#125;)</span><br><span class="line">        .subscribe(&#123; print($<span class="number">0</span>) &#125;)</span><br><span class="line">        .addDisposableTo(bag)</span><br><span class="line">    <span class="comment">/*输出顺序为:</span></span><br><span class="line"><span class="comment">         next(4)</span></span><br><span class="line"><span class="comment">         next(5)</span></span><br><span class="line"><span class="comment">         completed</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure>

<h3 id="skipWhileWithIndex"><a href="#skipWhileWithIndex" class="headerlink" title="skipWhileWithIndex"></a>skipWhileWithIndex</h3><ul>
<li>满足条件的都被取消，传入的闭包同skipWhile有点区别而已</li>
<li><code>skipWhile</code>的(&lt;4)和<code>skipWhileWithIndex</code>的(&lt;&#x3D;3)的效果是一样的</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Observable.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">        .skipWhileWithIndex(&#123; (element, index) -&gt; Bool <span class="keyword">in</span></span><br><span class="line">            index &lt;= <span class="number">3</span></span><br><span class="line">        &#125;)</span><br><span class="line">        .subscribe(&#123; print($<span class="number">0</span>) &#125;)</span><br><span class="line">        .addDisposableTo(bag)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*输出顺序为:</span></span><br><span class="line"><span class="comment">         next(4)</span></span><br><span class="line"><span class="comment">         next(5)</span></span><br><span class="line"><span class="comment">         completed</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure>


<h3 id="skipUntil"><a href="#skipUntil" class="headerlink" title="skipUntil"></a>skipUntil</h3><ul>
<li>直到某个sequence发出了事件消息，才开始接收当前sequence发出的事件消息</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">let subject3 = PublishSubject&lt;String&gt;()</span><br><span class="line">let subject4 = PublishSubject&lt;String&gt;()</span><br><span class="line">subject3.skipUntil(subject4)</span><br><span class="line">        .subscribe(&#123; print($<span class="number">0</span>) &#125;)</span><br><span class="line">        .addDisposableTo(bag)</span><br><span class="line">subject3.onNext(<span class="string">&quot;quan&quot;</span>)</span><br><span class="line">subject4.onNext(<span class="string">&quot;jun&quot;</span>)</span><br><span class="line">        </span><br><span class="line">subject4.onNext(<span class="string">&quot;ya&quot;</span>)<span class="comment">//开始接收消息</span></span><br><span class="line">        </span><br><span class="line">subject3.onNext(<span class="string">&quot;tian&quot;</span>)</span><br><span class="line">subject4.onNext(<span class="string">&quot;guo&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*输出顺序为:</span></span><br><span class="line"><span class="comment">         next(tian)</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure>


<h2 id="数学操作"><a href="#数学操作" class="headerlink" title="数学操作"></a>数学操作</h2><h3 id="toArray"><a href="#toArray" class="headerlink" title="toArray"></a>toArray</h3><ul>
<li>将sequence转换成一个array，并转换成单一事件信号，然后结束</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Observable.range(start: <span class="number">1</span>, count: <span class="number">5</span>)</span><br><span class="line">        .toArray()</span><br><span class="line">        .subscribe(&#123; print($<span class="number">0</span>) &#125;)</span><br><span class="line">        .addDisposableTo(bag)</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/*输出顺序为:</span></span><br><span class="line"><span class="comment">         next([1, 2, 3, 4, 5])</span></span><br><span class="line"><span class="comment">         completed</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure>
<h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><ul>
<li>用一个初始值，对事件数据进行累计操作。reduce接受一个初始值，和一个操作符号</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Observable.of(<span class="number">10</span>, <span class="number">12</span>, <span class="number">34</span>)</span><br><span class="line">       .reduce(<span class="number">0</span>, accumulator: +)</span><br><span class="line">       .subscribe(&#123; print($<span class="number">0</span>) &#125;)</span><br><span class="line">       .addDisposableTo(bag)</span><br><span class="line">       </span><br><span class="line">  <span class="comment">/*输出顺序为:</span></span><br><span class="line"><span class="comment">         next(56)</span></span><br><span class="line"><span class="comment">         completed</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure>
<h3 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h3><ul>
<li>concat会把多个sequence和并为一个sequence，并且当前面一个sequence发出了completed事件，才会开始下一个sequence的事件。</li>
<li>在第一sequence发出onCompleted完成之前，第二个sequence发出的事件都会被忽略</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">let subject1 = BehaviorSubject(value: <span class="string">&quot;quan&quot;</span>)</span><br><span class="line">let subject2 = BehaviorSubject(value: <span class="string">&quot;jun&quot;</span>)</span><br><span class="line">let variable = Variable(subject1)</span><br><span class="line">variable.asObservable()</span><br><span class="line">        .concat()</span><br><span class="line">        .subscribe(&#123; print($<span class="number">0</span>) &#125;)</span><br><span class="line">        .addDisposableTo(bag)</span><br><span class="line">subject1.onNext(<span class="string">&quot;ya&quot;</span>)</span><br><span class="line">subject1.onNext(<span class="string">&quot;jie&quot;</span>)</span><br><span class="line">subject2.onNext(<span class="string">&quot;jun&quot;</span>)  <span class="comment">//subject2不被输出</span></span><br><span class="line">        </span><br><span class="line">variable.value = subject2  <span class="comment">//subject1发出onCompleted()之前会继续输出subject1</span></span><br><span class="line">        </span><br><span class="line">subject1.onNext(<span class="string">&quot;guo&quot;</span>)</span><br><span class="line">subject2.onNext(<span class="string">&quot;tian&quot;</span>)</span><br><span class="line">        </span><br><span class="line">subject1.onCompleted()  <span class="comment">//subject1结束,开始输出subject2,此时subject2的值接受最后一个(&quot;tian&quot;)</span></span><br><span class="line">        </span><br><span class="line">subject2.onNext(<span class="string">&quot;love&quot;</span>)</span><br><span class="line">subject1.onNext(<span class="string">&quot;to love&quot;</span>) <span class="comment">//subject1将不再被输出</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">/*输出顺序为:</span></span><br><span class="line"><span class="comment">        next(quan)</span></span><br><span class="line"><span class="comment">        next(ya)</span></span><br><span class="line"><span class="comment">        next(jie)</span></span><br><span class="line"><span class="comment">        next(guo)</span></span><br><span class="line"><span class="comment">        next(tian)</span></span><br><span class="line"><span class="comment">        next(love)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="RxSwift的优点"><a href="#RxSwift的优点" class="headerlink" title="RxSwift的优点"></a>RxSwift的优点</h2><ul>
<li>Composable 可组合，在设计模式中有一种模式叫做组合模式，你可以方便的用不同的组合实现不同的类</li>
<li>Reusable 代码可重用，原因很简单，对应RxSwift，就是一堆Obserable</li>
<li>Declarative 响应式的，因为状态不可变，只有数据变化</li>
<li>Understandable and concise 简洁，容易理解。</li>
<li>Stable 稳定，因为RxSwift写出的代码，单元测试时分方便</li>
<li>Less stateful “无”状态性，因为对于响应式编程，你的应用程序就是一堆数据流</li>
<li>Without leaks 没有泄漏，因为资源管理非常简单</li>
</ul>
]]></content>
      <categories>
        <category>iOS组件库</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>RxSwift</tag>
      </tags>
  </entry>
  <entry>
    <title>Sign In with Apple</title>
    <url>/post/de12f33.html</url>
    <content><![CDATA[<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/ios/appleicon.png?x-oss-process=style/titanjun" alt="image"></p>
<span id="more"></span>





<ul>
<li>原文博客地址: <a href="https://www.titanjun.top/">Sign In With Apple</a></li>
<li>在之前的文章<a href="https://www.titanjun.top/iOS13%E9%80%82%E9%85%8D%E6%B7%B1%E8%89%B2%E6%A8%A1%E5%BC%8F(Dark%20Mode).html">iOS13适配深色模式(Dark Mode)</a>中只是简单提到了关于<a href="https://www.titanjun.top/">Sign In With Apple</a>的问题, 下面就着重介绍一下什么是<code>Apple</code>登录</li>
<li>对于很多应用都会有自己的账号登录体系, 但是一般都相对繁琐, 或者用户会忘记密码等, 为此一般都会接入微信、<code>QQ</code>登录, 国外应用也会有<code>Google</code>、<code>Facebook</code>等第三方登录方式</li>
<li>在<code>WWDC 2019</code>上, 苹果要求使用第三方登录的应用也必须接入苹果账号登录(2020年必须适配)</li>
<li>当然了如果你的<code>App</code>没有提供第三方登录，那就不用集成; 如果用到了第三方登录，那么需要提供<code>Sign in with Apple</code></li>
</ul>
<h2 id="Sign-in-with-Apple"><a href="#Sign-in-with-Apple" class="headerlink" title="Sign in with Apple"></a>Sign in with Apple</h2><blockquote>
<p>Sign in with Apple makes it easy for users to sign in to your apps and websites using their Apple ID. Instead of filling out forms, verifying email addresses, and choosing new passwords, they can use Sign in with Apple to set up an account and start using your app right away. All accounts are protected with two-factor authentication for superior security, and Apple will not track users’ activity in your app or website.</p>
</blockquote>
<blockquote>
<p>Make signing in easy</p>
</blockquote>
<ul>
<li><code>Sign In with Apple</code>为用户提供一种快速安全的登录方式, 用户可以轻松登录开发者的应用和网站</li>
<li>使用<code>Apple</code>登录可以让用户在系统中设置用户帐户，开发者可以获取到用户名称(<code>Name</code>), 用户唯一标识符(<code>ID</code>)以及经过验证的电子邮件地址(<code>email</code>)</li>
<li><code>Sign In with Apple</code>相关特性<ul>
<li>尊重用户隐私: 开发人员仅仅只能获取到用户的姓名和邮箱, 苹果也不会收集用户和应用交互的任何信息</li>
<li>系统内置的安全性：<code>2F</code>双重验证(<code>Face ID</code>或<code>Touch ID</code>)，从此登录不再需要密码</li>
<li>简化账号的创建和登录流程，无缝跨设备使用</li>
<li>开发者可以获取到已验证过的邮箱作为登录账号或者与用户进行通信（注：用户可以选择隐藏真实邮箱，并使用苹果提供的虚拟邮箱进行授权）</li>
<li>可跨平台使用, Apple登录支持<code>iOS</code>，<code>macOS</code>，<code>tvOS</code>和<code>watchOS</code>以及<code>JavaScript</code></li>
<li>更多信息可惨考<a href="https://developer.apple.com/sign-in-with-apple/"><br>使用Apple登录</a></li>
</ul>
</li>
</ul>
<div class="note info"><p>在代码集成之前还需要做一些准备工作</p></div>


<ol>
<li>在开发者网站，在需要添加<code>Sign in with Apple</code>功能</li>
</ol>
<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/ios/sign_apple.png" alt="image"></p>
<ol start="2">
<li>在<code>Xcode</code>里面开启<code>Sign in with Apple</code>功能</li>
</ol>
<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/ios/applesign.png" alt="Xcode"></p>
<h2 id="登录按钮"><a href="#登录按钮" class="headerlink" title="登录按钮"></a>登录按钮</h2><p><code>Apple</code>苹果登录按钮, 需要使用<code>ASAuthorizationAppleIDButton</code>类创建添加, 该类是<code>iOS 13</code>苹果提供的创建<code>Apple</code>登录按钮的专属类</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@available</span>(<span class="keyword">iOS</span> <span class="number">13.0</span>, <span class="operator">*</span>)</span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">ASAuthorizationAppleIDButton</span> : <span class="title class_">UIControl</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">convenience</span> <span class="keyword">init</span>(<span class="params">type</span>: <span class="type">ASAuthorizationAppleIDButton</span>.<span class="type">ButtonType</span>, <span class="params">style</span>: <span class="type">ASAuthorizationAppleIDButton</span>.<span class="type">Style</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="params">authorizationButtonType</span> <span class="params">type</span>: <span class="type">ASAuthorizationAppleIDButton</span>.<span class="type">ButtonType</span>, <span class="params">authorizationButtonStyle</span> <span class="params">style</span>: <span class="type">ASAuthorizationAppleIDButton</span>.<span class="type">Style</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置按钮的圆切角</span></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">var</span> cornerRadius: <span class="type">CGFloat</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>开始创建<code>Apple</code>登录按钮</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// apple登录按钮</span></span><br><span class="line"><span class="keyword">let</span> appleButton <span class="operator">=</span> <span class="type">ASAuthorizationAppleIDButton</span>(type: .continue, style: .black)</span><br><span class="line">appleButton.frame <span class="operator">=</span> <span class="type">CGRect</span>(x: <span class="number">100</span>, y: showLabel.frame.maxY <span class="operator">+</span> <span class="number">40</span>, width: <span class="number">200</span>, height: <span class="number">50</span>)</span><br><span class="line">appleButton.cornerRadius <span class="operator">=</span> <span class="number">10</span></span><br><span class="line">appleButton.addTarget(<span class="keyword">self</span>, action: <span class="keyword">#selector</span>(appleAction), for: .touchUpInside)</span><br><span class="line">view.addSubview(appleButton)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ASAuthorizationAppleIDButton</code>的初始化方法中有两个参数<code>type</code>和<code>style</code></li>
<li><code>type</code>是设置按钮的类型<code>ASAuthorizationAppleIDButton.ButtonType</code></li>
<li><code>style</code>设置按钮的样式<code>ASAuthorizationAppleIDButton.Style</code></li>
<li>可参考官网介绍<a href="https://developer.apple.com/design/human-interface-guidelines/sign-in-with-apple/overview/">Sign In with Apple</a></li>
</ul>
<h3 id="ButtonType"><a href="#ButtonType" class="headerlink" title="ButtonType"></a>ButtonType</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ButtonType</span> : <span class="title class_">Int</span> &#123;</span><br><span class="line">    <span class="comment">// signIn登录类型</span></span><br><span class="line">    <span class="keyword">case</span> signIn</span><br><span class="line">    <span class="comment">// continue类型</span></span><br><span class="line">    <span class="keyword">case</span> `continue`</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> `default`: <span class="type">ASAuthorizationAppleIDButton</span>.<span class="type">ButtonType</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不同<code>ButtonType</code>展示效果如下</p>
<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/ios/sign_type.png" alt="ButtonType"></p>
<h3 id="Style"><a href="#Style" class="headerlink" title="Style"></a>Style</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@available</span>(<span class="keyword">iOS</span> <span class="number">13.0</span>, <span class="operator">*</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Style</span> : <span class="title class_">Int</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">case</span> white</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> whiteOutline</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> black</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>不同<code>Style</code>展示效果和使用场景如下</p>
<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/ios/sign_style.jpg" alt="Style"></p>
<h3 id="cornerRadius"><a href="#cornerRadius" class="headerlink" title="cornerRadius"></a>cornerRadius</h3><p>设置按钮的圆角大小</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认值大概5左右, 具体值不知</span></span><br><span class="line">appleButton.cornerRadius <span class="operator">=</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>

<h2 id="发起授权请求"><a href="#发起授权请求" class="headerlink" title="发起授权请求"></a>发起授权请求</h2><p>在创建好登录按钮后, 点击按钮的操作就是, 根据用户登录的<code>AppleID</code>发起授权请求, 并获得授权码</p>
<ul>
<li><code>iOS 13</code>系统给我们提供了一个<code>ASAuthorizationAppleIDProvider</code>类</li>
<li>该类就是一种基于用户的<code>AppleID</code>生成用户的授权请求的一种机制</li>
<li>在发起授权请求之前, 需要配置要获取的数据权限范围（例如：用户名、邮箱等）</li>
<li>为获取授权结果, 还需要设置回调代理, 并发起授权请求</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@objc</span> <span class="keyword">fileprivate</span> <span class="keyword">func</span> <span class="title function_">appleAction</span>() &#123;</span><br><span class="line">    <span class="comment">// 基于用户的Apple ID授权用户，生成用户授权请求的一种机制</span></span><br><span class="line">    <span class="keyword">let</span> appleIDProvider <span class="operator">=</span> <span class="type">ASAuthorizationAppleIDProvider</span>()</span><br><span class="line">    <span class="comment">// 创建新的AppleID授权请求</span></span><br><span class="line">    <span class="keyword">let</span> request <span class="operator">=</span> appleIDProvider.createRequest()</span><br><span class="line">    <span class="comment">// 所需要请求的联系信息</span></span><br><span class="line">    request.requestedScopes <span class="operator">=</span> [.fullName, .email]</span><br><span class="line">    <span class="comment">// 管理授权请求的控制器</span></span><br><span class="line">    <span class="keyword">let</span> controller <span class="operator">=</span> <span class="type">ASAuthorizationController</span>(authorizationRequests: [request])</span><br><span class="line">    <span class="comment">// 授权成功或者失败的代理</span></span><br><span class="line">    controller.delegate <span class="operator">=</span> <span class="keyword">self</span></span><br><span class="line">    <span class="comment">// 显示上下文的代理, 系统可以在上下文中向用户展示授权页面</span></span><br><span class="line">    controller.presentationContextProvider <span class="operator">=</span> <span class="keyword">self</span></span><br><span class="line">    <span class="comment">// 在控制器初始化期间启动授权流</span></span><br><span class="line">    controller.performRequests()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="delegate"><a href="#delegate" class="headerlink" title="delegate"></a>delegate</h3><p>设置授权控制器通知授权请求的成功与失败的代理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 代理</span><br><span class="line">weak open var delegate: ASAuthorizationControllerDelegate?</span><br><span class="line"></span><br><span class="line">// 代理方法如下</span><br><span class="line">@available(iOS 13.0, *)</span><br><span class="line">public protocol ASAuthorizationControllerDelegate : NSObjectProtocol &#123;</span><br><span class="line">    // 授权成功的回调</span><br><span class="line">    optional func authorizationController(controller: ASAuthorizationController, didCompleteWithAuthorization authorization: ASAuthorization)</span><br><span class="line"></span><br><span class="line">    // 授权失败的回调</span><br><span class="line">    optional func authorizationController(controller: ASAuthorizationController, didCompleteWithError error: Error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="presentationContextProvider"><a href="#presentationContextProvider" class="headerlink" title="presentationContextProvider"></a>presentationContextProvider</h3><p>需要向用户展示授权页面时, 需要遵循该协议</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 显示上下文的代理, 系统可以在上下文中向用户展示授权页面</span></span><br><span class="line"><span class="keyword">weak</span> <span class="keyword">open</span> <span class="keyword">var</span> presentationContextProvider: <span class="type">ASAuthorizationControllerPresentationContextProviding</span>?</span><br><span class="line"></span><br><span class="line"><span class="comment">// 协议方法</span></span><br><span class="line"><span class="keyword">@available</span>(<span class="keyword">iOS</span> <span class="number">13.0</span>, <span class="operator">*</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">protocol</span> <span class="title class_">ASAuthorizationControllerPresentationContextProviding</span> : <span class="title class_">NSObjectProtocol</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该方法返回一个视图锚点, 告诉代理应该在哪个window 展示内容给用户</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">presentationAnchor</span>(<span class="params">for</span> <span class="params">controller</span>: <span class="type">ASAuthorizationController</span>) -&gt; <span class="type">ASPresentationAnchor</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法执行示例</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">presentationAnchor</span>(<span class="params">for</span> <span class="params">controller</span>: <span class="type">ASAuthorizationController</span>) -&gt; <span class="type">ASPresentationAnchor</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.view.window<span class="operator">!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="ASAuthorization"><a href="#ASAuthorization" class="headerlink" title="ASAuthorization"></a>ASAuthorization</h3><ul>
<li>在控制器获得授权的成功回调中, 协议方法提供了一个<code>ASAuthorization</code></li>
<li><code>ASAuthorization</code>是对控制器成功授权的封装, 包括两个属性</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@available</span>(<span class="keyword">iOS</span> <span class="number">13.0</span>, <span class="operator">*</span>)</span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">ASAuthorization</span> : <span class="title class_">NSObject</span> &#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建发起成功授权的发起者</span></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">var</span> provider: <span class="type">ASAuthorizationProvider</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成功授权后返回的相关凭证, 包含授权后的相关信息,是一个协议</span></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">var</span> credential: <span class="type">ASAuthorizationCredential</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ASAuthorizationCredential"><a href="#ASAuthorizationCredential" class="headerlink" title="ASAuthorizationCredential"></a>ASAuthorizationCredential</h3><p>是一个协议, 在处理授权成功的结果中, 需要使用遵循该协议的类, 有以下三个</p>
<ul>
<li><code>ASPasswordCredential</code>: 密码凭证</li>
<li><code>ASAuthorizationAppleIDCredential</code>: Apple ID身份验证成功产生的凭证</li>
<li><code>ASAuthorizationSingleSignOnCredential</code>: 单点登录（SSO）身份验证产生的凭据</li>
</ul>
<h4 id="ASPasswordCredential"><a href="#ASPasswordCredential" class="headerlink" title="ASPasswordCredential"></a>ASPasswordCredential</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@available</span>(<span class="keyword">iOS</span> <span class="number">12.0</span>, <span class="operator">*</span>)</span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">ASPasswordCredential</span> : <span class="title class_">NSObject</span>, <span class="title class_">ASAuthorizationCredential</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="params">user</span>: <span class="type">String</span>, <span class="params">password</span>: <span class="type">String</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用户名</span></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">var</span> user: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用户密码</span></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">var</span> password: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="ASAuthorizationAppleIDCredential"><a href="#ASAuthorizationAppleIDCredential" class="headerlink" title="ASAuthorizationAppleIDCredential"></a>ASAuthorizationAppleIDCredential</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@available</span>(<span class="keyword">iOS</span> <span class="number">13.0</span>, <span class="operator">*</span>)</span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">ASAuthorizationAppleIDCredential</span> : <span class="title class_">NSObject</span>, <span class="title class_">ASAuthorizationCredential</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 和用户AppleID关联的用户ID(标识符)</span></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">var</span> user: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传送给ASAuthorizationRequest的字符串</span></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">var</span> state: <span class="type">String</span>? &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用户授权的可访问的联系信息的种类</span></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">var</span> authorizedScopes: [<span class="type">ASAuthorization</span>.<span class="type">Scope</span>] &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为APP提供的授权证明的有效token</span></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">var</span> authorizationCode: <span class="type">Data</span>? &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// JSON Web Token (JWT), 用于以安全的方式向应用程序传递关于用户身份的信息</span></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">var</span> identityToken: <span class="type">Data</span>? &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用户的email</span></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">var</span> email: <span class="type">String</span>? &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用户名</span></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">var</span> fullName: <span class="type">PersonNameComponents</span>? &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用户是否是真实用户的状态</span></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">var</span> realUserStatus: <span class="type">ASUserDetectionStatus</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户是否是真实用户的枚举值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ASUserDetectionStatus</span> : <span class="title class_">Int</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> unsupported</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> unknown</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> likelyReal</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ASAuthorizationSingleSignOnCredential"><a href="#ASAuthorizationSingleSignOnCredential" class="headerlink" title="ASAuthorizationSingleSignOnCredential"></a>ASAuthorizationSingleSignOnCredential</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@available</span>(<span class="keyword">iOS</span> <span class="number">13.0</span>, <span class="operator">*</span>)</span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">ASAuthorizationSingleSignOnCredential</span> : <span class="title class_">NSObject</span>, <span class="title class_">ASAuthorizationCredential</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AuthenticationServices返回的字符串</span></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">var</span> state: <span class="type">String</span>? &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用户获取授权范围的token</span></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">var</span> accessToken: <span class="type">Data</span>? &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// JSON Web Token (JWT), 用于以安全的方式向应用程序传递关于用户身份的信息</span></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">var</span> identityToken: <span class="type">Data</span>? &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用户授权的可访问的联系信息的种类</span></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">var</span> authorizedScopes: [<span class="type">ASAuthorization</span>.<span class="type">Scope</span>] &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 完整的身份验证响应信息</span></span><br><span class="line">    <span class="keyword">@NSCopying</span> <span class="keyword">open</span> <span class="keyword">var</span> authenticatedResponse: <span class="type">HTTPURLResponse</span>? &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="授权成功"><a href="#授权成功" class="headerlink" title="授权成功"></a>授权成功</h3><p>上面有提到, 在<code>ASAuthorizationControllerDelegate</code>有两个协议方法, 分别是授权成功和失败的回调, 下面就具体看看</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">SignViewController</span>: <span class="title class_">ASAuthorizationControllerDelegate</span> &#123;</span><br><span class="line">    <span class="comment">// 处理成功的授权</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">authorizationController</span>(<span class="params">controller</span>: <span class="type">ASAuthorizationController</span>, <span class="params">didCompleteWithAuthorization</span> <span class="params">authorization</span>: <span class="type">ASAuthorization</span>) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;授权成功&quot;</span>)</span><br><span class="line">        <span class="comment">// 成功的Apple ID身份验证信息</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> appleIDCreden <span class="operator">=</span> authorization.credential <span class="keyword">as?</span> <span class="type">ASAuthorizationAppleIDCredential</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> userIdentifier <span class="operator">=</span> appleIDCreden.user</span><br><span class="line">            <span class="keyword">let</span> fullName <span class="operator">=</span> appleIDCreden.fullName</span><br><span class="line">            <span class="keyword">let</span> email <span class="operator">=</span> appleIDCreden.email</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 这里需要我们在系统中创建一个账户, 用于存储用户的唯一标识userIdentifier</span></span><br><span class="line">            <span class="comment">// 可以在系统的钥匙串中存储</span></span><br><span class="line">            <span class="keyword">let</span> webVC <span class="operator">=</span> <span class="type">WebViewController</span>()</span><br><span class="line">            webVC.user <span class="operator">=</span> userIdentifier</span><br><span class="line">            webVC.giveName <span class="operator">=</span> fullName<span class="operator">?</span>.givenName <span class="operator">??</span> <span class="string">&quot;&quot;</span></span><br><span class="line">            webVC.familyName <span class="operator">=</span> fullName<span class="operator">?</span>.familyName <span class="operator">??</span> <span class="string">&quot;&quot;</span></span><br><span class="line">            webVC.email <span class="operator">=</span> email <span class="operator">??</span> <span class="string">&quot;&quot;</span></span><br><span class="line">            navigationController<span class="operator">?</span>.pushViewController(webVC, animated: <span class="literal">true</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> passwordCreden <span class="operator">=</span> authorization.credential <span class="keyword">as?</span> <span class="type">ASPasswordCredential</span> &#123;</span><br><span class="line">            <span class="comment">// 密码凭证用户的唯一标识</span></span><br><span class="line">            <span class="keyword">let</span> userIdentifiler <span class="operator">=</span> passwordCreden.user</span><br><span class="line">            <span class="comment">// 密码凭证的密码</span></span><br><span class="line">            <span class="keyword">let</span> password <span class="operator">=</span> passwordCreden.password</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 显示相关信息</span></span><br><span class="line">            <span class="keyword">let</span> message <span class="operator">=</span> <span class="string">&quot;APP已经收到您选择的秘钥凭证<span class="subst">\n</span>Username: <span class="subst">\(userIdentifiler)</span><span class="subst">\n</span> Password: <span class="subst">\(password)</span>&quot;</span></span><br><span class="line">            showLabel.text <span class="operator">=</span> message</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            showLabel.text <span class="operator">=</span> <span class="string">&quot;授权信息均不符&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理授权错误</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">authorizationController</span>(<span class="params">controller</span>: <span class="type">ASAuthorizationController</span>, <span class="params">didCompleteWithError</span> <span class="params">error</span>: <span class="type">Error</span>) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;授权错误: <span class="subst">\(error)</span>&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> showText <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> authError <span class="operator">=</span> error <span class="keyword">as?</span> <span class="type">ASAuthorizationError</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> code <span class="operator">=</span> authError.code</span><br><span class="line">            <span class="keyword">switch</span> code &#123;</span><br><span class="line">            <span class="keyword">case</span> .canceled:</span><br><span class="line">                showText <span class="operator">=</span> <span class="string">&quot;用户取消了授权请求&quot;</span></span><br><span class="line">            <span class="keyword">case</span> .failed:</span><br><span class="line">                showText <span class="operator">=</span> <span class="string">&quot;授权请求失败&quot;</span></span><br><span class="line">            <span class="keyword">case</span> .invalidResponse:</span><br><span class="line">                showText <span class="operator">=</span> <span class="string">&quot;授权请求响应无效&quot;</span></span><br><span class="line">            <span class="keyword">case</span> .notHandled:</span><br><span class="line">                showText <span class="operator">=</span> <span class="string">&quot;未能处理授权请求&quot;</span></span><br><span class="line">            <span class="keyword">case</span> .unknown:</span><br><span class="line">                showText <span class="operator">=</span> <span class="string">&quot;授权请求失败, 未知的错误原因&quot;</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                showText <span class="operator">=</span> <span class="string">&quot;其他未知的错误原因&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        showLabel.text <span class="operator">=</span> showText</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<div class="note success"><p>做好了上面配置, 就可以看到下面的登录页面</p></div>



<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/ios/sign_sign.jpeg?x-oss-process=image/resize,m_lfit,h_500" alt="image"></p>
<ul>
<li>如果不修改姓名, 授权成功后将获取到用户的姓名</li>
<li>如果选择共享我的电子邮件, 授权成功将获取到用户的电子邮件地址</li>
<li>如果选择隐藏邮件地址, 授权成功将获取到一个虚拟的电子邮件地址</li>
<li>点击姓名右侧的清除按钮可以修改用户名, 如下页面</li>
</ul>
<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/ios/sign_name.jpeg?x-oss-process=image/resize,m_lfit,h_500" alt="name"></p>
<ul>
<li>如果登录用户修改了用户名, 那么授权成功后获取到的用户名就是修改后的</li>
<li>使用过<code>AppleID</code>登录过<code>App</code>，进入应用的时候会提示使用<code>TouchID</code>登录的场景如下</li>
</ul>
<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/ios/sign_has.jpeg?x-oss-process=image/resize,m_lfit,h_500" alt="image"></p>
<ul>
<li>如果使用指纹登录三次失败后, 下面会有一个使用密码继续的按钮, 可以使用手机密码继续登录</li>
<li>如果手机没有设置<code>Apple ID</code>, 使用苹果登录, 将会有弹窗提示,</li>
</ul>
<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/ios/sign_noid.png" alt="image"></p>
<h2 id="监听授权状态"><a href="#监听授权状态" class="headerlink" title="监听授权状态"></a>监听授权状态</h2><p>在特殊情况下我们还需要监听授权状态的改变, 并进行相应的处理</p>
<ul>
<li>用户终止在该<code>App</code>中使用<code>Sign in with Apple</code>功能</li>
<li>用户在设置里注销了<code>Apple ID</code></li>
<li>针对类似这种情况, <code>App</code>需要获取到这些状态，然后做退出登录操作</li>
<li>我们需要在<code>App</code>启动的时候，来获取当前用户的授权状态</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ASAuthorizationAppleIDProvider提供了一个获取用户授权状态和授权凭据是否有效</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">getCredentialState</span>(<span class="params">forUserID</span>: <span class="type">String</span>, <span class="params">completion</span>: (<span class="type">ASAuthorizationAppleIDProvider</span>.<span class="type">CredentialState</span>, <span class="type">Error</span>?) -&gt; <span class="type">Void</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ASAuthorizationAppleIDProvider.CredentialState的所有枚举值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">CredentialState</span> : <span class="title class_">Int</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> revoked</span><br><span class="line">    <span class="keyword">case</span> authorized</span><br><span class="line">    <span class="keyword">case</span> notFound</span><br><span class="line">    <span class="keyword">case</span> transferred</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<div class="note success"><p>示例代码如下</p></div>



<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">application</span>(<span class="keyword">_</span> <span class="params">application</span>: <span class="type">UIApplication</span>, <span class="params">didFinishLaunchingWithOptions</span> <span class="params">launchOptions</span>: [<span class="type">UIApplication</span>.<span class="params">LaunchOptionsKey</span>: <span class="keyword">Any</span>]<span class="operator">?</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">#available</span>(<span class="keyword">iOS</span> <span class="number">13.0</span>, <span class="operator">*</span>) &#123;</span><br><span class="line">        <span class="comment">// 钥匙串中取出的</span></span><br><span class="line">        <span class="keyword">let</span> userIdentifier <span class="operator">=</span> <span class="string">&quot;userIdentifier&quot;</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="operator">!</span>userIdentifier.isEmpty) &#123;</span><br><span class="line">            <span class="comment">// 基于用户的Apple ID授权用户，生成用户授权请求的一种机制</span></span><br><span class="line">            <span class="keyword">let</span> appleIDProvider <span class="operator">=</span> <span class="type">ASAuthorizationAppleIDProvider</span>()</span><br><span class="line">            <span class="comment">// 返回完成处理程序中给定用户的凭据状态</span></span><br><span class="line">            appleIDProvider.getCredentialState(forUserID: userIdentifier) &#123; (state, error) <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">switch</span> state &#123;</span><br><span class="line">                <span class="keyword">case</span> .authorized:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;授权状态有效&quot;</span>)</span><br><span class="line">                <span class="keyword">case</span> .notFound:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;授权凭证缺失（可能是使用AppleID 登录过App）&quot;</span>)</span><br><span class="line">                <span class="keyword">case</span> .revoked:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;上次使用苹果账号登录的凭据已被移除，需解除绑定并重新引导用户使用苹果登录&quot;</span>)</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;未知状态&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除此之外还可以通过通知方法来监听<code>revoked</code>状态, 在<code>ASAuthorizationAppleIDProvider</code>中增加了一个属性, 用于监听<code>revoked</code>状态</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@available</span>(<span class="keyword">iOS</span> <span class="number">13.0</span>, <span class="operator">*</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">let</span> <span class="title class_">credentialRevokedNotification</span>: <span class="title class_">NSNotification</span>.<span class="title class_">Name</span></span><br><span class="line"></span><br><span class="line">// 使用方法</span><br><span class="line"><span class="title class_">fileprivate</span> <span class="title class_">func</span> <span class="title class_">observeAppleSignInState</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">#available</span>(<span class="keyword">iOS</span> <span class="number">13.0</span>, <span class="operator">*</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> center <span class="operator">=</span> <span class="type">NotificationCenter</span>.default</span><br><span class="line">        center.addObserver(<span class="keyword">self</span>, selector: <span class="keyword">#selector</span>(handleStateChange(noti:)), name: <span class="type">ASAuthorizationAppleIDProvider</span>.credentialRevokedNotification, object: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@objc</span> <span class="keyword">fileprivate</span> <span class="keyword">func</span> <span class="title function_">handleStateChange</span>(<span class="params">noti</span>: <span class="keyword">Any</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;授权状态发生改变&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<hr>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><code>Sign In with Apple</code>涉及到的相关资料文档如下</p>
<ul>
<li><a href="https://developer.apple.com/documentation/authenticationservices">Sign In with Apple Entitlement</a></li>
<li><a href="https://developer.apple.com/documentation/signinwithapplerestapi/generate_and_validate_tokens">Generate and validate tokens</a></li>
<li><a href="https://developer.apple.com/documentation/authenticationservices/adding_the_sign_in_with_apple_flow_to_your_app">Adding the Sign In with Apple Flow to Your App</a></li>
<li><a href="https://docs-assets.developer.apple.com/published/8f9ca51349/AddingTheSignInWithAppleFlowToYourApp.zip">Sign In With Apple官方Demo(Swift版)</a></li>
<li><a href="https://blog.csdn.net/wpf199402076118/article/details/99677412">Sign In with Apple后台配置</a></li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>RxSwift+Moya网络请求之项目实战</title>
    <url>/post/e15a5d56.html</url>
    <content><![CDATA[<ul>
<li>RxSwift相关基本介绍和用法可参考:<ul>
<li><a href="https://www.titanjun.top/2017/09/15/RxSwift%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A301/">RxSwift的使用详解01</a></li>
<li><a href="https://www.titanjun.top/2017/09/21/RxSwift%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A302/">RxSwift的使用详解02</a></li>
</ul>
</li>
</ul>
<span id="more"></span>

<h2 id="下面将将进行实战项目"><a href="#下面将将进行实战项目" class="headerlink" title="下面将将进行实战项目"></a>下面将将进行实战项目</h2><ul>
<li>1.登录注册功能<ul>
<li>输入用户名要大于6个字符，不然密码不能输入</li>
<li>密码必须大于6个字符，不然重复密码不能输入</li>
<li>重复密码输入必须和密码一样，不然注册按钮不能点击</li>
<li>根据输入的字符是否合法,按钮动态的改变颜色</li>
</ul>
</li>
<li>2.UITableView和搜索SertchBar的应用<ul>
<li>searchBar根据输入的字体展示包含该字体的cell列表</li>
<li><a href="https://github.com/ReactiveX/RxSwift">RxSwift</a>实现tableView列表展示</li>
</ul>
</li>
<li>3.<a href="https://github.com/Moya/Moya">Moya</a>+<a href="https://github.com/ReactiveX/RxSwift">RxSwift</a>实现网络请求<ul>
<li>应用<a href="https://github.com/ReactiveX/RxSwift">RxSwift</a>在UICollectionView中的应用</li>
<li>用<a href="https://github.com/Moya/Moya">Moya</a>进行网络请求</li>
<li><a href="https://github.com/Hearst-DD/ObjectMapper">ObjectMapper</a>进行json到model的数据解析</li>
<li>整个<a href="https://github.com/coderQuanjun/RxSwift-Table-Collection">Demo</a>的架构使用<a href="http://www.codertian.com/2015/11/13/MVVM-patterns-introduce/">MVVM</a></li>
</ul>
</li>
<li>4.<a href="https://github.com/coderQuanjun/RxSwift-Table-Collection">Demo地址</a></li>
</ul>
<h3 id="下面简单看一下demo的界面"><a href="#下面简单看一下demo的界面" class="headerlink" title="下面简单看一下demo的界面"></a>下面简单看一下demo的界面</h3><center>登录注册</center>

<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-6a3971f8ea4a7622.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt="登录注册"></p>
<center>UITableView和SearchBar</center>

<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-e2cff86052a6aa5b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt="UITableView和SearchBar"></p>
<center>UICollectionView和Moya</center>

<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-da346221f1ddcba0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt="UICollectionView和Moya"></p>
<h2 id="项目结构和框架"><a href="#项目结构和框架" class="headerlink" title="项目结构和框架"></a>项目结构和框架</h2><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>demo是使用的纯MVVM模式，因为RxSwift就是为MVVM而生。不懂MVVM的猿友可参考<a href="http://www.codertian.com/2015/11/13/MVVM-patterns-introduce/">MVVM模式快速入门</a> </p>
<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-b180e89ddba220eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="项目结构"></p>
<h3 id="项目框架"><a href="#项目框架" class="headerlink" title="项目框架"></a>项目框架</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Swift三方库</span></span><br><span class="line">    <span class="comment">// Rx</span></span><br><span class="line">    pod <span class="string">&#x27;RxSwift&#x27;</span>  <span class="comment">//RxSwift的必备库</span></span><br><span class="line">    pod <span class="string">&#x27;RxCocoa&#x27;</span>  <span class="comment">//对 UIKit Foundation 进行 Rx 化</span></span><br><span class="line">    pod <span class="string">&#x27;RxDataSources&#x27;</span>   <span class="comment">// 帮助我们优雅的使用tableView的数据源方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 网络请求</span></span><br><span class="line">    pod <span class="string">&#x27;Moya/RxSwift&#x27;</span>  <span class="comment">// 为RxSwift专用提供，对Alamofire进行封装的一个网络请求库</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 图片处理</span></span><br><span class="line">    pod <span class="string">&#x27;Kingfisher&#x27;</span>  <span class="comment">//图片处理库</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据解析</span></span><br><span class="line">    pod <span class="string">&#x27;ObjectMapper&#x27;</span>  <span class="comment">//json转模型</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">// OC库</span></span><br><span class="line">    <span class="comment">// MJRefresh</span></span><br><span class="line">    pod <span class="string">&#x27;MJRefresh&#x27;</span>   <span class="comment">//MJ上拉下拉刷新</span></span><br><span class="line">    pod <span class="string">&#x27;SVProgressHUD&#x27;</span>  <span class="comment">//HUD</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="注册界面"><a href="#注册界面" class="headerlink" title="注册界面"></a>注册界面</h2><ul>
<li>这里主要使用了Observable的相关知识,不了解的童鞋可参考<a href="http://www.jianshu.com/p/319db438c4d3">RxSwift的使用详解01</a>,了解Observable的操作</li>
<li>注册和登录并没有保存已注册的账号和密码, 故登录功能并不完善,后期会在完善,望知晓</li>
<li>下面将针对注册用户名做简单介绍:</li>
</ul>
<h3 id="字符串的语法法则"><a href="#字符串的语法法则" class="headerlink" title="字符串的语法法则"></a>字符串的语法法则</h3><p>首先在model里处理输入字符串的语法法则和字符个数是否符合规范</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">extension InputValidator &#123;</span><br><span class="line">    <span class="comment">//判断字符串是否符合语法法则</span></span><br><span class="line">    <span class="keyword">class</span> func isValidEmail(_ email: String) -&gt; Bool &#123;</span><br><span class="line">        let regular = try? <span class="built_in">NSRegularExpression</span>(pattern: <span class="string">&quot;^\\S+@\\S+\\.\\S+$&quot;</span>, options: [])</span><br><span class="line">        <span class="keyword">if</span> let re = regular &#123;</span><br><span class="line">            let range = <span class="built_in">NSRange</span>(location: <span class="number">0</span>, length: email.lengthOfBytes(using: .utf8))</span><br><span class="line">            let result = re.matches(<span class="keyword">in</span>: email, options: [], range: range)</span><br><span class="line">            <span class="keyword">return</span> result.count &gt; <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断密码字符个数&gt;8</span></span><br><span class="line">    <span class="keyword">class</span> func isValidPassword(_ password: String) -&gt; Bool &#123;</span><br><span class="line">        <span class="keyword">return</span> password.characters.count &gt;= <span class="number">8</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断用户名</span></span><br><span class="line">    <span class="keyword">class</span> func validateUserName(_ username: String) -&gt; Result &#123;</span><br><span class="line">        <span class="comment">//判断字符个数是否正确</span></span><br><span class="line">        <span class="keyword">if</span> username.characters.count &lt; <span class="number">6</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.failure(message: <span class="string">&quot;输入的字符个数不能少于6个字符&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//账号可用</span></span><br><span class="line">        <span class="keyword">return</span> Result.success(message: <span class="string">&quot;账号可用&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>其中Result是一个返回是否成功的枚举值,可传入字符串变量</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Result &#123;</span><br><span class="line">    <span class="keyword">case</span> success(message: String)</span><br><span class="line">    <span class="keyword">case</span> failure(message: String)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="判断该用户名"><a href="#判断该用户名" class="headerlink" title="判断该用户名"></a>判断该用户名</h3><p>根据输入的用户名判断该用户名是否可用</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">var usernameObserable: Observable&lt;Result&gt;</span><br><span class="line">var passwordObserable: Observable&lt;Result&gt;</span><br><span class="line">var repeatPassObserable: Observable&lt;Result&gt;</span><br><span class="line">var registerBtnObserable: Observable&lt;Bool&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">init()&#123;</span><br><span class="line">    <span class="comment">//检测账号</span></span><br><span class="line">    usernameObserable = username.asObservable().map(&#123; (username) -&gt; Result <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">return</span> InputValidator.validateUserName(username)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;    </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>该返回参数Result,控制器将根据该Result是否成功来改变输入框是否是可编辑状态</li>
<li>初始化方法中，我们对传入的序列进行处理和转换成相对应的Result序列</li>
</ul>
<h3 id="controller逻辑"><a href="#controller逻辑" class="headerlink" title="controller逻辑"></a>controller逻辑</h3><p>根据用户名输入改变各控件状态</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 账号判断逻辑</span></span><br><span class="line">        <span class="comment">//1-1. 检测账号</span></span><br><span class="line">        usernameTextField.rx.text</span><br><span class="line">            .orEmpty <span class="comment">// 将String? 类型转为String型</span></span><br><span class="line">            .bindTo(registerVM.username)</span><br><span class="line">            .addDisposableTo(bag)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1-2. 根据账号监听提示字体的状态</span></span><br><span class="line">        registerVM.usernameObserable</span><br><span class="line">            .bindTo(usernameHintLabel.rx.validationResult)</span><br><span class="line">            .addDisposableTo(bag)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1-3. 根据账号监听密码输入框的状态</span></span><br><span class="line">        registerVM.usernameObserable</span><br><span class="line">            .bindTo(passwordTextField.rx.enableResult)</span><br><span class="line">            .addDisposableTo(bag)</span><br><span class="line">            </span><br></pre></td></tr></table></figure>

<ul>
<li>检测输入用户名是否符合规范</li>
<li>根据账号监听提示字体的状态</li>
<li>根据账号监听密码输入框的状态</li>
<li>根据账号监听注册按钮的状态</li>
</ul>
<h2 id="UITableView和SearchBar"><a href="#UITableView和SearchBar" class="headerlink" title="UITableView和SearchBar"></a>UITableView和SearchBar</h2><ul>
<li>该UITableView展示界面并未涉及网络请求</li>
<li>数据来源plist文件</li>
<li>图片为本地图片,可下载demo,在demo中查找图片</li>
<li>选用自定义UITableViewCell,故cell不做介绍</li>
<li>model小编这里也不多做介绍,详情可下载demo看具体代码</li>
</ul>
<h3 id="viewModel中逻辑"><a href="#viewModel中逻辑" class="headerlink" title="viewModel中逻辑"></a>viewModel中逻辑</h3><h4 id="获取模型数组"><a href="#获取模型数组" class="headerlink" title="获取模型数组"></a>获取模型数组</h4><p>读取plist文件,获取模型数组</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">fileprivate func getHeroData() -&gt; [HeroModel]&#123;</span><br><span class="line">    <span class="comment">// 1.获取路径</span></span><br><span class="line">    let path = Bundle.main.path(forResource: <span class="string">&quot;heros.plist&quot;</span>, ofType: <span class="literal">nil</span>)!</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 2.读取文件内容</span></span><br><span class="line">    let dictArray = <span class="built_in">NSArray</span>(contentsOfFile: path) as! [[String : Any]]</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 3.遍历所有的字典并且转成模型对象</span></span><br><span class="line">    <span class="keyword">return</span> dictArray.map(&#123; HeroModel(dict: $<span class="number">0</span>) &#125;).reversed()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="seachBar"><a href="#seachBar" class="headerlink" title="seachBar"></a>seachBar</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">lazy var heroVariable: Variable&lt;[HeroModel]&gt; = &#123;</span><br><span class="line">    <span class="keyword">return</span> Variable(<span class="keyword">self</span>.getHeroData())</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">var searchText: Observable&lt;String&gt;</span><br><span class="line">init(searchText: Observable&lt;String&gt;) &#123;</span><br><span class="line">    <span class="keyword">self</span>.searchText = searchText</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.searchText.subscribe(onNext: &#123; (str: String) <span class="keyword">in</span></span><br><span class="line">        let heros = <span class="keyword">self</span>.getHeroData().filter(&#123; (hero: HeroModel) -&gt; Bool <span class="keyword">in</span></span><br><span class="line">            <span class="comment">//过滤</span></span><br><span class="line">            <span class="keyword">if</span> str.isEmpty &#123; <span class="keyword">return</span> <span class="literal">true</span> &#125;</span><br><span class="line">            <span class="comment">//model是否包含搜索字符串</span></span><br><span class="line">            <span class="keyword">return</span> hero.name.contains(str)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">self</span>.heroVariable.value = heros</span><br><span class="line">    &#125;).addDisposableTo(bag)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>其中heroVariable是一个数组模型的包装箱,在controller内调用使用前需要asObservable或者asDriver解包装;详细用法可参考:<a href="http://www.jianshu.com/p/319db438c4d3">RxSwift的使用详解01</a></li>
<li>searchText搜索框输入的关键字,根据该关键字从数组中过滤出所有包含该关键字的model</li>
<li>对heroVariable重新赋值,发出事件</li>
</ul>
<h3 id="RxTableViewController"><a href="#RxTableViewController" class="headerlink" title="RxTableViewController"></a>RxTableViewController</h3><h4 id="searchBar搜索框"><a href="#searchBar搜索框" class="headerlink" title="searchBar搜索框"></a>searchBar搜索框</h4><p>searchBar搜索框,输入字符后间隔0.5秒开始搜索</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">var searchText: Observable&lt;String&gt; &#123;</span><br><span class="line">    <span class="comment">//输入后间隔0.5秒搜索,在主线程运行</span></span><br><span class="line">    <span class="keyword">return</span> searchBar.rx.text.orEmpty.throttle(<span class="number">0.5</span>, scheduler: MainScheduler.instance)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="UITableView的设置"><a href="#UITableView的设置" class="headerlink" title="UITableView的设置"></a>UITableView的设置</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2.给tableView绑定数据</span></span><br><span class="line"><span class="comment">//注意: 三个参数:row, model, cell三个顺序不可以搞错, 不需要的可省略 </span></span><br><span class="line">heroVM.heroVariable.asDriver().drive(rxTableView.rx.items(cellIdentifier: kCellID, cellType: RxTableViewCell.self)) &#123; (_, hero, cell) <span class="keyword">in</span></span><br><span class="line">    cell.heroModel = hero</span><br><span class="line">&#125;.addDisposableTo(bag)</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 3.监听UITableView的点击</span></span><br><span class="line">rxTableView.rx.modelSelected(HeroModel.self).subscribe &#123; (event: Event&lt;HeroModel&gt;) <span class="keyword">in</span></span><br><span class="line">    print(event.element?.name ?? <span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;.addDisposableTo(bag)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>将viewModel中的heroVariable进行解包装，如果是Driver序列，我们这里不使用bingTo，而是使用的Driver，用法和bingTo一模一样。</li>
<li>Deriver的监听一定发生在主线程，所以很适合我们更新UI的操作</li>
<li>如需设置delegate的代理</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">rxTableView.rx.setDelegate(<span class="keyword">self</span>).addDisposableTo(bag)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>然后在实现相应的代理方法即可,如: </p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">extension RxTableViewController: <span class="built_in">UITableViewDelegate</span>&#123;</span><br><span class="line">    func tableView(_ tableView: <span class="built_in">UITableView</span>, heightForRowAt indexPath: IndexPath) -&gt; <span class="built_in">CGFloat</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="网络请求和数据处理"><a href="#网络请求和数据处理" class="headerlink" title="网络请求和数据处理"></a>网络请求和数据处理</h2><ul>
<li>文件目录: <code>UICollectionView+Moya+ObjectMapper</code></li>
<li>与上述<code>UITableView</code>不同的是,这部分将以<a href="https://github.com/RxSwiftCommunity/RxDataSources">RxDataSources</a>处理数据源</li>
<li>model数组以sections组集合处理</li>
<li>结合<a href="https://github.com/Moya/Moya">Moya</a>进行网络请求</li>
<li>使用<a href="https://github.com/Hearst-DD/ObjectMapper">ObjectMapper</a>进行json数据转模型</li>
</ul>
<h3 id="配合ObjectMapper"><a href="#配合ObjectMapper" class="headerlink" title="配合ObjectMapper"></a>配合ObjectMapper</h3><p><strong>这里再介绍一下ObjectMapper</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> AnchorModel: Mappable &#123;</span><br><span class="line"></span><br><span class="line">    var name = <span class="string">&quot;&quot;</span>    <span class="comment">//名字</span></span><br><span class="line">    var pic51 = <span class="string">&quot;&quot;</span>   <span class="comment">//头像</span></span><br><span class="line">    var pic74 = <span class="string">&quot;&quot;</span>   <span class="comment">//大图</span></span><br><span class="line">    var live = <span class="number">0</span></span><br><span class="line">    var push = <span class="number">0</span></span><br><span class="line">    var focus = <span class="number">0</span>    <span class="comment">//关注量</span></span><br><span class="line">    </span><br><span class="line">    required init?(map: Map) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func mapping(map: Map) &#123;</span><br><span class="line">        name  &lt;- map[<span class="string">&quot;name&quot;</span>]</span><br><span class="line">        pic51 &lt;- map[<span class="string">&quot;pic51&quot;</span>]</span><br><span class="line">        pic74 &lt;- map[<span class="string">&quot;pic74&quot;</span>]</span><br><span class="line">        live  &lt;- map[<span class="string">&quot;live&quot;</span>]</span><br><span class="line">        push  &lt;- map[<span class="string">&quot;push&quot;</span>]</span><br><span class="line">        focus &lt;- map[<span class="string">&quot;focus&quot;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>使用 ObjectMapper ，需要让自己的 Model 类使用 Mappable 协议，这个协议包括两个方法：</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">required init?(map: Map) &#123;&#125;</span><br><span class="line"> </span><br><span class="line">func mapping(map: Map) &#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在 mapping 方法中，用 <code>&lt;-</code> 操作符来处理和映射你的 JSON数据</li>
<li>详细的 ObjectMapper 教程可以查看它的 <a href="https://github.com/Hearst-DD/ObjectMapper">Github 主页</a>，我在这里只做简单的介绍。</li>
</ul>
<h3 id="Moya的使用"><a href="#Moya的使用" class="headerlink" title="Moya的使用"></a>Moya的使用</h3><ul>
<li><a href="https://github.com/Moya/Moya">Moya</a>是基于<a href="https://github.com/Alamofire/Alamofire">Alamofire</a>的网络请求库，这里我使用了Moya&#x2F;Swift，它在Moya的基础上添加了对RxSwift的接口支持。</li>
<li>Github上的官方介绍罗列了Moya的一些特点：<ul>
<li>编译时检查正确的API端点访问.   </li>
<li>使你定义不同端点枚举值对应相应的用途更加明晰. </li>
<li>提高测试地位从而使单元测试更加容易.</li>
</ul>
</li>
<li>接下来我们来说下Moya的使用</li>
</ul>
<h4 id="创建一个枚举API"><a href="#创建一个枚举API" class="headerlink" title="创建一个枚举API"></a>创建一个枚举API</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//请求枚举类型</span></span><br><span class="line"><span class="keyword">enum</span> JunNetworkTool &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">case</span> getNewList</span><br><span class="line">    <span class="keyword">case</span> getHomeList(page: Int)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="为枚举添加扩展"><a href="#为枚举添加扩展" class="headerlink" title="为枚举添加扩展"></a>为枚举添加扩展</h4><ul>
<li>需遵循协议 TargetType</li>
<li>这个协议的Moya这个库规定的协议，可以单击进入相应的文件进行查看</li>
<li>这个协议内的每一个参数(除了<code>validate</code>可不重写)都必须重写,否则会报错</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//请求参数</span></span><br><span class="line">extension JunNetworkTool: TargetType &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//统一基本的url</span></span><br><span class="line">    var baseURL: URL &#123;</span><br><span class="line">        <span class="keyword">return</span> (URL(string: <span class="string">&quot;http://qf.56.com/home/v4/moreAnchor.ios&quot;</span>))!</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//path字段会追加至baseURL后面</span></span><br><span class="line">    var path: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//请求的方式</span></span><br><span class="line">    var method: Moya.Method &#123;</span><br><span class="line">        <span class="keyword">return</span> .get</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//参数编码方式(这里使用URL的默认方式)</span></span><br><span class="line">    var parameterEncoding: ParameterEncoding &#123;</span><br><span class="line">        <span class="keyword">return</span> URLEncoding.default</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//用于单元测试</span></span><br><span class="line">    var sampleData: Data &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;getList&quot;</span>.data(using: .utf8)!</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将要被执行的任务(请求：request 下载：upload 上传：download)</span></span><br><span class="line">    var task: Task &#123;</span><br><span class="line">        <span class="keyword">return</span> .request</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//请求参数(会在请求时进行编码)</span></span><br><span class="line">    var parameters: [String: Any]? &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .getHomeList(let index):</span><br><span class="line">            <span class="keyword">return</span> [<span class="string">&quot;index&quot;</span>: index]</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="string">&quot;index&quot;</span>: <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//是否执行Alamofire验证，默认值为false</span></span><br><span class="line">    var validate: Bool &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><p>定义一个全局变量用于整个项目的网络请求</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">let junNetworkTool = RxMoyaProvider&lt;JunNetworkTool&gt;()</span><br></pre></td></tr></table></figure>

<p>至此，我们就可以使用这个全局变量来请求数据了</p>
<h3 id="RxDataSources"><a href="#RxDataSources" class="headerlink" title="RxDataSources"></a><a href="https://github.com/RxSwiftCommunity/RxDataSources">RxDataSources</a></h3><ul>
<li>RxDataSources是以section来做为数据结构来传输，这点很重要，比如:在传统的数据源实现的方法中有一个numberOfSection，我们在很多情况下只需要一个section，所以这个方法可实现，也可以不实现，默认返回的就是1，这给我们带来的一个迷惑点：【tableView是由row来组成的】，不知道在坐的各位中有没有是这么想的呢？？有的话那从今天开始就要认清楚这一点，【tableView其实是由section组成的】，所以在使用RxDataSources的过程中，即使你的setion只有一个，那你也得返回一个section的数组出去！！！</li>
<li>传统方式适用于简单的数据集，但不处理需要将复杂数据集与多个部分进行绑定的情况，或者在添加&#x2F;修改&#x2F;删除项目时需要执行动画时。而使用RxDataSources时，它很容易写</li>
<li>想了解更多关于<a href="https://github.com/RxSwiftCommunity/RxDataSources">RxDataSources</a>的用法,请参考其GitHub主页</li>
</ul>
<h4 id="Sections自定义"><a href="#Sections自定义" class="headerlink" title="Sections自定义"></a>Sections自定义</h4><ul>
<li>在我们自定义的Model中创建一个AnchorSection的结构体</li>
<li>并遵循SectionModelType协议，实现相应的协议方法</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//MARK: SectionModel</span></span><br><span class="line"><span class="keyword">struct</span> AnchorSection &#123;</span><br><span class="line">    <span class="comment">// items就是rows</span></span><br><span class="line">    var items: [Item]</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 你也可以这里加你需要的东西，比如 headerView 的 title</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension AnchorSection: SectionModelType &#123;</span><br><span class="line">    <span class="comment">// 重定义 Item 的类型为</span></span><br><span class="line">    typealias Item = AnchorModel</span><br><span class="line">    init(original: AnchorSection, items: [AnchorSection.Item]) &#123;</span><br><span class="line">        <span class="keyword">self</span> = original</span><br><span class="line">        <span class="keyword">self</span>.items = items</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ViewModel"><a href="#ViewModel" class="headerlink" title="ViewModel"></a>ViewModel</h3><h4 id="自定义协议BaseViewModel"><a href="#自定义协议BaseViewModel" class="headerlink" title="自定义协议BaseViewModel"></a>自定义协议BaseViewModel</h4><p>我们知道MVVM思想就是将原本在ViewController的视图显示逻辑、验证逻辑、网络请求等代码存放于ViewModel中，让我们的ViewController瘦身。这些逻辑由ViewModel负责，外界不需要关心，外界只需要结果，ViewModel也只需要将结果给到外界，基于此，我们定义了一个协议</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">protocol JunViewModelType &#123;</span><br><span class="line">    <span class="comment">//associatedtype: 关联类型为协议中的某个类型提供了一个占位名（或者说别名），其代表的实际类型在协议被采纳时才会被指定</span></span><br><span class="line">    associatedtype Input</span><br><span class="line">    associatedtype Output</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//我们通过 transform 方法将input携带的数据进行处理，生成了一个Output</span></span><br><span class="line">    func transform(input: Input) -&gt; Output</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="自定义刷新"><a href="#自定义刷新" class="headerlink" title="自定义刷新"></a>自定义刷新</h4><ul>
<li>自定义用于网络请求的刷新状态</li>
<li>根据枚举值的判断,改变collection的刷新状态</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//刷新的状态</span></span><br><span class="line"><span class="keyword">enum</span> JunRefreshStatus &#123;</span><br><span class="line">    <span class="keyword">case</span> none</span><br><span class="line">    <span class="keyword">case</span> beingHeaderRefresh</span><br><span class="line">    <span class="keyword">case</span> endHeaderRefresh</span><br><span class="line">    <span class="keyword">case</span> beingFooterRefresh</span><br><span class="line">    <span class="keyword">case</span> endFooterRefresh</span><br><span class="line">    <span class="keyword">case</span> noMoreData</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="自定义用于继承的BaseViewModel"><a href="#自定义用于继承的BaseViewModel" class="headerlink" title="自定义用于继承的BaseViewModel"></a>自定义用于继承的BaseViewModel</h4><ul>
<li>定义请求数据的页数index</li>
<li>定义input和output的结构体</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> BaseViewModel: <span class="built_in">NSObject</span> &#123;</span><br><span class="line">    <span class="comment">// 记录当前的索引值</span></span><br><span class="line">    var index: Int = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">struct</span> JunInput &#123;</span><br><span class="line">        <span class="comment">// 网络请求类型</span></span><br><span class="line">        let category: JunNetworkTool</span><br><span class="line">        </span><br><span class="line">        init(category: JunNetworkTool) &#123;</span><br><span class="line">            <span class="keyword">self</span>.category = category</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">struct</span> JunOutput &#123;</span><br><span class="line">        <span class="comment">// tableView的sections数据</span></span><br><span class="line">        let sections: Driver&lt;[AnchorSection]&gt;</span><br><span class="line">        <span class="comment">// 外界通过该属性告诉viewModel加载数据（传入的值是为了标志是否重新加载）</span></span><br><span class="line">        let requestCommond = PublishSubject&lt;Bool&gt;()</span><br><span class="line">        <span class="comment">// 告诉外界的tableView当前的刷新状态</span></span><br><span class="line">        let refreshStatus = Variable&lt;JunRefreshStatus&gt;(.none)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//初始化时,section的数据</span></span><br><span class="line">        init(sections: Driver&lt;[AnchorSection]&gt;) &#123;</span><br><span class="line">            <span class="keyword">self</span>.sections = sections</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="自定义AnchorViewModel"><a href="#自定义AnchorViewModel" class="headerlink" title="自定义AnchorViewModel"></a>自定义AnchorViewModel</h4><ul>
<li><ol>
<li>继承BaseViewModel</li>
</ol>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> AnchorViewModel : BaseViewModel&#123;</span><br><span class="line">    <span class="comment">// 存放着解析完成的模型数组</span></span><br><span class="line">    let anchorArr = Variable&lt;[AnchorModel]&gt;([])</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><ol start="2">
<li>遵循JunViewModelType协议</li>
</ol>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">extension AnchorViewModel: JunViewModelType &#123;</span><br><span class="line">    typealias Input = JunInput</span><br><span class="line">    typealias Output = JunOutput</span><br><span class="line"></span><br><span class="line">    func transform(input: AnchorViewModel.JunInput) -&gt; AnchorViewModel.JunOutput &#123;</span><br><span class="line">        let sectionArr = anchorArr.asDriver().map &#123; (models) -&gt; [AnchorSection] <span class="keyword">in</span></span><br><span class="line">            <span class="comment">// 当models的值被改变时会调用</span></span><br><span class="line">            <span class="keyword">return</span> [AnchorSection(items: models)]</span><br><span class="line">        &#125;.asDriver(onErrorJustReturn: [])</span><br><span class="line">        </span><br><span class="line">        let output = JunOutput(sections: sectionArr)</span><br><span class="line">        </span><br><span class="line">        output.requestCommond.subscribe(onNext: &#123; (isReloadData) <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">self</span>.index = isReloadData ? <span class="number">1</span> : <span class="keyword">self</span>.index + <span class="number">1</span></span><br><span class="line">            <span class="comment">//开始请求数据</span></span><br><span class="line">            junNetworkTool.request(JunNetworkTool.getHomeList(page: <span class="keyword">self</span>.index))</span><br><span class="line">                .mapObjectArray(AnchorModel.self)</span><br><span class="line">                .subscribe(&#123; (event) <span class="keyword">in</span></span><br><span class="line">                    <span class="keyword">switch</span> event &#123;</span><br><span class="line">                    <span class="keyword">case</span> let .next(modelArr):</span><br><span class="line">                        <span class="keyword">self</span>.anchorArr.value = isReloadData ? modelArr : (<span class="keyword">self</span>.anchorArr.value) + modelArr</span><br><span class="line">                        SVProgressHUD.showSuccess(withStatus: <span class="string">&quot;加载成功&quot;</span>)</span><br><span class="line">                    <span class="keyword">case</span> let .error(error):</span><br><span class="line">                        SVProgressHUD.showError(withStatus: error.localizedDescription)</span><br><span class="line">                    <span class="keyword">case</span> .completed:</span><br><span class="line">                        output.refreshStatus.value = isReloadData ? .endHeaderRefresh : .endFooterRefresh</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;).addDisposableTo(bag)</span><br><span class="line">        &#125;).addDisposableTo(bag)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>sectionArr是将model数组按照section分别存储</li>
<li>当请求回来的anchorArr数据改变的时候, sectionArr随之会发生改变</li>
<li>isReloadData用于区分是下拉刷新(true时), 还是上拉加载更多(false时)</li>
</ul>
<h3 id="RxCollectionViewController控制器中"><a href="#RxCollectionViewController控制器中" class="headerlink" title="RxCollectionViewController控制器中"></a>RxCollectionViewController控制器中</h3><ul>
<li>创建数据源RxDataSources</li>
<li>绑定cell</li>
<li>初始化input和output请求</li>
<li>绑定section数据</li>
<li>设置刷新</li>
</ul>
<h4 id="创建数据源RxDataSources"><a href="#创建数据源RxDataSources" class="headerlink" title="创建数据源RxDataSources"></a>创建数据源RxDataSources</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个数据源属性，类型为自定义的Section类型</span></span><br><span class="line">let dataSource = RxCollectionViewSectionedReloadDataSource&lt;AnchorSection&gt;()</span><br></pre></td></tr></table></figure>

<h4 id="绑定cell-自定义的cell要提前注册"><a href="#绑定cell-自定义的cell要提前注册" class="headerlink" title="绑定cell(自定义的cell要提前注册)"></a>绑定cell(自定义的cell要提前注册)</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">dataSource.configureCell = &#123; dataSource, collectionView, indexPath, item <span class="keyword">in</span></span><br><span class="line">    let cell = collectionView.dequeueReusableCell(withReuseIdentifier: kCollecCellID, <span class="keyword">for</span>: indexPath) as! RxCollectionViewCell</span><br><span class="line">    cell.anchorModel = item</span><br><span class="line">    <span class="keyword">return</span> cell</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>以上四个参数的顺序分别为:dataSource, collectionView(或者tableView), indexPath, model, 其对应类型不言而喻,不多做介绍</li>
</ul>
<h4 id="初始化input和output请求"><a href="#初始化input和output请求" class="headerlink" title="初始化input和output请求"></a>初始化input和output请求</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">let vmInput = AnchorViewModel.JunInput(category: .getNewList)</span><br><span class="line">let vmOutput = anchorVM.transform(input: vmInput)</span><br></pre></td></tr></table></figure>

<h4 id="绑定section数据"><a href="#绑定section数据" class="headerlink" title="绑定section数据"></a>绑定section数据</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//4-1. 通过dataSource和section的model数组绑定数据(demo的用法, 推荐)</span></span><br><span class="line">vmOutput.sections</span><br><span class="line">    .asDriver()</span><br><span class="line">    .drive(collectionVIew.rx.items(dataSource: dataSource))</span><br><span class="line">    .addDisposableTo(bag)</span><br></pre></td></tr></table></figure>

<h4 id="设置刷新"><a href="#设置刷新" class="headerlink" title="设置刷新"></a>设置刷新</h4><h4 id="在controller中初始化刷新状态"><a href="#在controller中初始化刷新状态" class="headerlink" title="在controller中初始化刷新状态"></a>在controller中初始化刷新状态</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">collectionVIew.mj_header = MJRefreshNormalHeader(refreshingBlock: &#123;</span><br><span class="line">    vmOutput.requestCommond.onNext(<span class="literal">true</span>)</span><br><span class="line">&#125;)</span><br><span class="line">collectionVIew.mj_header.beginRefreshing()</span><br><span class="line">        </span><br><span class="line">collectionVIew.mj_footer = MJRefreshAutoNormalFooter(refreshingBlock: &#123;</span><br><span class="line">    vmOutput.requestCommond.onNext(<span class="literal">false</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="添加刷新的序列"><a href="#添加刷新的序列" class="headerlink" title="添加刷新的序列"></a>添加刷新的序列</h4><ul>
<li>在JunOutput的结构体中添加刷新序列</li>
<li>我们在进行网络请求并得到结果之后，修改refreshStatus的value为相应的JunRefreshStatus项</li>
<li>MJRefre遍会根据该状态做出相应的刷新事件</li>
<li>默认状态为none</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 告诉外界的tableView当前的刷新状态</span></span><br><span class="line">let refreshStatus = Variable&lt;JunRefreshStatus&gt;(.none)</span><br></pre></td></tr></table></figure>

<h4 id="外界订阅output的refreshStatus"><a href="#外界订阅output的refreshStatus" class="headerlink" title="外界订阅output的refreshStatus"></a>外界订阅output的refreshStatus</h4><ul>
<li>外界订阅output的refreshStatus，并且根据接收到的值进行相应的操作</li>
<li>refreshStatus每次改变都会触发刷新事件</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//5. 设置刷新状态</span></span><br><span class="line">vmOutput.refreshStatus.asObservable().subscribe(onNext: &#123; (status) <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">switch</span> status &#123;</span><br><span class="line">    <span class="keyword">case</span> .beingHeaderRefresh:</span><br><span class="line">        <span class="keyword">self</span>.collectionVIew.mj_header.beginRefreshing()</span><br><span class="line">    <span class="keyword">case</span> .endHeaderRefresh:</span><br><span class="line">        <span class="keyword">self</span>.collectionVIew.mj_header.endRefreshing()</span><br><span class="line">    <span class="keyword">case</span> .beingFooterRefresh:</span><br><span class="line">        <span class="keyword">self</span>.collectionVIew.mj_footer.beginRefreshing()</span><br><span class="line">    <span class="keyword">case</span> .endFooterRefresh:</span><br><span class="line">        <span class="keyword">self</span>.collectionVIew.mj_footer.endRefreshing()</span><br><span class="line">    <span class="keyword">case</span> .noMoreData:                   </span><br><span class="line">        <span class="keyword">self</span>.collectionVIew.mj_footer.endRefreshingWithNoMoreData()</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).addDisposableTo(bag)</span><br></pre></td></tr></table></figure>

<h4 id="output提供一个requestCommond用于控制是否请求数据"><a href="#output提供一个requestCommond用于控制是否请求数据" class="headerlink" title="output提供一个requestCommond用于控制是否请求数据"></a>output提供一个requestCommond用于控制是否请求数据</h4><ul>
<li>PublishSubject 的特点：即可以作为Observable，也可以作为Observer，说白了就是可以发送信号，也可以订阅信号</li>
<li>当你订阅PublishSubject的时候，你只能接收到订阅他之后发生的事件。subject.onNext()发出onNext事件，对应的还有onError()和onCompleted()事件</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 外界通过该属性告诉viewModel加载数据（传入的值是为了标志是否重新加载）</span></span><br><span class="line">let requestCommond = PublishSubject&lt;Bool&gt;()</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>为了研究RxSwift相关知识, 工作之余的时间,差不多一个月了</li>
<li>学习的瓶颈大部分在于网络请求和配合刷新这一模块</li>
<li>文中如出现self循环引用的问题,还望大神多多指正</li>
<li>小编目前也还在初学阶段,文中如出现小错误还望多多指正,如有更好的方法,也希望不吝分享</li>
<li>如果喜欢,可以收藏,也可以在Github上star一下</li>
</ul>
<h3 id="最后再一次附上Demo地址"><a href="#最后再一次附上Demo地址" class="headerlink" title="最后再一次附上Demo地址"></a>最后再一次附上<a href="https://github.com/coderQuanjun/RxSwift-Table-Collection">Demo地址</a></h3><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献:"></a>参考文献:</h3><ul>
<li><a href="https://github.com/Moya/Moya">Moya</a></li>
<li><a href="https://github.com/Hearst-DD/ObjectMapper">ObjectMapper</a></li>
<li><a href="https://github.com/RxSwiftCommunity/RxDataSources">RxDataSources</a></li>
<li><a href="https://github.com/onevcat/Kingfisher">Kingfisher</a></li>
<li><a href="http://www.jianshu.com/p/319db438c4d3">RxSwift的使用详解01</a></li>
<li><a href="http://www.jianshu.com/p/bcd0dc328308">RxSwift的使用详解02</a></li>
<li><a href="https://www.2cto.com/kf/201703/611678.html">moya + RxSwift 进行网络请求</a></li>
<li><a href="http://www.jianshu.com/p/9d536d3a1740">扒一扒swift中的unowned和weak下</a></li>
<li><a href="http://mp.weixin.qq.com/s/B-AdatKDkjknKCYorqSfEw">iOS - RxSwift -项目实战记录</a></li>
</ul>
]]></content>
      <categories>
        <category>iOS组件库</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>RxSwift</tag>
      </tags>
  </entry>
  <entry>
    <title>Socket搭建即时通讯服务器</title>
    <url>/post/3cb11047.html</url>
    <content><![CDATA[<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/ios/WebSocket1.png?x-oss-process=style/titanjun" alt="webSecket"></p>
<span id="more"></span>

<h2 id="即时通讯"><a href="#即时通讯" class="headerlink" title="即时通讯"></a>即时通讯</h2><ul>
<li>相关代码<a href="https://github.com/CoderTitan/WebSocketDemo">Demo地址</a></li>
<li>即时通讯<code>（Instant messaging，简称IM）</code>是一个终端服务，允许两人或多人使用网路即时的传递文字讯息、档案、语音与视频交流</li>
<li>即时通讯按使用用途分为企业即时通讯和网站即时通讯</li>
<li>根据装载的对象又可分为手机即时通讯和PC即时通讯，手机即时通讯代表是短信，网站、视频即时通讯</li>
</ul>
<h3 id="IM通信原理"><a href="#IM通信原理" class="headerlink" title="IM通信原理"></a>IM通信原理</h3><ul>
<li>客户端A与客户端B如何产生通信？客户端A不能直接和客户端B，因为两者相距太远。</li>
<li>这时就需要通过IM服务器，让两者产生通信.</li>
<li>客户端A通过<code>socket</code>与IM服务器产生连接,客户端B也通过<code>socket</code>与IM服务器产生连接</li>
<li>A先把信息发送给IM应用服务器，并且指定发送给B，服务器根据A信息中描述的接收者将它转发给B，同样B到A也是这样。</li>
<li>通讯问题: 服务器是不能主动连接客户端的，只能客户端主动连接服务器</li>
</ul>
<h3 id="即时通讯连接原理"><a href="#即时通讯连接原理" class="headerlink" title="即时通讯连接原理"></a>即时通讯连接原理</h3><ul>
<li>即时通讯都是长连接，基本上都是<a href="https://blog.csdn.net/linsongbin1/article/details/54980801/">HTTP1.1</a>协议，设置<code>Connection</code>为<code>keep-alive</code>即可实现长连接，而<code>HTTP1.1</code>默认是长连接，也就是默认<code>Connection</code>的值就是<code>keep-alive</code></li>
<li>HTTP分为长连接和短连接，其实本质上是TCP连接，HTTP协议是应用层的协议，而TCP才是真正的传输层协议, IP是网络层协议，只有负责传输的这一层才需要建立连接</li>
<li>例如: 急送一个快递，HTTP协议指的那个快递单，你寄件的时候填的单子就像是发了一个HTTP请求。而TCP协议就是中间运货的运输工具，它是负责运输的，而运输工具所行驶的路就是所谓的TCP连接</li>
<li>HTTP短连接（非持久连接）是指，客户端和服务端进行一次HTTP请求&#x2F;响应之后，就关闭连接。所以，下一次的HTTP请求&#x2F;响应操作就需要重新建立连接。</li>
<li>HTTP长连接（持久连接）是指，客户端和服务端建立一次连接之后，可以在这条连接上进行多次请求&#x2F;响应操作。持久连接可以设置过期时间，也可以不设置</li>
</ul>
<h3 id="即时通讯数据传递方式"><a href="#即时通讯数据传递方式" class="headerlink" title="即时通讯数据传递方式"></a>即时通讯数据传递方式</h3><p>目前实现即时通讯的有四种方式（短轮询、长轮询、SSE、<code>Websocket</code>）</p>
<h4 id="短轮询"><a href="#短轮询" class="headerlink" title="短轮询:"></a>短轮询:</h4><ul>
<li>每隔一小段时间就发送一个请求到服务器，服务器返回最新数据，然后客户端根据获得的数据来更新界面，这样就间接实现了即时通信</li>
<li>优点是简单，缺点是对服务器压力较大，浪费带宽流量（通常情况下数据都是没有发生改变的）。</li>
<li>主要是客户端人员写代码，服务器人员比较简单，适于小型应用</li>
</ul>
<h4 id="长轮询"><a href="#长轮询" class="headerlink" title="长轮询:"></a>长轮询:</h4><ul>
<li>客户端发送一个请求到服务器，服务器查看客户端请求的数据(服务器中数据)是否发生了变化（是否有最新数据），如果发生变化则立即响应返回，否则保持这个连接并定期检查最新数据，直到发生了数据更新或连接超时</li>
<li>同时客户端连接一旦断开，则再次发出请求，这样在相同时间内大大减少了客户端请求服务器的次数.</li>
<li>弊端:服务器长时间连接会消耗资源，返回数据顺序无保证，难于管理维护</li>
<li>底层实现:在服务器的程序中加入一个死循环，在循环中监测数据的变动。当发现新数据时，立即将其输出给浏览器并断开连接，浏览器在收到数据后，再次发起请求以进入下一个周期</li>
</ul>
<h4 id="SSE"><a href="#SSE" class="headerlink" title="SSE"></a>SSE</h4><ul>
<li>（<code>Server-sent Events</code>服务器推送事件）:为了解决浏览器只能够单向传输数据到服务端，HTML5提供了一种新的技术叫做服务器推送事件SSE</li>
<li>SSE技术提供的是从服务器单向推送数据给浏览器的功能，加上配合浏览器主动HTTP请求，两者结合起来,实际上就实现了客户端和服务器的双向通信.</li>
</ul>
<h4 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h4><ul>
<li>以上提到的这些解决方案中，都是利用浏览器单向请求服务器或者服务器单向推送数据到浏览器</li>
<li>而在HTML5中，为了加强web的功能，提供了<code>websocket</code>技术，它不仅是一种web通信方式，也是一种应用层协议</li>
<li>它提供了浏览器和服务器之间原生的全双工跨域通信，通过浏览器和服务器之间建立<code>websocket</code>连接,在同一时刻能够实现客户端到服务器和服务器到客户端的数据发送</li>
</ul>
<h2 id="WebSocket-1"><a href="#WebSocket-1" class="headerlink" title="WebSocket"></a>WebSocket</h2><ul>
<li><a href="http://websocket.org/">WebSocket</a> 是一种网络通信协议。<a href="https://note.youdao.com/">RFC6455</a> 定义了它的通信标准</li>
<li><code>WebSocket</code>是一种双向通信协议，在建立连接后，<code>WebSocket</code> 服务器和客户端都能主动的向对方发送或接收数据</li>
<li><code>WebSocket</code>是基于<code>HTTP</code>协议的，或者说借用了<code>HTTP</code>协议来完成一部分握手(连接)，在握手(连接)阶段与<code>HTTP</code>是相同的,只不过<code>HTTP</code>不能服务器给客户端推送，而<code>WebSocket</code>可以</li>
</ul>
<h3 id="WebSocket如何工作"><a href="#WebSocket如何工作" class="headerlink" title="WebSocket如何工作"></a>WebSocket如何工作</h3><ul>
<li>Web浏览器和服务器都必须实现<code>WebSockets</code>协议来建立和维护连接。</li>
<li>由于<code>WebSockets</code>连接长期存在，与典型的<code>HTTP</code>连接不同，对服务器有重要的影响</li>
<li>基于多线程或多进程的服务器无法适用于 <code>WebSockets</code>，因为它旨在打开连接，尽可能快地处理请求，然后关闭连接</li>
<li>任何实际的<code>WebSockets</code>服务器端实现都需要一个异步服务器</li>
</ul>
<p><img data-src="http://pcat1usdp.bkt.clouddn.com/webServer.jpg" alt="webServer"></p>
<h4 id="Websocket协议"><a href="#Websocket协议" class="headerlink" title="Websocket协议"></a><code>Websocket</code>协议</h4><p>协议头: ws, 服务器根据协议头判断是<code>Http</code>还是<code>websocket</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 请求头</span></span><br><span class="line">     <span class="variable constant_">GET</span> <span class="attr">ws</span>:<span class="comment">//localhost:12345/websocket/test.html HTTP/1.1</span></span><br><span class="line">     <span class="title class_">Origin</span>: <span class="attr">http</span>:<span class="comment">//localhost</span></span><br><span class="line">     <span class="title class_">Connection</span>: <span class="title class_">Upgrade</span></span><br><span class="line">     <span class="title class_">Host</span>: <span class="attr">localhost</span>:<span class="number">12345</span></span><br><span class="line">     <span class="title class_">Sec</span>-<span class="title class_">WebSocket</span>-<span class="title class_">Key</span>: <span class="title class_">JspZdPxs9MrWCt3</span>j6h7KdQ==  </span><br><span class="line">     <span class="title class_">Upgrade</span>: websocket </span><br><span class="line">     <span class="title class_">Sec</span>-<span class="title class_">WebSocket</span>-<span class="title class_">Version</span>: <span class="number">13</span></span><br><span class="line">    <span class="comment">// Sec-WebSocket-Key: 叫“梦幻字符串”是个密钥，只有有这个密钥 服务器才能通过解码认出来，这是个WB的请求，要建立TCP连接了！！！如果这个字符串没有按照加密规则加密，那服务端就认不出来，就会认为这整个协议就是个HTTP请求。更不会开TCP。其他的字段都可以随便设置，但是这个字段是最重要的字段，标识WB协议的一个字段</span></span><br><span class="line">     </span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应头</span></span><br><span class="line">     <span class="variable constant_">HTTP</span>/<span class="number">1.1</span> <span class="number">101</span> <span class="title class_">Web</span> <span class="title class_">Socket</span> <span class="title class_">Protocol</span> <span class="title class_">Handshake</span></span><br><span class="line">     <span class="title class_">WebSocket</span>-<span class="title class_">Location</span>: <span class="attr">ws</span>:<span class="comment">//localhost:12345/websocket/test.php</span></span><br><span class="line">     <span class="title class_">Connection</span>: <span class="title class_">Upgrade</span></span><br><span class="line">     <span class="title class_">Upgrade</span>: websocket</span><br><span class="line">     <span class="title class_">Sec</span>-<span class="title class_">WebSocket</span>-<span class="title class_">Accept</span>: zUyzbJdkVJjhhu8KiAUCDmHtY/o= </span><br><span class="line">     <span class="title class_">WebSocket</span>-<span class="title class_">Origin</span>: <span class="attr">http</span>:<span class="comment">//localhost</span></span><br><span class="line">     </span><br><span class="line">    <span class="comment">// Sec-WebSocket-Accept: 叫“梦幻字符串”，和上面那个梦幻字符串作用一样。不同的是，这个字符串是要让客户端辨认的，客户端拿到后自动解码。并且辨认是不是一个WB请求。然后进行相应的操作。这个字段也是重中之重，不可随便修改的。加密规则，依然是有规则的</span></span><br></pre></td></tr></table></figure>


<h3 id="WebSocket客户端"><a href="#WebSocket客户端" class="headerlink" title="WebSocket客户端"></a>WebSocket客户端</h3><p>在客户端，没有必要为<code>WebSockets</code>使用<code>JavaScript</code>库。实现<code>WebSockets</code>的<code>Web</code> 浏览器将通过<code>WebSockets</code>对象公开所有必需的客户端功能（主要指支持<code>HTML5</code>的浏览器）</p>
<h4 id="客户端-API"><a href="#客户端-API" class="headerlink" title="客户端 API"></a>客户端 API</h4><p>以下 API 用于创建<code>WebSocket</code>对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Socket</span> = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(url, [protocol] );</span><br></pre></td></tr></table></figure>

<ul>
<li>以上代码中的第一个参数<code>url</code>, 指定连接的<code>URL</code></li>
<li>第二个参数<code>protocol</code>是可选的，指定了可接受的子协议</li>
</ul>
<h4 id="WebSocket属性"><a href="#WebSocket属性" class="headerlink" title="WebSocket属性"></a>WebSocket属性</h4><p>以下是<code>WebSocket</code>对象的属性。假定我们使用了以上代码创建了<code>Socket</code>对象</p>
<ul>
<li><code>Socket.readyState</code>: 只读属性<code>readyState</code>表示连接状态, 可以是以下值<ul>
<li>0 : 表示连接尚未建立</li>
<li>1 : 表示连接已建立，可以进行通信</li>
<li>2 : 表示连接正在进行关闭</li>
<li>3 : 表示连接已经关闭或者连接不能打开。</li>
</ul>
</li>
<li><code>Socket.bufferedAmount</code>: 只读属性<code>bufferedAmount</code><ul>
<li>表示已被<code>send()</code> 放入正在队列中等待传输，但是还没有发出的<code>UTF-8</code>文本字节数</li>
</ul>
</li>
</ul>
<h4 id="WebSocket事件"><a href="#WebSocket事件" class="headerlink" title="WebSocket事件"></a>WebSocket事件</h4><p>以下是<code>WebSocket</code>对象的相关事件。假定我们使用了以上代码创建了<code>Socket</code> 对象：</p>
<table>
<thead>
<tr>
<th>事件</th>
<th>事件处理程序</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>open</td>
<td>Socket.onopen</td>
<td>连接建立时触发</td>
</tr>
<tr>
<td>message</td>
<td>Socket.onmessage</td>
<td>客户端接收服务端数据时触发</td>
</tr>
<tr>
<td>error</td>
<td>Socket.onerror</td>
<td>通信发生错误时触发</td>
</tr>
<tr>
<td>close</td>
<td>Socket.onclose</td>
<td>连接关闭时触发</td>
</tr>
</tbody></table>
<h4 id="WebSocket方法"><a href="#WebSocket方法" class="headerlink" title="WebSocket方法"></a>WebSocket方法</h4><p>以下是<code>WebSocket</code>对象的相关方法。假定我们使用了以上代码创建了<code>Socket</code>对象：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Socket.send()</td>
<td>使用连接发送数据</td>
</tr>
<tr>
<td>Socket.close()</td>
<td>关闭连接</td>
</tr>
</tbody></table>
<div class='note success'><p>代码示例</p></div>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="keyword">var</span> socket = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&quot;ws://localhost:9090&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立 web socket 连接成功触发事件</span></span><br><span class="line">socket.<span class="property">onopen</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 使用send发送数据</span></span><br><span class="line">    socket.<span class="title function_">send</span>(<span class="string">&quot;发送数据&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(socket.<span class="property">bufferedAmount</span>)</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;数据发送中&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接受服务端数据是触发事件</span></span><br><span class="line">socket.<span class="property">onmessage</span> = <span class="keyword">function</span> (<span class="params">evt</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> received_msg = evt.<span class="property">data</span></span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;数据已经接受..&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 断开 websocket 连接成功触发事件</span></span><br><span class="line">socket.<span class="property">onclose</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;链接已经关闭&#x27;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(socket.<span class="property">readyState</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="WebSocket服务端"><a href="#WebSocket服务端" class="headerlink" title="WebSocket服务端"></a>WebSocket服务端</h3><p><code>WebSocket</code>在服务端的实现非常丰富。<code>Node.js</code>、<code>Java</code>、<code>C++</code>、<code>Python</code> 等多种语言都有自己的解决方案, 其中<code>Node.js</code>常用的有以下三种</p>
<ul>
<li><a href="https://github.com/uNetworking/uWebSockets">µWebSockets</a></li>
<li><a href="https://socket.io/">Socket.IO</a></li>
<li><a href="https://github.com/theturtle32/WebSocket-Node">WebSocket-Node</a></li>
</ul>
<p>下面就着重研究一下<code>Socket.IO</code>吧, 因为别的我也不会, 哈哈哈哈……</p>
<h2 id="Socket-IO"><a href="#Socket-IO" class="headerlink" title="Socket.IO"></a><code>Socket.IO</code></h2><ul>
<li><a href="https://github.com/socketio">Socket.IO</a>是一个库，可以在浏览器和服务器之间实现实时，双向和基于事件的通信</li>
<li><a href="https://github.com/socketio">Socket.IO</a>是一个完全由<code>JavaScript</code>实现、基于<code>Node.js</code>、支持<code>WebSocket</code>的协议用于实时通信、跨平台的开源框架</li>
<li><a href="https://github.com/socketio">Socket.IO</a>包括了客户端(<code>iOS,Android</code>)和服务器端(<code>Node.js</code>)的代码，可以很好的实现iOS即时通讯技术</li>
<li><a href="https://github.com/socketio">Socket.IO</a>支持及时、双向、基于事件的交流，可在不同平台、浏览器、设备上工作，可靠性和速度稳定</li>
<li><a href="https://github.com/socketio">Socket.IO</a>实际上是<code>WebSocket</code>的父集，<code>Socket.io</code>封装了<code>WebSocket</code>和轮询等方法，会根据情况选择方法来进行通讯</li>
<li>典型的应用场景如：<ul>
<li>实时分析：将数据推送到客户端，客户端表现为实时计数器、图表、日志客户</li>
<li>实时通讯：聊天应用</li>
<li>二进制流传输：<code>socket.io</code>支持任何形式的二进制文件传输，例如图片、视频、音频等</li>
<li>文档合并：允许多个用户同时编辑一个文档，并能够看到每个用户做出的修改</li>
</ul>
</li>
</ul>
<h3 id="Socket-IO服务端"><a href="#Socket-IO服务端" class="headerlink" title="Socket.IO服务端"></a>Socket.IO服务端</h3><ul>
<li><a href="https://github.com/socketio">Socket.IO</a>实质是一个库, 所以在使用之前必须先导入<code>Socket.IO</code>库</li>
<li><code>Node.js</code>导入库和<code>iOS</code>导入第三方库性质一样, 只不过<code>iOS</code>使用的是<code>pods</code>管理, <code>Node.js</code>使用<code>npm</code></li>
</ul>
<h4 id="导入Socket-IO库"><a href="#导入Socket-IO库" class="headerlink" title="导入Socket.IO库"></a>导入<code>Socket.IO</code>库</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 1. 进入当当前文件夹</span><br><span class="line">cd ...</span><br><span class="line"></span><br><span class="line">// 2. 创建package.json文件</span><br><span class="line">npm init</span><br><span class="line"></span><br><span class="line">/// 3. 导入库</span><br><span class="line">npm install socket.io --sava</span><br><span class="line">npm install express --sava</span><br></pre></td></tr></table></figure>


<h4 id="创建socket"><a href="#创建socket" class="headerlink" title="创建socket"></a>创建socket</h4><ul>
<li><code>socket</code>本质还是<code>http</code>协议，所以需要绑定<code>http</code>服务器，才能启动socket服务.</li>
<li>而且需要通过<code>web</code>服务器监听端口，<code>socket</code>不能监听端口，有人访问端口才能建立连接，所以先创建<code>web</code>服务器</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入http模块</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 面向express框架开发，加载express框架，方便处理get,post请求</span></span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建web服务器</span></span><br><span class="line"><span class="keyword">var</span> server = http.<span class="title class_">Server</span>(express)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入socket.io模块</span></span><br><span class="line"><span class="keyword">var</span> socketio = <span class="built_in">require</span>(<span class="string">&#x27;socket.io&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建爱你socket服务器</span></span><br><span class="line"><span class="keyword">var</span> serverSocket = <span class="title function_">socketio</span>(server)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">9090</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;监听9090&#x27;</span>)</span><br></pre></td></tr></table></figure>


<h4 id="建立socket连接"><a href="#建立socket连接" class="headerlink" title="建立socket连接"></a>建立socket连接</h4><ul>
<li>服务器不需要主动建立连接，建立连接是客户端的事情，服务器只需要监听连接</li>
<li>客户端主动连接会发送<code>connection</code>事件，服务端只需要监听<code>connection</code>事件有没有发送，就知道客户端有没有主动连接服务器</li>
<li><code>Socket.IO</code>本质是通过发送和接受事件触发服务器和客户端之间的通讯，任何能被编辑成<code>JSON</code>或二进制的对象都可以传递</li>
<li><code>socket.on</code>: 监听事件，这个方法会有两个参数，第一个参数是事件名称，第二个参数是监听事件的回调函数，监听到链接就会执行这个回调函数</li>
<li>监听<code>connection</code>，回调函数会传入一个连接好的<code>socket</code>，这个<code>socket</code>就是客户端的<code>socket</code></li>
<li><code>socket</code>连接原理，就是客户端和服务端通过<code>socket</code>连接，服务器有<code>socket</code>，客户端也有</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 监听客户端有没有连接成功,如果连接成功,服务端会发送connection事件,通知客户端连接成功</span></span><br><span class="line"><span class="comment">// serverSocket: 服务端, clientSocket: 客户端</span></span><br><span class="line">serverSocket.<span class="title function_">on</span>(<span class="string">&#x27;connection&#x27;</span>, <span class="keyword">function</span> (<span class="params">clientSocket</span>) &#123;</span><br><span class="line">    <span class="comment">// 建立socket连接成功</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;建立连接成功&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(clientSocket)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="Socket-IO客户端"><a href="#Socket-IO客户端" class="headerlink" title="Socket.IO客户端"></a>Socket.IO客户端</h3><ul>
<li><a href="https://github.com/socketio/socket.io-client-swift">Socket.IO-Client-Swift</a>是<code>iOS</code>使用的库, 目前只有<code>Swift</code>版本</li>
<li>iOS中的使用</li>
</ul>
<h4 id="创建socket对象"><a href="#创建socket对象" class="headerlink" title="创建socket对象"></a>创建socket对象</h4><p>创建<code>SocketIOClient</code>对象, 两种创建方式</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一种, SocketIOClientConfiguration: 可选参数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">init</span>(<span class="params">socketURL</span>: <span class="type">URL</span>, <span class="params">config</span>: <span class="type">SocketIOClientConfiguration</span> <span class="operator">=</span> [])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种, 底层还是使用的第一种方式创建</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">convenience</span> <span class="keyword">init</span>(<span class="params">socketURL</span>: <span class="type">URL</span>, <span class="params">config</span>: [<span class="params">String</span>: <span class="keyword">Any</span>]<span class="operator">?</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(socketURL: socketURL, config: config<span class="operator">?</span>.toSocketConfiguration() <span class="operator">??</span> [])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li><code>SocketIOClientConfiguration</code>: 是一个数组, 等同于<code>[SocketIOClientOption]</code></li>
<li><code>SocketIOClientOption</code>的所有取值如下</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">SocketIOClientOption</span> : <span class="title class_">ClientOption</span> &#123;</span><br><span class="line">    <span class="comment">/// 使用压缩的方式进行传输</span></span><br><span class="line">    <span class="keyword">case</span> compress</span><br><span class="line">    <span class="comment">/// 通过字典内容连接</span></span><br><span class="line">    <span class="keyword">case</span> connectParams([String: <span class="keyword">Any</span>])</span><br><span class="line">    <span class="comment">/// NSHTTPCookies的数组, 在握手过程中传递, Default is nil.</span></span><br><span class="line">    <span class="keyword">case</span> cookies([<span class="type">HTTPCookie</span>])</span><br><span class="line">    <span class="comment">/// 添加自定义请求头初始化来请求, 默认为nil</span></span><br><span class="line">    <span class="keyword">case</span> extraHeaders([String: <span class="type">String</span>])</span><br><span class="line">    <span class="comment">/// 将为每个连接创建一个新的connect, 如果你在重新连接有bug时使用.</span></span><br><span class="line">    <span class="keyword">case</span> forceNew(<span class="type">Bool</span>)</span><br><span class="line">    <span class="comment">/// 传输是否使用HTTP长轮询, 默认false</span></span><br><span class="line">    <span class="keyword">case</span> forcePolling(<span class="type">Bool</span>)</span><br><span class="line">    <span class="comment">/// 是否使用 WebSockets. Default is `false`</span></span><br><span class="line">    <span class="keyword">case</span> forceWebsockets(<span class="type">Bool</span>)</span><br><span class="line">    <span class="comment">/// 调度handle的运行队列, 默认在主队列</span></span><br><span class="line">    <span class="keyword">case</span> handleQueue(<span class="type">DispatchQueue</span>)</span><br><span class="line">    <span class="comment">/// 是否打印调试信息. Default is false</span></span><br><span class="line">    <span class="keyword">case</span> log(<span class="type">Bool</span>)</span><br><span class="line">    <span class="comment">/// 可自定义SocketLogger调试日志</span></span><br><span class="line">    <span class="keyword">case</span> logger(<span class="type">SocketLogger</span>)</span><br><span class="line">    <span class="comment">/// 自定义服务器使用的路径.</span></span><br><span class="line">    <span class="keyword">case</span> path(<span class="type">String</span>)</span><br><span class="line">    <span class="comment">/// 链接失败时, 是否重新链接, Default is `true`</span></span><br><span class="line">    <span class="keyword">case</span> reconnects(<span class="type">Bool</span>)</span><br><span class="line">    <span class="comment">/// 重新连接多少次. Default is `-1` (无限次)</span></span><br><span class="line">    <span class="keyword">case</span> reconnectAttempts(<span class="type">Int</span>)</span><br><span class="line">    <span class="comment">/// 等待重连时间. Default is `10`</span></span><br><span class="line">    <span class="keyword">case</span> reconnectWait(<span class="type">Int</span>)</span><br><span class="line">    <span class="comment">/// 是否使用安全传输, Default is false</span></span><br><span class="line">    <span class="keyword">case</span> secure(<span class="type">Bool</span>)</span><br><span class="line">    <span class="comment">/// 设置允许那些证书有效</span></span><br><span class="line">    <span class="keyword">case</span> security(<span class="type">SSLSecurity</span>)</span><br><span class="line">    <span class="comment">/// 自签名只能用于开发模式</span></span><br><span class="line">    <span class="keyword">case</span> selfSigned(<span class="type">Bool</span>)</span><br><span class="line">    <span class="comment">/// NSURLSessionDelegate 底层引擎设置. 如果你需要处理自签名证书. Default is nil.</span></span><br><span class="line">    <span class="keyword">case</span> sessionDelegate(<span class="type">URLSessionDelegate</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建<code>SocketIOClient</code></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意协议：ws开头</span></span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> url <span class="operator">=</span> <span class="type">URL</span>(string: <span class="string">&quot;ws://localhost:9090&quot;</span>) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line"><span class="keyword">let</span> manager <span class="operator">=</span> <span class="type">SocketManager</span>(socketURL: url, config: [.log(<span class="literal">true</span>), .compress])</span><br><span class="line"><span class="comment">// SocketIOClient</span></span><br><span class="line"><span class="keyword">let</span> socket <span class="operator">=</span> manager.defaultSocket</span><br></pre></td></tr></table></figure>


<h4 id="监听连接"><a href="#监听连接" class="headerlink" title="监听连接"></a>监听连接</h4><ul>
<li>创建好<code>socket</code>对象,然后连接用<code>connect</code>方法</li>
<li>因为<code>socket</code>需要进行3次握手，不可能马上建议连接，需要监听是否连接成功的回调,使用<code>on</code>方法</li>
<li><code>ON</code>方法两个参数<ul>
<li>参数一: 监听的事件名称，参数二：监听事件回调函数，会自动调用</li>
<li>回调函数也有两个参数(参数一：服务器传递的数据 参数二:确认请求数据<code>ACK</code>)</li>
<li>在<code>TCP/IP</code>协议中，如果接收方成功的接收到数据，那么会回复一个<code>ACK</code>数据- <code>ACK</code>只是一个标记，标记是否成功传输数据</li>
</ul>
</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 回调闭包</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">NormalCallback</span> <span class="operator">=</span> ([<span class="keyword">Any</span>], <span class="type">SocketAckEmitter</span>) -&gt; ()</span><br><span class="line"></span><br><span class="line"><span class="comment">// on方法</span></span><br><span class="line"><span class="keyword">@discardableResult</span></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">func</span> <span class="title function_">on</span>(<span class="keyword">_</span> <span class="params">event</span>: <span class="type">String</span>, <span class="params">callback</span>: <span class="keyword">@escaping</span> <span class="type">NormalCallback</span>) -&gt; <span class="type">UUID</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// SocketClientEvent: 接受枚举类型的on方法</span></span><br><span class="line"><span class="keyword">@discardableResult</span></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">func</span> <span class="title function_">on</span>(<span class="params">clientEvent</span> <span class="params">event</span>: <span class="type">SocketClientEvent</span>, <span class="params">callback</span>: <span class="keyword">@escaping</span> <span class="type">NormalCallback</span>) -&gt; <span class="type">UUID</span> &#123;</span><br><span class="line">    <span class="comment">// 这里调用的是上面的on方法</span></span><br><span class="line">    <span class="keyword">return</span> on(event.rawValue, callback: callback)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>完整代码</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> url <span class="operator">=</span> <span class="type">URL</span>(string: <span class="string">&quot;ws://localhost:9090&quot;</span>) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> manager <span class="operator">=</span> <span class="type">SocketManager</span>(socketURL: url, config: [.log(<span class="literal">true</span>), .compress])</span><br><span class="line"><span class="keyword">let</span> socket <span class="operator">=</span> manager.defaultSocket</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听链接成功</span></span><br><span class="line">socket.on(clientEvent: .connect) &#123; (data, ack) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;链接成功&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(data)</span><br><span class="line">    <span class="built_in">print</span>(ack)</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">socket.connect()</span><br></pre></td></tr></table></figure>


<h3 id="SocketIO事件"><a href="#SocketIO事件" class="headerlink" title="SocketIO事件"></a>SocketIO事件</h3><p><code>SocketIO</code>通过事件链接服务器和传递数据</p>
<h4 id="客户端监听事件"><a href="#客户端监听事件" class="headerlink" title="客户端监听事件"></a>客户端监听事件</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 监听链接成功</span></span><br><span class="line">socket.on(clientEvent: .connect) &#123; (data, ack) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;链接成功&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(data)</span><br><span class="line">    <span class="built_in">print</span>(ack)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="客户端发送事件"><a href="#客户端发送事件" class="headerlink" title="客户端发送事件"></a>客户端发送事件</h4><p>只有连接成功之后，才能发送事件</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 建立一个连接到服务器. 连接成功会触发 &quot;connect&quot;事件</span></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">func</span> <span class="title function_">connect</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接到服务器. 如果连接超时,会调用handle</span></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">func</span> <span class="title function_">connect</span>(<span class="params">timeoutAfter</span>: <span class="type">Double</span>, <span class="params">withHandler</span> <span class="params">handler</span>: (() -&gt; ())<span class="operator">?</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重开一个断开连接的socket</span></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">func</span> <span class="title function_">disconnect</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向服务器发送事件, 参数一: 事件的名称，参数二: 传输的数据组</span></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">func</span> <span class="title function_">emit</span>(<span class="keyword">_</span> <span class="params">event</span>: <span class="type">String</span>, <span class="params">with</span> <span class="params">items</span>: [<span class="keyword">Any</span>])</span><br></pre></td></tr></table></figure>

<h4 id="服务器监听事件"><a href="#服务器监听事件" class="headerlink" title="服务器监听事件"></a>服务器监听事件</h4><ul>
<li>监听客户端事件，需要嵌套在连接好的<code>connect</code>回调函数中</li>
<li>必须使用回调函数的<code>socket</code>参数，如<code>function(s)</code>中的s，监听事件,因此这是客户端的<code>socket</code>，肯定监听客户端发来的事件</li>
<li>服务器监听连接的回调函数的参数可以添加多个，具体看客户端传递数据数组有几个，每个参数都是与客户段一一对应，第一个参数对应客户端数组第0个数据</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 监听socket连接</span></span><br><span class="line">socket.<span class="title function_">on</span>(<span class="string">&#x27;connection&#x27;</span>,<span class="keyword">function</span>(<span class="params">s</span>)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;监听到客户端连接&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// data:客户端数组第0个元素</span></span><br><span class="line">    <span class="comment">// data1:客户端数组第1个元素</span></span><br><span class="line">    s.<span class="title function_">on</span>(<span class="string">&#x27;chat&#x27;</span>,<span class="keyword">function</span>(<span class="params">data,data1</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;监听到chat事件&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(data,data1);</span><br><span class="line">        </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="服务器发送事件"><a href="#服务器发送事件" class="headerlink" title="服务器发送事件"></a>服务器发送事件</h4><p>这里的<code>socket</code>一定要用服务器端的<code>socket</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 给当前客户端发送数据，其他客户端收不到.</span></span><br><span class="line">socket.<span class="title function_">emit</span>(<span class="string">&#x27;chat&#x27;</span>, <span class="string">&#x27;服务器&#x27;</span> + data)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发给所有客户端，不包含当前客户端</span></span><br><span class="line">socket.<span class="property">emit</span>.<span class="property">broadcast</span>.<span class="title function_">emit</span>(<span class="string">&#x27;chat&#x27;</span>, <span class="string">&#x27;发给所有客户端,不包含当前客户端&#x27;</span> + data)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发给所有客户端，包含当前客户端</span></span><br><span class="line">socket.<span class="property">emit</span>.<span class="property">sockets</span>.<span class="title function_">emit</span>(<span class="string">&#x27;chat&#x27;</span>, <span class="string">&#x27;发给所有客户端,包含当前客户端&#x27;</span> + data)</span><br></pre></td></tr></table></figure>


<h2 id="SocketIO分组"><a href="#SocketIO分组" class="headerlink" title="SocketIO分组"></a>SocketIO分组</h2><ul>
<li>每一个客户端和服务器只会保持一个<code>socket</code>链接, 那么怎么吧每一条信息推送到对应的聊天室, 针对多个聊天室的问题有如何解决</li>
<li>给每个聊天室都分组, 服务器就可以给指定的组进行数据的推送, 就不会影响到其他的聊天室</li>
</ul>
<h3 id="如何分组"><a href="#如何分组" class="headerlink" title="如何分组"></a>如何分组</h3><ul>
<li><code>socket.io</code>提供<a href="https://socket.io/docs/rooms-and-namespaces/">rooms和namespace的API</a></li>
<li>用<code>rooms</code>的API就可以实现多房间聊天了，总结出来无外乎就是：<code>join/leave room</code> 和 <code>say to room</code></li>
<li>这里的<code>socket</code>是客户端的<code>socket</code>，也就是连接成功，传递过来的<code>socket</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// join和leave</span></span><br><span class="line">io.<span class="title function_">on</span>(<span class="string">&#x27;connection&#x27;</span>, <span class="keyword">function</span>(<span class="params">socket</span>)&#123;</span><br><span class="line">  socket.<span class="title function_">join</span>(<span class="string">&#x27;some room&#x27;</span>);</span><br><span class="line">  <span class="comment">// socket.leave(&#x27;some room&#x27;);</span></span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// say to room</span></span><br><span class="line">io.<span class="title function_">to</span>(<span class="string">&#x27;some room&#x27;</span>).<span class="title function_">emit</span>(<span class="string">&#x27;some event&#x27;</span>):</span><br><span class="line">io.<span class="title function_">in</span>(<span class="string">&#x27;some room&#x27;</span>).<span class="title function_">emit</span>(<span class="string">&#x27;some event&#x27;</span>):</span><br></pre></td></tr></table></figure>

<h3 id="分组的原理"><a href="#分组的原理" class="headerlink" title="分组的原理"></a>分组的原理</h3><ul>
<li>只要客户端<code>socket</code>调用<code>join</code>，服务器就会把客户端<code>socket</code>和分组的名称绑定起来</li>
<li>到时候就可以根据分组的名称找到对应客户端的<code>socket</code>，就能给指定的客户端推送信息</li>
<li>一个客户端<code>socket</code>只能添加到一组，离开的时候，要记得移除</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>Socket</category>
      </categories>
      <tags>
        <tag>Node</tag>
        <tag>Socket</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift 5.0新特性更新</title>
    <url>/post/fecd5afa.html</url>
    <content><![CDATA[<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/ios/swift.jpg?x-oss-process=style/titanjun" alt="Swift"></p>
<span id="more"></span>


<ul>
<li>期待已久的<code>Swift 5.0</code>终于来啦, <code>Swift 5.0</code>是<code>Swift</code>中最备受关注的一个版本, 传说中<code>ABI</code>稳定的版本</li>
<li>随着<code>Xcode Bate 10.2</code>的发布, <code>Swift 5.0</code>也发布了测试版, 相信也带来了很多优化和改进</li>
<li>下面运行环境都是在<code>Xcode Bate 10.2</code>环境中进行的</li>
</ul>
<h2 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h2><h3 id="dynamicCallable"><a href="#dynamicCallable" class="headerlink" title="dynamicCallable"></a>dynamicCallable</h3><ul>
<li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0216-dynamic-callable.md">SE-0216</a></li>
<li><code>@dynamicCallable</code>为<code>Swift</code>添加了一个新属性, 允许使用一个简单的语法糖调用函数一样调用命名类型</li>
<li>如果需要添加<code>@dynamicCallable</code>属性, 就必须要实现以下方法中的一个或者两个</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">dynamicallyCall</span>(<span class="params">withArguments</span> <span class="params">args</span>: [<span class="type">Int</span>]) -&gt; <span class="type">Double</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">dynamicallyCall</span>(<span class="params">withKeywordArguments</span> <span class="params">args</span>: <span class="type">KeyValuePairs</span>&lt;<span class="type">String</span>, <span class="type">Int</span>&gt;) -&gt; <span class="type">Double</span></span><br></pre></td></tr></table></figure>

<div class="note warning"><p>注意点</p></div>

<ul>
<li>除了接受各种输入外，您还可以为各种输出提供多个重载, 自定义返回值, 可以是<code>String</code>, <code>Int</code>等等……</li>
<li><code>KeyValuePairs</code>的使用和介绍, 没有使用过的<a href="https://www.titanjun.top/2018/06/06/Swift%204.2%20%E6%96%B0%E7%89%B9%E6%80%A7%E6%9B%B4%E6%96%B0/#KeyValuePairs">可参考</a></li>
</ul>
<p>下面看一个例子, <code>RandomNumberGenerator</code>生成一个随机数</p>
<div class="note info"><p>`Swift 5.0`之前的定义和调用方式</p></div>


<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义方式</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RandomNumberGenerator</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">generate</span>(<span class="params">numberOfZeroes</span>: <span class="type">Int</span>) -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> maximum <span class="operator">=</span> pow(<span class="number">10</span>, <span class="type">Double</span>(numberOfZeroes))</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Double</span>.random(in: <span class="number">0</span><span class="operator">...</span>maximum)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方式</span></span><br><span class="line"><span class="keyword">let</span> random <span class="operator">=</span> <span class="type">RandomNumberGenerator</span>()</span><br><span class="line"><span class="keyword">let</span> num <span class="operator">=</span> random.generate(numberOfZeroes: <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(num)</span><br></pre></td></tr></table></figure>

<div class="note info"><p>在`Swift 5.0`使用`@dynamicCallable`属性</p></div>


<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义方式</span></span><br><span class="line"><span class="keyword">@dynamicCallable</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RandomNumberGenerator</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">dynamicallyCall</span>(<span class="params">withArguments</span> <span class="params">args</span>: [<span class="type">Int</span>]) -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> numberOfZeroes <span class="operator">=</span> <span class="type">Double</span>(args.first <span class="operator">??</span> <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">let</span> maximum <span class="operator">=</span> pow(<span class="number">10</span>, numberOfZeroes)</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Double</span>.random(in: <span class="number">0</span><span class="operator">...</span>maximum)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方式</span></span><br><span class="line"><span class="keyword">let</span> random <span class="operator">=</span> <span class="type">RandomNumberGenerator</span>()</span><br><span class="line"><span class="keyword">let</span> num <span class="operator">=</span> random(<span class="number">2</span>)</span><br><span class="line"><span class="comment">// random(2)等同于random.dynamicallyCall(withArguments: [2])</span></span><br><span class="line"><span class="built_in">print</span>(num)</span><br></pre></td></tr></table></figure>

<div class="note warning"><p>`@dynamicCallable`使用注意事项</p></div>

<ul>
<li>可以将它应用于结构，枚举，类和协议。</li>
<li>如果你实现<code>withKeywordArguments:</code>并且没有实现<code>withArguments:</code>，你仍然可以在没有参数标签的情况下调用</li>
<li>如果你的实现<code>withKeywordArguments:</code>或<code>withArguments:</code>时标记为<code>throw</code>，则调用该类型也将被抛出<code>throw</code></li>
<li>扩展名无法添加<code>@dynamicCallable</code>，只能添加到主要类型上</li>
<li>仍然可以为你定义的类型添加其他方法和属性，并且能够正常使用</li>
</ul>
<h3 id="WritableKeyPath"><a href="#WritableKeyPath" class="headerlink" title="WritableKeyPath"></a><a href="https://developer.apple.com/documentation/swift/writablekeypath?language=objc">WritableKeyPath</a></h3><ul>
<li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0227-identity-keypath.md">SE-0227</a></li>
<li>添加引用标识键路径的功能，该路径指的是应用它的整个输入值</li>
<li><code>Swift</code>中的每个值都有一个特殊的伪属性.self，它指的是整个值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let id = \Int.self  </span><br><span class="line">var x = 1</span><br><span class="line">print(id)   ////Swift.WritableKeyPath&lt;Swift.Int, Swift.Int&gt;</span><br><span class="line">x.self = 2</span><br><span class="line">print(x)   //2</span><br><span class="line">print(x.self)  //2</span><br><span class="line"></span><br><span class="line">print(x[keyPath: id])  //2</span><br><span class="line">x[keyPath: id] = 3</span><br><span class="line">print(x[keyPath: id])  //3</span><br></pre></td></tr></table></figure>

<h3 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h3><p>在<code>Swift 5</code>之前，可以编写一个带有可变参数的枚举, 但是在<code>Swift 5</code>开始, 调用时会报错, 如下</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">X</span> &#123;</span><br><span class="line">    <span class="comment">// 此处定义切没有调用时不会报错</span></span><br><span class="line">    <span class="keyword">case</span> foo(bar: <span class="type">Int</span>...) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">baz</span>() -&gt; <span class="type">X</span> &#123;</span><br><span class="line">    <span class="comment">// 此处调用时会报错</span></span><br><span class="line">    <span class="keyword">return</span> .foo(bar: <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>在<code>Swift 5</code>之后, 上述定义改成数组参数, 而不是可变参数, 如下</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">X</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> foo(bar: [<span class="type">Int</span>]) </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">baz</span>() -&gt; <span class="type">X</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> .foo(bar: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>


<h3 id="Raw-Strings"><a href="#Raw-Strings" class="headerlink" title="Raw Strings"></a>Raw Strings</h3><h4 id="处理"><a href="#处理" class="headerlink" title="\处理"></a><code>\</code>处理</h4><ul>
<li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0200-raw-string-escaping.md">SE-0200</a>增加了创建原始字符串的功能，其中反斜杠和引号被解释为文字符号，而不是转义字符或字符串终止符</li>
<li>单行字符串文字可以用反斜杠填充, 以保证原字符串, 否则会报错</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文字引用类型</span></span><br><span class="line"><span class="comment">// 错误写法</span></span><br><span class="line"><span class="keyword">let</span> quote <span class="operator">=</span> <span class="string">&quot;Alice: &quot;</span><span class="type">How</span> long <span class="keyword">is</span> forever<span class="operator">?</span><span class="string">&quot; White Rabbit: &quot;</span><span class="type">Sometimes</span>, just one second.<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="comment">// 正确写法</span></span><br><span class="line"><span class="keyword">let</span> quote1 <span class="operator">=</span> <span class="string">&quot;Alice: <span class="subst">\&quot;</span>How long is forever?<span class="subst">\&quot;</span> White Rabbit: <span class="subst">\&quot;</span>Sometimes, just one second.<span class="subst">\&quot;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正则表法式类型</span></span><br><span class="line"><span class="comment">// 错误写法</span></span><br><span class="line"><span class="keyword">let</span> ucCaseCheck <span class="operator">=</span> <span class="string">&quot;enum\s+.+\&#123;.*case\s+[:upper:]&quot;</span></span><br><span class="line"><span class="comment">// 正确写法</span></span><br><span class="line"><span class="keyword">let</span> ucCaseCheck <span class="operator">=</span> <span class="string">&quot;enum<span class="subst">\\</span>s+.+<span class="subst">\\</span>&#123;.*case<span class="subst">\\</span>s+[:upper:]&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="处理-1"><a href="#处理-1" class="headerlink" title="#处理"></a><code>#</code>处理</h4><ul>
<li>要使用原始字符串, 可使用<code>#</code>将字符串包裹起来</li>
<li><code>#</code>字符串开头和结尾的符号成为字符串分隔符的一部分，因此如下<code>Swift</code>理解<code>“rain”</code>和<code>“Spain”</code>周围的独立引号应该被视为文字引号而不是结束字符串</li>
<li>原始字符串也允许使用反斜杠, 但是将反斜杠视为字符串中的文字字符，而不是转义字符</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> rain <span class="operator">=</span> <span class="string">#&quot;The &quot;rain&quot; in &quot;Spain&quot; falls mainly on the Spaniards.&quot;#</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> keypaths <span class="operator">=</span> <span class="string">#&quot;Swift keypaths such as \Person.name hold uninvoked references to properties.&quot;#</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> answer <span class="operator">=</span> <span class="number">42</span></span><br><span class="line"><span class="keyword">let</span> dontpanic <span class="operator">=</span> <span class="string">#&quot;The answer to life, the universe, and everything is <span class="subst">\#(answer)</span>.&quot;#</span></span><br></pre></td></tr></table></figure>

<div class="note warning"><p>注意</p></div>

<ul>
<li>上面使用<code>\#(answer)</code>引用变量而不是<code>\(answer)</code>, 因为在用<code>#</code>包裹的字符串中反斜杠将会被失败别为文字字符而不是转义字符, 所以必须额外的添加<code>#</code></li>
</ul>
<h4 id="处理-2"><a href="#处理-2" class="headerlink" title="##处理"></a><code>##</code>处理</h4><ul>
<li>在字符串的开头和结尾使用<code>#</code>处理, 在字符串中可以使用反斜杠等特殊字符, 那如果字符串中需要使用<code>#</code>, 又该如何处理??</li>
<li>使用<code>#</code>包裹字符串, 默认会以<code>#</code>为字符串的结束符号, <code>#</code>后面的文字将不再处理, 在这种情况下, 我们会使用<code>##</code>处理</li>
<li>注意: 字符串的开头和结尾的标识必须一样</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str <span class="operator">=</span> <span class="string">##&quot;My dog said &quot;woof&quot;#gooddog&quot;##</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a>多行字符串</h4><p>原始字符串与<code>Swift</code>的多行字符串系统完全兼容 - 只需用于<code>#&quot;&quot;&quot;</code>启动，然后<code>&quot;&quot;&quot;#</code>结束</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> multiline <span class="operator">=</span> <span class="string">#&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The answer to life,</span></span><br><span class="line"><span class="string">    the universe,</span></span><br><span class="line"><span class="string">    and everything is <span class="subst">\#(answer)</span>.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;#</span></span><br></pre></td></tr></table></figure>

<h3 id="try-嵌套"><a href="#try-嵌套" class="headerlink" title="try?嵌套"></a><code>try?</code>嵌套</h3><p>先看下面代码</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> id: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init?</span>(<span class="params">id</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> id <span class="operator">&lt;</span> <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.id <span class="operator">=</span> id</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">getMessages</span>() <span class="keyword">throws</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="comment">// complicated code here</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;No messages&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>Swift4.2</code>及其之前的版本中</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user <span class="operator">=</span> <span class="type">User</span>(id: <span class="number">1</span>)</span><br><span class="line"><span class="comment">// 这里得到的message的类型是: let messages: String??</span></span><br><span class="line"><span class="keyword">let</span> messages <span class="operator">=</span> <span class="keyword">try?</span> user<span class="operator">?</span>.getMessages()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果我们想得到非可选值就需要</span></span><br><span class="line"><span class="built_in">print</span>((messages <span class="operator">??</span> <span class="string">&quot;&quot;</span>) <span class="operator">??</span> <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="comment">// 或者多次强解, 当然不建议强解写法</span></span><br><span class="line"><span class="built_in">print</span>(messages<span class="operator">!!</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>在<code>Swift4.2</code>及其之前的版本中, 上面返回的是一个2层嵌套的可选值, 如果有多层嵌套处理起来也是相当更麻烦的</li>
<li>在<code>Swift 5</code>中就完美的解决了这个问题, 如果当前值是可选的, 那么<code>try?</code>将不会将值包装在可选值中, 因此最终结果只是一个<code>String?</code></li>
<li>因此在<code>Swift 5</code>中无论有多少可嵌套的可选最后, 返回值永远只是一个可选值</li>
<li>同样，如果你使用了可选的链接<code>as?</code>，你仍然只有一个级别的可选性</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user <span class="operator">=</span> <span class="type">User</span>(id: <span class="number">1</span>)</span><br><span class="line"><span class="comment">// 类型: let messages: String?</span></span><br><span class="line"><span class="keyword">let</span> messages <span class="operator">=</span> <span class="keyword">try?</span> user<span class="operator">?</span>.getMessages()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(messages <span class="operator">??</span> <span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="isMultiple"><a href="#isMultiple" class="headerlink" title="isMultiple"></a><code>isMultiple</code></h3><ul>
<li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0225-binaryinteger-iseven-isodd-ismultiple.md">SE-0225</a>为整数类型添加了一个方法<code>isMultiple</code></li>
<li>该方法可以检查一个证书是否为另一个整数的倍数</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> rowNumber <span class="operator">=</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> rowNumber.isMultiple(of: <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Even&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Odd&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该方法等效于</span></span><br><span class="line"><span class="keyword">if</span> rowNumber <span class="operator">%</span> <span class="number">2</span> <span class="operator">==</span> <span class="number">0</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="count"><a href="#count" class="headerlink" title="count"></a><code>count</code></h3><ul>
<li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0220-count-where.md">SE-0220</a></li>
<li>在<code>Swift</code>之前的版本中, 有一个函数<code>filter</code>可以过滤出数组中符合条件的的元素, 组成一个新的数组, 详细使用可参考<a href="https://www.titanjun.top/2017/05/19/Swift%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/">Swift函数式编程之高级用法</a></li>
<li>在<code>Swift 5</code>中新增了一个函数<code>count(where:)</code>, 可以获取数组中符合条件的元素的个数</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr <span class="operator">=</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">34</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">45</span>, <span class="number">6</span>, <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> filter <span class="operator">=</span> arr.filter(&#123; <span class="variable">$0</span> <span class="operator">&gt;</span> <span class="number">10</span> &#125;)</span><br><span class="line"><span class="built_in">print</span>(filter)  <span class="comment">//[34, 12, 45]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> count <span class="operator">=</span> arr.count(where: &#123; <span class="variable">$0</span> <span class="operator">&gt;</span> <span class="number">10</span> &#125;)</span><br><span class="line"><span class="built_in">print</span>(count)  <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h3 id="compactMapValues"><a href="#compactMapValues" class="headerlink" title="compactMapValues"></a><code>compactMapValues</code></h3><ul>
<li>在<code>Swift4.x</code>的版本有两个函数<code>compactMap</code>和<code>mapValues</code></li>
<li><code>compactMap</code>: 返回一个操作后得到的新的数组, 类似<code>flatMap</code></li>
<li><code>mapValues</code>: 字典中的函数, 对字典的<code>value</code>值执行操作, 返回改变<code>value</code>后的新的字典</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> times <span class="operator">=</span> [</span><br><span class="line">    <span class="string">&quot;first&quot;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&quot;second&quot;</span>: <span class="number">43</span>,</span><br><span class="line">    <span class="string">&quot;three&quot;</span>: <span class="number">12</span>,</span><br><span class="line">    <span class="string">&quot;four&quot;</span>: <span class="number">3</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> compact <span class="operator">=</span> times.compactMap(&#123; <span class="variable">$0</span>.value <span class="operator">&gt;</span> <span class="number">10</span> &#125;)</span><br><span class="line"><span class="built_in">print</span>(compact)</span><br><span class="line"><span class="comment">// [true, false, true, false]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mapValues <span class="operator">=</span> times.mapValues(&#123; <span class="variable">$0</span> <span class="operator">+</span> <span class="number">2</span> &#125;)</span><br><span class="line"><span class="built_in">print</span>(mapValues)</span><br><span class="line"><span class="comment">// [&quot;second&quot;: 45, &quot;first&quot;: 4, &quot;three&quot;: 14, &quot;four&quot;: 5]</span></span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0218-introduce-compact-map-values.md">SE-0218</a>在<code>Swift 5</code>中新增了一个函数<code>compactMapValues</code></li>
<li><code>compactMapValues</code>是将上述两个方法的功能合并在一起, 返回一个对<code>value</code>操作后的新字典, 并且自动过滤不符合条件的键值对</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> times1 <span class="operator">=</span> [</span><br><span class="line">    <span class="string">&quot;Hudson&quot;</span>: <span class="string">&quot;38&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Clarke&quot;</span>: <span class="string">&quot;42&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Robinson&quot;</span>: <span class="string">&quot;35&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Hartis&quot;</span>: <span class="string">&quot;DNF&quot;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> comMap2 <span class="operator">=</span> times1.compactMapValues(&#123; <span class="type">Int</span>(<span class="variable">$0</span>) &#125;)</span><br><span class="line"><span class="built_in">print</span>(comMap2)</span><br><span class="line"><span class="comment">// [&quot;Clarke&quot;: 42, &quot;Robinson&quot;: 35, &quot;Hudson&quot;: 38]</span></span><br></pre></td></tr></table></figure>

<h3 id="SubSequence"><a href="#SubSequence" class="headerlink" title="SubSequence"></a><code>SubSequence</code></h3><ul>
<li><a href="https://developer.apple.com/documentation/swift/sequence?language=objc"><code>Sequence</code></a>协议不再具有<code>SubSequence</code>关联类型。先前返回<code>SubSequence</code>的<code>Sequence</code>方法现在会返回具体类型</li>
<li>使用<code>SubSequence</code>的<code>Sequence</code>扩展应该修改为类似地使用具体类型，或者修改为<a href="https://developer.apple.com/documentation/swift/collection?language=objc"><code>Collection</code></a>的扩展，在<a href="https://developer.apple.com/documentation/swift/collection?language=objc"><code>Collection</code></a>中<code>SubSequence</code>仍然可用</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// swift 5不在支持</span></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">Sequence</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">dropTwo</span>() -&gt; <span class="type">SubSequence</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.dropFirst(<span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 建议改为</span></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">Sequence</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">dropTwo</span>() -&gt; <span class="type">DropFirstSequence</span>&lt;<span class="keyword">Self</span>&gt; &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.dropFirst(<span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">Collection</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">dropTwo</span>() -&gt; <span class="type">SubSequence</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.dropFirst(<span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="其他相关更新"><a href="#其他相关更新" class="headerlink" title="其他相关更新"></a>其他相关更新</h2><h3 id="SE-0214"><a href="#SE-0214" class="headerlink" title="SE-0214"></a><a href="https://link.juejin.im/?target=https://github.com/apple/swift-evolution/blob/master/proposals/0214-DictionaryLiteral.md">SE-0214</a></h3><p><code>DictionaryLiteral</code>类型重命名为<code>KeyValuePairs</code></p>
<h3 id="SE-0238"><a href="#SE-0238" class="headerlink" title="SE-0238"></a><a href="https://link.juejin.im/?target=https://github.com/apple/swift-evolution/blob/master/proposals/0238-package-manager-build-settings.md">SE-0238</a></h3><ul>
<li>在使用<code>Swift 5</code>软件包管理器时，<code>Targets</code>可以声明一些常用的针对特定目标的<code>build settings</code>设置</li>
<li>新设置也可以基于平台和构建配置进行条件化处理。包含的构建设置支持<code>Swift</code>和<code>C</code>语言定义，<code>C</code>语言头文件搜索路径，链接库和链接框架</li>
</ul>
<h3 id="SE-0236"><a href="#SE-0236" class="headerlink" title="SE- 0236"></a><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0236-package-manager-platform-deployment-settings.md">SE- 0236</a></h3><ul>
<li>在使用<code>Swift 5</code>时, 可以自定义所支持的最低版本号, 如果该项目的依赖包所支持的最低版本大于项目的最低版本号, 则项目会报错</li>
</ul>
<h3 id="SR-695"><a href="#SR-695" class="headerlink" title="SR-695"></a><a href="https://link.juejin.im/?target=https://bugs.swift.org/browse/SR-695">SR-695</a></h3><p>在<code>Swift 5</code>中不再支持返回<code>Self</code>的类方法</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不在支持</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123; </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">func</span> <span class="title class_">factory</span>() -&gt; <span class="title class_">Self</span> &#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="SR-631"><a href="#SR-631" class="headerlink" title="SR-631"></a><a href="https://bugs.swift.org/browse/SR-631">SR-631</a></h3><p>不同文件中的扩展名无法相互识别</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FirstClass</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">FirstClass</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">SecondClass</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里将会报错: &quot;SecondClass is not a member type of FirstClass&quot;</span></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">FirstClass</span>.<span class="title class_">SecondClass</span> &#123; </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">ThirdClass</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SR-7251"><a href="#SR-7251" class="headerlink" title="SR-7251"></a><a href="https://bugs.swift.org/browse/SR-7251">SR-7251</a></h3><p>在<code>Swift 5</code>中, 在所声明的类里面, 所声明的变量名不能和类名一样</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;&#125;</span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">S</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">var</span> i: <span class="type">Int</span> &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">i</span> &#123;&#125; <span class="comment">// error: “i”的声明无效</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的方式是没有问题的</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S1</span>&lt;<span class="title class_">T</span>&gt; &#123;&#125;</span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">S1</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">var</span> i: <span class="type">Int</span> &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">i</span> &#123;&#125; <span class="comment">// This is fine!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul>
<li><a href="https://developer.apple.com/documentation/xcode_release_notes/xcode_10_2_beta_release_notes/swift_5_release_notes_for_xcode_10_2_beta?language=objc">Swift 5官方文档</a></li>
<li><a href="https://www.hackingwithswift.com/articles/126/whats-new-in-swift-5-0">What’s new in Swift 5.0</a></li>
</ul>
<hr>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift 4.1 的新特性</title>
    <url>/post/da0fafd1.html</url>
    <content><![CDATA[<ul>
<li>苹果公司在 3.29 正式发布了正式版的<code>Xcode 9.3</code>和<code>Swift 4.1</code>, 让我们看看<code>Swift 4.1</code>带来了哪些新功能和新亮点</li>
<li>测试需要Xcode9.3, 请确保你的Xcode是最新的9.3版本</li>
<li><code>Swift 4.1</code>与<code>Swift 4.0</code>是源代码兼容的，所以如果你已经使用<code>Xcode</code>中的<code>Swift Migrator</code>将你的项目迁移到<code>Swift 4.0</code>，那么新特性不会破坏你的代码</li>
<li>下面在<code>Xcode9.3</code>下新建一个<code>Playground</code>工程, 测试我们的代码</li>
</ul>
<span id="more"></span>

<h4 id="条件一致性-Conditional-Conformance"><a href="#条件一致性-Conditional-Conformance" class="headerlink" title="条件一致性(Conditional Conformance)"></a>条件一致性(Conditional Conformance)</h4><ul>
<li>条件一致性使类型参数满足特定条件的泛型类型的协议一致性 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0143-conditional-conformances.md">[ SE-0143 ]</a></li>
<li>在Swift 4中，如果数组、字典或者可选类型的元素类型遵循<code>Equatable</code>，你是可以在数组之间、字典之间和可选类型之间进行比较的, 如下示例:</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Int类型的数组</span></span><br><span class="line">let arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">let arr2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">print(arr1 == arr2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较value值为Int的字典</span></span><br><span class="line">let dic1 = [<span class="string">&quot;age&quot;</span>: <span class="number">19</span>, <span class="string">&quot;score&quot;</span>: <span class="number">60</span>]</span><br><span class="line">let dic2 = [<span class="string">&quot;age&quot;</span>: <span class="number">19</span>, <span class="string">&quot;score&quot;</span>: <span class="number">60</span>]</span><br><span class="line">print(dic1 == dic2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较Int?</span></span><br><span class="line">let age1 = dic1[<span class="string">&quot;age&quot;</span>]</span><br><span class="line">let age2 = dic2[<span class="string">&quot;age&quot;</span>]</span><br><span class="line">print(age1 == age2)</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 以上输出结果都是: true</span></span><br></pre></td></tr></table></figure>

<p>这里如果我们把<code>Int</code>都换成<code>Int?</code>类型, 在<code>Swift4.0</code>中是不能编译通过的, 如下:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Int类型的数组</span></span><br><span class="line">let arr1: [Int?] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">let arr2: [Int?] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">print(arr1 == arr2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较value值为Int的字典</span></span><br><span class="line">let dic1: [String: Int?] = [<span class="string">&quot;age&quot;</span>: <span class="number">19</span>, <span class="string">&quot;score&quot;</span>: <span class="number">60</span>]</span><br><span class="line">let dic2: [String: Int?] = [<span class="string">&quot;age&quot;</span>: <span class="number">19</span>, <span class="string">&quot;score&quot;</span>: <span class="number">60</span>]</span><br><span class="line">print(dic1 == dic2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较Int?</span></span><br><span class="line">let age1 = dic1[<span class="string">&quot;age&quot;</span>]</span><br><span class="line">let age2 = dic2[<span class="string">&quot;age&quot;</span>]</span><br><span class="line">print(age1 == age2)</span><br></pre></td></tr></table></figure>

<ul>
<li>在这些实例中, 我们用<code>==</code>测试相等性, 在Swift4.0中, <code>Int</code>类型遵循<code>Equatable</code>协议, 可以比较, 但是<code>Int?</code>类型却没有遵循<code>Equatable</code>协议</li>
<li>但是在Swift4.1中, 完美的解决了这个问题, 上述代码可比那已通过, 且都输出: <code>true</code></li>
<li>在<code>Swift 4.0</code>中<code>[Set&lt;Int&gt;]</code>之间可以直接对比，但是<code>[[Int]]</code>不能。现在<code>Swift 4.1</code>中，<code>[[Int]]</code>也能直接对比</li>
<li>总的来说，<code>Swift 4.1</code>的<code>Array</code>、<code>Dictionary</code>和<code>Optional</code>，只要他们的元素都遵循了<code>Equatable</code>和<code>Hashable</code>，那么他们也遵循<code>Equatable</code>和<code>Hashable</code></li>
</ul>
<h4 id="合成-Equatable-和-Hashable"><a href="#合成-Equatable-和-Hashable" class="headerlink" title="合成 Equatable 和 Hashable"></a>合成 <code>Equatable</code> 和 <code>Hashable</code></h4><ul>
<li>如果对象相等，则这两个对象的 <code>hash</code> 值一定相等</li>
<li>如果两个对象 <code>hash</code> 值相等，这两个对象不一定相等。</li>
<li><code>Swift</code> 中 <code>Hashable</code> 一定是 <code>Equatable</code>，因为前者继承了后者。<br>在<code>Swift 4</code>中，若遵循<code>Equatable</code>协议的时候，我们必须实现<code>Equatable</code>协议的<code>==</code>方法, <code>Equatable</code>协议如下:</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">public protocol Equatable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Returns a Boolean value indicating whether two values are equal.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// Equality is the inverse of inequality. For any values `a` and `b`,</span></span><br><span class="line">    <span class="comment">/// `a == b` implies that `a != b` is `false`.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// - Parameters:</span></span><br><span class="line">    <span class="comment">///   - lhs: A value to compare.</span></span><br><span class="line">    <span class="comment">///   - rhs: Another value to compare.</span></span><br><span class="line">    public <span class="keyword">static</span> func == (lhs: Self, rhs: Self) -&gt; Bool</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Swift4.0中, 必须实现<code>Equatable</code>协议的方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> Name: Equatable &#123;</span><br><span class="line">    var name1 = <span class="string">&quot;name1&quot;</span></span><br><span class="line">    var name2 = <span class="string">&quot;name2&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> func == (lhs: Name, rhs: Name) -&gt; Bool &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.name1 == rhs.name1 &amp;&amp;</span><br><span class="line">            lhs.name2 == rhs.name2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>Swift 4.1</code>，只需要加上<code>Equatable</code>即可, 不需要实现任何协议方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> Name: Equatable &#123;</span><br><span class="line">    var name1 = <span class="string">&quot;name1&quot;</span></span><br><span class="line">    var name2 = <span class="string">&quot;name2&quot;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JSON编码时支持Camel-Case和Snake-Case之间的转换"><a href="#JSON编码时支持Camel-Case和Snake-Case之间的转换" class="headerlink" title="JSON编码时支持Camel Case和Snake Case之间的转换"></a><code>JSON</code>编码时支持<code>Camel Case</code>和<code>Snake Case</code>之间的转换</h4><ul>
<li><code>Swift 4.0</code>引入了<code>Codable</code>，但是有个麻烦的问题：如果<code>JSON</code>数据的<code>key</code>命名格式是<code>snake_case</code>的话，我们必须创建自己的<code>CodingKeys</code>来告诉苹果怎么转换。在<code>Swift 4.0</code>中</li>
<li>但是在<code>Swift 4.1</code>中，苹果给<code>JSONDecoder</code>引入了一个属性<code>keyDecodingStrategy</code>；对应的<code>JSONEncoder</code>引入了一个属性<code>keyEncodingStrategy</code>。这样我们就不需要设置定义<code>CodingKeys</code>了。只需要在<code>decoding</code>的时候把<code>keyDecodingStrategy</code>设置为<code>.convertFromSnakeCase</code>；在<code>encoding</code>的时候把<code>keyEncodingStrategy</code>设置为<code>.convertToSnakeCase</code></li>
<li>下面是分别针对数组&#x2F;字典&#x2F;集合的解析形式</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> Student: Codable, Hashable &#123;</span><br><span class="line">  let firstName: String</span><br><span class="line">  let averageGrade: Int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let cosmin = Student(firstName: <span class="string">&quot;Cosmin&quot;</span>, averageGrade: <span class="number">10</span>)</span><br><span class="line">let george = Student(firstName: <span class="string">&quot;George&quot;</span>, averageGrade: <span class="number">9</span>)</span><br><span class="line">let encoder = JSONEncoder()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Encode an Array of students</span></span><br><span class="line">let students = [cosmin, george]</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  try encoder.encode(students)</span><br><span class="line">&#125; catch &#123;</span><br><span class="line">  print(<span class="string">&quot;Failed encoding students array: \(error)&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Encode a Dictionary with student values</span></span><br><span class="line">let studentsDictionary = [<span class="string">&quot;Cosmin&quot;</span>: cosmin, <span class="string">&quot;George&quot;</span>: george]</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  try encoder.encode(studentsDictionary)</span><br><span class="line">&#125; catch &#123;</span><br><span class="line">  print(<span class="string">&quot;Failed encoding students dictionary: \(error)&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Encode a Set of students</span></span><br><span class="line">let studentsSet: Set = [cosmin, george]</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  try encoder.encode(studentsSet)</span><br><span class="line">&#125; catch &#123;</span><br><span class="line">  print(<span class="string">&quot;Failed encoding students set: \(error)&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Encode an Optional Student</span></span><br><span class="line">let optionalStudent: Student? = cosmin</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  try encoder.encode(optionalStudent)</span><br><span class="line">&#125; catch &#123;</span><br><span class="line">  print(<span class="string">&quot;Failed encoding optional student: \(error)&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Hashable-Index-Types-哈希化索引"><a href="#Hashable-Index-Types-哈希化索引" class="headerlink" title="Hashable Index Types(哈希化索引)"></a><code>Hashable Index Types</code>(哈希化索引)</h4><p>扩展 <code>Key-path</code> 表达式在标准库中的使用范围。让标准库中所有的索引类型都符合 <code>Hashable</code> 协议，这样，<code>[Int]</code>、<code>String</code> 和所有其它标准集合使用 <code>key-path</code> 下标时，表现都是一样的</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">let swiftString2 = <span class="string">&quot;one two three&quot;</span></span><br><span class="line">let charact1 = \String.[swiftString2.startIndex]</span><br><span class="line">print(swiftString2[keyPath: charact1])</span><br><span class="line"></span><br><span class="line">let arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">let value2 = \[Int].[<span class="number">1</span>]</span><br><span class="line">print(arr[keyPath: value2])</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果:</span></span><br><span class="line">o</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<h4 id="compactMap的用法"><a href="#compactMap的用法" class="headerlink" title="compactMap的用法"></a><code>compactMap</code>的用法</h4><p>在<code>Swift 4.0</code>中，我们经常使用<code>flatMap</code>来过滤<code>nil</code>，也可以进行降维操作, 详情可参考<a href="https://www.titanjun.top/2017/05/19/Swift%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/">Swift函数式编程之高级用法</a></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">let arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="literal">nil</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="literal">nil</span>]</span><br><span class="line">let arr1 = arr.flatMap(&#123; $<span class="number">0</span> &#125;)</span><br><span class="line">print(arr1)</span><br><span class="line"></span><br><span class="line"><span class="comment">//这样使用会有类似的警告</span></span><br><span class="line"><span class="string">&#x27;flatMap&#x27;</span> is deprecated: Please use compactMap(_:) <span class="keyword">for</span> the <span class="keyword">case</span> where closure returns an optional value</span><br><span class="line">Use <span class="string">&#x27;compactMap(_:)&#x27;</span> instead</span><br><span class="line"></span><br><span class="line"><span class="comment">//Swift4.1中的用法</span></span><br><span class="line">let arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="literal">nil</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="literal">nil</span>]</span><br><span class="line">let arr2 = arr.compactMap(&#123; $<span class="number">0</span> &#125;)</span><br><span class="line">print(arr2)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>主要是因为在<code>Swift4.0</code>中<code>flatMap</code>有很多重载, 可能会引起歧义, 所以在<code>Swift4.1</code>中把<code>flatMap</code>重命名为<code>compactMap</code></p>
</blockquote>
<h4 id="除了协议中的-weak-和-unowned。"><a href="#除了协议中的-weak-和-unowned。" class="headerlink" title="除了协议中的 weak 和 unowned。"></a>除了协议中的 weak 和 unowned。</h4><ul>
<li>当你在<code>Tune</code>协议中定义了两个属性<code>key</code>和<code>pitch</code>, <code>pitch</code>可能为<code>nil</code>, 所以你在协议中可以用<code>weak</code>修饰</li>
<li>但是如果在协议本身中定义的话，<code>weak</code>和<code>unowned</code>都没有实际意义, 所以在<code>Swift4.1</code>中就已经去掉了这些关键字, 并且在协议中使用这些关键字将会爆出警告</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Key &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> Pitch &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Swift 4</span></span><br><span class="line">protocol Tune &#123;</span><br><span class="line">    unowned var key: Key &#123; get set &#125;</span><br><span class="line">    <span class="keyword">weak</span> var pitch: Pitch? &#123; get set &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Swift 4.1</span></span><br><span class="line">protocol Tune &#123;</span><br><span class="line">    var key: Key &#123; get set &#125;</span><br><span class="line">    var pitch: Pitch? &#123; get set &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="UnsafeMutableBufferPointer的改变"><a href="#UnsafeMutableBufferPointer的改变" class="headerlink" title="UnsafeMutableBufferPointer的改变"></a><code>UnsafeMutableBufferPointer</code>的改变</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Swift4.0</span></span><br><span class="line">let buffer = UnsafeMutableBufferPointer&lt;Int&gt;(start: UnsafeMutablePointer&lt;Int&gt;.allocate(capacity: <span class="number">10</span>),</span><br><span class="line">                                             count: <span class="number">10</span>)</span><br><span class="line">let mutableBuffer = UnsafeMutableBufferPointer(start: UnsafeMutablePointer(mutating: buffer.baseAddress),</span><br><span class="line">                                               count: buffer.count)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Swift4.1</span></span><br><span class="line">let buffer = UnsafeMutableBufferPointer&lt;Int&gt;.allocate(capacity: <span class="number">10</span>)</span><br><span class="line">let mutableBuffer = UnsafeMutableBufferPointer(mutating: UnsafeBufferPointer(buffer))</span><br></pre></td></tr></table></figure>

<blockquote>
<p>相对<code>Swift4.0</code>的改变, <code>Swift4.1</code>这点改变键值太微不足道了, 传说中<code>Swift5</code>的<code>API</code>会趋于稳定, 但是估计改变可能也是非常大的, 坐等<code>Swift5</code>发布…</p>
</blockquote>
<h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4><ul>
<li><a href="https://www.raywenderlich.com/187826/whats-new-in-swift-4-1">What’s New in Swift 4.1?</a></li>
</ul>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift4.0新特性之String和Array和Dictionary</title>
    <url>/post/c2889347.html</url>
    <content><![CDATA[<blockquote>
<ul>
<li>推荐: <a href="https://www.cnswift.org/">Swift 编程语言</a></li>
<li>原文链接: <a href="https://www.raywenderlich.com/163857/whats-new-swift-4">What’s New in Swift 4?</a></li>
<li>Guards翻译组: <a href="http://www.jianshu.com/p/3bedf1de5cb3">中文地址</a></li>
<li>Swift 4是苹果计划在2017年秋季推出的最新版本，值得关注的是其提供了与Swift 3代码很好的兼容性，并最大限度的保持了ABI稳定性.</li>
</ul>
</blockquote>
<span id="more"></span>

<hr>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><blockquote>
<p>字符串已经像之前的2.0版一样, 改为了Collection类型 。此变化消除了字符串对字符数组的依赖</p>
</blockquote>
<h3 id="创建空字符串的两种方式-可用isEmpty判断是否为空"><a href="#创建空字符串的两种方式-可用isEmpty判断是否为空" class="headerlink" title="创建空字符串的两种方式,可用isEmpty判断是否为空"></a>创建空字符串的两种方式,可用isEmpty判断是否为空</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">let SwiftString = <span class="string">&quot;Hello&quot;</span></span><br><span class="line">var emptyString = <span class="string">&quot;&quot;</span>               <span class="comment">// empty string literal</span></span><br><span class="line">var anotherEmptyString = String()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="字符和字符串"><a href="#字符和字符串" class="headerlink" title="字符和字符串"></a>字符和字符串</h3><h4 id="遍历字符串"><a href="#遍历字符串" class="headerlink" title="遍历字符串"></a>遍历字符串</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="type">char</span> <span class="keyword">in</span> SwiftString &#123;</span><br><span class="line">    print(<span class="type">char</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="通过-Character类型创建单个字符"><a href="#通过-Character类型创建单个字符" class="headerlink" title="通过 Character类型创建单个字符"></a>通过 Character类型创建单个字符</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">let <span class="type">char</span> : Character = <span class="string">&quot;H&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="String值可以通过传入-Character来构造："><a href="#String值可以通过传入-Character来构造：" class="headerlink" title="String值可以通过传入 Character来构造："></a>String值可以通过传入 Character来构造：</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">let charArr : [Character] = [<span class="string">&quot;H&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;l&quot;</span>, <span class="string">&quot;l&quot;</span>, <span class="string">&quot;o&quot;</span>]</span><br><span class="line">print(String(<span class="type">char</span>)) <span class="comment">// H</span></span><br><span class="line">print(String(charArr)) <span class="comment">// Hello</span></span><br></pre></td></tr></table></figure>

<h4 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a>拼接字符串</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式一:</span></span><br><span class="line">let addString = String(charArr) + String(<span class="type">char</span>) <span class="comment">//HelloH</span></span><br><span class="line"><span class="comment">//方式二:</span></span><br><span class="line">var addString2 = <span class="string">&quot;Why&quot;</span></span><br><span class="line">addString2 += String(charArr) <span class="comment">//&quot;WhyHello&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串个数"><a href="#字符串个数" class="headerlink" title="字符串个数"></a>字符串个数</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">let count1 = SwiftString.count <span class="comment">//5(类型: String.CharacterView.IndexDistance)</span></span><br><span class="line">let count2 = SwiftString.characters.count <span class="comment">// 5(Int型)</span></span><br><span class="line">count1:</span><br></pre></td></tr></table></figure>

<h3 id="是否为空"><a href="#是否为空" class="headerlink" title="是否为空"></a>是否为空</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">let isStr = SwiftString.isEmpty <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h3 id="去掉某一个或几个字符"><a href="#去掉某一个或几个字符" class="headerlink" title="去掉某一个或几个字符"></a>去掉某一个或几个字符</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">let text1 = SwiftString.dropFirst()<span class="comment">//&quot;ello&quot;</span></span><br><span class="line">let text2 = SwiftString.dropLast()<span class="comment">//&quot;Hell&quot;</span></span><br><span class="line">let text3 = SwiftString.dropFirst(<span class="number">2</span>)<span class="comment">//&quot;llo&quot;</span></span><br><span class="line">let text4 = SwiftString.dropLast(<span class="number">2</span>)<span class="comment">//&quot;Hel&quot;</span></span><br><span class="line"><span class="comment">//注:以上皆为String.SubSequence类型</span></span><br><span class="line">let text5 = String(text1) <span class="comment">//&quot;ello&quot;---text5为String类型</span></span><br></pre></td></tr></table></figure>

<h3 id="倒叙"><a href="#倒叙" class="headerlink" title="倒叙"></a>倒叙</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">let text6 = String(SwiftString.reversed()) <span class="comment">//&quot;olleH&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串分割数组"><a href="#字符串分割数组" class="headerlink" title="字符串分割数组"></a>字符串分割数组</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">let swiftString2 = <span class="string">&quot;one two three&quot;</span></span><br><span class="line">let StrArr = swiftString2.split(separator: <span class="string">&quot; &quot;</span>) <span class="comment">//[&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]</span></span><br><span class="line"><span class="comment">//let StrArr: [String.SubSequence]</span></span><br></pre></td></tr></table></figure>

<h3 id="删除不符合ASCII编码的字符"><a href="#删除不符合ASCII编码的字符" class="headerlink" title="删除不符合ASCII编码的字符"></a>删除不符合ASCII编码的字符</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">let swiftString3 = <span class="string">&quot;quanjun 🐷,&quot;</span></span><br><span class="line">let qj = swiftString3.filter &#123; (<span class="type">char</span>) -&gt; Bool <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> <span class="type">char</span>.unicodeScalars.reduce(<span class="literal">true</span>, &#123; $<span class="number">0</span> &amp;&amp; $<span class="number">1.</span>isASCII &#125;)</span><br><span class="line">&#125;</span><br><span class="line">print(qj)  <span class="comment">//&quot;quanjun ,&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串索引"><a href="#字符串索引" class="headerlink" title="字符串索引"></a>字符串索引</h3><ul>
<li>Swift 的字符串不能通过整数值索引</li>
<li>使用 index(before:) 和 index(after:) 方法来访问给定索引的前后。要访问给定索引更远的索引，你可以使用 index(_:offsetBy:) 方法而不是多次调用这两个方法。</li>
<li>Swift 4添加了Substring类型，用于引用String的子序列。</li>
<li>String和Substring都实现了StringProtocol，两者几乎具有相同的功能：</li>
</ul>
<h4 id="startIndex和endIndex"><a href="#startIndex和endIndex" class="headerlink" title="startIndex和endIndex"></a>startIndex和endIndex</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let greeting = &quot;Guten Tag!&quot;</span><br><span class="line">//startIndex属性来访问 String中第一个 Character的位置</span><br><span class="line">print(greeting[greeting.startIndex])</span><br><span class="line">print(greeting[greeting.index(after: greeting.startIndex)])</span><br><span class="line">//endIndex属性就是 String中最后一个字符后的位置。endIndex属性并不是字符串下标脚本的合法实际参数</span><br><span class="line">//greeting[greeting.endIndex] //会报错</span><br><span class="line">print(greeting[greeting.index(before: greeting.endIndex)])</span><br><span class="line">//注: 如果 String为空，则 startIndex与 endIndex相等</span><br><span class="line"></span><br><span class="line">let index = greeting.index(greeting.startIndex, offsetBy: 2)</span><br><span class="line">print(greeting[index])</span><br><span class="line">let indesString = greeting[greeting.startIndex...index]  //&quot;Gut&quot;</span><br><span class="line">//注:indesString : Substring类型</span><br><span class="line">print(String(indesString)) //&quot;Gut&quot;</span><br></pre></td></tr></table></figure>

<h4 id="使用-characters属性的-indices属性来创建所有能够用来访问字符串中独立字符的索引范围-Range。"><a href="#使用-characters属性的-indices属性来创建所有能够用来访问字符串中独立字符的索引范围-Range。" class="headerlink" title="使用 characters属性的 indices属性来创建所有能够用来访问字符串中独立字符的索引范围 Range。"></a>使用 characters属性的 indices属性来创建所有能够用来访问字符串中独立字符的索引范围 Range。</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> greeting.characters.indices &#123;</span><br><span class="line">    print(<span class="string">&quot;\(greeting[index]) &quot;</span>, terminator: <span class="string">&quot;&quot;</span>)<span class="comment">//不换行输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a>多行字符串</h3><ul>
<li>注:你可以在多行字面量中使用单个双引号 “ 。要在多行字符串中包含 “”” ，你必须用反斜杠（ \ ）转义至少其中一个双引号</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">let rowsString = <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">                我是一只小鸭子</span></span><br><span class="line"><span class="string">                咿呀咿呀哟</span></span><br><span class="line"><span class="string">                \&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">                &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">print(rowsString)</span><br></pre></td></tr></table></figure>

<h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><ul>
<li>Swift 的 Array类型被桥接到了基础框架的 NSArray类上。</li>
<li>Swift 数组的类型完整写法是 Array<Element>， Element是数组允许存入的值的类型。你同样可以简写数组的类型为 [Element]。</li>
</ul>
<h3 id="创建确定大小且元素都设定为相同默认值的数组。"><a href="#创建确定大小且元素都设定为相同默认值的数组。" class="headerlink" title="创建确定大小且元素都设定为相同默认值的数组。"></a>创建确定大小且元素都设定为相同默认值的数组。</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*Array*/</span></span><br><span class="line"><span class="comment">//默认值（叫做 repeating）和新数组元素的数量（叫做 count)</span></span><br><span class="line">var array1 = Array(repeating: <span class="number">1</span>, count: <span class="number">2</span>)</span><br><span class="line">var array2 = Array(repeating: <span class="number">3</span>, count: <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h3 id="连接两个数组来创建数组-类型必须一致"><a href="#连接两个数组来创建数组-类型必须一致" class="headerlink" title="连接两个数组来创建数组(类型必须一致)"></a>连接两个数组来创建数组(类型必须一致)</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">var array3 = array1 + array2</span><br><span class="line">print(array3) <span class="comment">//[1, 1, 3, 3]</span></span><br></pre></td></tr></table></figure>

<h3 id="数组个数"><a href="#数组个数" class="headerlink" title="数组个数"></a>数组个数</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">print(array3.count)  <span class="comment">//5</span></span><br></pre></td></tr></table></figure>

<h3 id="判断数组个数是否为0"><a href="#判断数组个数是否为0" class="headerlink" title="判断数组个数是否为0"></a>判断数组个数是否为0</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">print(array3.isEmpty)  <span class="comment">//false</span></span><br><span class="line">print(array3.count == <span class="number">0</span>)  <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h3 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">array3.append(<span class="number">4</span>) <span class="comment">//[1, 1, 3, 3, 4]</span></span><br><span class="line">array3 += [<span class="number">5</span>]  <span class="comment">//[1, 1, 3, 3, 4, 5]</span></span><br><span class="line">array3 += [<span class="number">6</span>, <span class="number">5</span>]  <span class="comment">//[1, 1, 3, 3, 4, 5, 6, 5]</span></span><br></pre></td></tr></table></figure>

<h3 id="取值"><a href="#取值" class="headerlink" title="取值"></a>取值</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">print(array3[<span class="number">0</span>]) <span class="comment">// 1</span></span><br><span class="line">array3[<span class="number">1</span>] = <span class="number">9</span> <span class="comment">// [1, 9, 3, 3, 4, 5, 6, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用下标改变一个范围的值，就算替换与范围长度不同的值的合集也行</span></span><br><span class="line">array3[<span class="number">2.</span>.<span class="number">.4</span>] = [<span class="number">0</span>, <span class="number">8</span>] <span class="comment">//[1, 9, 0, 8, 5, 6, 5]</span></span><br></pre></td></tr></table></figure>
<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> array3 &#123;</span><br><span class="line">    print(item)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//元组输出</span></span><br><span class="line"><span class="keyword">for</span> (index, item) <span class="keyword">in</span> array3.enumerated() &#123;</span><br><span class="line">    print(<span class="string">&quot;\(index)---\(item)&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//倒叙输出</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> array3.reversed() &#123;</span><br><span class="line">    print(item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//forEach遍历,如同for-in</span></span><br><span class="line">let arr = [<span class="number">1</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">5</span>]</span><br><span class="line">arr.forEach &#123; (x) <span class="keyword">in</span></span><br><span class="line">    print(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除和插入"><a href="#删除和插入" class="headerlink" title="删除和插入"></a>删除和插入</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">array3.remove(at: <span class="number">1</span>)  <span class="comment">//[1, 0, 8, 5, 6, 5]</span></span><br><span class="line">array3.removeFirst()  <span class="comment">//[0, 8, 5, 6, 5]</span></span><br><span class="line">array3.removeLast()   <span class="comment">//[0, 8, 5, 6]</span></span><br><span class="line">array3.removeFirst(<span class="number">2</span>) <span class="comment">//[5,6]</span></span><br><span class="line">array3.removeLast(<span class="number">1</span>)  <span class="comment">//[5]</span></span><br><span class="line">array3.removeAll()    <span class="comment">//[]</span></span><br></pre></td></tr></table></figure>

<h3 id="获取元素在数组中的索引"><a href="#获取元素在数组中的索引" class="headerlink" title="获取元素在数组中的索引"></a>获取元素在数组中的索引</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr <span class="operator">=</span> [<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;4&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;6&quot;</span>, <span class="string">&quot;2&quot;</span>]</span><br><span class="line"><span class="comment">//获取最后一个元素索引</span></span><br><span class="line"><span class="keyword">let</span> index0 <span class="operator">=</span> arr.endIndex           <span class="comment">//6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取第一个元素索引</span></span><br><span class="line"><span class="keyword">let</span> index1 <span class="operator">=</span> arr.startIndex         <span class="comment">//0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取指定某元素索引</span></span><br><span class="line"><span class="keyword">let</span> index2 <span class="operator">=</span> arr.index(of: <span class="string">&quot;3&quot;</span>)     <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当数组中有多个相同元素时, 返回指定元素的第一个的索引</span></span><br><span class="line"><span class="keyword">let</span> index3 <span class="operator">=</span> arr.index(of: <span class="string">&quot;2&quot;</span>)     <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回指定某索引的后一个索引, 等同于4+1</span></span><br><span class="line"><span class="keyword">let</span> index4 <span class="operator">=</span> arr.index(after: <span class="number">4</span>)    <span class="comment">//5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回指定某索引的前一个索引, 等同于4-1</span></span><br><span class="line"><span class="keyword">let</span> index5 <span class="operator">=</span> arr.index(before: <span class="number">8</span>)   <span class="comment">//7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//根据元素内的某属性获取索引</span></span><br><span class="line"><span class="keyword">let</span> strArr <span class="operator">=</span> [(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;1&quot;</span>), (<span class="string">&quot;b&quot;</span>, <span class="string">&quot;2&quot;</span>), (<span class="string">&quot;s&quot;</span>, <span class="string">&quot;3&quot;</span>)]</span><br><span class="line"><span class="keyword">let</span> index <span class="operator">=</span> strArr.index(where: &#123; <span class="variable">$0</span>.<span class="number">0</span> <span class="operator">==</span> <span class="string">&quot;b&quot;</span> &#125;)</span><br><span class="line"><span class="comment">//返回值是一个可选值: Optional(1)</span></span><br></pre></td></tr></table></figure>

<h2 id="Dictionary-and-Set"><a href="#Dictionary-and-Set" class="headerlink" title="Dictionary and Set"></a>Dictionary and Set</h2><ul>
<li>至于Collection类型，Set和Dictionary并不那么最直观的</li>
<li>Swift 的 Dictionary桥接到了基础框架的 NSDictionary类。</li>
</ul>
<h3 id="首先列表可以是从一系列键值对（元组）创建一个字典"><a href="#首先列表可以是从一系列键值对（元组）创建一个字典" class="headerlink" title="首先列表可以是从一系列键值对（元组）创建一个字典:"></a>首先列表可以是从一系列键值对（元组）创建一个字典:</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Dictionary</span></span><br><span class="line">let keyNames = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>]</span><br><span class="line">let valueNames = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">//public init&lt;S&gt;(uniqueKeysWithValues keysAndValues: S) where S : Sequence, S.Element == (Key, Value)</span></span><br><span class="line"><span class="comment">//对于该方法的具体解释,可以点进去看一下官方的讲解</span></span><br><span class="line">let nameDic = Dictionary(uniqueKeysWithValues: zip(keyNames, valueNames))</span><br><span class="line">print(nameDic)</span><br><span class="line"><span class="comment">//[&quot;b&quot;: 2, &quot;e&quot;: 6, &quot;a&quot;: 1, &quot;d&quot;: 5, &quot;c&quot;: 4]</span></span><br></pre></td></tr></table></figure>

<h3 id="在初始化Dictionary时-你现在可以使用你喜欢的方式来处理重复的键-同时避免覆盖键值对，且不会出现任何问题："><a href="#在初始化Dictionary时-你现在可以使用你喜欢的方式来处理重复的键-同时避免覆盖键值对，且不会出现任何问题：" class="headerlink" title="在初始化Dictionary时, 你现在可以使用你喜欢的方式来处理重复的键,同时避免覆盖键值对，且不会出现任何问题："></a>在初始化Dictionary时, 你现在可以使用你喜欢的方式来处理重复的键,同时避免覆盖键值对，且不会出现任何问题：</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">let keyNames2 = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">//public init&lt;S&gt;(_ keysAndValues: S, uniquingKeysWith combine: (Value, Value) throws -&gt; Value) rethrows where S : Sequence, S.Element == (Key, Value)</span></span><br><span class="line"><span class="comment">//对于该方法的具体解释,可以点进去看一下官方的讲解</span></span><br><span class="line">let nameDic2 = Dictionary(zip(keyNames2, repeatElement(<span class="number">1</span>, count: keyNames2.count)), uniquingKeysWith: +)</span><br><span class="line">print(nameDic2)</span><br><span class="line"><span class="comment">//[&quot;b&quot;: 2, &quot;a&quot;: 2, &quot;c&quot;: 1]</span></span><br></pre></td></tr></table></figure>


<h3 id="Dictionary-和-Set现在都可以将结果-通过filter函数-过滤到原始类型的新对象中："><a href="#Dictionary-和-Set现在都可以将结果-通过filter函数-过滤到原始类型的新对象中：" class="headerlink" title="Dictionary 和 Set现在都可以将结果 通过filter函数 过滤到原始类型的新对象中："></a>Dictionary 和 Set现在都可以将结果 通过filter函数 过滤到原始类型的新对象中：</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">let nameDic3 = nameDic.filter(&#123; $<span class="number">0.</span>value &lt; <span class="number">5</span> &#125;)</span><br><span class="line">print(nameDic3)</span><br><span class="line"><span class="comment">//[&quot;b&quot;: 2, &quot;a&quot;: 1, &quot;c&quot;: 4]</span></span><br></pre></td></tr></table></figure>

<h3 id="Dictionary为直接映射其值提供了一种非常有用的方法-："><a href="#Dictionary为直接映射其值提供了一种非常有用的方法-：" class="headerlink" title="Dictionary为直接映射其值提供了一种非常有用的方法:："></a>Dictionary为直接映射其值提供了一种非常有用的方法:：</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将value值Int转化为字符串</span></span><br><span class="line">let nameDic4 = nameDic3.mapValues(&#123; <span class="string">&quot;\($0)&quot;</span> &#125;)</span><br><span class="line">print(nameDic4)</span><br><span class="line"><span class="comment">//[&quot;b&quot;: &quot;2&quot;, &quot;a&quot;: &quot;1&quot;, &quot;c&quot;: &quot;4&quot;]</span></span><br></pre></td></tr></table></figure>

<h3 id="在Dictionary上访问某个值时，常见的做法是使用nil-coalescing-operator给出默认值"><a href="#在Dictionary上访问某个值时，常见的做法是使用nil-coalescing-operator给出默认值" class="headerlink" title="在Dictionary上访问某个值时，常见的做法是使用nil-coalescing operator给出默认值"></a>在Dictionary上访问某个值时，常见的做法是使用nil-coalescing operator给出默认值</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">let nameDic5 = nameDic4[<span class="string">&quot;d&quot;</span>, <span class="keyword">default</span> : <span class="string">&quot;unknown&quot;</span>]</span><br></pre></td></tr></table></figure>

<h3 id="我们可以从Sequence”中初始化Dictionary，并将其分组为bucket-："><a href="#我们可以从Sequence”中初始化Dictionary，并将其分组为bucket-：" class="headerlink" title="我们可以从Sequence”中初始化Dictionary，并将其分组为bucket:："></a>我们可以从Sequence”中初始化Dictionary，并将其分组为bucket:：</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注: 当通过特定模式对数据进行分组时，这相当方便。</span></span><br><span class="line">let name2 = [<span class="string">&quot;Proxima&quot;</span>, <span class="string">&quot;Centauri A&quot;</span>, <span class="string">&quot;Centauri B&quot;</span>, <span class="string">&quot;Barnard&quot;</span>, <span class="string">&quot;Wolf&quot;</span>]</span><br><span class="line">let nameDic6 = Dictionary(grouping: name2, by: &#123; $<span class="number">0.</span>first! &#125;)</span><br><span class="line">print(nameDic6)</span><br><span class="line"><span class="comment">//[&quot;B&quot;: [&quot;Barnard&quot;], &quot;W&quot;: [&quot;Wolf&quot;], &quot;P&quot;: [&quot;Proxima&quot;], &quot;C&quot;: [&quot;Centauri A&quot;, &quot;Centauri B&quot;]]</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>涉及Zip的用法,详见<a href="http://www.jianshu.com/p/8c39bbacceb2">Swift语法之Zip详解</a></p>
</blockquote>
<h3 id="预留空间"><a href="#预留空间" class="headerlink" title="预留空间"></a>预留空间</h3><ul>
<li>Sequence和Dictionary现在都具有明确保留容量的能力</li>
<li>在这些类型上，Reallocation可能是一项代价高昂的任务。</li>
<li>如果你知道需要存储的数据量时, 使用reserveCapacity(_:)可以提高性能且便捷</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">var name3 : [String : Int] = [ : ]</span><br><span class="line">print(name3.capacity) <span class="comment">// 0</span></span><br><span class="line">name3.reserveCapacity(<span class="number">10</span>) <span class="comment">//储备 10元素的能力</span></span><br><span class="line">print(name3.capacity) <span class="comment">// 12</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>SwiftLint代码规范属性说明01</title>
    <url>/post/4a241a51.html</url>
    <content><![CDATA[<blockquote>
<p>下面来具体介绍一下SwiftLint的具体的代码规则的相关说明</p>
<ul>
<li><a href="https://github.com/github/swift-style-guide">Github 公布的 Swift 代码规范–原文</a></li>
<li><a href="https://github.com/Artwalk/swift-style-guide/blob/master/README_CN.md">Github 公布的 Swift 代码规范–中文</a></li>
<li><a href="https://github.com/realm/SwiftLint/blob/master/Rules.md">官方的SwiftLint规则说明</a></li>
</ul>
</blockquote>
<span id="more"></span>


<h3 id="规则1-closing-brace"><a href="#规则1-closing-brace" class="headerlink" title="规则1: closing_brace"></a>规则1: closing_brace</h3><p>在使用Swift 3.2或更高版本时，首选系统的KVO 的API和keypath</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>block_based_kvo</td>
<td>启用</td>
<td>no</td>
<td>idiomatic</td>
</tr>
</tbody></table>
<p>官方示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//编译通过</span></span><br><span class="line">let observer = foo.observe(\.value, options: [.new]) &#123; (foo, change) <span class="keyword">in</span></span><br><span class="line">   print(change.newValue)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//会触发警告</span></span><br><span class="line"><span class="keyword">class</span> Foo: <span class="built_in">NSObject</span> &#123;</span><br><span class="line">   override func observeValue(forKeyPath keyPath: String?, of object: Any?,</span><br><span class="line">                               change: [<span class="built_in">NSKeyValueChangeKey</span> : Any]?,</span><br><span class="line">                               context: UnsafeMutableRawPointer?) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="规则2-class-delegate-protocol"><a href="#规则2-class-delegate-protocol" class="headerlink" title="规则2: class_delegate_protocol"></a>规则2: class_delegate_protocol</h3><p>委托协议应该只是class类，可以被弱引用(官方解释,先放出官方示例吧)</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>class_delegate_protocol</td>
<td>启用</td>
<td>no</td>
<td>lint</td>
</tr>
</tbody></table>
<p>示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不会触发warning</span></span><br><span class="line">protocol FooDelegate: <span class="keyword">class</span> &#123;&#125;</span><br><span class="line">protocol FooDelegate: <span class="keyword">class</span>, BarDelegate &#123;&#125;</span><br><span class="line">protocol Foo &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> FooDelegate &#123;&#125;</span><br><span class="line">@objc protocol FooDelegate &#123;&#125;</span><br><span class="line">@objc(MyFooDelegate)</span><br><span class="line">protocol FooDelegate &#123;&#125;</span><br><span class="line">protocol FooDelegate: BarDelegate &#123;&#125;</span><br><span class="line">protocol FooDelegate: AnyObject &#123;&#125;</span><br><span class="line">protocol FooDelegate: <span class="built_in">NSObjectProtocol</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//会触发warning</span></span><br><span class="line">protocol FooDelegate &#123;&#125;</span><br><span class="line">protocol FooDelegate: Bar &#123;&#125;</span><br></pre></td></tr></table></figure>


<h3 id="规则3-closing-brace"><a href="#规则3-closing-brace" class="headerlink" title="规则3: closing_brace"></a>规则3: closing_brace</h3><p>类似小括号包含大括号的不能用空格</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>closing_brace</td>
<td>启用</td>
<td>yes</td>
<td>style</td>
</tr>
</tbody></table>
<p>具体示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不会触发warning</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>].map(&#123; $<span class="number">0</span> &#125;)</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>].map(</span><br><span class="line">  &#123; $<span class="number">0</span> &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//会触发warning</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>].map(&#123; $<span class="number">0</span> &#125; )</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>].map(&#123; $<span class="number">0</span> &#125;   )</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>].map( &#123; $<span class="number">0</span> &#125;)</span><br></pre></td></tr></table></figure>

<h3 id="规则4-closure-end-indentation"><a href="#规则4-closure-end-indentation" class="headerlink" title="规则4: closure_end_indentation"></a>规则4: closure_end_indentation</h3><p>闭包的封闭端和开始端有相同的缩进, 意思就是 大括号（一般是方法）上下对齐的问题，这样使code看起来更加整洁</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>closure_end_indentation</td>
<td>未启用</td>
<td>no</td>
<td>style</td>
</tr>
</tbody></table>
<p>具体示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不会触发closure_end_indentation</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>].map &#123; $<span class="number">0</span> + <span class="number">1</span> &#125;</span><br><span class="line"><span class="comment">//不会触发closure_end_indentation</span></span><br><span class="line">SignalProducer(values: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">   .startWithNext &#123; number <span class="keyword">in</span></span><br><span class="line">       print(number)</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//不会触发closure_end_indentation</span></span><br><span class="line">function &#123;</span><br><span class="line">    ..........</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//会触发closure_end_indentation</span></span><br><span class="line">SignalProducer(values: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">   .startWithNext &#123; number <span class="keyword">in</span></span><br><span class="line">       print(number)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不会触发closure_end_indentation</span></span><br><span class="line">function &#123;</span><br><span class="line">    ..........</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="规则5-closure-parameter-position"><a href="#规则5-closure-parameter-position" class="headerlink" title="规则5: closure_parameter_position"></a>规则5: closure_parameter_position</h3><p>闭包参数位置， 闭包参数应该和大括号左边在同一行, 推荐使用</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>closure_parameter_position</td>
<td>启用</td>
<td>no</td>
<td>style</td>
</tr>
</tbody></table>
<p>具体示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// number 和 &#123; 在同一行, 不会触发warning</span></span><br><span class="line">let names = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">names.forEach &#123; (number) <span class="keyword">in</span></span><br><span class="line">    print(number)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let names = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">names.map &#123; number <span class="keyword">in</span></span><br><span class="line">    number + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 这样不行，违背 closure_parameter_position规则, 触发warning</span></span><br><span class="line">let names = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">names.forEach &#123; </span><br><span class="line">    (number) <span class="keyword">in</span></span><br><span class="line">    print(number)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> let names = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"> names.map &#123;</span><br><span class="line">     number <span class="keyword">in</span></span><br><span class="line">     number + <span class="number">1</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="规则6-closure-spacing"><a href="#规则6-closure-spacing" class="headerlink" title="规则6: closure_spacing"></a>规则6: closure_spacing</h3><p>在闭包的{}中间要有一个空格,如map({ $0 })</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>closure_spacing</td>
<td>未启用</td>
<td>yes</td>
<td>style</td>
</tr>
</tbody></table>
<p>以下示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">不会触发警告</span><br><span class="line">map(&#123; $<span class="number">0</span> &#125;)</span><br><span class="line">[].map (&#123; $<span class="number">0.</span>description &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//会触发警告</span></span><br><span class="line">map(&#123;$<span class="number">0</span> &#125;)</span><br><span class="line">map(&#123; $<span class="number">0</span>&#125;)</span><br><span class="line">map(&#123;$<span class="number">0</span>&#125;)</span><br><span class="line">[].map (&#123;$<span class="number">0.</span>description     &#125;)</span><br></pre></td></tr></table></figure>

<h3 id="规则7-colon"><a href="#规则7-colon" class="headerlink" title="规则7: colon"></a>规则7: colon</h3><p>冒号的使用， swiftlint的这个colon属性规则很简单，要求“ ：”紧靠所定义的常量或变量等，必须没有空格，与所指定的类型之间必须只有一个空格，多一个或少一个都不行，如果是用在Dictionary中，则要求紧靠Key，与Value之间必须有且仅有一个空格。这个规则我觉得应该强制推荐使用</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>colon</td>
<td>启用</td>
<td>yes</td>
<td>style</td>
</tr>
</tbody></table>
<p>具体示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不会触发警告</span></span><br><span class="line">let abc: String = <span class="string">&quot;jun&quot;</span></span><br><span class="line">let abc = [<span class="number">1</span>: [<span class="number">3</span>: <span class="number">2</span>], <span class="number">3</span>: <span class="number">4</span>]</span><br><span class="line">let abc = [<span class="number">1</span>: [<span class="number">3</span>: <span class="number">2</span>], <span class="number">3</span>: <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">//会触发警告</span></span><br><span class="line">let jun:Void</span><br><span class="line">let jun : Void</span><br><span class="line">let jun :Void</span><br><span class="line">let jun:   Void</span><br></pre></td></tr></table></figure>

<h3 id="规则8-comma"><a href="#规则8-comma" class="headerlink" title="规则8: comma"></a>规则8: comma</h3><p>逗号使用只要遵循“前不离身后退一步”就行了，这个也强制推荐使用</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>comma</td>
<td>启用</td>
<td>yes</td>
<td>style</td>
</tr>
</tbody></table>
<p>具体示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不触发警告</span></span><br><span class="line">[a, b, c, d]</span><br><span class="line"></span><br><span class="line"><span class="comment">//触发警告</span></span><br><span class="line">[a ,b]</span><br></pre></td></tr></table></figure>

<h3 id="规则9-compiler-protocol-init"><a href="#规则9-compiler-protocol-init" class="headerlink" title="规则9: compiler_protocol_init"></a>规则9: compiler_protocol_init</h3><p>编译器协议初始化, 不建议.init等初始化方式, 建议使用简单的初始化形式</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>compiler_protocol_init</td>
<td>启用</td>
<td>no</td>
<td>lint</td>
</tr>
</tbody></table>
<p>官方示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">static</span> let description = RuleDescription(</span><br><span class="line">    identifier: <span class="string">&quot;compiler_protocol_init&quot;</span>,</span><br><span class="line">    name: <span class="string">&quot;Compiler Protocol Init&quot;</span>,</span><br><span class="line">    description: <span class="string">&quot;The initializers declared in compiler protocols such as `ExpressibleByArrayLiteral` &quot;</span> +</span><br><span class="line">                 <span class="string">&quot;shouldn&#x27;t be called directly.&quot;</span>,</span><br><span class="line">    kind: .lint,</span><br><span class="line">    nonTriggeringExamples: [</span><br><span class="line">        <span class="string">&quot;let set: Set&lt;Int&gt; = [1, 2]\n&quot;</span>,</span><br><span class="line">        <span class="string">&quot;let set = Set(array)\n&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    triggeringExamples: [</span><br><span class="line">        <span class="string">&quot;let set = ↓Set(arrayLiteral: 1, 2)\n&quot;</span>,</span><br><span class="line">        <span class="string">&quot;let set = ↓Set.init(arrayLiteral: 1, 2)\n&quot;</span></span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="规则10-conditional-returns-on-newline"><a href="#规则10-conditional-returns-on-newline" class="headerlink" title="规则10: conditional_returns_on_newline"></a>规则10: conditional_returns_on_newline</h3><p>条件语句不能写在同一行, 条件返回语句应该在新的一行。 当有条件返回的时候应该换行返回，而不是在同一行</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>conditional_returns_on_newline</td>
<td>未启用</td>
<td>no</td>
<td>style</td>
</tr>
</tbody></table>
<p>具体示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// swiftlint 不推荐的写法, 否则会触发warning</span></span><br><span class="line"><span class="keyword">if</span> <span class="literal">true</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">guard <span class="literal">true</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// swiftlint 推荐的写法</span></span><br><span class="line"><span class="keyword">if</span> <span class="literal">true</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">guard <span class="literal">true</span> <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="规则11-contains-over-first-not-nil"><a href="#规则11-contains-over-first-not-nil" class="headerlink" title="规则11: contains_over_first_not_nil"></a>规则11: contains_over_first_not_nil</h3><p>类似first函数不能判断是否为nil</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>contains_over_first_not_nil</td>
<td>未启用</td>
<td>no</td>
<td>performance</td>
</tr>
</tbody></table>
<p>具体示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//推荐写法</span></span><br><span class="line">let first = myList.first(where: &#123; $<span class="number">0</span> % <span class="number">2</span> == <span class="number">0</span> &#125;)</span><br><span class="line">let first = myList.first &#123; $<span class="number">0</span> % <span class="number">2</span> == <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不推荐写法</span></span><br><span class="line">myList.first &#123; $<span class="number">0</span> % <span class="number">2</span> == <span class="number">0</span> &#125; != <span class="literal">nil</span></span><br><span class="line">myList.first(where: &#123; $<span class="number">0</span> % <span class="number">2</span> == <span class="number">0</span> &#125;) != <span class="literal">nil</span></span><br></pre></td></tr></table></figure>

<h3 id="规则12-control-statement"><a href="#规则12-control-statement" class="headerlink" title="规则12: control_statement"></a>规则12: control_statement</h3><p>控制语句, for，while，do，catch语句中的条件不能包含在()中</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>control_statement</td>
<td>启用</td>
<td>no</td>
<td>style</td>
</tr>
</tbody></table>
<p>具体示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//建议写法</span></span><br><span class="line"><span class="keyword">if</span> condition &#123;</span><br><span class="line"><span class="keyword">if</span> (a, b) == (<span class="number">0</span>, <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不建议写法</span></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line"><span class="keyword">if</span>(condition) &#123;</span><br><span class="line"><span class="keyword">if</span> ((a || b) &amp;&amp; (c || d)) &#123;</span><br></pre></td></tr></table></figure>

<h3 id="规则13-custom-rules"><a href="#规则13-custom-rules" class="headerlink" title="规则13: custom_rules"></a>规则13: custom_rules</h3><p>自定义规则。 这个属性可以通过提供正则表达式来创建自定义规则， 可选指定语法类型搭配， 安全、级别和要陈列的什么信息。 这个属性只要熟悉使用正则表达式的人使用，目前可以不适用</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>custom_rules</td>
<td>启用</td>
<td>no</td>
<td>style</td>
</tr>
</tbody></table>
<h3 id="规则14-cyclomatic-complexity"><a href="#规则14-cyclomatic-complexity" class="headerlink" title="规则14: cyclomatic_complexity"></a>规则14: cyclomatic_complexity</h3><p>循环复杂度。函数体的复杂度应该要限制，这个属性主要约束条件句、循环句中的循环嵌套问题， 当嵌套太多的循环时，则会触发swiftlint中的warning和error，当达到10个循环嵌套时就会报warning，达到20个循环嵌套时就会报error</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>cyclomatic_complexity</td>
<td>启用</td>
<td>no</td>
<td>metrics</td>
</tr>
</tbody></table>
<h3 id="规则15-discarded-notification-center-observer"><a href="#规则15-discarded-notification-center-observer" class="headerlink" title="规则15: discarded_notification_center_observer"></a>规则15: discarded_notification_center_observer</h3><p>当使用注册的通知时, 应该存储返回的观察者, 便于用完之后移除通知</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>discarded_notification_center_observer</td>
<td>启用</td>
<td>no</td>
<td>lint</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//推荐写法</span></span><br><span class="line">let foo = nc.addObserver(forName: .NSSystemTimeZoneDidChange, object: <span class="literal">nil</span>, queue: <span class="literal">nil</span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line">let foo = nc.addObserver(forName: .NSSystemTimeZoneDidChange, object: <span class="literal">nil</span>, queue: <span class="literal">nil</span>, using: &#123; &#125;)</span><br><span class="line"></span><br><span class="line">func foo() -&gt; Any &#123;</span><br><span class="line">   <span class="keyword">return</span> nc.addObserver(forName: .NSSystemTimeZoneDidChange, object: <span class="literal">nil</span>, queue: <span class="literal">nil</span>, using: &#123; &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//不推荐写法</span></span><br><span class="line">nc.addObserver(forName: .NSSystemTimeZoneDidChange, object: <span class="literal">nil</span>, queue: <span class="literal">nil</span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line">nc.addObserver(forName: .NSSystemTimeZoneDidChange, object: <span class="literal">nil</span>, queue: <span class="literal">nil</span>, using: &#123; &#125;)</span><br><span class="line"></span><br><span class="line">@discardableResult func foo() -&gt; Any &#123;</span><br><span class="line">   <span class="keyword">return</span> nc.addObserver(forName: .NSSystemTimeZoneDidChange, object: <span class="literal">nil</span>, queue: <span class="literal">nil</span>, using: &#123; &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="规则16-discouraged-direct-init"><a href="#规则16-discouraged-direct-init" class="headerlink" title="规则16: discouraged_direct_init"></a>规则16: discouraged_direct_init</h3><p>阻止直接初始化导致的错误类型, 有类方法的,用类方法初始化(不建议直接init初始化)</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>discouraged_direct_init</td>
<td>启用</td>
<td>no</td>
<td>lint</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//建议写法</span></span><br><span class="line">let foo = <span class="built_in">UIDevice</span>.current</span><br><span class="line">let foo = Bundle.main</span><br><span class="line">let foo = Bundle(path: <span class="string">&quot;bar&quot;</span>)</span><br><span class="line">let foo = Bundle(identifier: <span class="string">&quot;bar&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//不建议写法</span></span><br><span class="line">let foo = <span class="built_in">UIDevice</span>()</span><br><span class="line">let foo = Bundle()</span><br><span class="line">let foo = bar(bundle: Bundle(), device: <span class="built_in">UIDevice</span>())</span><br></pre></td></tr></table></figure>

<h3 id="规则17-discouraged-optional-boolean"><a href="#规则17-discouraged-optional-boolean" class="headerlink" title="规则17: discouraged_optional_boolean"></a>规则17: discouraged_optional_boolean</h3><p>不建议使用可选布尔值</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>discouraged_optional_boolean</td>
<td>未启用</td>
<td>no</td>
<td>idiomatic</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//建议写法</span></span><br><span class="line">var foo: Bool</span><br><span class="line">var foo: [String: Bool]</span><br><span class="line">var foo: [Bool]</span><br><span class="line">let foo: Bool = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//不建议写法</span></span><br><span class="line">var foo: Bool?</span><br><span class="line">var foo: [String: Bool?]</span><br><span class="line">var foo: [Bool?]</span><br><span class="line">let foo: Bool? = <span class="literal">nil</span></span><br></pre></td></tr></table></figure>

<h3 id="规则18-discouraged-object-literal"><a href="#规则18-discouraged-object-literal" class="headerlink" title="规则18: discouraged_object_literal"></a>规则18: discouraged_object_literal</h3><p>优先使用对象初始化方法, 不建议使用代码块初始化</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>discouraged_object_literal</td>
<td>未启用</td>
<td>no</td>
<td>idiomatic</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不建议写法</span></span><br><span class="line">let white = #colorLiteral(red: <span class="number">1.0</span>, green: <span class="number">1.0</span>, blue: <span class="number">1.0</span>, alpha: <span class="number">1.0</span>)</span><br><span class="line">let image = ↓#imageLiteral(resourceName: <span class="string">&quot;image.jpg&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="规则19-dynamic-inline"><a href="#规则19-dynamic-inline" class="headerlink" title="规则19: dynamic_inline"></a>规则19: dynamic_inline</h3><p>避免一起使用 dynamic 和 @inline(_ _always)， 否则报 error</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>dynamic_inline</td>
<td>启用</td>
<td>no</td>
<td>lint</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 正确的做法</span></span><br><span class="line"><span class="keyword">class</span> LangKe &#123;</span><br><span class="line">    dynamic func myFunction() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> LangKe &#123;</span><br><span class="line">    @inline(__always) func myFunction() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> LangKe &#123;</span><br><span class="line">    @inline(never) dynamic func myFunction() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 只要同时使用 dynamic 和 @inline(_ _always)都报错 error！！！</span></span><br><span class="line"><span class="keyword">class</span> LangKe &#123;</span><br><span class="line">    @inline(__always) public dynamic func myFunction() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="规则20-array-init"><a href="#规则20-array-init" class="headerlink" title="规则20: array_init"></a>规则20: array_init</h3><p>序列转化成数组时, 优先使用数组转化, 而不是seq.map {$ 0}将序列转换为数组</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>array_init</td>
<td>未启用</td>
<td>no</td>
<td>lint</td>
</tr>
</tbody></table>
<p>官方示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">static</span> let description = RuleDescription(</span><br><span class="line">    identifier: <span class="string">&quot;array_init&quot;</span>,</span><br><span class="line">    name: <span class="string">&quot;Array Init&quot;</span>,</span><br><span class="line">    description: <span class="string">&quot;Prefer using Array(seq) than seq.map &#123; $0 &#125; to convert a sequence into an Array.&quot;</span>,</span><br><span class="line">    kind: .lint,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//以下示例不会触发警告</span></span><br><span class="line">    nonTriggeringExamples: [</span><br><span class="line">        <span class="string">&quot;Array(foo)\n&quot;</span>,</span><br><span class="line">        <span class="string">&quot;foo.map &#123; $0.0 &#125;\n&quot;</span>,</span><br><span class="line">        <span class="string">&quot;foo.map &#123; $1 &#125;\n&quot;</span>,</span><br><span class="line">        <span class="string">&quot;foo.map &#123; $0() &#125;\n&quot;</span>,</span><br><span class="line">        <span class="string">&quot;foo.map &#123; ((), $0) &#125;\n&quot;</span>,</span><br><span class="line">        <span class="string">&quot;foo.map &#123; $0! &#125;\n&quot;</span>,</span><br><span class="line">        <span class="string">&quot;foo.map &#123; $0! /* force unwrap */ &#125;\n&quot;</span>,</span><br><span class="line">        <span class="string">&quot;foo.something &#123; RouteMapper.map($0) &#125;\n&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//以下示例会触发警告</span></span><br><span class="line">    triggeringExamples: [</span><br><span class="line">        <span class="string">&quot;↓foo.map(&#123; $0 &#125;)\n&quot;</span>,</span><br><span class="line">        <span class="string">&quot;↓foo.map &#123; $0 &#125;\n&quot;</span>,</span><br><span class="line">        <span class="string">&quot;↓foo.map &#123; return $0 &#125;\n&quot;</span>,</span><br><span class="line">        <span class="string">&quot;↓foo.map &#123; elem in\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;   elem\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;&#125;\n&quot;</span>,</span><br><span class="line">        <span class="string">&quot;↓foo.map &#123; elem in\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;   return elem\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;&#125;\n&quot;</span>,</span><br><span class="line">        <span class="string">&quot;↓foo.map &#123; (elem: String) in\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;   elem\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;&#125;\n&quot;</span>,</span><br><span class="line">        <span class="string">&quot;↓foo.map &#123; elem -&gt; String in\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;   elem\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;&#125;\n&quot;</span>,</span><br><span class="line">        <span class="string">&quot;↓foo.map &#123; $0 /* a comment */ &#125;\n&quot;</span></span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="规则21-empty-count"><a href="#规则21-empty-count" class="headerlink" title="规则21: empty_count"></a>规则21: empty_count</h3><p>建议使用isEmpty判断,而不是使用count&#x3D;&#x3D;0判断</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>empty_count</td>
<td>未启用</td>
<td>no</td>
<td>performance</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// swiftlint不建议这样使用</span></span><br><span class="line">let number = <span class="string">&quot;long&quot;</span></span><br><span class="line"><span class="keyword">if</span> number.characters.count == <span class="number">0</span> &#123;</span><br><span class="line">    print(<span class="string">&quot;为空&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    print(<span class="string">&quot;不为空&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// swiftlint建议这种正式风格</span></span><br><span class="line"><span class="keyword">if</span> number.isEmpty &#123;</span><br><span class="line">    print(<span class="string">&quot;为空&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    print(<span class="string">&quot;不为空&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="规则22-empty-enum-arguments"><a href="#规则22-empty-enum-arguments" class="headerlink" title="规则22: empty_enum_arguments"></a>规则22: empty_enum_arguments</h3><p>当枚举与关联类型匹配时，如果不使用它们，参数可以省略</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>empty_enum_arguments</td>
<td>启用</td>
<td>yes</td>
<td>style</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//SwiftLint建议写法</span></span><br><span class="line"><span class="keyword">switch</span> foo &#123;</span><br><span class="line">    <span class="keyword">case</span> .bar: <span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> foo &#123;</span><br><span class="line">    <span class="keyword">case</span> .bar(let x): <span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> foo &#123;</span><br><span class="line">    <span class="keyword">case</span> let .bar(x): <span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> (foo, bar) &#123;</span><br><span class="line">    <span class="keyword">case</span> (_, _): <span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> foo &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;bar&quot;</span>.uppercased(): <span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SwiftLint不建议写法</span></span><br><span class="line"><span class="keyword">switch</span> foo &#123;</span><br><span class="line">    <span class="keyword">case</span> .bar(_): <span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> foo &#123;</span><br><span class="line">    <span class="keyword">case</span> .bar(): <span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> foo &#123;</span><br><span class="line">    <span class="keyword">case</span> .bar(_), .bar2(_): <span class="keyword">break</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="规则23-empty-parameters"><a href="#规则23-empty-parameters" class="headerlink" title="规则23: empty_parameters"></a>规则23: empty_parameters</h3><p>闭包参数为空时,建议使用() -&gt;Void, 而不是Void -&gt;Void</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>empty_parameters</td>
<td>启用</td>
<td>yes</td>
<td>style</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 01 不会触发warning</span></span><br><span class="line">let abc: () -&gt; Void</span><br><span class="line"></span><br><span class="line">func foo(completion: () -&gt; Void) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 02 直接报错</span></span><br><span class="line">let bcd: Void -&gt; Void</span><br><span class="line"></span><br><span class="line">func foo(completion: Void -&gt; Void) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="规则24-empty-parentheses-with-trailing-closure"><a href="#规则24-empty-parentheses-with-trailing-closure" class="headerlink" title="规则24: empty_parentheses_with_trailing_closure"></a>规则24: empty_parentheses_with_trailing_closure</h3><p>在使用尾随闭包的时候， 应该尽量避免使用空的圆括号</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>empty_parentheses_with_trailing_closure</td>
<td>启用</td>
<td>yes</td>
<td>style</td>
</tr>
</tbody></table>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不会触发warning</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>].map &#123; $<span class="number">0</span> + <span class="number">1</span> &#125;</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>].map(&#123; $<span class="number">0</span> + <span class="number">1</span> &#125;)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>].reduce(<span class="number">0</span>) &#123; $<span class="number">0</span> + $<span class="number">1</span> &#125;</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>].map &#123; number <span class="keyword">in</span></span><br><span class="line">   number + <span class="number">1</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//会触发warning</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>].map() &#123; $<span class="number">0</span> + <span class="number">1</span> &#125;</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>].map( ) &#123; $<span class="number">0</span> + <span class="number">1</span> &#125;</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>].map() &#123; number <span class="keyword">in</span></span><br><span class="line">   number + <span class="number">1</span> </span><br><span class="line">&#125;</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>].map(  ) &#123; number <span class="keyword">in</span></span><br><span class="line">   number + <span class="number">1</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="规则26-explicit-acl"><a href="#规则26-explicit-acl" class="headerlink" title="规则26: explicit_acl"></a>规则26: explicit_acl</h3><p>…所有属性和方法的声明, 都应该明确指定修饰关键字</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>explicit_acl</td>
<td>未启用</td>
<td>no</td>
<td>idiomatic</td>
</tr>
</tbody></table>
<p>官方代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//非触发示例</span></span><br><span class="line">internal <span class="keyword">enum</span> A &#123;&#125;</span><br><span class="line">public final <span class="keyword">class</span> B &#123;&#125;</span><br><span class="line">private <span class="keyword">struct</span> C &#123;&#125;</span><br><span class="line">internal func a() &#123; let a =  &#125;</span><br><span class="line">private <span class="keyword">struct</span> C &#123; let d = <span class="number">5</span> &#125;</span><br><span class="line">internal <span class="keyword">class</span> A &#123; deinit &#123;&#125; &#125;</span><br><span class="line">internal protocol A &#123;</span><br><span class="line">    func b()</span><br><span class="line">    var c: Int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//触发示例</span></span><br><span class="line"><span class="keyword">enum</span> A &#123;&#125;</span><br><span class="line">final <span class="keyword">class</span> B &#123;&#125;</span><br><span class="line">internal <span class="keyword">struct</span> C &#123; let d = <span class="number">5</span> &#125;</span><br><span class="line">public <span class="keyword">struct</span> C &#123; let d = <span class="number">5</span> &#125;</span><br><span class="line">func a() &#123;&#125;</span><br><span class="line">internal let a = <span class="number">0</span></span><br><span class="line">func b() &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="规则27-explicit-type-interface"><a href="#规则27-explicit-type-interface" class="headerlink" title="规则27: explicit_type_interface"></a>规则27: explicit_type_interface</h3><p>声明的属性应该明确其类型, 如: var myVar: Int &#x3D; 0</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>explicit_type_interface</td>
<td>未启用</td>
<td>no</td>
<td>idomatic</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//推荐写法</span></span><br><span class="line"><span class="keyword">class</span> Foo &#123;</span><br><span class="line">  var myVar: Int? = <span class="number">0</span></span><br><span class="line">  let myLet: Int? = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不建议写法</span></span><br><span class="line"><span class="keyword">class</span> Foo &#123;</span><br><span class="line">  var myVar = <span class="number">0</span></span><br><span class="line">  let myLet = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="规则28-extension-access-modifier"><a href="#规则28-extension-access-modifier" class="headerlink" title="规则28: extension_access_modifier"></a>规则28: extension_access_modifier</h3><p>在自定义类中,推荐使用extension扩展</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>extension_access_modifier</td>
<td>未启用</td>
<td>no</td>
<td>idiomatic</td>
</tr>
</tbody></table>
<h3 id="规则29-no-extension-access-modifier"><a href="#规则29-no-extension-access-modifier" class="headerlink" title="规则29: no_extension_access_modifier"></a>规则29: no_extension_access_modifier</h3><p>在extension扩展前面,不建议使用(fileprivate, public)等修饰符</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>no_extension_access_modifier</td>
<td>未启用</td>
<td>no</td>
<td>idiomatic</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不建议以下写法</span></span><br><span class="line">private extension String &#123;&#125;</span><br><span class="line">public extension String &#123;&#125;</span><br><span class="line">open extension String &#123;&#125;</span><br><span class="line">internal extension String &#123;&#125;</span><br><span class="line">fileprivate extension String &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="规则30-fallthrough"><a href="#规则30-fallthrough" class="headerlink" title="规则30: fallthrough"></a>规则30: fallthrough</h3><p>switch语句中不建议使用fallthrough</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>fallthrough</td>
<td>启用</td>
<td>no</td>
<td>idiomatic</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//推荐写法</span></span><br><span class="line"><span class="keyword">switch</span> foo &#123;</span><br><span class="line"><span class="keyword">case</span> .bar, .bar2, .bar3:</span><br><span class="line">    something()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不建议写法</span></span><br><span class="line"><span class="keyword">switch</span> foo &#123;</span><br><span class="line"><span class="keyword">case</span> .bar:</span><br><span class="line">    fallthrough</span><br><span class="line"><span class="keyword">case</span> .bar2:</span><br><span class="line">    something()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="规则31-fatal-error-message"><a href="#规则31-fatal-error-message" class="headerlink" title="规则31: fatal_error_message"></a>规则31: fatal_error_message</h3><p>执行fatalError错误时,建议有一个提示信息; 如:fatalError(“Foo”)</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>fatal_error_message</td>
<td>未启用</td>
<td>no</td>
<td>idiomatic</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//推荐写法</span></span><br><span class="line">required init?(coder aDecoder: <span class="built_in">NSCoder</span>) &#123;</span><br><span class="line">    fatalError(<span class="string">&quot;init(coder:) has not been implemented&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不建议</span></span><br><span class="line">required init?(coder aDecoder: <span class="built_in">NSCoder</span>) &#123;</span><br><span class="line">    fatalError(<span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="规则32-file-header"><a href="#规则32-file-header" class="headerlink" title="规则32: file_header"></a>规则32: file_header</h3><p>文件头。新建的文件开始的注释应该一样</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>aaa</td>
<td>未启用</td>
<td>no</td>
<td>style</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 不会触发warning</span></span><br><span class="line"><span class="comment">/// 如果我新建一个工程，在ViewController.swift文件中， 开始的注释应该是：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  ViewController.swift</span></span><br><span class="line"><span class="comment">//  SwiftLint</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by langke on 17/1/17.</span></span><br><span class="line"><span class="comment">//  Copyright © 2017年 langke. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line">改变一下变为：</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  MyViewController.swift...................由于这里和外面的文件名不一样，所以触发warning（实际上在swift 3.0上测试这个属性暂时没有任何作用！！）</span></span><br><span class="line"><span class="comment">//  SwiftLint</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by langke on 17/1/17.</span></span><br><span class="line"><span class="comment">//   Copyright © 2017年 langke. All rights reserved................官方terminal表示，Copyright和Created没有对齐，也会触发warning！！！</span></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure>

<h3 id="规则33-file-length"><a href="#规则33-file-length" class="headerlink" title="规则33: file_length"></a>规则33: file_length</h3><p>文件内容行数, 超过400行warning, 超过1000行给error</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>file_length</td>
<td>启用</td>
<td>no</td>
<td>metrics</td>
</tr>
</tbody></table>
<h3 id="规则34-first-where"><a href="#规则34-first-where" class="headerlink" title="规则34: first_where"></a>规则34: first_where</h3><p>不建议在使用filter和map函数后直接使用.first</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>first_where</td>
<td>未启用</td>
<td>no</td>
<td>performance</td>
</tr>
</tbody></table>
<p>官方代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">static</span> let description = RuleDescription(</span><br><span class="line">    identifier: <span class="string">&quot;first_where&quot;</span>,</span><br><span class="line">    name: <span class="string">&quot;First Where&quot;</span>,</span><br><span class="line">    description: <span class="string">&quot;Prefer using `.first(where:)` over `.filter &#123; &#125;.first` in collections.&quot;</span>,</span><br><span class="line">    kind: .performance,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//不会触发警告</span></span><br><span class="line">    nonTriggeringExamples: [</span><br><span class="line">        <span class="string">&quot;kinds.filter(excludingKinds.contains).isEmpty &amp;&amp; kinds.first == .identifier\n&quot;</span>,</span><br><span class="line">        <span class="string">&quot;myList.first(where: &#123; $0 % 2 == 0 &#125;)\n&quot;</span>,</span><br><span class="line">        <span class="string">&quot;match(pattern: pattern).filter &#123; $0.first == .identifier &#125;\n&quot;</span>,</span><br><span class="line">        <span class="string">&quot;(myList.filter &#123; $0 == 1 &#125;.suffix(2)).first\n&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">//以下写法会触发警告</span></span><br><span class="line">    triggeringExamples: [</span><br><span class="line">        <span class="string">&quot;↓myList.filter &#123; $0 % 2 == 0 &#125;.first\n&quot;</span>,</span><br><span class="line">        <span class="string">&quot;↓myList.filter(&#123; $0 % 2 == 0 &#125;).first\n&quot;</span>,</span><br><span class="line">        <span class="string">&quot;↓myList.map &#123; $0 + 1 &#125;.filter(&#123; $0 % 2 == 0 &#125;).first\n&quot;</span>,</span><br><span class="line">        <span class="string">&quot;↓myList.map &#123; $0 + 1 &#125;.filter(&#123; $0 % 2 == 0 &#125;).first?.something()\n&quot;</span>,</span><br><span class="line">        <span class="string">&quot;↓myList.filter(someFunction).first\n&quot;</span>,</span><br><span class="line">        <span class="string">&quot;↓myList.filter(&#123; $0 % 2 == 0 &#125;)\n.first\n&quot;</span>,</span><br><span class="line">        <span class="string">&quot;(↓myList.filter &#123; $0 == 1 &#125;).first\n&quot;</span></span><br><span class="line">    ]</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="规则35-for-where"><a href="#规则35-for-where" class="headerlink" title="规则35: for_where"></a>规则35: for_where</h3><p>在for循环中,不建议使用单个if语句或者只使用一次循环变量,可使用where或者if{}else{}语句</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>for_where</td>
<td>启用</td>
<td>no</td>
<td>idiomatic</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//推荐写法</span></span><br><span class="line"><span class="keyword">for</span> user <span class="keyword">in</span> users where user.id == <span class="number">1</span> &#123; &#125;</span><br><span class="line"><span class="keyword">for</span> user <span class="keyword">in</span> users &#123;</span><br><span class="line">   <span class="keyword">if</span> let <span class="type">id</span> = user.id &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> user <span class="keyword">in</span> users &#123;</span><br><span class="line">   <span class="keyword">if</span> var <span class="type">id</span> = user.id &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> user <span class="keyword">in</span> users &#123;</span><br><span class="line">   <span class="keyword">if</span> user.id == <span class="number">1</span> &#123; &#125; <span class="keyword">else</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> user <span class="keyword">in</span> users &#123;</span><br><span class="line">   <span class="keyword">if</span> user.id == <span class="number">1</span> &#123; &#125;</span><br><span class="line">   print(user)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> user <span class="keyword">in</span> users &#123;</span><br><span class="line">   let <span class="type">id</span> = user.id</span><br><span class="line">   <span class="keyword">if</span> <span class="type">id</span> == <span class="number">1</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> user <span class="keyword">in</span> users &#123;</span><br><span class="line">   <span class="keyword">if</span> user.id == <span class="number">1</span> &amp;&amp; user.age &gt; <span class="number">18</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不建议写法</span></span><br><span class="line"><span class="keyword">for</span> user <span class="keyword">in</span> users &#123;</span><br><span class="line">   <span class="keyword">if</span> user.id == <span class="number">1</span> &#123; <span class="keyword">return</span> <span class="literal">true</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="规则36-force-cast"><a href="#规则36-force-cast" class="headerlink" title="规则36: force_cast"></a>规则36: force_cast</h3><p>不建议直接强解类型</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>force_cast</td>
<td>启用</td>
<td>no</td>
<td>idiomatic</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//建议写法</span></span><br><span class="line"><span class="built_in">NSNumber</span>() as? Int</span><br><span class="line"></span><br><span class="line"><span class="comment">//不推荐</span></span><br><span class="line"><span class="built_in">NSNumber</span>() ↓as! Int</span><br></pre></td></tr></table></figure>

<h3 id="规则37-force-try"><a href="#规则37-force-try" class="headerlink" title="规则37: force_try"></a>规则37: force_try</h3><p>对会抛出异常(throws)的方法,不建议try!强解</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>force_try</td>
<td>启用</td>
<td>no</td>
<td>idiomatic</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">func myFunction() throws &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 这样写是可以的，不会触发 error</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    try myFunction()</span><br><span class="line">&#125; catch &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 这样直接触发 error</span></span><br><span class="line">try! myFunction()</span><br></pre></td></tr></table></figure>

<h3 id="规则38-force-unwrapping"><a href="#规则38-force-unwrapping" class="headerlink" title="规则38: force_unwrapping"></a>规则38: force_unwrapping</h3><p>强制解包&#x2F;拆包。我们知道，当一个类型是可选类型的时候，当我们获取值时，需要强制解包（也叫隐式解包）, 通常我们是在一个变量或者所需要的常量、类型等后面加一个“ ！”， 然而，swiftlint建议强制解包应该要避免， 否则将给予warning</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>force_unwrapping</td>
<td>未启用</td>
<td>no</td>
<td>idiomatic</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 将触发warning</span></span><br><span class="line">navigationController!.pushViewController(myViewController, animated: <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">let url = <span class="built_in">NSURL</span>(string: <span class="string">&quot;http://www.baidu.com&quot;</span>)!</span><br><span class="line">print(url)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> cell!</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 不会触发warning</span></span><br><span class="line">navigationController?.pushViewController(myViewController, animated: <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<h3 id="规则39-function-body-length"><a href="#规则39-function-body-length" class="headerlink" title="规则39: function_body_length"></a>规则39: function_body_length</h3><p>函数体长度， 函数体不应该跨越太多行， 超过40行给warning， 超过100行直接报错</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>function_body_length</td>
<td>启用</td>
<td>no</td>
<td>metrics</td>
</tr>
</tbody></table>
<h3 id="规则40-function-parameter-count"><a href="#规则40-function-parameter-count" class="headerlink" title="规则40: function_parameter_count"></a>规则40: function_parameter_count</h3><ul>
<li>函数参数个数， 函数参数数量(init方法除外)应该少点， 不要太多，swiftlint规定函数参数数量超过5个给warning， 超过8个直接报error</li>
<li>注：<code>function_parameter_count: error</code> 这样并不能改变它的警告或错误，该属性不允许修改，但是可以禁用</li>
</ul>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>function_parameter_count</td>
<td>启用</td>
<td>no</td>
<td>metrics</td>
</tr>
</tbody></table>
<h3 id="规则41-generic-type-name"><a href="#规则41-generic-type-name" class="headerlink" title="规则41: generic_type_name"></a>规则41: generic_type_name</h3><p>泛型类型名称只能包含字母数字字符，以大写字母开头，长度介于1到20个字符之间</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>generic_type_name</td>
<td>未启用</td>
<td>no</td>
<td>idiomatic</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//推荐写法</span></span><br><span class="line">func foo&lt;T&gt;() &#123;&#125;</span><br><span class="line">func foo&lt;T&gt;() -&gt; T &#123;&#125;</span><br><span class="line">func foo&lt;T, U&gt;(param: U) -&gt; T &#123;&#125;</span><br><span class="line">func foo&lt;T: Hashable, U: Rule&gt;(param: U) -&gt; T &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不推荐写法</span></span><br><span class="line">func foo&lt;T_Foo&gt;() &#123;&#125;</span><br><span class="line">func foo&lt;T, U_Foo&gt;(param: U_Foo) -&gt; T &#123;&#125;</span><br><span class="line">func foo&lt;TTTTTTTTTTTTTTTTTTTTT&gt;() &#123;&#125;</span><br><span class="line">func foo&lt;type&gt;() &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="规则42-identifier-name"><a href="#规则42-identifier-name" class="headerlink" title="规则42: identifier_name"></a>规则42: identifier_name</h3><p>变量标识符名称应该只包含字母数字字符，并以小写字母开头或只应包含大写字母。在上述例外情况下，当变量名称被声明为静态且不可变时，变量名称可能以大写字母开头。变量名称不应该太长或太短</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>identifier_name</td>
<td>启用</td>
<td>no</td>
<td>style</td>
</tr>
</tbody></table>
<p>官方给出的示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">internal <span class="keyword">struct</span> IdentifierNameRuleExamples &#123;</span><br><span class="line">    <span class="comment">//不会触发error</span></span><br><span class="line">    <span class="keyword">static</span> let nonTriggeringExamples = [</span><br><span class="line">        <span class="string">&quot;let myLet = 0&quot;</span>,</span><br><span class="line">        <span class="string">&quot;var myVar = 0&quot;</span>,</span><br><span class="line">        <span class="string">&quot;private let _myLet = 0&quot;</span>,</span><br><span class="line">        <span class="string">&quot;class Abc &#123; static let MyLet = 0 &#125;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;let URL: NSURL? = nil&quot;</span>,</span><br><span class="line">        <span class="string">&quot;let XMLString: String? = nil&quot;</span>,</span><br><span class="line">        <span class="string">&quot;override var i = 0&quot;</span>,</span><br><span class="line">        <span class="string">&quot;enum Foo &#123; case myEnum &#125;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;func isOperator(name: String) -&gt; Bool&quot;</span>,</span><br><span class="line">        <span class="string">&quot;func typeForKind(_ kind: SwiftDeclarationKind) -&gt; String&quot;</span>,</span><br><span class="line">        <span class="string">&quot;func == (lhs: SyntaxToken, rhs: SyntaxToken) -&gt; Bool&quot;</span>,</span><br><span class="line">        <span class="string">&quot;override func IsOperator(name: String) -&gt; Bool&quot;</span></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="comment">//会触发error</span></span><br><span class="line">    <span class="keyword">static</span> let triggeringExamples = [</span><br><span class="line">        <span class="string">&quot;↓let MyLet = 0&quot;</span>,</span><br><span class="line">        <span class="string">&quot;↓let _myLet = 0&quot;</span>,</span><br><span class="line">        <span class="string">&quot;private ↓let myLet_ = 0&quot;</span>,</span><br><span class="line">        <span class="string">&quot;↓let myExtremelyVeryVeryVeryVeryVeryVeryLongLet = 0&quot;</span>,</span><br><span class="line">        <span class="string">&quot;↓var myExtremelyVeryVeryVeryVeryVeryVeryLongVar = 0&quot;</span>,</span><br><span class="line">        <span class="string">&quot;private ↓let _myExtremelyVeryVeryVeryVeryVeryVeryLongLet = 0&quot;</span>,</span><br><span class="line">        <span class="string">&quot;↓let i = 0&quot;</span>,</span><br><span class="line">        <span class="string">&quot;↓var id = 0&quot;</span>,</span><br><span class="line">        <span class="string">&quot;private ↓let _i = 0&quot;</span>,</span><br><span class="line">        <span class="string">&quot;↓func IsOperator(name: String) -&gt; Bool&quot;</span>,</span><br><span class="line">        <span class="string">&quot;enum Foo &#123; case ↓MyEnum &#125;&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="规则44-implicit-getter"><a href="#规则44-implicit-getter" class="headerlink" title="规则44: implicit_getter"></a>规则44: implicit_getter</h3><p>对于只有只读属性不建议重写get方法</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>implicit_getter</td>
<td>启用</td>
<td>no</td>
<td>style</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不会触发error</span></span><br><span class="line"><span class="comment">//重写get和set方法</span></span><br><span class="line"><span class="keyword">class</span> Foo &#123;</span><br><span class="line">  var foo: Int &#123;</span><br><span class="line">    get &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">    set &#123;</span><br><span class="line">      _abc = newValue </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//只读</span></span><br><span class="line"><span class="keyword">class</span> Foo &#123;</span><br><span class="line">  var foo: Int &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">20</span> </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Foo &#123;</span><br><span class="line">  <span class="keyword">static</span> var foo: Int &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">20</span> </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//会触发error</span></span><br><span class="line"><span class="keyword">class</span> Foo &#123;</span><br><span class="line">  var foo: Int &#123;</span><br><span class="line">    get &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">20</span> </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Foo &#123;</span><br><span class="line">  var foo: Int &#123;</span><br><span class="line">    get&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">20</span> </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="规则45-implicit-return"><a href="#规则45-implicit-return" class="headerlink" title="规则45: implicit_return"></a>规则45: implicit_return</h3><p> 建议使用隐式返回闭包; 如: foo.map({ $0 + 1 })</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>implicit_return</td>
<td>未启用</td>
<td>no</td>
<td>style</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//推荐写法</span></span><br><span class="line">foo.map &#123; $<span class="number">0</span> + <span class="number">1</span> &#125;</span><br><span class="line">foo.map(&#123; $<span class="number">0</span> + <span class="number">1</span> &#125;)</span><br><span class="line">foo.map &#123; value <span class="keyword">in</span> value + <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不建议写法</span></span><br><span class="line">foo.map &#123; value <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">return</span> value + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">foo.map &#123;</span><br><span class="line">  <span class="keyword">return</span> $<span class="number">0</span> + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="规则46-implicitly-unwrapped-optional"><a href="#规则46-implicitly-unwrapped-optional" class="headerlink" title="规则46: implicitly_unwrapped_optional"></a>规则46: implicitly_unwrapped_optional</h3><p>尽量避免隐式解析可选类型的使用</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>implicitly_unwrapped_optional</td>
<td>未启用</td>
<td>no</td>
<td>idiomatic</td>
</tr>
</tbody></table>
<p>下面吗给出官方示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">static</span> let description = RuleDescription(</span><br><span class="line">    identifier: <span class="string">&quot;implicitly_unwrapped_optional&quot;</span>,</span><br><span class="line">    name: <span class="string">&quot;Implicitly Unwrapped Optional&quot;</span>,</span><br><span class="line">    description: <span class="string">&quot;Implicitly unwrapped optionals should be avoided when possible.&quot;</span>,</span><br><span class="line">    kind: .idiomatic,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//不会触发warning</span></span><br><span class="line">    nonTriggeringExamples: [</span><br><span class="line">        <span class="string">&quot;@IBOutlet private var label: UILabel!&quot;</span>,</span><br><span class="line">        <span class="string">&quot;@IBOutlet var label: UILabel!&quot;</span>,</span><br><span class="line">        <span class="string">&quot;@IBOutlet var label: [UILabel!]&quot;</span>,</span><br><span class="line">        <span class="string">&quot;if !boolean &#123;&#125;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;let int: Int? = 42&quot;</span>,</span><br><span class="line">        <span class="string">&quot;let int: Int? = nil&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//会触发warning</span></span><br><span class="line">    triggeringExamples: [</span><br><span class="line">        <span class="string">&quot;let label: UILabel!&quot;</span>,</span><br><span class="line">        <span class="string">&quot;let IBOutlet: UILabel!&quot;</span>,</span><br><span class="line">        <span class="string">&quot;let labels: [UILabel!]&quot;</span>,</span><br><span class="line">        <span class="string">&quot;var ints: [Int!] = [42, nil, 42]&quot;</span>,</span><br><span class="line">        <span class="string">&quot;let label: IBOutlet!&quot;</span>,</span><br><span class="line">        <span class="string">&quot;let int: Int! = 42&quot;</span>,</span><br><span class="line">        <span class="string">&quot;let int: Int! = nil&quot;</span>,</span><br><span class="line">        <span class="string">&quot;var int: Int! = 42&quot;</span>,</span><br><span class="line">        <span class="string">&quot;let int: ImplicitlyUnwrappedOptional&lt;Int&gt;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;let collection: AnyCollection&lt;Int!&gt;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;func foo(int: Int!) &#123;&#125;&quot;</span></span><br><span class="line">    ]</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="规则47-is-disjoint"><a href="#规则47-is-disjoint" class="headerlink" title="规则47: is_disjoint"></a>规则47: is_disjoint</h3><p>初始化集合Set时,推荐使用Set.isDisjoint(), 不建议:Set.intersection</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>is_disjoint</td>
<td>启用</td>
<td>no</td>
<td>idiomatic</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//推荐写法</span></span><br><span class="line">_ = Set(syntaxKinds).isDisjoint(with: commentAndStringKindsSet)</span><br><span class="line">let isObjc = !objcAttributes.isDisjoint(with: dictionary.enclosedSwiftAttributes)</span><br></pre></td></tr></table></figure>

<h3 id="规则48-joined-default-parameter"><a href="#规则48-joined-default-parameter" class="headerlink" title="规则48: joined_default_parameter"></a>规则48: joined_default_parameter</h3><p>joined方法使用默认分隔符时, 建议使用joined()方法, 而不是joined(separator: “”)方法</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>joined_default_parameter</td>
<td>未启用</td>
<td>yes</td>
<td>idiomatic</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//建议写法</span></span><br><span class="line">let foo = bar.joined()</span><br><span class="line">let foo = bar.joined(separator: <span class="string">&quot;,&quot;</span>)</span><br><span class="line">let foo = bar.joined(separator: toto)</span><br><span class="line"></span><br><span class="line"><span class="comment">//不建议写法</span></span><br><span class="line">let foo = bar.joined(separator: <span class="string">&quot;&quot;</span>)</span><br><span class="line">let foo = bar.filter(toto).joined(separator: <span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="规则49-large-tuple"><a href="#规则49-large-tuple" class="headerlink" title="规则49: large_tuple"></a>规则49: large_tuple</h3><p>定义的元组成员个数,超过两个warning</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>large_tuple</td>
<td>启用</td>
<td>no</td>
<td>metrics</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不会触发warning</span></span><br><span class="line">let foo: (Int, Int)</span><br><span class="line">let foo: (start: Int, end: Int)</span><br><span class="line">let foo: (Int, (Int, String))</span><br><span class="line"></span><br><span class="line"><span class="comment">//会触发warning</span></span><br><span class="line">let foo: (Int, Int, Int)</span><br><span class="line">let foo: (start: Int, end: Int, value: String)</span><br><span class="line">let foo: (Int, (Int, Int, Int))</span><br></pre></td></tr></table></figure>

<h3 id="规则50-leading-whitespace"><a href="#规则50-leading-whitespace" class="headerlink" title="规则50: leading_whitespace"></a>规则50: leading_whitespace</h3><p>文件开始不应该有空格或者换行, 否则就会触发warning</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>leading_whitespace</td>
<td>启用</td>
<td>yes</td>
<td>style</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 不会触发warning</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  ViewController.swift</span></span><br><span class="line"><span class="comment">//  SwiftLint</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by langke on 17/1/12.</span></span><br><span class="line"><span class="comment">//  Copyright © 2017年 langke. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 会触发warning</span></span><br><span class="line"> <span class="comment">//..................................这里有一个空格</span></span><br><span class="line"><span class="comment">//  ViewController.swift</span></span><br><span class="line"><span class="comment">//  SwiftLint</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by langke on 17/1/12.</span></span><br><span class="line"><span class="comment">//  Copyright © 2017年 langke. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 会触发warning</span></span><br><span class="line">......................................这里是一个空行</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  ViewController.swift</span></span><br><span class="line"><span class="comment">//  SwiftLint</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by langke on 17/1/12.</span></span><br><span class="line"><span class="comment">//  Copyright © 2017年 langke. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考文档<br><a href="https://github.com/realm/SwiftLint/blob/master/Rules.md#array-init">SwiftLint规则官方文档</a><br><a href="https://github.com/realm/SwiftLint/tree/master/Source/SwiftLintFramework/Rules">SwiftLint个规则详细介绍</a></p>
</blockquote>
<blockquote>
<p>有些地方的解释和示例可能不是很完善, 希望各位大神多多指导,后续会持续更新中…….</p>
</blockquote>
]]></content>
      <categories>
        <category>iOS组件库</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>SwiftLint</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift 4.2 新特性更新</title>
    <url>/post/bc9c7e33.html</url>
    <content><![CDATA[<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/ios/swift.jpg?x-oss-process=style/titanjun" alt="Swift"></p>
<span id="more"></span>


<ul>
<li><code>Github</code>地址–<a href="https://github.com/CoderTitan/Swift-4.2Demo/tree/master">Swift 4.2代码地址</a></li>
<li><code>Swift 4.2</code>是<code>Swift 4.0</code>发布以来的第二次小更新, 继上次<code>Xcode 9.3</code>和<code>Swift 4.1</code>发布以来也有俩月有余</li>
<li>上个版本<a href="https://www.titanjun.top/2018/04/24/Swift%204.1%20%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/">Swift 4.1 的新特性</a>中介绍了条件一致性和哈希索引等相关更新</li>
<li>随着<code>Xcode Bate 10</code>的发布, <code>Swift 4.2</code>也发布了测试版, 相信也带来了很多优化和改进</li>
<li>下面运行环境都是在<code>Xcode Bate 10</code>环境中进行的</li>
</ul>
<h3 id="CaseInterable协议"><a href="#CaseInterable协议" class="headerlink" title="CaseInterable协议"></a><code>CaseInterable</code>协议</h3><ul>
<li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0194-derived-collection-of-enum-cases.md">SE-0194</a>介绍了在<code>Swift 4.2</code>中新增的一个新的<code>CaseIterable</code>协议</li>
<li>定义的枚举遵循<code>CaseIterable</code>协议后, 编译时<code>Swift</code> 会自动合成一个<code>allCases</code>属性，是包含枚举的所有<code>case</code>项的数组</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">NetState</span>: <span class="title class_">CaseIterable</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> wifi</span><br><span class="line">    <span class="keyword">case</span> hotWifi</span><br><span class="line">    <span class="keyword">case</span> mobile</span><br><span class="line">    <span class="keyword">case</span> none</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>之后我们在其他地方调用改枚举时就可以获取到<code>allCase</code>属性, 如下</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="type">NetState</span>.allCases)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;case个数: &quot;</span> <span class="operator">+</span> <span class="string">&quot;<span class="subst">\(NetState.allCases.count)</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> <span class="type">NetState</span>.allCases &#123;</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果:</span></span><br><span class="line">[__lldb_expr_9.<span class="type">NetState</span>.wifi, __lldb_expr_9.<span class="type">NetState</span>.hotWifi, __lldb_expr_9.<span class="type">NetState</span>.mobile, __lldb_expr_9.<span class="type">NetState</span>.none]</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span>个数: <span class="number">4</span></span><br><span class="line"></span><br><span class="line">wifi</span><br><span class="line">hotWifi</span><br><span class="line">mobile</span><br><span class="line">none</span><br></pre></td></tr></table></figure>

<div class="note info"><p>这个`allCases`的自动合成仅替换没有参数的`case`值, 但是如果需要你需要所有`case`值, 可以重写`allCases`属性自己添加</p></div>

<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">FoodKind</span>: <span class="title class_">CaseIterable</span> &#123;</span><br><span class="line">    <span class="comment">//此处, 必须重写allCases属性, 否则报错</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> allCases: [<span class="type">FoodKind</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> [.apple, .pear, .orange(look: <span class="literal">false</span>)]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> apple</span><br><span class="line">    <span class="keyword">case</span> pear</span><br><span class="line">    <span class="keyword">case</span> orange(look: <span class="type">Bool</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> <span class="type">FoodKind</span>.allCases &#123;</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 输出结果:</span></span><br><span class="line"><span class="comment"> apple</span></span><br><span class="line"><span class="comment"> pear</span></span><br><span class="line"><span class="comment"> orange(look: false)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<div class="note primary"><p>如果有枚举项标记为`unavailable`，则默认无法合成`allCases`，只能依靠自己来手动合成</p></div>

<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">CarKind</span>: <span class="title class_">CaseIterable</span> &#123;</span><br><span class="line">    <span class="comment">//当有unavailable修饰的case值, 也必须重写allCase属性</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> allCases: [<span class="type">CarKind</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> [.bwm, .ford]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> bwm</span><br><span class="line">    <span class="keyword">case</span> ford</span><br><span class="line"></span><br><span class="line">    <span class="keyword">@available</span>(<span class="operator">*</span>, unavailable)</span><br><span class="line">    <span class="keyword">case</span> toyota</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> <span class="type">CarKind</span>.allCases &#123;</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 输出结果:</span></span><br><span class="line"><span class="comment"> bwm</span></span><br><span class="line"><span class="comment"> ford</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>



<h3 id="KeyValuePairs"><a href="#KeyValuePairs" class="headerlink" title="KeyValuePairs"></a>KeyValuePairs</h3><p><code>KeyValuePairs</code>是一种类似字典的数据类型(类似一种字典数组, 切字典有且仅有一个<code>key-value</code>值)，提供了类似字典的功能, 除此之外还具有字典所不具有的功能</p>
<ul>
<li>不需要遵循<code>Hashable</code>协议</li>
<li>可以添加具有重复键的成员</li>
<li>每一个成员变量都有其唯一的索引值</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具有重复键值的KeyValuePairs数据类型</span></span><br><span class="line"><span class="keyword">var</span> dic: <span class="type">KeyValuePairs</span> <span class="operator">=</span> [<span class="string">&quot;first&quot;</span>: <span class="string">&quot;titan&quot;</span>, <span class="string">&quot;second&quot;</span>: <span class="string">&quot;jun&quot;</span>, <span class="string">&quot;second&quot;</span>: <span class="string">&quot;top&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问第一个元素的key-value值</span></span><br><span class="line"><span class="built_in">print</span>(dic[<span class="number">0</span>])</span><br><span class="line"><span class="comment">// (key: &quot;first&quot;, value: &quot;titan&quot;)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;first: key = <span class="subst">\(dic[<span class="number">0</span>].key)</span>, value = <span class="subst">\(dic[<span class="number">0</span>].value)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// first: key = first, value = titan</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历所有的key-value</span></span><br><span class="line"><span class="keyword">for</span> dict <span class="keyword">in</span> dic &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;key = <span class="subst">\(dict.key)</span>, value = <span class="subst">\(dict.value)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输出结果</span></span><br><span class="line"><span class="comment">key = first, value = titan</span></span><br><span class="line"><span class="comment">key = second, value = jun</span></span><br><span class="line"><span class="comment">key = second, value = top</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>


<h3 id="warning和-error编译指令"><a href="#warning和-error编译指令" class="headerlink" title="#warning和#error编译指令"></a><code>#warning</code>和<code>#error</code>编译指令</h3><ul>
<li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0196-diagnostic-directives.md">SE-0196</a>介绍新的编译指令来强制<code>Xcode</code>在<code>build</code>时生成警告或错误信息</li>
<li>这两个指令是<code>#warning</code>和<code>#error</code>，前者会强制<code>Xcode</code>在生成你的代码时发出一个警告，后者会发出一个编译错误这样你的代码就完全不能编译</li>
<li><code>#warning</code>主要用于提醒你或者别人一些工作还没有完成，<code>Xcode</code>模板常使用<code>#warning</code>标记一些你需要替换成自己代码的方法存根(<code>method stubs</code>)。</li>
<li><code>#error</code>主要用于如果你发送一个库，需要其他开发者提供一些数据。比如，一个网络 <code>API</code>的认证密码，你需要用户输入它们自己的密码，就使用<code>#error</code>在继续之前强制他们更改这行代码</li>
</ul>
<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-9babace437ddb9f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<div class="note info"><p>`#warning`和`#error`可以和已存的`#if`编译指令共同使用，并且只有在条件为`true`时才会激活。例如：</p></div>

<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">#if</span> os(macOS)</span><br><span class="line"><span class="keyword">#error</span>(<span class="string">&quot;MyLibrary is not supported on macOS.&quot;</span>)</span><br><span class="line"><span class="keyword">#endif</span></span><br></pre></td></tr></table></figure>

<h3 id="动态成员查找"><a href="#动态成员查找" class="headerlink" title="动态成员查找"></a>动态成员查找</h3><ul>
<li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0195-dynamic-member-lookup.md">SE-0195</a>介绍了一个方法，让<code>Swift</code>更接近类似<code>Python</code>的脚本语言, 让<code>Swift</code>可以以属性访问的方式调用下标操作</li>
<li>这让我们可以像<code>Python</code>一样来访问字典值，不过是以类型安全的方式, 其核心在于:<ul>
<li><code>@dynamicMemberLookup</code>: 可以让<code>Swift</code>以一种下标方法去进行属性访问</li>
<li><code>subscript(dynamicMember:)</code>：可以通过所请求属性的字符串名得到，并且可以返回你想要的任何值</li>
</ul>
</li>
<li>我们可以创建一个<code>Titan</code>结构，并且从一个字典读取它的值</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Titan</span> &#123;</span><br><span class="line">    <span class="keyword">subscript</span>(<span class="params">dynamicMember</span> <span class="params">member</span>: <span class="type">String</span>) -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> properties <span class="operator">=</span> [<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Titanjun&quot;</span>, <span class="string">&quot;city&quot;</span>: <span class="string">&quot;Hang&quot;</span>]</span><br><span class="line">        <span class="keyword">return</span> properties[member, <span class="keyword">default</span>: <span class="string">&quot;0&quot;</span>] <span class="comment">//默认值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>可以看到上述代码按字符串接收成员名字，并返回一个字符串。</li>
<li>从内部看它只是在一个字典中查找这个成员名字并返回它的值</li>
<li>即使取不到对应的值, 也会以默认值的形式返回, 上述结构的代码可以这么写</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> titan <span class="operator">=</span> <span class="type">Titan</span>()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(titan.name)</span><br><span class="line"><span class="built_in">print</span>(titan.city)</span><br><span class="line"><span class="built_in">print</span>(titan.age)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="type">Titanjun</span></span><br><span class="line"><span class="type">Hang</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>

<div class="note default"><p>处理多种不同的类型</p></div>

<ul>
<li>上述<code>subscript(dynamicMember:)</code> 方法必须返回一串字符，这体现了<code>Swift</code>的类型安全性</li>
<li>如果你想要多种不同的类型, 就执行不同的<code>subscript(dynamicMember:)</code>方法</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@dynamicMemberLookup</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Titan</span> &#123;</span><br><span class="line">    <span class="keyword">subscript</span>(<span class="params">dynamicMember</span> <span class="params">member</span>: <span class="type">String</span>) -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> properties <span class="operator">=</span> [<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Titanjun&quot;</span>, <span class="string">&quot;city&quot;</span>: <span class="string">&quot;Hang&quot;</span>]</span><br><span class="line">        <span class="keyword">return</span> properties[member, <span class="keyword">default</span>: <span class="string">&quot;0&quot;</span>] <span class="comment">//默认值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">subscript</span>(<span class="params">dynamicMember</span> <span class="params">member</span>: <span class="type">String</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> properties <span class="operator">=</span> [<span class="string">&quot;age&quot;</span>: <span class="number">20</span>, <span class="string">&quot;source&quot;</span>: <span class="number">99</span>]</span><br><span class="line">        <span class="keyword">return</span> properties[member, <span class="keyword">default</span>: <span class="number">0</span>] <span class="comment">//默认值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<div class="note warning"><p>需要注意的是: 这里取值的时候, 必须注明所取得值的类型
</p></div>

<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> titan <span class="operator">=</span> <span class="type">Titan</span>()</span><br><span class="line"><span class="keyword">let</span> name: <span class="type">String</span> <span class="operator">=</span> titan.name</span><br><span class="line"><span class="keyword">let</span> city: <span class="type">String</span> <span class="operator">=</span> titan.city</span><br><span class="line"><span class="keyword">let</span> age: <span class="type">Int</span> <span class="operator">=</span> titan.age</span><br><span class="line"><span class="keyword">let</span> jun: <span class="type">String</span> <span class="operator">=</span> titan.jun</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(jun)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;name = <span class="subst">\(name)</span>, city = <span class="subst">\(city)</span>, age = <span class="subst">\(age)</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出:</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line">name <span class="operator">=</span> <span class="type">Titanjuun</span>, city <span class="operator">=</span> <span class="type">Hang</span>, age <span class="operator">=</span> <span class="number">20</span></span><br></pre></td></tr></table></figure>

<h3 id="增强的条件一致性"><a href="#增强的条件一致性" class="headerlink" title="增强的条件一致性"></a>增强的条件一致性</h3><p>条件一致性在<a href="https://www.titanjun.top/2018/04/24/Swift%204.1%20%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/">Swift 4.1</a>中引入，一个类型的所有元素如果符合<code>Hashable</code>协议，则类型自动符合<code>Hashable</code>协议</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义Purchaseable协议</span></span><br><span class="line"><span class="keyword">protocol</span> <span class="title class_">Purchaseable</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">buy</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个符合该协议的结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Book</span>: <span class="title class_">Purchaseable</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">buy</span>() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;You bought a book&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组遵循该协议, 并且每一个元素也遵循该协议</span></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">Array</span>: <span class="title class_">Purchaseable</span> <span class="title class_">where</span> <span class="title class_">Element</span>: <span class="title class_">Purchaseable</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">buy</span>() &#123;</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            item.buy()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note danger"><p>下面我们在Swift 4.1中运行如下代码, 会发现崩溃
</p></div>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let items: Any = [Book(), Book(), Book()]</span><br><span class="line"></span><br><span class="line">if let books = items as? Purchaseable &#123;</span><br><span class="line">    books.buy()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果你收到一种类型的数据，想要检查它是否可以被转化为一个条件一致性协议, 这种在<code>Swift 4.1</code>中是不支持的, 但是在<code>Swift 4.2</code>中却可以很好的解决</li>
<li>另外, 对<code>Hashable</code>一致性自动合并的支持在<code>Swift 4.2</code>被大幅提高，来自<code>Swift</code> 标准库的几个内置类型，包括<code>optionals</code>, <code>arrays</code>, <code>dictionaries</code>和 <code>ranges</code>, 现在当他们的元素符合<code>Hashable</code>时会自动符合<code>Hashable</code> 协议</li>
</ul>
<h3 id="本地集合元素移除"><a href="#本地集合元素移除" class="headerlink" title="本地集合元素移除"></a>本地集合元素移除</h3><p><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0197-remove-where.md">SE-0197</a>介绍一个新的<code>removeAll(where:)</code>方法, 高效地执行根据条件删除操作</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> pythons <span class="operator">=</span> [<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Michael&quot;</span>, <span class="string">&quot;Graham&quot;</span>, <span class="string">&quot;Terry&quot;</span>, <span class="string">&quot;Eric&quot;</span>, <span class="string">&quot;Terry&quot;</span>]</span><br><span class="line">pythons.removeAll &#123; <span class="variable">$0</span>.hasPrefix(<span class="string">&quot;Terry&quot;</span>) &#125;</span><br><span class="line"><span class="built_in">print</span>(pythons)</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出: [&quot;John&quot;, &quot;Michael&quot;, &quot;Graham&quot;, &quot;Eric&quot;]</span></span><br></pre></td></tr></table></figure>

<div class="note warning"><p>对比`filter`过滤方法
</p></div>

<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> python2 <span class="operator">=</span> [<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Michael&quot;</span>, <span class="string">&quot;Graham&quot;</span>, <span class="string">&quot;Terry&quot;</span>, <span class="string">&quot;Eric&quot;</span>, <span class="string">&quot;Terry&quot;</span>]</span><br><span class="line">python2 <span class="operator">=</span> python2.filter &#123; <span class="operator">!</span><span class="variable">$0</span>.hasPrefix(<span class="string">&quot;Terry&quot;</span>) &#125;</span><br><span class="line"><span class="built_in">print</span>(python2)</span><br></pre></td></tr></table></figure>

<p>这并不是非常有效地使用内存，它指定了你不想要的东西，而不是你想要的东西</p>
<h3 id="随机数字的生成和洗牌"><a href="#随机数字的生成和洗牌" class="headerlink" title="随机数字的生成和洗牌"></a>随机数字的生成和洗牌</h3><ul>
<li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0202-random-unification.md">SE-0202</a>中<code>Swift</code>引入了新的随机数<code>API</code></li>
<li>可以通过调用<code>random()</code>随机数方法来生成一个随机数, 只需提供一个随机数范围即可</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ranInt <span class="operator">=</span> <span class="type">Int</span>.random(in: <span class="number">0</span><span class="operator">..&lt;</span><span class="number">5</span>)</span><br><span class="line"><span class="keyword">let</span> ranFloat <span class="operator">=</span> <span class="type">Float</span>.random(in: <span class="number">0</span><span class="operator">..&lt;</span><span class="number">5</span>)</span><br><span class="line"><span class="keyword">let</span> ranDouble <span class="operator">=</span> <span class="type">Double</span>.random(in: <span class="number">0</span><span class="operator">..&lt;</span><span class="number">5</span>)</span><br><span class="line"><span class="keyword">let</span> ranCGFloat <span class="operator">=</span> <span class="type">CGFloat</span>.random(in: <span class="number">0</span><span class="operator">..&lt;</span><span class="number">5</span>)</span><br><span class="line"><span class="keyword">let</span> ranBOOL <span class="operator">=</span> <span class="type">Bool</span>.random()</span><br></pre></td></tr></table></figure>

<div class="note primary"><p>对数组进行重新洗牌
</p></div>

<p><code>SE-0202</code>还支持使用新方法<code>shuffle()</code>和<code>shuffled()</code>方法对数组元素进行重新随机排序</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> albums <span class="operator">=</span> [<span class="string">&quot;Red&quot;</span>, <span class="string">&quot;1989&quot;</span>, <span class="string">&quot;Reputation&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有返回值</span></span><br><span class="line">albums.shuffle()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有返回值, 重新返回一个数组</span></span><br><span class="line"><span class="keyword">let</span> shuffled <span class="operator">=</span> albums.shuffled()</span><br></pre></td></tr></table></figure>

<div class="note info"><p>获取数组中的一个随机元素
</p></div>

<p><code>randomElement()</code>: 数组的一个新方法, 如果数组部位空, 则返回数组中的一个随机元素, 否则返回<code>nil</code></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> random <span class="operator">=</span> albums.randomElement() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The random album is <span class="subst">\(random)</span>.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="更简单，更安全的哈希"><a href="#更简单，更安全的哈希" class="headerlink" title="更简单，更安全的哈希"></a>更简单，更安全的哈希</h3><ul>
<li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0206-hashable-enhancements.md">SE-0206</a>介绍了在<code>Swift 4.1</code>中简化了我们使自定义类型符合<code>Hashable</code>协议的方式</li>
<li><code>Swift 4.2</code>引入了一个新的<code>Hasher</code>结构，它提供了一个随机播种的通用散列函数</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">iPad</span>: <span class="title class_">Hashable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> serialNumber: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> capacity: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">hash</span>(<span class="params">into</span> <span class="params">hasher</span>: <span class="keyword">inout</span> <span class="type">Hasher</span>) &#123;</span><br><span class="line">        hasher.combine(serialNumber)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>可以通过<code>combine()</code>重复调用将更多属性添加到散列，并且添加属性的顺序会影响完成的散列值。</li>
<li>还可以将其<code>Hasher</code>用作独立散列发生器：只要提供您想散列的任何值，然后调用<code>finalize()</code>以生成最终值</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> first <span class="operator">=</span> iPad(serialNumber: <span class="string">&quot;12345&quot;</span>, capacity: <span class="number">256</span>)</span><br><span class="line"><span class="keyword">let</span> second <span class="operator">=</span> iPad(serialNumber: <span class="string">&quot;54321&quot;</span>, capacity: <span class="number">512</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hasher <span class="operator">=</span> <span class="type">Hasher</span>()</span><br><span class="line">hasher.combine(first)</span><br><span class="line">hasher.combine(second)</span><br><span class="line"><span class="keyword">let</span> hash <span class="operator">=</span> hasher.finalize()</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Hasher</code>每次散列对象时都会使用随机种子，这意味着任何对象的散列值在您的应用运行之间有效地保证是不同的</li>
<li>这又意味着您添加到集合或字典中的元素很可能在您每次运行应用程序时都有不同的顺序</li>
</ul>
<h3 id="检查序列元素是否符合条件"><a href="#检查序列元素是否符合条件" class="headerlink" title="检查序列元素是否符合条件"></a>检查序列元素是否符合条件</h3><p><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0207-containsOnly.md">SE-0207</a>提供了<code>allSatisfy()</code>一种检查序列中的所有元素是否满足条件的新方法</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断数组的所有元素是否全部大于85</span></span><br><span class="line"><span class="keyword">let</span> scores <span class="operator">=</span> [<span class="number">86</span>, <span class="number">88</span>, <span class="number">95</span>, <span class="number">92</span>]</span><br><span class="line"><span class="comment">//返回一个BOOL</span></span><br><span class="line"><span class="keyword">let</span> passed <span class="operator">=</span> scores.allSatisfy(&#123; <span class="variable">$0</span> <span class="operator">&gt;</span> <span class="number">85</span> &#125;)</span><br><span class="line"><span class="built_in">print</span>(passed)</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出: true</span></span><br></pre></td></tr></table></figure>


<h3 id="布尔切换"><a href="#布尔切换" class="headerlink" title="布尔切换"></a>布尔切换</h3><p><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0199-bool-toggle.md">SE-0199</a>引入了一种新的<code>toggle()</code>方法, 可以将布尔值取反, 实现代码如下:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Bool</span> &#123;</span><br><span class="line">   <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">toggle</span>() &#123;</span><br><span class="line">      <span class="keyword">self</span> <span class="operator">=</span> <span class="operator">!</span><span class="keyword">self</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success"><p>测试代码
</p></div>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var isSwift = true</span><br><span class="line">//toggle函数没有返回值</span><br><span class="line">isSwift.toggle()</span><br><span class="line">print(isSwift)</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><ul>
<li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0204-add-last-methods.md">SE-0204</a>介绍了数组中的获取满足条件的数组中的最后一个元素或者索引值</li>
<li>在<code>Swift 4.1</code>中我们只能取得<code>first</code>值, 却无法获取数组中的最后一个值(或者要用大量代码实现)</li>
<li>在<code>Swift 4.2</code>中提供了<code>last(where:)</code>和<code>lastIndex(where:)</code>方法来获取数组中满足条件的最后的元素和索引值</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取满足条件的数组中的第一个值</span></span><br><span class="line"><span class="keyword">let</span> a <span class="operator">=</span> [<span class="number">20</span>, <span class="number">30</span>, <span class="number">10</span>, <span class="number">40</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">10</span>, <span class="number">40</span>, <span class="number">20</span>]</span><br><span class="line"><span class="built_in">print</span>(a.first(where: &#123; <span class="variable">$0</span> <span class="operator">&gt;</span> <span class="number">25</span> &#125;))  </span><br><span class="line"><span class="built_in">print</span>(a.index(where: &#123; <span class="variable">$0</span> <span class="operator">&gt;</span> <span class="number">25</span> &#125;))</span><br><span class="line"><span class="built_in">print</span>(a.index(of: <span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出:</span></span><br><span class="line"><span class="number">30</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<div class="note success"><p>`Swift 4.2`中新增的`last`函数
</p></div>

<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在Swift4.1中</span></span><br><span class="line"><span class="built_in">print</span>((a.reversed().index(where: &#123; <span class="variable">$0</span> <span class="operator">&gt;</span> <span class="number">25</span> &#125;)<span class="operator">?</span>.base).map(&#123; a.index(before: <span class="variable">$0</span>) &#125;))</span><br><span class="line"><span class="comment">//输出: 7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Swift 4.2</span></span><br><span class="line"><span class="comment">//获取满足条件的元素</span></span><br><span class="line"><span class="built_in">print</span>(a.last(where: &#123; <span class="variable">$0</span> <span class="operator">&gt;</span> <span class="number">25</span> &#125;))   <span class="comment">//40</span></span><br><span class="line"><span class="comment">//获取满足条件的元素的索引</span></span><br><span class="line"><span class="built_in">print</span>(a.lastIndex(where: &#123; <span class="variable">$0</span> <span class="operator">&gt;</span> <span class="number">25</span> &#125;))   <span class="comment">//7</span></span><br></pre></td></tr></table></figure>



<h3 id="展望Swift-5-0"><a href="#展望Swift-5-0" class="headerlink" title="展望Swift 5.0"></a>展望Swift 5.0</h3><ul>
<li>苹果形容<code>Swift 4.2</code>为”为了实现Swift 5中ABI稳定性的中继点”, 想必<code>Swift 4.1</code>和<code>Swift 4.2</code>的发布也是为了<code>Swift 5.0</code>做一个铺垫</li>
<li>最后还是期待<code>Swift 5.0</code>能够带来更加稳定的<code>API</code></li>
</ul>
<h4 id="附录参考"><a href="#附录参考" class="headerlink" title="附录参考"></a>附录参考</h4><ul>
<li><a href="https://www.hackingwithswift.com/articles/77/whats-new-in-swift-4-2">What’s new in Swift 4.2?</a></li>
<li><a href="https://swift.org/blog/4-2-release-process/">Swift 4.2 Release Process</a></li>
<li><a href="https://github.com/apple/swift-evolution/tree/master/proposals">Swift evolution</a></li>
</ul>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift之Vision 图像识别框架</title>
    <url>/post/99a85893.html</url>
    <content><![CDATA[<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-c0b83aa723e149ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="VNObservation.png"></p>
<span id="more"></span>


<ul>
<li>2017年苹果大大又推出了新机型iPhone 8和iPhone 8Plus, 这还不是重点, 重点是那一款价值9000RMB的iPhone X, 虽说网上吐槽声从未停止过, 但是我觉得还是不错的哈!</li>
<li>软件方面, 苹果大大也推出了iOS 11, 经本人iPhone 7手机亲测, 耗电快外加通知栏改不完的bug</li>
<li>当然了随着iOS 11的推出, 也随之推出了一些新的API，如：<a href="https://developer.apple.com/documentation/arkit"><code>ARKit</code></a> 、<a href="https://developer.apple.com/documentation/coreml"><code>Core ML</code></a>、<a href="https://developer.apple.com/documentation/fileprovider"><code>FileProvider</code></a>、<a href="https://developer.apple.com/documentation/identitylookup"><code>IdentityLookup</code></a> 、<a href="https://developer.apple.com/documentation/corenfc"><code>Core NFC</code></a>、<a href="https://developer.apple.com/documentation/vision"><code>Vison</code></a> 等。</li>
<li>这里我们还要说的就是Apple 在 WWDC 2017 推出的图像识别框架–<code>Vison</code><a href="https://developer.apple.com/documentation/vision">官方文档</a></li>
<li><a href="https://github.com/coderQuanjun/JunVisionFace">Demo地址</a></li>
</ul>
<h2 id="Vision应用场景"><a href="#Vision应用场景" class="headerlink" title="Vision应用场景"></a>Vision应用场景</h2><ul>
<li><code>Face Detection and Recognition</code> : 人脸检测<ul>
<li>支持检测笑脸、侧脸、局部遮挡脸部、戴眼镜和帽子等场景，可以标记出人脸的矩形区域</li>
<li>可以标记出人脸和眼睛、眉毛、鼻子、嘴、牙齿的轮廓，以及人脸的中轴线</li>
</ul>
</li>
<li><code>Image Alignment Analysis</code>: 图像对比分析</li>
<li><code>Barcode Detection</code>: 二维码&#x2F;条形码检测<ul>
<li>用于查找和识别图像中的条码</li>
<li>检测条形码信息</li>
</ul>
</li>
<li><code>Text Detection</code>: 文字检测<ul>
<li>查找图像中可见文本的区域</li>
<li>检测文本区域的信息</li>
</ul>
</li>
<li><code>Object Detection and Tracking</code>: 目标跟踪<ul>
<li>脸部，矩形和通用模板</li>
</ul>
</li>
</ul>
<h2 id="Vision支持的图片类型"><a href="#Vision支持的图片类型" class="headerlink" title="Vision支持的图片类型"></a>Vision支持的图片类型</h2><h3 id="Objective-C中"><a href="#Objective-C中" class="headerlink" title="Objective-C中"></a>Objective-C中</h3><ul>
<li><code>CVPixelBufferRef</code></li>
<li><code>CGImageRef</code></li>
<li><code>CIImage</code></li>
<li><code>NSURL</code></li>
<li><code>NSData</code></li>
</ul>
<h3 id="Swift中"><a href="#Swift中" class="headerlink" title="Swift中"></a>Swift中</h3><ul>
<li><code>CVPixelBuffer</code></li>
<li><code>CGImage</code></li>
<li><code>CIImage</code></li>
<li><code>URL</code></li>
<li><code>Data</code></li>
</ul>
<blockquote>
<p>具体详情可在<code>Vision.framework</code>的<code>VNImageRequestHandler.h</code>文件中查看</p>
</blockquote>
<h2 id="Vision之API介绍"><a href="#Vision之API介绍" class="headerlink" title="Vision之API介绍"></a>Vision之API介绍</h2><ul>
<li>使用在<code>vision</code>的时候，我们首先需要明确自己需要什么效果，然后根据想要的效果来选择不同的类</li>
<li>给各种功能的 <code>Request</code> 提供给一个 <code>RequestHandler</code></li>
<li><code>Handler</code> 持有需要识别的图片信息，并将处理结果分发给每个 <code>Request</code> 的 <code>completion Block</code> 中</li>
<li>可以从 <code>results</code> 属性中得到 <code>Observation</code> 数组</li>
<li><code>observations</code>数组中的内容根据不同的request请求返回了不同的<code>observation</code></li>
<li>每种<code>Observation</code>有<code>boundingBox</code>，<code>landmarks</code>等属性，存储的是识别后物体的坐标，点位等</li>
<li>我们拿到坐标后，就可以进行一些UI绘制。</li>
</ul>
<h3 id="RequestHandler处理请求对象"><a href="#RequestHandler处理请求对象" class="headerlink" title="RequestHandler处理请求对象"></a><code>RequestHandler</code>处理请求对象</h3><ul>
<li><code>VNImageRequestHandler</code>: 处理与单个图像有关的一个或多个图像分析请求的对象<ul>
<li>一般情况下都是用该类处理识别请求</li>
<li>初始化方法支持<code>CVPixelBuffer</code>, <code>CGImage</code>, <code>CIImage</code>, <code>URL</code>, <code>Data</code></li>
</ul>
</li>
<li><code>VNSequenceRequestHandler</code>: 处理与多个图像序列有关的图像分析请求的对象<ul>
<li>目前我在处理物体跟踪的时候使用该类</li>
<li>初始化方法同上</li>
</ul>
</li>
</ul>
<h3 id="VNRequest介绍"><a href="#VNRequest介绍" class="headerlink" title="VNRequest介绍"></a>VNRequest介绍</h3><ul>
<li><code>VNRequest</code>: 图像分析请求的抽象类, 继承于<code>NSObject</code></li>
<li><code>VNBaseImageRequest</code>: 专注于图像的特定部分的分析请求</li>
<li>具体分析请求类如下: </li>
<li><img data-src="http://upload-images.jianshu.io/upload_images/4122543-b58783bec9d07551.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="VNImageBasedRequest.png"></li>
</ul>
<h3 id="VNObservation检测对象"><a href="#VNObservation检测对象" class="headerlink" title="VNObservation检测对象"></a><code>VNObservation</code>检测对象</h3><ul>
<li><code>VNObservation</code>: 图像分析结果的抽象类, 继承与<code>NSObject</code></li>
<li>图像检测结果的相关处理类如下:</li>
</ul>
<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-c0b83aa723e149ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="VNObservation.png"></p>
<h2 id="实战演练"><a href="#实战演练" class="headerlink" title="实战演练"></a>实战演练</h2><h3 id="文本检测"><a href="#文本检测" class="headerlink" title="文本检测"></a>文本检测</h3><ul>
<li>方式一: 识别出具体的每一个字体的位置信息</li>
<li>方式二: 识别一行字体的位置信息</li>
<li>如图效果:</li>
</ul>
<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-0c09426c80013322.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/200" alt="WechatIMG3.jpeg"> </p>
<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-8b970c464c26ffb0.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/200" alt="WechatIMG5.jpeg"></p>
<h4 id="现将图片转成初始化VNImageRequestHandler对象时-可接受的的CIImage"><a href="#现将图片转成初始化VNImageRequestHandler对象时-可接受的的CIImage" class="headerlink" title="现将图片转成初始化VNImageRequestHandler对象时, 可接受的的CIImage"></a>现将图片转成初始化<code>VNImageRequestHandler</code>对象时, 可接受的的<code>CIImage</code></h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 转成ciimage</span></span><br><span class="line">guard let ciImage = <span class="built_in">CIImage</span>(image: image) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建处理请求的handle"><a href="#创建处理请求的handle" class="headerlink" title="创建处理请求的handle"></a>创建处理请求的handle</h4><ul>
<li>参数一: 图片类型</li>
<li>参数二: 字典类型, 有默认值为[:]</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">let requestHandle = VNImageRequestHandler(ciImage: ciImage, options: [:])</span><br></pre></td></tr></table></figure>

<h4 id="创建回调闭包"><a href="#创建回调闭包" class="headerlink" title="创建回调闭包"></a>创建回调闭包</h4><ul>
<li>两个参数, 无返回值</li>
<li><code>VNRequest</code>: 是所有请求Request的父类</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">public typealias VNRequestCompletionHandler = (VNRequest, Error?) -&gt; Swift.Void</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>具体代码如下:</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//4. 设置回调</span></span><br><span class="line">let completionHandle: VNRequestCompletionHandler = &#123; request, error <span class="keyword">in</span></span><br><span class="line">    let observations = request.results</span><br><span class="line">    <span class="comment">//识别出来的对象数组    </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="创建识别请求"><a href="#创建识别请求" class="headerlink" title="创建识别请求"></a>创建识别请求</h4><ul>
<li>两种初始化方式</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//无参数</span></span><br><span class="line">public convenience init()</span><br><span class="line">    </span><br><span class="line"><span class="comment">//闭包参数</span></span><br><span class="line">public init(completionHandler: Vision.VNRequestCompletionHandler? = <span class="literal">nil</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>这里使用带闭包的初始化方式</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">let baseRequest = VNDetectTextRectanglesRequest(completionHandler: completionHandle)</span><br></pre></td></tr></table></figure>

<ul>
<li>属性设置(是否识别具体的每一个文字)</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置识别具体文字</span></span><br><span class="line">baseRequest.setValue(<span class="literal">true</span>, forKey: <span class="string">&quot;reportCharacterBoxes&quot;</span>) </span><br></pre></td></tr></table></figure>
<ul>
<li>不设置该属性, 识别出来的是一行文字</li>
</ul>
<h4 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">open func perform(_ requests: [VNRequest]) throws</span><br></pre></td></tr></table></figure>

<ul>
<li>该方法会抛出一个异常错误</li>
<li>在连续不断(摄像头扫描)发送请求过程中, 必须在子线程执行该方法, 否则会造成线程堵塞</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//6. 发送请求</span></span><br><span class="line">DispatchQueue.global().async &#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        try requestHandle.perform([baseRequest])</span><br><span class="line">    &#125;catch&#123;</span><br><span class="line">        print(<span class="string">&quot;Throws：\(error)&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="处理识别的Observations对象"><a href="#处理识别的Observations对象" class="headerlink" title="处理识别的Observations对象"></a>处理识别的<code>Observations</code>对象</h4><ul>
<li>识别出来的<code>results</code>是<code>[Any]?</code>类型</li>
<li>根据<code>boundingBox</code>属性可以获取到对应的文本区域的尺寸</li>
<li>需要注意的是:<ul>
<li><code>boundingBox</code>得到的是相对iamge的比例尺寸, 都是小于1的</li>
<li>Y轴坐标于UIView坐标系是相反的</li>
</ul>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 获取识别到的VNTextObservation</span></span><br><span class="line">guard let boxArr = observations as? [VNTextObservation] <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//2. 创建rect数组</span></span><br><span class="line">var bigRects = [<span class="built_in">CGRect</span>](), smallRects = [<span class="built_in">CGRect</span>]()</span><br><span class="line">        </span><br><span class="line"><span class="comment">//3. 遍历识别结果</span></span><br><span class="line"><span class="keyword">for</span> boxObj <span class="keyword">in</span> boxArr &#123;</span><br><span class="line">    <span class="comment">// 3.1尺寸转换</span></span><br><span class="line">    <span class="comment">//获取一行文本的区域位置</span></span><br><span class="line">    bigRects.append(convertRect(boxObj.boundingBox, image))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2. 获取</span></span><br><span class="line">    guard let rectangleArr = boxObj.characterBoxes <span class="keyword">else</span> &#123; <span class="keyword">continue</span> &#125;</span><br><span class="line">    <span class="keyword">for</span> rectangle <span class="keyword">in</span> rectangleArr&#123;</span><br><span class="line">        <span class="comment">//3. 得到每一个字体的的尺寸</span></span><br><span class="line">        let boundBox = rectangle.boundingBox</span><br><span class="line">        smallRects.append(convertRect(boundBox, image))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>坐标转换</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// image坐标转换</span></span><br><span class="line">fileprivate func convertRect(_ rectangleRect: <span class="built_in">CGRect</span>, _ image: <span class="built_in">UIImage</span>) -&gt; <span class="built_in">CGRect</span> &#123;</span><br><span class="line"><span class="comment">//此处是将Image的实际尺寸转化成imageView的尺寸</span></span><br><span class="line">    let imageSize = image.scaleImage()</span><br><span class="line">    let w = rectangleRect.width * imageSize.width</span><br><span class="line">    let h = rectangleRect.height * imageSize.height</span><br><span class="line">    let x = rectangleRect.minX * imageSize.width</span><br><span class="line">    <span class="comment">//该Y坐标与UIView的Y坐标是相反的</span></span><br><span class="line">    let y = (<span class="number">1</span> - rectangleRect.minY) * imageSize.height - h</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CGRect</span>(x: x, y: y, width: w, height: h)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="矩形识别和静态人脸识别"><a href="#矩形识别和静态人脸识别" class="headerlink" title="矩形识别和静态人脸识别"></a>矩形识别和静态人脸识别</h3><ul>
<li><p>识别图像中的矩形</p>
</li>
<li><p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-05e6a9cc6c193b1d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="1511935758595.jpg"></p>
</li>
<li><p>静态人脸识别</p>
</li>
<li><p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-e5faf93cebae945e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="1511936019734.jpg"></p>
</li>
<li><p>主要核心代码</p>
</li>
<li></li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 转成ciimage</span></span><br><span class="line">guard let ciImage = <span class="built_in">CIImage</span>(image: image) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//2. 创建处理request</span></span><br><span class="line">let requestHandle = VNImageRequestHandler(ciImage: ciImage, options: [:])</span><br><span class="line">        </span><br><span class="line"><span class="comment">//3. 创建baseRequest</span></span><br><span class="line"><span class="comment">//大多数识别请求request都继承自VNImageBasedRequest</span></span><br><span class="line">var baseRequest = VNImageBasedRequest()</span><br><span class="line">        </span><br><span class="line"><span class="comment">//4. 设置回调</span></span><br><span class="line">let completionHandle: VNRequestCompletionHandler = &#123; request, error <span class="keyword">in</span></span><br><span class="line">    let observations = request.results</span><br><span class="line">    <span class="keyword">self</span>.handleImageObservable(type: type, image: image, observations, completeBack)</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//5. 创建识别请求</span></span><br><span class="line"><span class="keyword">switch</span> type &#123;</span><br><span class="line"><span class="keyword">case</span> .rectangle:</span><br><span class="line">    baseRequest = VNDetectRectanglesRequest(completionHandler: completionHandle)</span><br><span class="line"><span class="keyword">case</span> .staticFace:</span><br><span class="line">    baseRequest = VNDetectFaceRectanglesRequest(completionHandler: completionHandle)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>处理识别的observation</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 矩形检测</span></span><br><span class="line">fileprivate func rectangleDectect(_ observations: [Any]?, image: <span class="built_in">UIImage</span>, _ complecHandle: JunDetectHandle)&#123;</span><br><span class="line">    <span class="comment">//1. 获取识别到的VNRectangleObservation</span></span><br><span class="line">    guard let boxArr = observations as? [VNRectangleObservation] <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    <span class="comment">//2. 创建rect数组</span></span><br><span class="line">    var bigRects = [<span class="built_in">CGRect</span>]()</span><br><span class="line">    <span class="comment">//3. 遍历识别结果</span></span><br><span class="line">    <span class="keyword">for</span> boxObj <span class="keyword">in</span> boxArr &#123;</span><br><span class="line">        <span class="comment">// 3.1</span></span><br><span class="line">        bigRects.append(convertRect(boxObj.boundingBox, image))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4. 回调结果</span></span><br><span class="line">    complecHandle(bigRects, [])</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>静态人脸识别需要将<code>observation</code>转成<code>VNFaceObservation</code></li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">guard let boxArr = observations as? [VNFaceObservation] <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="条码识别"><a href="#条码识别" class="headerlink" title="条码识别"></a>条码识别</h3><p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-9f199a027f186a5c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="1511936988374.jpg"></p>
<ul>
<li>这里请求的步骤与矩形识别相同, 这里不再赘述</li>
<li>需要注意的是,在初始化request的时候需要设一个置可识别的条码类型参数</li>
<li>这里先看一下<code>VNDetectBarcodesRequest</code>的两个参数</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//支持的可识别的条码类型(需要直接用class调用)</span></span><br><span class="line">open <span class="keyword">class</span> var supportedSymbologies: [VNBarcodeSymbology] &#123; get &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置可识别的条码类型</span></span><br><span class="line">open var symbologies: [VNBarcodeSymbology]</span><br></pre></td></tr></table></figure>

<ul>
<li>此处设置可识别到的条码类型为, 该请求支持是别的所有类型, 如下</li>
<li>注意<code>supportedSymbologies</code>参数的调用方法</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">let request = VNDetectBarcodesRequest(completionHandler: completionHandle)</span><br><span class="line">request.symbologies = VNDetectBarcodesRequest.supportedSymbologies</span><br></pre></td></tr></table></figure>

<ul>
<li>条码识别不但能识别条码的位置信息, 还可以识别出条码的相关信息, 这里以二维码为例</li>
<li>这里需要将识别的<code>observations</code>转成<code>[VNBarcodeObservation]</code></li>
<li><code>VNBarcodeObservation</code>有三个属性</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//条码类型: qr, code128....等等</span></span><br><span class="line">open var symbology: VNBarcodeSymbology &#123; get &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//条码的相关信息</span></span><br><span class="line">open var barcodeDescriptor: <span class="built_in">CIBarcodeDescriptor</span>? &#123; get &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是二维码, 则是二维码的网址链接    </span></span><br><span class="line">open var payloadStringValue: String? &#123; get &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如上述图片识别出来的<code>payloadStringValue</code>参数则是小编的<a href="http://www.jianshu.com/u/5bd5e9ed569e">简书地址</a></li>
<li>下面是以上述图片的二维码为例处理的<code>CIBarcodeDescriptor</code>对象</li>
<li>有兴趣的可以仔细研究研究</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 二维码信息处理</span></span><br><span class="line">fileprivate func qrCodeHandle(barCode: <span class="built_in">CIBarcodeDescriptor</span>?)&#123;</span><br><span class="line">    <span class="comment">//1. 转成对应的条码对象</span></span><br><span class="line">    guard let code = barCode as? <span class="built_in">CIQRCodeDescriptor</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2. 解读条码信息</span></span><br><span class="line">    let level = code.errorCorrectionLevel.hashValue</span><br><span class="line">    let version = code.symbolVersion</span><br><span class="line">    let mask = code.maskPattern</span><br><span class="line">    let data = code.errorCorrectedPayload</span><br><span class="line">    let dataStr = String(data: data, encoding: .utf8)</span><br><span class="line">    print(<span class="string">&quot;这是二维码信息--&quot;</span>, level, <span class="string">&quot;---&quot;</span>, version, <span class="string">&quot;----&quot;</span>, mask, <span class="string">&quot;---&quot;</span>, dataStr ?? <span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="人脸特征识别"><a href="#人脸特征识别" class="headerlink" title="人脸特征识别"></a>人脸特征识别</h3><ul>
<li><p>可识别出人脸的轮廓, 眼睛, 鼻子, 嘴巴等具体位置</p>
</li>
<li><p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-895670df5fd8e2c9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="1511944652200.jpg"></p>
</li>
<li><p><code>VNFaceLandmarks2D</code>介绍</p>
</li>
<li></li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 脸部轮廓</span></span><br><span class="line">var faceContour: VNFaceLandmarkRegion2D?</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 左眼, 右眼</span></span><br><span class="line">var leftEye: VNFaceLandmarkRegion2D?</span><br><span class="line">var rightEye: VNFaceLandmarkRegion2D?</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 左睫毛, 右睫毛</span></span><br><span class="line">var leftEyebrow: VNFaceLandmarkRegion2D?</span><br><span class="line">var rightEyebrow: VNFaceLandmarkRegion2D?</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 左眼瞳, 右眼瞳</span></span><br><span class="line">var leftPupil: VNFaceLandmarkRegion2D?</span><br><span class="line">var rightPupil: VNFaceLandmarkRegion2D?</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 鼻子, 鼻嵴, 正中线</span></span><br><span class="line">var nose: VNFaceLandmarkRegion2D?</span><br><span class="line">var noseCrest: VNFaceLandmarkRegion2D?</span><br><span class="line">var medianLine: VNFaceLandmarkRegion2D?</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 外唇, 内唇</span></span><br><span class="line">var outerLips: VNFaceLandmarkRegion2D?</span><br><span class="line">var innerLips: VNFaceLandmarkRegion2D?</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//某一部位所有的像素点</span><br><span class="line">@nonobjc public var normalizedPoints: [CGPoint] &#123; get &#125;</span><br><span class="line"></span><br><span class="line">//某一部位的所有像素点的个数</span><br><span class="line">open var pointCount: Int &#123; get &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>将所有的像素点坐标转换成image对应的尺寸坐标</li>
<li>使用图像上下文, 对应部位画线</li>
<li>在UIView中重写<code>func draw(_ rect: CGRect)</code>方法</li>
<li></li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//5.1 获取当前上下文</span></span><br><span class="line">let content = <span class="built_in">UIGraphicsGetCurrentContext</span>()</span><br><span class="line">                </span><br><span class="line"><span class="comment">//5.2 设置填充颜色(setStroke设置描边颜色)</span></span><br><span class="line"><span class="built_in">UIColor</span>.green.set()</span><br><span class="line">                </span><br><span class="line"><span class="comment">//5.3 设置宽度</span></span><br><span class="line">content?.setLineWidth(<span class="number">2</span>)</span><br><span class="line">                </span><br><span class="line"><span class="comment">//5.4. 设置线的类型(连接处)</span></span><br><span class="line">content?.setLineJoin(.round)</span><br><span class="line">content?.setLineCap(.round)</span><br><span class="line">                </span><br><span class="line"><span class="comment">//5.5. 设置抗锯齿效果</span></span><br><span class="line">content?.setShouldAntialias(<span class="literal">true</span>)</span><br><span class="line">content?.setAllowsAntialiasing(<span class="literal">true</span>)</span><br><span class="line">                </span><br><span class="line"><span class="comment">//5.6 开始绘制</span></span><br><span class="line">content?.addLines(between: pointArr)</span><br><span class="line">content?.drawPath(using: .stroke)</span><br><span class="line">                </span><br><span class="line"><span class="comment">//5.7 结束绘制</span></span><br><span class="line">content?.strokePath()</span><br></pre></td></tr></table></figure>

<h3 id="动态人脸识别和实时动态添加"><a href="#动态人脸识别和实时动态添加" class="headerlink" title="动态人脸识别和实时动态添加"></a>动态人脸识别和实时动态添加</h3><blockquote>
<p>由于真机不好录制gif图(尝试了一下, 效果不是很好, 放弃了), 想看效果的朋友<a href="https://github.com/coderQuanjun/JunVisionFace">下载源码</a>真机运行吧</p>
</blockquote>
<ul>
<li><p>这里提供一张<a href="http://upload-images.jianshu.io/upload_images/4122543-e390e4107c0b811b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">可供扫描的图片</a></p>
</li>
<li><p><code>request</code>的初始化这里就不做介绍了, 说一下<code>handle</code>的初始化方法</p>
<ul>
<li><code>CVPixelBuffer</code>: 扫描实时输出的对象</li>
</ul>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 创建处理请求</span></span><br><span class="line">let faceHandle = VNImageRequestHandler(cvPixelBuffer: pixelBuffer, options: [:])</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>主要强调一点, 相机扫描, 获取实时图像的过程, 必须在子线程执行, 否在会堵塞线程, 整个app失去响应, 亲自踩过的坑</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">DispatchQueue.global().async &#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        try faceHandle.perform([baseRequest])</span><br><span class="line">    &#125;catch&#123;</span><br><span class="line">        print(<span class="string">&quot;Throws：\(error)&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="扫描结果处理"><a href="#扫描结果处理" class="headerlink" title="扫描结果处理"></a>扫描结果处理</h4><ul>
<li>动态人脸识别和静态人脸识别不同的地方就是, 动态实时刷新, 更新UI, 所以处理结果的方法相同</li>
<li>动态添加: 这里处理方式是添加一个眼镜效果</li>
<li>这里需要获取到两只眼睛的位置和宽度<ul>
<li>先获取到左右眼的所有的像素点和像素点的个数</li>
<li>遍历所有的像素点, 转换成合适的坐标</li>
<li>将左右眼的所有的point, 分别获取X和Y坐标放到不同的数组</li>
<li>将数组有小到大排序, 得到X的最大和最小的差值, Y的最大和最小的差值</li>
<li>具体代码如下</li>
</ul>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// H偶去转换后的尺寸坐标</span></span><br><span class="line">fileprivate func getEyePoint(faceModel: FaceFeatureModel, position: <span class="built_in">AVCaptureDevice</span>.Position) -&gt; <span class="built_in">CGRect</span>&#123;</span><br><span class="line">    <span class="comment">//1. 获取左右眼</span></span><br><span class="line">    guard let leftEye = faceModel.leftEye <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="built_in">CGRect</span>.zero &#125;</span><br><span class="line">    guard let rightEye = faceModel.rightEye <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="built_in">CGRect</span>.zero &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 位置数组</span></span><br><span class="line">    let leftPoint = conventPoint(landmark: leftEye, faceRect: faceModel.faceObservation.boundingBox, position: position)</span><br><span class="line">    let rightPoint = conventPoint(landmark: rightEye, faceRect: faceModel.faceObservation.boundingBox, position: position)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 排序</span></span><br><span class="line">    let pointXs = (leftPoint<span class="number">.0</span> + rightPoint<span class="number">.0</span>).sorted()</span><br><span class="line">    let pointYs = (leftPoint<span class="number">.1</span> + rightPoint<span class="number">.1</span>).sorted()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4. 添加眼睛</span></span><br><span class="line">    let image = <span class="built_in">UIImage</span>(named: <span class="string">&quot;eyes&quot;</span>)!</span><br><span class="line">    let imageWidth = (pointXs.last ?? <span class="number">0.0</span>) - (pointXs.first ?? <span class="number">0</span>) + <span class="number">40</span></span><br><span class="line">    let imageHeight = image.size.height / image.size.width * imageWidth</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CGRect</span>(x: (pointXs.first ?? <span class="number">0</span>) - <span class="number">20</span>, y: (pointYs.first ?? <span class="number">0</span>) - <span class="number">5</span>, width: imageWidth, height: imageHeight)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>每一只眼睛的坐标处理</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 坐标转换</span></span><br><span class="line">fileprivate func conventPoint(landmark: VNFaceLandmarkRegion2D, faceRect: <span class="built_in">CGRect</span>, position: <span class="built_in">AVCaptureDevice</span>.Position) -&gt; ([<span class="built_in">CGFloat</span>], [<span class="built_in">CGFloat</span>])&#123;</span><br><span class="line">    <span class="comment">//1. 定义</span></span><br><span class="line">    var XArray = [<span class="built_in">CGFloat</span>](), YArray = [<span class="built_in">CGFloat</span>]()</span><br><span class="line">    let viewRect = previewLayer.frame</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2. 遍历</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0.</span>.&lt;landmark.pointCount &#123;</span><br><span class="line">        <span class="comment">//2.1 获取当前位置并转化到合适尺寸</span></span><br><span class="line">        let point = landmark.normalizedPoints[i]</span><br><span class="line">        let rectWidth = viewRect.width * faceRect.width</span><br><span class="line">        let rectHeight = viewRect.height * faceRect.height</span><br><span class="line">        let rectY = viewRect.height - (point.y * rectHeight + faceRect.minY * viewRect.height)</span><br><span class="line">        var rectX = point.x * rectWidth + faceRect.minX * viewRect.width</span><br><span class="line">        <span class="keyword">if</span> position == .front&#123;</span><br><span class="line">            rectX = viewRect.width + (point.x - <span class="number">1</span>) * rectWidth</span><br><span class="line">        &#125;</span><br><span class="line">        XArray.append(rectX)</span><br><span class="line">        YArray.append(rectY)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (XArray, YArray)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>最后获取到该<code>CGRect</code>, 添加眼镜效果即可</li>
</ul>
<h3 id="物体跟踪"><a href="#物体跟踪" class="headerlink" title="物体跟踪"></a>物体跟踪</h3><ul>
<li>简介<ul>
<li>我们在屏幕上点击某物体, 然后Vision就会根据点击的物体, 实时跟踪该物体</li>
<li>当你移动手机或者物体时, 识别的对象和红框的位置是统一的</li>
</ul>
</li>
<li>这里我们出的的对象是<code>VNDetectedObjectObservation</code></li>
<li>定义一个观察属性</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">fileprivate var lastObservation: VNDetectedObjectObservation?</span><br></pre></td></tr></table></figure>
<ul>
<li>创建一个处理多个图像序列的请求</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//处理与多个图像序列的请求handle</span></span><br><span class="line">let sequenceHandle = VNSequenceRequestHandler()</span><br></pre></td></tr></table></figure>
<ul>
<li>创建跟踪识别请求</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//4. 创建跟踪识别请求</span></span><br><span class="line">let trackRequest = VNTrackObjectRequest(detectedObjectObservation: lastObservation, completionHandler: completionHandle)</span><br><span class="line"><span class="comment">//将精度设置为高</span></span><br><span class="line">trackRequest.trackingLevel = .accurate</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>当用户点击屏幕时，我们想要找出用户点击的位置,</li>
<li>根据点击的位置, 获取到一个新的物体对象</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2. 转换坐标</span></span><br><span class="line">let convertRect = visionTool.convertRect(viewRect: redView.frame, layerRect: previewLayer.frame)</span><br><span class="line">        </span><br><span class="line"><span class="comment">//3. 根据点击的位置获取新的对象</span></span><br><span class="line">let newObservation = VNDetectedObjectObservation(boundingBox: convertRect)</span><br><span class="line">lastObservation = newObservation</span><br></pre></td></tr></table></figure>

<ul>
<li>获取到扫描的结果, 如果是一个<code>VNDetectedObjectObservation</code>对象, 重新赋值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//1. 获取一个实际的结果</span><br><span class="line">guard let newObservation = observations?.first as? VNDetectedObjectObservation else &#123; return &#125;</span><br><span class="line">            </span><br><span class="line">//2. 重新赋值</span><br><span class="line">self.lastObservation = newObservation</span><br></pre></td></tr></table></figure>

<ul>
<li>根据获取到的新值, 获取物体的坐标位置</li>
<li>转换坐标, 改变红色框的位置</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//4. 坐标转换</span></span><br><span class="line">let newRect = newObservation.boundingBox</span><br><span class="line">let convertRect = visionTool.convertRect(newRect, <span class="keyword">self</span>.previewLayer.frame)</span><br><span class="line"><span class="keyword">self</span>.redView.frame = convertRect</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以上就是iOS 11的新框架Vision在Swift中的所有使用的情况</p>
</blockquote>
<ul>
<li>文中所列的内容可能有点空洞, 也稍微有点乱</li>
<li>小编也是刚接触Vision, 文中如有解释不全, 或者错误的地方, 还请不吝赐教</li>
</ul>
<hr>
<h2 id="GitHub–Demo地址"><a href="#GitHub–Demo地址" class="headerlink" title="GitHub–Demo地址"></a>GitHub–<a href="https://github.com/coderQuanjun/JunVisionFace">Demo地址</a></h2><ul>
<li>注意:  </li>
<li>这里只是列出了主要的核心代码,具体的代码逻辑请参考demo</li>
<li>文中相关介绍有的地方如果有不是很详细或者有更好建议的,欢迎联系小编</li>
<li>如果方便的话, 还望star一下</li>
</ul>
]]></content>
      <categories>
        <category>Swift框架</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>Vision</tag>
      </tags>
  </entry>
  <entry>
    <title>SwiftLint代码规范属性说明02</title>
    <url>/post/d32d4beb.html</url>
    <content><![CDATA[<ul>
<li>这篇文章是继前两篇文章的继续更新</li>
<li><a href="https://www.titanjun.top/2018/02/07/Xcode%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E4%B9%8BSwiftLint%E9%85%8D%E7%BD%AE/">Xcode代码规范之SwiftLint配置</a>–这篇文章对SwiftLint进行了简单介绍和针对Xcode的相关配置</li>
<li><a href="https://www.titanjun.top/2018/03/03/SwiftLint%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E5%B1%9E%E6%80%A7%E8%AF%B4%E6%98%8E01/">SwiftLint代码规范属性说明01</a>–这里介绍了上半部分的相关属性的介绍</li>
<li>下面来具体介绍一下SwiftLint的其他的代码规则的相关说明</li>
</ul>
<span id="more"></span>


<h3 id="规则51-legacy-cggeometry-functions"><a href="#规则51-legacy-cggeometry-functions" class="headerlink" title="规则51: legacy_cggeometry_functions"></a>规则51: legacy_cggeometry_functions</h3><p>当获取某个视图的宽、高、最小X、最大X值等等， swiftlint推荐使用swift的标准语法， 尽量不要使用从Objective-C中的遗留版本， 尽量语法swift化</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>legacy_cggeometry_functions</td>
<td>启用</td>
<td>yes</td>
<td>idiomatic</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 这样不推荐使用</span></span><br><span class="line"><span class="built_in">CGRectGetWidth</span>(someView.frame)</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 推荐使用下面的形式</span></span><br><span class="line">rect.width</span><br><span class="line">rect.height</span><br><span class="line">rect.minX</span><br><span class="line">rect.midX</span><br><span class="line">rect...................</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="规则52-legacy-constant"><a href="#规则52-legacy-constant" class="headerlink" title="规则52: legacy_constant"></a>规则52: legacy_constant</h3><p>和属性<code>legacy_cggeometry_functions</code>一样， 结构范围常数尽量分开、明确、具体， 不要使用OC的遗留整体常数</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>legacy_constant</td>
<td>启用</td>
<td>yes</td>
<td>idiomatic</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 规范的写法，不会触发warning</span></span><br><span class="line"><span class="built_in">CGPoint</span>.zero</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 不规范的写法， 会触发warning</span></span><br><span class="line"><span class="built_in">CGPointZero</span></span><br><span class="line"><span class="built_in">CGRectZero</span></span><br></pre></td></tr></table></figure>

<h3 id="规则53-legacy-constructor"><a href="#规则53-legacy-constructor" class="headerlink" title="规则53: legacy_constructor"></a>规则53: legacy_constructor</h3><p>swiftlint要求系统自带构造器， 使用swift语法化， 不要使用OC版本的构造器</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>legacy_constructor</td>
<td>启用</td>
<td>yes</td>
<td>idiomatic</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// swift语法，相信之后系统也会强制规定使用</span></span><br><span class="line"><span class="built_in">CGPoint</span>（x: <span class="number">10</span>， y: <span class="number">20</span>）</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 错误的构造器语法</span></span><br><span class="line"><span class="built_in">CGPointMake</span>(<span class="number">10</span>, <span class="number">20</span>)</span><br></pre></td></tr></table></figure>

<h3 id="规则54-legacy-nsgeometry-functions"><a href="#规则54-legacy-nsgeometry-functions" class="headerlink" title="规则54: legacy_nsgeometry_functions"></a>规则54: legacy_nsgeometry_functions</h3><p>ns类几何函数， 和前面的几个属性一样， 使用swift点语法函数， 不使用以前的版本。</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>legacy_nsgeometry_functions</td>
<td>启用</td>
<td>yes</td>
<td>idiomatic</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 正确</span></span><br><span class="line">view.width/height/minX</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 错误</span></span><br><span class="line"><span class="built_in">NSWidth</span>(view.frame)</span><br></pre></td></tr></table></figure>

<h3 id="规则55-let-var-whitespace"><a href="#规则55-let-var-whitespace" class="headerlink" title="规则55: let_var_whitespace"></a>规则55: let_var_whitespace</h3><p>let和var语句应该用空白行与其他语句分开</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>let_var_whitespace</td>
<td>未启用</td>
<td>no</td>
<td>style</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//推荐这样写</span></span><br><span class="line">let a = <span class="number">0</span></span><br><span class="line">var x = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">x = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//不建议写法</span></span><br><span class="line">var x = <span class="number">1</span></span><br><span class="line">x = <span class="number">2</span></span><br></pre></td></tr></table></figure>

<h3 id="规则56-line-length"><a href="#规则56-line-length" class="headerlink" title="规则56: line_length"></a>规则56: line_length</h3><p>行的字符长度属性。这个强烈不推荐使用。官方的规定是超过120字符就给warning， 超过200个字符就直接报error！！！我们又不是写底层脚本的，所以建议这种方式禁用！！</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>line_length</td>
<td>启用</td>
<td>no</td>
<td>metrics</td>
</tr>
</tbody></table>
<h3 id="规则57-literal-expression-end-indentation"><a href="#规则57-literal-expression-end-indentation" class="headerlink" title="规则57: literal_expression_end_indentation"></a>规则57: literal_expression_end_indentation</h3><p>字典和数组的开头和结尾要有相同的缩进格式</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>literal_expression_end_indentation</td>
<td>未启用</td>
<td>no</td>
<td>style</td>
</tr>
</tbody></table>
<h3 id="规则58-mark"><a href="#规则58-mark" class="headerlink" title="规则58: mark"></a>规则58: mark</h3><p>标记方法或者属性。这个推荐使用， 可以统一方法标记的格式， 有利于review查找某个方法或者属性的时候更清晰。使用也非常简单： “MARK”前空一格，”MARK:”后空一格。</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>mark</td>
<td>启用</td>
<td>yes</td>
<td>lint</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//推荐写法</span></span><br><span class="line"><span class="comment">// MARK: good</span></span><br><span class="line"><span class="comment">// MARK: - good</span></span><br><span class="line"><span class="comment">// MARK: -</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//不建议写法</span></span><br><span class="line"><span class="comment">//MARK: bad</span></span><br><span class="line"><span class="comment">// MARK:bad</span></span><br><span class="line"><span class="comment">//MARK:bad</span></span><br><span class="line"><span class="comment">//  MARK: bad</span></span><br><span class="line"><span class="comment">// MARK:  bad</span></span><br><span class="line"><span class="comment">// MARK: -bad</span></span><br></pre></td></tr></table></figure>

<h3 id="规则59-multiline-arguments"><a href="#规则59-multiline-arguments" class="headerlink" title="规则59: multiline_arguments"></a>规则59: multiline_arguments</h3><p>调用函数和方法时, 其参数应该在同一行上，或者每行一个</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>multiline_arguments</td>
<td>未启用</td>
<td>no</td>
<td>style</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不建议以下写法</span></span><br><span class="line">foo(<span class="number">0</span>, param1: <span class="number">1</span>, param2: <span class="literal">true</span>,</span><br><span class="line">    param3: [<span class="number">3</span>])</span><br><span class="line">    </span><br><span class="line">foo(</span><br><span class="line">    <span class="number">0</span>, param1: <span class="number">1</span>,</span><br><span class="line">    param2: <span class="literal">true</span>, param3: [<span class="number">3</span>]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="规则60-multiline-parameters"><a href="#规则60-multiline-parameters" class="headerlink" title="规则60: multiline_parameters"></a>规则60: multiline_parameters</h3><p>声明函数和方法时, 其参数应该在同一行上，或者每行一个</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>multiline_parameters</td>
<td>未启用</td>
<td>no</td>
<td>style</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//不建议以下写法</span><br><span class="line">protocol Foo &#123;</span><br><span class="line">   func foo(param1: Int,</span><br><span class="line">             param2: Bool, param3: [String]) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protocol Foo &#123;</span><br><span class="line">   func foo(param1: Int, param2: Bool,</span><br><span class="line">             param3: [String]) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="规则61-multiple-closures-with-trailing-closure"><a href="#规则61-multiple-closures-with-trailing-closure" class="headerlink" title="规则61: multiple_closures_with_trailing_closure"></a>规则61: multiple_closures_with_trailing_closure</h3><p>当函数有多个闭包时, 不建议使用尾随闭包语法</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>multiple_closures_with_trailing_closure</td>
<td>启用</td>
<td>no</td>
<td>style</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不建议写法</span></span><br><span class="line">foo.something(param1: &#123; $<span class="number">0</span> &#125;) &#123; $<span class="number">0</span> + <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UIView</span>.animate(withDuration: <span class="number">1.0</span>, animations: &#123;</span><br><span class="line">    someView.alpha = <span class="number">0.0</span></span><br><span class="line">&#125;) &#123; _ <span class="keyword">in</span></span><br><span class="line">    someView.removeFromSuperview()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="规则62-nesting"><a href="#规则62-nesting" class="headerlink" title="规则62: nesting"></a>规则62: nesting</h3><p>嵌套。类型嵌套至多一级结构， 函数语句嵌套至多五级结构。</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>nesting</td>
<td>启用</td>
<td>no</td>
<td>metrics</td>
</tr>
</tbody></table>
<h3 id="规则63-nimble-operator"><a href="#规则63-nimble-operator" class="headerlink" title="规则63: nimble_operator"></a>规则63: nimble_operator</h3><p>快捷操作符。和自由匹配函数相比， 更喜欢快捷操作符， 比如：&gt;&#x3D;、 &#x3D;&#x3D;、 &lt;&#x3D;、 &lt;等等。</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>nimble_operator</td>
<td>未启用</td>
<td>yes</td>
<td>idiomatic</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 会触发warning</span></span><br><span class="line">(person.voice).toNot(equal(<span class="string">&quot;Hello world&quot;</span>))     <span class="comment">// 判断字符串相同</span></span><br><span class="line"><span class="number">10.</span>to(beGreaterThan(<span class="number">5</span>))     <span class="comment">// 10比5大</span></span><br><span class="line"><span class="number">99.</span>to(beLessThan(<span class="number">100</span>))       <span class="comment">// 99比100小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 改为以下</span></span><br><span class="line">(person.voice) != <span class="string">&quot;Hello world&quot;</span>   <span class="comment">// 判断字符串相同</span></span><br><span class="line"><span class="number">10</span> &gt; <span class="number">5</span>                <span class="comment">// 10比5大</span></span><br><span class="line"><span class="number">99</span> &lt; <span class="number">100</span>              <span class="comment">// 99比100小</span></span><br></pre></td></tr></table></figure>

<h3 id="规则64-no-extension-access-modifier"><a href="#规则64-no-extension-access-modifier" class="headerlink" title="规则64: no_extension_access_modifier"></a>规则64: no_extension_access_modifier</h3><p>在extension扩展前面,不建议使用(fileprivate, public)等修饰符</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>no_extension_access_modifier</td>
<td>未启用</td>
<td>no</td>
<td>idiomatic</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不推荐写法</span></span><br><span class="line">private extension String &#123;&#125;</span><br><span class="line">public extension String &#123;&#125;</span><br><span class="line">open extension String &#123;&#125;</span><br><span class="line">internal extension String &#123;&#125;</span><br><span class="line">fileprivate extension String &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="规则65-no-grouping-extension"><a href="#规则65-no-grouping-extension" class="headerlink" title="规则65: no_grouping_extension"></a>规则65: no_grouping_extension</h3><p>只有class和protocol可以使用extension,其他类型不可使用</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>no_grouping_extension</td>
<td>未启用</td>
<td>no</td>
<td>idiomatic</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不推荐写法</span></span><br><span class="line"><span class="keyword">enum</span> Fruit &#123;&#125;</span><br><span class="line">extension Fruit &#123;&#125;</span><br><span class="line"></span><br><span class="line">extension Tea: Error &#123;&#125;</span><br><span class="line"><span class="keyword">struct</span> Tea &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Ham &#123; <span class="keyword">class</span> Spam &#123;&#125;&#125;</span><br><span class="line">extension Ham.Spam &#123;&#125;</span><br><span class="line"></span><br><span class="line">extension External &#123; <span class="keyword">struct</span> Gotcha &#123;&#125;&#125;</span><br><span class="line">extension External.Gotcha &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="规则66-notification-center-detachment"><a href="#规则66-notification-center-detachment" class="headerlink" title="规则66: notification_center_detachment"></a>规则66: notification_center_detachment</h3><p>对象移除通知只能在deinit移除self,函数中不能removeObserver(self)</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>notification_center_detachment</td>
<td>启用</td>
<td>no</td>
<td>lint</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不会触发warning</span></span><br><span class="line"><span class="keyword">class</span> Foo &#123; </span><br><span class="line">   deinit &#123;</span><br><span class="line">       NotificationCenter.default.removeObserver(<span class="keyword">self</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Foo &#123; </span><br><span class="line">   func bar() &#123;</span><br><span class="line">       NotificationCenter.default.removeObserver(otherObject)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//会触发warning</span></span><br><span class="line"><span class="keyword">class</span> Foo &#123; </span><br><span class="line">   func bar() &#123;</span><br><span class="line">       NotificationCenter.default.removeObserver(<span class="keyword">self</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="规则67-number-separator"><a href="#规则67-number-separator" class="headerlink" title="规则67: number_separator"></a>规则67: number_separator</h3><p>数字分割线。当在大量的小数中， 应该使用下划线来作为千分位分割线</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>number_separator</td>
<td>未启用</td>
<td>yes</td>
<td>style</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 推荐使用这种形式</span></span><br><span class="line">let xxx = <span class="number">1</span>_000_000_000<span class="number">.000</span>_1</span><br><span class="line">print(xxx)</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 不推荐使用这种形式（在swift </span></span><br><span class="line">let xxx = <span class="number">1000000000.0001</span></span><br><span class="line">print(xxx)</span><br></pre></td></tr></table></figure>

<h3 id="规则68-object-literal"><a href="#规则68-object-literal" class="headerlink" title="规则68: object_literal"></a>规则68: object_literal</h3><p>swiftlint表示比起图片和颜色初始化，更喜欢对象初始化。因为swift初始化可以用表情，图片，颜色等，这不符合项目中的一些习惯用法</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>object_literal</td>
<td>未启用</td>
<td>no</td>
<td>idiomatic</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不会触发warning</span></span><br><span class="line">let image = #imageLiteral(resourceName: <span class="string">&quot;image.jpg&quot;</span>)</span><br><span class="line">let color = #colorLiteral(red: <span class="number">0.9607843161</span>, green: <span class="number">0.7058823705</span>, blue: <span class="number">0.200000003</span>, alpha: <span class="number">1</span>)</span><br><span class="line">let image = <span class="built_in">UIImage</span>(named: aVariable)</span><br><span class="line">let image = <span class="built_in">UIImage</span>(named: <span class="string">&quot;interpolated \(variable)&quot;</span>)</span><br><span class="line">let color = <span class="built_in">UIColor</span>(red: value, green: value, blue: value, alpha: <span class="number">1</span>)</span><br><span class="line">let image = <span class="built_in">NSImage</span>(named: aVariable)</span><br><span class="line">let image = <span class="built_in">NSImage</span>(named: <span class="string">&quot;interpolated \(variable)&quot;</span>)</span><br><span class="line">let color = <span class="built_in">NSColor</span>(red: value, green: value, blue: value, alpha: <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//会触发warning</span></span><br><span class="line">let image = ↓<span class="built_in">UIImage</span>(named: <span class="string">&quot;foo&quot;</span>)</span><br><span class="line">let color = ↓<span class="built_in">UIColor</span>(red: <span class="number">0.3</span>, green: <span class="number">0.3</span>, blue: <span class="number">0.3</span>, alpha: <span class="number">1</span>)</span><br><span class="line">let color = ↓<span class="built_in">UIColor</span>(red: <span class="number">100</span> / <span class="number">255.0</span>, green: <span class="number">50</span> / <span class="number">255.0</span>, blue: <span class="number">0</span>, alpha: <span class="number">1</span>)</span><br><span class="line">let color = ↓<span class="built_in">UIColor</span>(white: <span class="number">0.5</span>, alpha: <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h3 id="规则69-opening-brace"><a href="#规则69-opening-brace" class="headerlink" title="规则69: opening_brace"></a>规则69: opening_brace</h3><p>花括号之前应该有一个空格,且与声明在同一行</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>opening_brace</td>
<td>启用</td>
<td>yes</td>
<td>style</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//建议写法</span></span><br><span class="line">func abc() &#123;</span><br><span class="line">&#125;</span><br><span class="line">[].map() &#123; $<span class="number">0</span> &#125;</span><br><span class="line">[].map(&#123; &#125;)</span><br><span class="line"><span class="keyword">if</span> let a = b &#123; &#125;</span><br><span class="line"><span class="keyword">while</span> a == b &#123; &#125;</span><br><span class="line">guard let a = b <span class="keyword">else</span> &#123; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="规则70-operator-usage-whitespace"><a href="#规则70-operator-usage-whitespace" class="headerlink" title="规则70: operator_usage_whitespace"></a>规则70: operator_usage_whitespace</h3><p>操作符使用规则， 操作符两边应该有空格。比如 “+” “-” “？？”</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>operator_usage_whitespace</td>
<td>未启用</td>
<td>yes</td>
<td>style</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//建议写法</span></span><br><span class="line">let foo = <span class="number">1</span> + <span class="number">2</span></span><br><span class="line">let foo = <span class="number">1</span> &gt; <span class="number">2</span></span><br><span class="line">let foo = !<span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//不推荐写法</span></span><br><span class="line">let foo = <span class="number">1</span>+<span class="number">2</span></span><br><span class="line">let foo = <span class="number">1</span>   + <span class="number">2</span></span><br><span class="line">let foo = <span class="number">1</span>   +    <span class="number">2</span></span><br><span class="line">let foo = <span class="number">1</span> +    <span class="number">2</span></span><br><span class="line">let foo=<span class="number">1</span>+<span class="number">2</span></span><br></pre></td></tr></table></figure>

<h3 id="规则71-operator-whitespace"><a href="#规则71-operator-whitespace" class="headerlink" title="规则71: operator_whitespace"></a>规则71: operator_whitespace</h3><p>空格&#x2F;空白操作符。当定义空格操作符的时候，被定义的名字或类型两边应该各有一个单行空格操作符</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>operator_whitespace</td>
<td>启用</td>
<td>no</td>
<td>style</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 触发警告</span></span><br><span class="line"><span class="keyword">class</span> Something: Equatable &#123;</span><br><span class="line">    var text: String?</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &quot;==&quot;和“(lhs: Something, rhs: Something)”之间应该有一个空格</span></span><br><span class="line">    <span class="keyword">static</span> func ==(lhs: Something, rhs: Something) -&gt; Bool &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.text == rhs.text</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="规则72-overridden-super-call"><a href="#规则72-overridden-super-call" class="headerlink" title="规则72: overridden_super_call"></a>规则72: overridden_super_call</h3><p>一些重写的方法应该调用super.(父类的)方法</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>overridden_super_call</td>
<td>未启用</td>
<td>no</td>
<td>lint</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 这样会触发警告</span></span><br><span class="line"> <span class="keyword">class</span> VCd: <span class="built_in">UIViewController</span> &#123;</span><br><span class="line">     override func viewWillAppear(_ animated: Bool) &#123;</span><br><span class="line">        <span class="comment">//没有调用父类</span></span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/// 不会触发警告</span></span><br><span class="line">  <span class="keyword">class</span> VCd: <span class="built_in">UIViewController</span> &#123;</span><br><span class="line">     override func viewWillAppear(_ animated: Bool) &#123;</span><br><span class="line">        <span class="variable language_">super</span>.viewWillAppear(animated)</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="规则73-override-in-extension"><a href="#规则73-override-in-extension" class="headerlink" title="规则73: override_in_extension"></a>规则73: override_in_extension</h3><p>在extension中,不能重写未声明的属性和未定义的方法</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>override_in_extension</td>
<td>未启用</td>
<td>no</td>
<td>lint</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//错误写法</span></span><br><span class="line">extension Person &#123;</span><br><span class="line">  <span class="comment">//该属性之前未定义, 不能重写</span></span><br><span class="line">  override var age: Int &#123; <span class="keyword">return</span> <span class="number">42</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension Person &#123;</span><br><span class="line">  <span class="comment">//该方法之前也为定义不能重写</span></span><br><span class="line">  override func celebrateBirthday() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="规则74-pattern-matching-keywords"><a href="#规则74-pattern-matching-keywords" class="headerlink" title="规则74: pattern_matching_keywords"></a>规则74: pattern_matching_keywords</h3><p>…<br>在switch-case语句中, 建议不要将case中的let和var等关键字放到元祖内</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>pattern_matching_keywords</td>
<td>未启用</td>
<td>no</td>
<td>idiomatic</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//正确写法</span></span><br><span class="line"><span class="keyword">switch</span> foo &#123;</span><br><span class="line">    <span class="keyword">case</span> let .foo(x, y): <span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> foo &#123;</span><br><span class="line">    <span class="keyword">case</span> .foo(let x), .bar(let x): <span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//错误写法</span></span><br><span class="line"><span class="keyword">switch</span> foo &#123;</span><br><span class="line">    <span class="keyword">case</span> (↓let x,  ↓let y): <span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> foo &#123;</span><br><span class="line">    <span class="keyword">case</span> .foo(↓let x, ↓let y): <span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> foo &#123;</span><br><span class="line">    <span class="keyword">case</span> (.yamlParsing(↓let x), .yamlParsing(↓let y)): <span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> foo &#123;</span><br><span class="line">    <span class="keyword">case</span> (↓var x,  ↓var y): <span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> foo &#123;</span><br><span class="line">    <span class="keyword">case</span> .foo(↓var x, ↓var y): <span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="规则76-prefixed-toplevel-constant"><a href="#规则76-prefixed-toplevel-constant" class="headerlink" title="规则76: prefixed_toplevel_constant"></a>规则76: prefixed_toplevel_constant</h3><p>类似全局常量,建议前缀以k开头</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>prefixed_toplevel_constant</td>
<td>未启用</td>
<td>no</td>
<td>style</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//推荐写法</span></span><br><span class="line">private let kFoo = <span class="number">20.0</span></span><br><span class="line">public let kFoo = <span class="literal">false</span></span><br><span class="line">internal let kFoo = <span class="string">&quot;Foo&quot;</span></span><br><span class="line">let kFoo = <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="规则77-private-action"><a href="#规则77-private-action" class="headerlink" title="规则77: private_action"></a>规则77: private_action</h3><p>IBActions修饰的方法,应该都是私有的</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>private_action</td>
<td>未启用</td>
<td>no</td>
<td>lint</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//推荐写法</span></span><br><span class="line"><span class="keyword">class</span> Foo &#123;</span><br><span class="line">	@IBAction private func barButtonTapped(_ sender: <span class="built_in">UIButton</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> Foo &#123;</span><br><span class="line">	@IBAction private func barButtonTapped(_ sender: <span class="built_in">UIButton</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Foo &#123;</span><br><span class="line">	@IBAction fileprivate func barButtonTapped(_ sender: <span class="built_in">UIButton</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> Foo &#123;</span><br><span class="line">	@IBAction fileprivate func barButtonTapped(_ sender: <span class="built_in">UIButton</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">private extension Foo &#123;</span><br><span class="line">	@IBAction func barButtonTapped(_ sender: <span class="built_in">UIButton</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">fileprivate extension Foo &#123;</span><br><span class="line">	@IBAction func barButtonTapped(_ sender: <span class="built_in">UIButton</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="规则78-private-outlet"><a href="#规则78-private-outlet" class="headerlink" title="规则78: private_outlet"></a>规则78: private_outlet</h3><p>IBOutlets修饰的属性应该都是私有的</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>private_outlet</td>
<td>未启用</td>
<td>no</td>
<td>lint</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//推荐写法</span></span><br><span class="line"><span class="keyword">class</span> Foo &#123;</span><br><span class="line">  @IBOutlet private var label: <span class="built_in">UILabel</span>?</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Foo &#123;</span><br><span class="line">  @IBOutlet private var label: <span class="built_in">UILabel</span>!</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不推荐写法</span></span><br><span class="line"><span class="keyword">class</span> Foo &#123;</span><br><span class="line">  @IBOutlet var label: <span class="built_in">UILabel</span>?</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Foo &#123;</span><br><span class="line">  @IBOutlet var label: <span class="built_in">UILabel</span>!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="规则79-private-over-fileprivate"><a href="#规则79-private-over-fileprivate" class="headerlink" title="规则79: private_over_fileprivate"></a>规则79: private_over_fileprivate</h3><p>private比fileprivate的私有程度更高</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>private_over_fileprivate</td>
<td>启用</td>
<td>yes</td>
<td>idiomatic</td>
</tr>
</tbody></table>
<h3 id="规则80-private-unit-test"><a href="#规则80-private-unit-test" class="headerlink" title="规则80: private_unit_test"></a>规则80: private_unit_test</h3><p>私有的单元测试。被标记为private的单元测试不会被测试工具XCTest运行， 也就是说，被标记为private的单元测试会被静态跳过</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>private_unit_test</td>
<td>启用</td>
<td>no</td>
<td>lint</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">private ↓<span class="keyword">class</span> FooTest: <span class="built_in">XCTestCase</span> &#123; ...............继承于测试用例类<span class="built_in">XCTestCase</span>, 被标记为private，所以触发warning</span><br><span class="line">     func test1() &#123;&#125;</span><br><span class="line">     internal func test2() &#123;&#125;</span><br><span class="line">     public func test3() &#123;&#125;</span><br><span class="line">     private func test4() &#123;&#125;.......另外注意这里，上面既然不会通过，那显然这里也不会通过，根本不会走这个func</span><br><span class="line"> &#125;  </span><br><span class="line"></span><br><span class="line"> internal <span class="keyword">class</span> FooTest: <span class="built_in">XCTestCase</span> &#123; ......开始通过测试，因为没有被标记为private</span><br><span class="line">     func test1() &#123;&#125;</span><br><span class="line">     internal func test2() &#123;&#125;</span><br><span class="line">     public func test3() &#123;&#125;</span><br><span class="line">     private ↓func test4() &#123;&#125;................不通过，因为被标记为private</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> public <span class="keyword">class</span> FooTest: <span class="built_in">XCTestCase</span> &#123; ..........通过</span><br><span class="line">     func test1() &#123;&#125;</span><br><span class="line">     internal func test2() &#123;&#125;</span><br><span class="line">     public func test3() &#123;&#125;</span><br><span class="line">     private ↓func test4() &#123;&#125;.................不通过，因为被标记成private</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">class</span> FooTest: <span class="built_in">XCTestCase</span> &#123; ..........通过</span><br><span class="line">     func test1() &#123;&#125;</span><br><span class="line">     internal func test2() &#123;&#125;</span><br><span class="line">     public func test3() &#123;&#125;</span><br><span class="line">     private ↓func test4() &#123;&#125;.................不通过，因为被标记成private</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="规则81-prohibited-super-call"><a href="#规则81-prohibited-super-call" class="headerlink" title="规则81: prohibited_super_call"></a>规则81: prohibited_super_call</h3><p>一些方法不应该调用父类的方法</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>prohibited_super_call</td>
<td>未启用</td>
<td>no</td>
<td>lint</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以下方法不建议调用父类的方法</span></span><br><span class="line"><span class="keyword">class</span> VC: <span class="built_in">UIViewController</span> &#123;</span><br><span class="line">	override func loadView() &#123;↓</span><br><span class="line">		<span class="variable language_">super</span>.loadView()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> VC: <span class="built_in">NSFileProviderExtension</span> &#123;</span><br><span class="line">	override func providePlaceholder(at url: URL,completionHandler: @escaping (Error?) -&gt; Void) &#123;↓</span><br><span class="line">		<span class="keyword">self</span>.method1()</span><br><span class="line">		<span class="variable language_">super</span>.providePlaceholder(at:url, completionHandler: completionHandler)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> VC: <span class="built_in">NSView</span> &#123;</span><br><span class="line">	override func updateLayer() &#123;↓</span><br><span class="line">		<span class="keyword">self</span>.method1()</span><br><span class="line">		<span class="variable language_">super</span>.updateLayer()</span><br><span class="line">		<span class="keyword">self</span>.method2()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> VC: <span class="built_in">NSView</span> &#123;</span><br><span class="line">	override func updateLayer() &#123;↓</span><br><span class="line">		defer &#123;</span><br><span class="line">			<span class="variable language_">super</span>.updateLayer()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="规则82-protocol-property-accessors-order"><a href="#规则82-protocol-property-accessors-order" class="headerlink" title="规则82: protocol_property_accessors_order"></a>规则82: protocol_property_accessors_order</h3><p>在协议中声明属性时，访问者的顺序应该是get set</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>protocol_property_accessors_order</td>
<td>启用</td>
<td>yes</td>
<td>style</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//建议</span></span><br><span class="line">protocol Foo &#123;</span><br><span class="line">   var bar: String &#123; get set &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//不建议</span></span><br><span class="line">protocol Foo &#123;</span><br><span class="line">   var bar: String &#123; set get &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="规则83-quick-discouraged-call"><a href="#规则83-quick-discouraged-call" class="headerlink" title="规则83: quick_discouraged_call"></a>规则83: quick_discouraged_call</h3><p>在单元测试中,不建议在describe和content比保重直接调用方法和类</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>quick_discouraged_call</td>
<td>未启用</td>
<td>no</td>
<td>lint</td>
</tr>
</tbody></table>
<h3 id="规则84-quick-discouraged-focused-test"><a href="#规则84-quick-discouraged-focused-test" class="headerlink" title="规则84: quick_discouraged_focused_test"></a>规则84: quick_discouraged_focused_test</h3><p>在单元测试中,不建议集中测试,否则可能不能运行成功</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>quick_discouraged_focused_test</td>
<td>未启用</td>
<td>no</td>
<td>lint</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//官方示例, 不建议</span></span><br><span class="line"><span class="keyword">class</span> TotoTests: QuickSpec &#123;</span><br><span class="line">   override func spec() &#123;</span><br><span class="line">       ↓fdescribe(<span class="string">&quot;foo&quot;</span>) &#123; &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="规则85-quick-discouraged-pending-test"><a href="#规则85-quick-discouraged-pending-test" class="headerlink" title="规则85: quick_discouraged_pending_test"></a>规则85: quick_discouraged_pending_test</h3><p>单元测试中阻止未进行的测试单元</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>quick_discouraged_pending_test</td>
<td>未启用</td>
<td>no</td>
<td>lint</td>
</tr>
</tbody></table>
<h3 id="规则86-redundant-discardable-let"><a href="#规则86-redundant-discardable-let" class="headerlink" title="规则86: redundant_discardable_let"></a>规则86: redundant_discardable_let</h3><p>不需要初始化方法返回结果时,建议使用: _ &#x3D; Person(), 而不是:let _ &#x3D; Person()</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>redundant_discardable_let</td>
<td>启用</td>
<td>yes</td>
<td>style</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//推荐</span></span><br><span class="line">_ = foo()</span><br><span class="line"><span class="keyword">if</span> let _ = foo() &#123; &#125;</span><br><span class="line">guard let _ = foo() <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不建议</span></span><br><span class="line">let _ = foo()</span><br><span class="line"><span class="keyword">if</span> _ = foo() &#123; let _ = bar() &#125;</span><br></pre></td></tr></table></figure>

<h3 id="规则87-redundant-nil-coalescing"><a href="#规则87-redundant-nil-coalescing" class="headerlink" title="规则87: redundant_nil_coalescing"></a>规则87: redundant_nil_coalescing</h3><p>使用可能为为nil的可选值时,建议使用: str ?? “”, ??左右两侧要有一个空格</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>redundant_nil_coalescing</td>
<td>未启用</td>
<td>yes</td>
<td>idiomatic</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//建议写法</span></span><br><span class="line">var myVar: Int?; myVar ?? <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//不建议写法</span></span><br><span class="line">var myVar: Int? = <span class="literal">nil</span>; myVar  ?? <span class="literal">nil</span></span><br><span class="line">var myVar: Int? = <span class="literal">nil</span>; myVar??<span class="literal">nil</span></span><br></pre></td></tr></table></figure>

<h3 id="规则88-redundant-optional-initialization"><a href="#规则88-redundant-optional-initialization" class="headerlink" title="规则88: redundant_optional_initialization"></a>规则88: redundant_optional_initialization</h3><p>初始化nil变量是,不建议赋值nil</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>redundant_optional_initialization</td>
<td>启用</td>
<td>yes</td>
<td>idiomatic</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不会触发warning</span></span><br><span class="line">var myVar: Int?</span><br><span class="line">let myVar: Int? = <span class="literal">nil</span></span><br><span class="line">var myVar: Optional&lt;Int&gt;</span><br><span class="line">let myVar: Optional&lt;Int&gt; = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//会触发warning</span></span><br><span class="line">var myVar: Int?↓ = <span class="literal">nil</span></span><br><span class="line">var myVar: Optional&lt;Int&gt;↓ = <span class="literal">nil</span></span><br><span class="line">var myVar: Int?↓=<span class="literal">nil</span></span><br><span class="line">var myVar: Optional&lt;Int&gt;↓=<span class="literal">nil</span></span><br></pre></td></tr></table></figure>

<h3 id="规则89-redundant-string-enum-value"><a href="#规则89-redundant-string-enum-value" class="headerlink" title="规则89: redundant_string_enum_value"></a>规则89: redundant_string_enum_value</h3><p>在定义字符串枚举的时候, 当字符串枚举值等于枚举名称时，可以不用赋值</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>redundant_string_enum_value</td>
<td>启用</td>
<td>no</td>
<td>idiomatic</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不会触发warning</span></span><br><span class="line"><span class="keyword">enum</span> Numbers: String &#123;</span><br><span class="line"> <span class="keyword">case</span> one</span><br><span class="line"> <span class="keyword">case</span> two</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span> Numbers: Int &#123;</span><br><span class="line"> <span class="keyword">case</span> one = <span class="number">1</span></span><br><span class="line"> <span class="keyword">case</span> two = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//会触发warning</span></span><br><span class="line"><span class="keyword">enum</span> Numbers: String &#123;</span><br><span class="line"> <span class="keyword">case</span> one = ↓<span class="string">&quot;one&quot;</span></span><br><span class="line"> <span class="keyword">case</span> two = ↓<span class="string">&quot;two&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span> Numbers: String &#123;</span><br><span class="line"> <span class="keyword">case</span> one = ↓<span class="string">&quot;one&quot;</span>, two = ↓<span class="string">&quot;two&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="规则90-redundant-void-return"><a href="#规则90-redundant-void-return" class="headerlink" title="规则90: redundant_void_return"></a>规则90: redundant_void_return</h3><p>当函数返回值为Void时,建议不谢返回值, 定义常量或者变量的时候可以</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>redundant_void_return</td>
<td>启用</td>
<td>yes</td>
<td>idiomatic</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不会触发warning</span></span><br><span class="line">func foo() &#123;&#125;</span><br><span class="line">func foo() -&gt; Int &#123;&#125;</span><br><span class="line">func foo() -&gt; Int -&gt; Void &#123;&#125;</span><br><span class="line">func foo() -&gt; VoidResponse</span><br><span class="line">let foo: Int -&gt; Void</span><br><span class="line"></span><br><span class="line"><span class="comment">//会触发warning</span></span><br><span class="line">func foo()↓ -&gt; Void &#123;&#125;</span><br><span class="line">protocol Foo &#123;</span><br><span class="line"> func foo()↓ -&gt; Void</span><br><span class="line">&#125;</span><br><span class="line">func foo()↓ -&gt; () &#123;&#125;</span><br><span class="line">protocol Foo &#123;</span><br><span class="line"> func foo()↓ -&gt; ()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="规则91-required-enum-case"><a href="#规则91-required-enum-case" class="headerlink" title="规则91: required_enum_case"></a>规则91: required_enum_case</h3><p>定义的枚举,必须有与其对应的操作实现</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>required_enum_case</td>
<td>未启用</td>
<td>no</td>
<td>lint</td>
</tr>
</tbody></table>
<h3 id="规则92-return-arrow-whitespace"><a href="#规则92-return-arrow-whitespace" class="headerlink" title="规则92: return_arrow_whitespace"></a>规则92: return_arrow_whitespace</h3><p>swiftlint推荐返回箭头和返回类型应该被空格分开</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>return_arrow_whitespace</td>
<td>启用</td>
<td>yes</td>
<td>style</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//推荐写法</span></span><br><span class="line">func abc() -&gt; Int &#123;&#125;</span><br><span class="line">func abc() -&gt; [Int] &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不建议写法</span></span><br><span class="line">func abc()↓-&gt;Int &#123;&#125;</span><br><span class="line">func abc()↓-&gt;[Int] &#123;&#125;</span><br><span class="line">func abc()↓-&gt;(Int, Int) &#123;&#125;</span><br><span class="line">func abc()↓-&gt; Int &#123;&#125;</span><br><span class="line">func abc()↓ -&gt;Int &#123;&#125;</span><br></pre></td></tr></table></figure>


<h3 id="规则93-shorthand-operator"><a href="#规则93-shorthand-operator" class="headerlink" title="规则93: shorthand_operator"></a>规则93: shorthand_operator</h3><p>在swiftlint中， 就是我们常用的简洁操作运算符，比如：+&#x3D; ， -&#x3D;， *&#x3D;， &#x2F;&#x3D; 等等。在swiftlint中，在做一些赋值操作的时候，推荐使用简短操作符</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>shorthand_operator</td>
<td>启用</td>
<td>no</td>
<td>style</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 不推荐使用</span></span><br><span class="line">var value = <span class="number">4</span></span><br><span class="line">value = value / <span class="number">2</span></span><br><span class="line">print(value)</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 推荐使用</span></span><br><span class="line">var value = <span class="number">4</span></span><br><span class="line">value /= <span class="number">2</span></span><br><span class="line">print(value)</span><br></pre></td></tr></table></figure>


<h3 id="规则94-single-test-class"><a href="#规则94-single-test-class" class="headerlink" title="规则94: single_test_class"></a>规则94: single_test_class</h3><p>单元测试中,测试文件应该包含一个QuickSpec或XCTestCase类</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>single_test_class</td>
<td>未启用</td>
<td>no</td>
<td>style</td>
</tr>
</tbody></table>
<h3 id="规则95-sorted-first-last"><a href="#规则95-sorted-first-last" class="headerlink" title="规则95: sorted_first_last"></a>规则95: sorted_first_last</h3><p>在获取某数组中最大最小值时,建议使用min和max函数,而不是sorted().first和sorted().lase</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>sorted_first_last</td>
<td>未启用</td>
<td>no</td>
<td>style</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="规则96-aaa"><a href="#规则96-aaa" class="headerlink" title="规则96: aaa"></a>规则96: aaa</h3><p>…</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>aaa</td>
<td>未启用</td>
<td>no</td>
<td>style</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//建议</span></span><br><span class="line">let min = myList.min()</span><br><span class="line">let min = myList.min(by: &#123; $<span class="number">0</span> &lt; $<span class="number">1</span> &#125;)</span><br><span class="line">let min = myList.min(by: &gt;)</span><br><span class="line">let min = myList.max()</span><br><span class="line">let min = myList.max(by: &#123; $<span class="number">0</span> &lt; $<span class="number">1</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//不建议</span></span><br><span class="line">myList.sorted().first</span><br><span class="line">myList.sorted(by: &#123; $<span class="number">0.</span>description &lt; $<span class="number">1.</span>description &#125;).first</span><br><span class="line">myList.sorted(by: &gt;).first</span><br><span class="line">myList.map &#123; $<span class="number">0</span> + <span class="number">1</span> &#125;.sorted().first</span><br><span class="line">myList.sorted(by: someFunction).first</span><br></pre></td></tr></table></figure>


<h3 id="规则97-sorted-imports"><a href="#规则97-sorted-imports" class="headerlink" title="规则97: sorted_imports"></a>规则97: sorted_imports</h3><p>分类&#x2F;有序导入。 这个属性有些奇怪， 要求导入的时候导入的类要按顺序导入</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>sorted_imports</td>
<td>未启用</td>
<td>yes</td>
<td>style</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//建议写法</span></span><br><span class="line">import AAA</span><br><span class="line">import BBB</span><br><span class="line">import CCC</span><br><span class="line">import DDD</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import Alamofire</span><br><span class="line">import API</span><br></pre></td></tr></table></figure>


<h3 id="规则98-statement-position"><a href="#规则98-statement-position" class="headerlink" title="规则98: statement_position"></a>规则98: statement_position</h3><p>陈述句位置， 这里主要指的是 else 和 catch 前面要加一个空格， 也不能大于1个空格， 否则就会触发警告</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>statement_position</td>
<td>启用</td>
<td>yes</td>
<td>style</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 没有空格，触发warning</span></span><br><span class="line">let number = <span class="string">&quot;long&quot;</span></span><br><span class="line"><span class="keyword">if</span> number.isEmpty &#123;</span><br><span class="line">    print(<span class="string">&quot;为空&quot;</span>)</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;.............................注意这里</span><br><span class="line">    print(<span class="string">&quot;不为空&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 这里也会触发warning， 因为else if换行了</span></span><br><span class="line">let number = <span class="string">&quot;long&quot;</span></span><br><span class="line"><span class="keyword">if</span> number.isEmpty &#123;</span><br><span class="line">    print(<span class="string">&quot;为空&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> number.contains(<span class="string">&quot;long&quot;</span>) &#123;............................注意这里</span><br><span class="line">    print(<span class="string">&quot;不为空&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    print(<span class="string">&quot;s&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 正确的写法</span></span><br><span class="line">let number = <span class="string">&quot;long&quot;</span></span><br><span class="line"><span class="keyword">if</span> number.isEmpty &#123;</span><br><span class="line">    print(<span class="string">&quot;为空&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    print(<span class="string">&quot;不为空&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="规则99-strict-fileprivate"><a href="#规则99-strict-fileprivate" class="headerlink" title="规则99: strict_fileprivate"></a>规则99: strict_fileprivate</h3><p>extension中不建议使用fileprivate 修饰方法和属性</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>strict_fileprivate</td>
<td>未启用</td>
<td>no</td>
<td>idiomatic</td>
</tr>
</tbody></table>
<h3 id="规则100-superfluous-disable-command"><a href="#规则100-superfluous-disable-command" class="headerlink" title="规则100: superfluous_disable_command"></a>规则100: superfluous_disable_command</h3><p>被禁用的规则不会在禁用区域触发警告</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>superfluous_disable_command</td>
<td>启用</td>
<td>no</td>
<td>lint</td>
</tr>
</tbody></table>
<blockquote>
<p>文中如有不足之处请多指教</p>
</blockquote>
<blockquote>
<p>持续更新中…..</p>
</blockquote>
]]></content>
      <categories>
        <category>iOS组件库</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>SwiftLint</tag>
      </tags>
  </entry>
  <entry>
    <title>SwiftLint代码规范属性说明03</title>
    <url>/post/a42a7b7d.html</url>
    <content><![CDATA[<ul>
<li><p>这篇文章是继前两篇文章的继续更新</p>
</li>
<li><p><a href="https://www.titanjun.top/2018/02/07/Xcode%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E4%B9%8BSwiftLint%E9%85%8D%E7%BD%AE/">Xcode代码规范之SwiftLint配置</a>–这篇文章对SwiftLint进行了简单介绍和针对Xcode的相关配置</p>
</li>
<li><p><a href="https://www.titanjun.top/2018/03/03/SwiftLint%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E5%B1%9E%E6%80%A7%E8%AF%B4%E6%98%8E01/">SwiftLint代码规范属性说明01</a>–这里介绍了上半部分的相关属性的介绍</p>
</li>
<li><p><a href="http://www.titanjun.top/2018/03/10/SwiftLint%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E5%B1%9E%E6%80%A7%E8%AF%B4%E6%98%8E02/">SwiftLint代码规范属性说明02</a>–这里介绍了上半部分的相关属性的介绍</p>
</li>
<li><p>下面来具体介绍一下SwiftLint的其他的代码规则的相关说明</p>
</li>
</ul>
<span id="more"></span>



<h3 id="规则101-switch-case-alignment"><a href="#规则101-switch-case-alignment" class="headerlink" title="规则101: switch_case_alignment"></a>规则101: switch_case_alignment</h3><p>switch-case语句中switch和case应该垂直对齐</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>switch_case_alignment</td>
<td>启用</td>
<td>no</td>
<td>style</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//应该是这样</span></span><br><span class="line"><span class="keyword">switch</span> someBool &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="literal">true</span>: <span class="comment">// case 1</span></span><br><span class="line">    print(<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="literal">false</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">case</span> let .someEnum(val) = someFunc() &#123;</span><br><span class="line">        print(<span class="string">&#x27;blue&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//而不是这样</span></span><br><span class="line"><span class="keyword">switch</span> someBool &#123;</span><br><span class="line">    ↓<span class="keyword">case</span> <span class="literal">true</span>:</span><br><span class="line">         print(<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">    ↓<span class="keyword">case</span> <span class="literal">false</span>:</span><br><span class="line">         print(<span class="string">&#x27;blue&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="规则102-switch-case-on-newline"><a href="#规则102-switch-case-on-newline" class="headerlink" title="规则102: switch_case_on_newline"></a>规则102: switch_case_on_newline</h3><p>在switch语法里， case应该总是在一个新行上面</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>switch_case_on_newline</td>
<td>启用</td>
<td>no</td>
<td>idiomatic</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// swiftlint表示会触发warning</span></span><br><span class="line">    <span class="keyword">switch</span> type &#123;</span><br><span class="line">    <span class="keyword">case</span> .value1: print(<span class="string">&quot;1&quot;</span>)...................在同一行错</span><br><span class="line">    <span class="keyword">case</span> .value2: print(<span class="string">&quot;2&quot;</span>)...................在同一行错</span><br><span class="line">    <span class="keyword">default</span>: print(<span class="string">&quot;3&quot;</span>)...................在同一行错</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 不会触发warning</span></span><br><span class="line">    <span class="keyword">switch</span> type &#123;</span><br><span class="line">    <span class="keyword">case</span> .value1:</span><br><span class="line">        print(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> .value2:</span><br><span class="line">        print(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        print(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="规则103-syntactic-sugar"><a href="#规则103-syntactic-sugar" class="headerlink" title="规则103: syntactic_sugar"></a>规则103: syntactic_sugar</h3><p>swiftlint推荐使用速记语法糖， 例如 [Int] 代替 Array, 强烈建议推荐使用</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>syntactic_sugar</td>
<td>启用</td>
<td>no</td>
<td>idiomatic</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 触发warning</span></span><br><span class="line">    let myArray: Array&lt;Int&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">    print(myArray)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 正确写法，不会触发warning</span></span><br><span class="line">    let myArray: [Int] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">    print(myArray)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="规则104-todo"><a href="#规则104-todo" class="headerlink" title="规则104: todo"></a>规则104: todo</h3><p>TODO 和 FIXME 应该避免使用， 使用“notaTODO 和 notaFIXME”代替。另外， 和 MARK 标记不同的是， “notaTODO 和 notaFIXME”没有空格要求</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>todo</td>
<td>启用</td>
<td>no</td>
<td>lint</td>
</tr>
</tbody></table>
<h3 id="规则105-trailing-closure"><a href="#规则105-trailing-closure" class="headerlink" title="规则105: trailing_closure"></a>规则105: trailing_closure</h3><p>关于闭包中{}的使用, 推荐使用尾随闭包的语法</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>trailing_closure</td>
<td>未启用</td>
<td>no</td>
<td>style</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//推荐使用</span></span><br><span class="line">foo.map &#123; $<span class="number">0</span> + <span class="number">1</span> &#125;</span><br><span class="line">foo.reduce(<span class="number">0</span>) &#123; $<span class="number">0</span> + <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不推荐使用</span></span><br><span class="line">foo.map(&#123; $<span class="number">0</span> + <span class="number">1</span> &#125;)</span><br><span class="line">↓foo.reduce(<span class="number">0</span>, combine: &#123; $<span class="number">0</span> + <span class="number">1</span> &#125;)</span><br></pre></td></tr></table></figure>


<h3 id="规则106-trailing-comma"><a href="#规则106-trailing-comma" class="headerlink" title="规则106: trailing_comma"></a>规则106: trailing_comma</h3><p>…<br>这个属性主要针对数组和字典最后一个元素, 不建议在最后一个元素会面加逗号</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>trailing_comma</td>
<td>启用</td>
<td>yes</td>
<td>style</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 数组这样写是没有任何问题的, 但是最后一个元素3后面加了一个逗号“,”尽管这样不会报错，但是这会让程序的可读性变差</span></span><br><span class="line">let ages = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,]</span><br><span class="line">let person = [<span class="string">&quot;XingYun&quot;</span>: <span class="number">98</span>, <span class="string">&quot;JinGang&quot;</span>: <span class="number">128</span>, <span class="string">&quot;LangKe&quot;</span>: <span class="number">18</span>,]</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 使用swiftlint的trailing_comma规则后，就会报warning， 所以正确的写法不应该加上这个“,”</span></span><br><span class="line">let ages = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">let person = [<span class="string">&quot;XingYun&quot;</span>: <span class="number">98</span>, <span class="string">&quot;JinGang&quot;</span>: <span class="number">128</span>, <span class="string">&quot;LangKe&quot;</span>: <span class="number">18</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="规则107-trailing-newline"><a href="#规则107-trailing-newline" class="headerlink" title="规则107: trailing_newline"></a>规则107: trailing_newline</h3><p>文件（属性、方法）结束的的时候（“}”之前）， 应该有一个空格新行，但这里要注意的是</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>trailing_newline</td>
<td>启用</td>
<td>yes</td>
<td>style</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 空一行，不会触发警告</span></span><br><span class="line">nonTriggeringExamples: [</span><br><span class="line">    <span class="string">&quot;let a = 0\n&quot;</span></span><br><span class="line">],</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 下面会触发警告</span></span><br><span class="line">triggeringExamples: [</span><br><span class="line">    <span class="string">&quot;let a = 0&quot;</span>,   <span class="comment">/// 不空行，会触发警告（实际上，我试过，不会触发警告）</span></span><br><span class="line">    <span class="string">&quot;let a = 0\n\n&quot;</span>   <span class="comment">/// 空两行， 会触发警告（实际上，我试过，会触发警告，但是触发的是vertical_whitespace警告而不是trailing_newline）</span></span><br><span class="line">],</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 说说这里，它要求改正为都空一行，虽然这样code看起来很轻松，但如果定义变量或常量太多，就太分散了（值得说的是，就算不空行也不会触发trailing_newline, 应该刚才也已经说了，这个属性只是说“应该”，而不是必须）</span></span><br><span class="line">corrections: [</span><br><span class="line">    <span class="string">&quot;let a = 0&quot;</span>: <span class="string">&quot;let a = 0\n&quot;</span>,</span><br><span class="line">    <span class="string">&quot;let b = 0\n\n&quot;</span>: <span class="string">&quot;let b = 0\n&quot;</span>,</span><br><span class="line">    <span class="string">&quot;let c = 0\n\n\n\n&quot;</span>: <span class="string">&quot;let c = 0\n&quot;</span></span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="规则108-trailing-semicolon"><a href="#规则108-trailing-semicolon" class="headerlink" title="规则108: trailing_semicolon"></a>规则108: trailing_semicolon</h3><p>尽管在变量或常量赋值之后加不加分号在swift中没有硬性的要求，但是为了使code style更swift化，所以尽量或者绝对不要加“;”</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>trailing_semicolon</td>
<td>启用</td>
<td>yes</td>
<td>idiomatic</td>
</tr>
</tbody></table>
<h3 id="规则109-trailing-whitespace"><a href="#规则109-trailing-whitespace" class="headerlink" title="规则109: trailing_whitespace"></a>规则109: trailing_whitespace</h3><p>函数方法结束后,不建议添加空格行, 和vertical_whitespace貌似有冲突</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>trailing_whitespace</td>
<td>启用</td>
<td>yes</td>
<td>style</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 下面这个例子不会触发警告，但是一旦其中有一个空行就会触发警告trailing_whitespace, 这和vertical_whitespace实质上有些冲突，vertical_whitespace要求两行code之间不超过1行，要么没有空行，要么只有1行，而trailing_whitespace要求没有空行！！！</span></span><br><span class="line"><span class="keyword">class</span> ViewController: <span class="built_in">UIViewController</span> &#123;</span><br><span class="line">override func viewDidLoad() &#123;</span><br><span class="line">    <span class="variable language_">super</span>.viewDidLoad()</span><br><span class="line">    let a = <span class="number">0</span></span><br><span class="line">    let b = <span class="number">1</span></span><br><span class="line">    let c = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">func chenlong() -&gt; Void &#123;</span><br><span class="line">    let a = <span class="number">0</span></span><br><span class="line">    print(a)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="规则110-type-body-length"><a href="#规则110-type-body-length" class="headerlink" title="规则110: type_body_length"></a>规则110: type_body_length</h3><p>类型体长度。类型体长度不应该跨越太多行， 超过200行给warning，超过350行给error。一般是大括号或者括号内, 比如定义一个enum或struct</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>type_body_length</td>
<td>启用</td>
<td>no</td>
<td>metrics</td>
</tr>
</tbody></table>
<h3 id="规则111-type-name"><a href="#规则111-type-name" class="headerlink" title="规则111: type_name"></a>规则111: type_name</h3><p>…<br>类型名， 类型名应该只包含字母数字字符， 并且以大写字母开头，长度在3-40个字符</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>type_name</td>
<td>启用</td>
<td>no</td>
<td>idiomatic</td>
</tr>
</tbody></table>
<h3 id="规则112-unneeded-break-in-switch"><a href="#规则112-unneeded-break-in-switch" class="headerlink" title="规则112: unneeded_break_in_switch"></a>规则112: unneeded_break_in_switch</h3><p>在switch-case语句中, 有方法调用或操作时,避免使用break语句</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>unneeded_break_in_switch</td>
<td>启用</td>
<td>no</td>
<td>idiomatic</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不会触发warning</span></span><br><span class="line"><span class="keyword">switch</span> foo &#123;</span><br><span class="line"><span class="keyword">case</span> .bar:</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> foo &#123;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> foo &#123;</span><br><span class="line"><span class="keyword">case</span> .bar:</span><br><span class="line">    something()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//会触发warning</span></span><br><span class="line"><span class="keyword">switch</span> foo &#123;</span><br><span class="line"><span class="keyword">case</span> .bar:</span><br><span class="line"><span class="comment">//这里已经有方法调用了</span></span><br><span class="line">    something()</span><br><span class="line">    ↓<span class="keyword">break</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="规则113-unneeded-parentheses-in-closure-argument"><a href="#规则113-unneeded-parentheses-in-closure-argument" class="headerlink" title="规则113: unneeded_parentheses_in_closure_argument"></a>规则113: unneeded_parentheses_in_closure_argument</h3><p>…<br>在定义或使用闭包时,闭包参数不建议使用括号()</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>unneeded_parentheses_in_closure_argument</td>
<td>未启用</td>
<td>yes</td>
<td>style</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//建议</span></span><br><span class="line">let foo = &#123; (bar: Int) <span class="keyword">in</span> &#125;</span><br><span class="line">let foo = &#123; bar, _  <span class="keyword">in</span> &#125;</span><br><span class="line">let foo = &#123; bar <span class="keyword">in</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不建议</span></span><br><span class="line">call(arg: &#123; ↓(bar) <span class="keyword">in</span> &#125;)</span><br><span class="line">call(arg: &#123; ↓(bar, _) <span class="keyword">in</span> &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="规则114-unused-closure-parameter"><a href="#规则114-unused-closure-parameter" class="headerlink" title="规则114: unused_closure_parameter"></a>规则114: unused_closure_parameter</h3><p>swiftlint建议最好把不使用的闭包参数使用 “_”代替</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>unused_closure_parameter</td>
<td>启用</td>
<td>yes</td>
<td>lint</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不会触发warning</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>].map &#123; number <span class="keyword">in</span></span><br><span class="line"> number + <span class="number">1</span> </span><br><span class="line">&#125;</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>].map &#123; _ <span class="keyword">in</span></span><br><span class="line"> <span class="number">3</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//会触发warning</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>].map &#123; ↓number <span class="keyword">in</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>].map &#123; ↓number <span class="keyword">in</span></span><br><span class="line"> <span class="keyword">return</span> numberWithSuffix</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="规则115-unused-enumerated"><a href="#规则115-unused-enumerated" class="headerlink" title="规则115: unused_enumerated"></a>规则115: unused_enumerated</h3><p>在for遍历数组时, 如有未使用的索引,不建议使用.enumerated()</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>unused_enumerated</td>
<td>启用</td>
<td>no</td>
<td>idiomatic</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不会触发warning</span></span><br><span class="line"><span class="keyword">for</span> (idx, foo) <span class="keyword">in</span> bar.enumerated() &#123; &#125;</span><br><span class="line"><span class="keyword">for</span> (_, foo) <span class="keyword">in</span> bar.enumerated().something() &#123; &#125;</span><br><span class="line"><span class="keyword">for</span> (_, foo) <span class="keyword">in</span> bar.something() &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//会触发warning</span></span><br><span class="line"><span class="keyword">for</span> (↓_, foo) <span class="keyword">in</span> bar.enumerated() &#123; &#125;</span><br><span class="line"><span class="keyword">for</span> (↓_, foo) <span class="keyword">in</span> abc.bar.enumerated() &#123; &#125;</span><br><span class="line"><span class="keyword">for</span> (↓_, foo) <span class="keyword">in</span> abc.something().enumerated() &#123; &#125;</span><br><span class="line"><span class="keyword">for</span> (idx, ↓_) <span class="keyword">in</span> bar.enumerated() &#123; &#125;</span><br></pre></td></tr></table></figure>


<h3 id="规则116-unused-optional-binding"><a href="#规则116-unused-optional-binding" class="headerlink" title="规则116: unused_optional_binding"></a>规则116: unused_optional_binding</h3><p>在使用if判断某变量是否为nil的时候, 不建议使用下划线(_)</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>unused_optional_binding</td>
<td>启用</td>
<td>no</td>
<td>style</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不会触发warning</span></span><br><span class="line"><span class="keyword">if</span> let bar = Foo.optionalValue &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//会触发warning</span></span><br><span class="line"><span class="keyword">if</span> let ↓_ = Foo.optionalValue &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> let a = Foo.optionalValue, let ↓_ = Foo.optionalValue2 &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="规则117-valid-ibinspectable"><a href="#规则117-valid-ibinspectable" class="headerlink" title="规则117: valid_ibinspectable"></a>规则117: valid_ibinspectable</h3><p>@IBInspectable在swiftlint中的使用需要注意， 第一必须是变量， 第二必须要有指定的类型，如果指定的类型是可选类型或者隐式类型，则目前官方只支持以下几种类型：</p>
<p>String, NSString, UIColor, NSColor, UIImage, NSImage.</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>valid_ibinspectable</td>
<td>启用</td>
<td>no</td>
<td>lint</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 指定为变量var， 类型为String？和String！</span></span><br><span class="line">@IBInspectable private var yyy: String?</span><br><span class="line">@IBInspectable private var zzz: String!</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 如果写成这样，编译能通过，但是会触发警告, 因为swiftlint暂不支持Int可选和隐式类型:</span></span><br><span class="line">@IBInspectable private var dddl: Int!</span><br><span class="line">@IBInspectable private var eeel: Int?</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 如果指定的类型不是可选类型， 就应该初始化，否则系统不允许，会报错所在的类没有初始化</span></span><br><span class="line">对：</span><br><span class="line">@IBInspectable private var counts: Int = <span class="number">0</span></span><br><span class="line">系统报错：</span><br><span class="line">@IBInspectable private var counts: Int </span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="规则118-vertical-parameter-alignment"><a href="#规则118-vertical-parameter-alignment" class="headerlink" title="规则118: vertical_parameter_alignment"></a>规则118: vertical_parameter_alignment</h3><p>垂直方向上的参数对齐。当函数参数有多行的时候， 函数参数在垂直方向上应该对齐（参数换行的时候左边对齐）</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>vertical_parameter_alignment</td>
<td>启用</td>
<td>no</td>
<td>style</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不会触发warning</span></span><br><span class="line">func validateFunction(_ file: File, kind: SwiftDeclarationKind,</span><br><span class="line">                      dictionary: [String: SourceKitRepresentable]) &#123; &#125;</span><br><span class="line">                      </span><br><span class="line">func validateFunction(_ file: File, kind: SwiftDeclarationKind,</span><br><span class="line">                      dictionary: [String: SourceKitRepresentable])</span><br><span class="line">                      -&gt; [StyleViolation]</span><br><span class="line"><span class="comment">//会触发warning</span></span><br><span class="line">func validateFunction(_ file: File, kind: SwiftDeclarationKind,</span><br><span class="line">                  ↓dictionary: [String: SourceKitRepresentable]) &#123; &#125;</span><br></pre></td></tr></table></figure>


<h3 id="规则119-vertical-parameter-alignment-on-call"><a href="#规则119-vertical-parameter-alignment-on-call" class="headerlink" title="规则119: vertical_parameter_alignment_on_call"></a>规则119: vertical_parameter_alignment_on_call</h3><p>当调用多个参数的函数时,如果参数多行显示,则应该垂直对齐</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>vertical_parameter_alignment_on_call</td>
<td>未启用</td>
<td>no</td>
<td>style</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不会触发warning</span></span><br><span class="line">foo(param1: <span class="number">1</span>, param2: bar</span><br><span class="line">    param3: <span class="literal">false</span>, param4: <span class="literal">true</span>)</span><br><span class="line">foo(param1: <span class="number">1</span>, param2: bar)</span><br><span class="line">foo(param1: <span class="number">1</span>, param2: bar</span><br><span class="line">    param3: <span class="literal">false</span>,</span><br><span class="line">    param4: <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//会触发warning</span></span><br><span class="line">foo(param1: <span class="number">1</span>, param2: bar</span><br><span class="line">                ↓param3: <span class="literal">false</span>, param4: <span class="literal">true</span>)</span><br><span class="line">                </span><br><span class="line">foo(param1: <span class="number">1</span>, param2: bar</span><br><span class="line"> ↓param3: <span class="literal">false</span>, param4: <span class="literal">true</span>)</span><br><span class="line"> </span><br><span class="line">foo(param1: <span class="number">1</span>, param2: bar</span><br><span class="line">       ↓param3: <span class="literal">false</span>,</span><br><span class="line">       ↓param4: <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="规则120-vertical-whitespace"><a href="#规则120-vertical-whitespace" class="headerlink" title="规则120: vertical_whitespace"></a>规则120: vertical_whitespace</h3><p>垂直方向上的空格行，限制为一行（注释除外）</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>vertical_whitespace</td>
<td>启用</td>
<td>yes</td>
<td>style</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 没有空格， nonTriggerWarning</span></span><br><span class="line">override func viewDidLoad() &#123;</span><br><span class="line">    <span class="variable language_">super</span>.viewDidLoad()</span><br><span class="line">    let aaa = <span class="number">0</span></span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="comment">/// 有一行空格, nonTriggerWarning</span></span><br><span class="line">override func viewDidLoad() &#123;</span><br><span class="line">    <span class="variable language_">super</span>.viewDidLoad()</span><br><span class="line">    let aaa = <span class="number">0</span></span><br><span class="line">    ...........................<span class="number">.1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// &gt;=2行，就会触发警告</span></span><br><span class="line">override func viewDidLoad() &#123;</span><br><span class="line">    <span class="variable language_">super</span>.viewDidLoad()</span><br><span class="line">    let aaa = <span class="number">0</span></span><br><span class="line">   ............................<span class="number">.1</span></span><br><span class="line">   ............................<span class="number">.2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="规则121-void-return"><a href="#规则121-void-return" class="headerlink" title="规则121: void_return"></a>规则121: void_return</h3><p>多余的返回值为空， 在函数声明的时候，返回值为空是多余的。定义常量或者变量的时候可以</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>void_return</td>
<td>启用</td>
<td>yes</td>
<td>style</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 这个属性要求这样写， 返回值为空省略</span></span><br><span class="line">func XingYun() &#123;</span><br><span class="line">    print(<span class="string">&quot;titan&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 这个属性要求别这样写，否则会有warning（但是我在swift 3.0上测试并没有触发warning）</span></span><br><span class="line">func XingYun() -&gt; Void &#123;</span><br><span class="line">    print(<span class="string">&quot;titan&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="规则122-weak-delegate"><a href="#规则122-weak-delegate" class="headerlink" title="规则122: weak_delegate"></a>规则122: weak_delegate</h3><p>代理应该写成weak类型（弱代理）来避免循环引用</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>weak_delegate</td>
<td>启用</td>
<td>no</td>
<td>lint</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 1.1 编译通过</span></span><br><span class="line"><span class="keyword">class</span> Langke &#123;</span><br><span class="line">    var chenlong: <span class="built_in">NSObjectProtocol</span>?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 1.2 编译通过，但是触发swiftlint的 weak_delegate警告， 原因是变量名 myDelegate 中有 delegate 关键字，这属于名字滥用</span></span><br><span class="line"><span class="keyword">class</span> Langke &#123;</span><br><span class="line">    var myDelegate: <span class="built_in">NSObjectProtocol</span>?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 1.3 编译通过， 不会触发警告， 原因是在 var 关键字前面加了 weak</span></span><br><span class="line"><span class="keyword">class</span> Langke &#123;</span><br><span class="line">    <span class="keyword">weak</span> var myDelegate: <span class="built_in">NSObjectProtocol</span>?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 2.1 编译通过，但是触发 weak_delegate 警告，原因是 scrollDelegate 中 Delegate 放在了最后， 被理解成了代理</span></span><br><span class="line"><span class="keyword">class</span> Langke &#123;</span><br><span class="line">    var scrollDelegate: <span class="built_in">UIScrollViewDelegate</span>?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 2.2 编译通过， 既然变量名被理解成了代理， 那为了类似防止循环引用， 应该加关键字 weak</span></span><br><span class="line"><span class="keyword">class</span> Langke &#123;</span><br><span class="line">    <span class="keyword">weak</span> var scrollDelegate: <span class="built_in">UIScrollViewDelegate</span>?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 编译通过， 不会触发警告， 因为delegate放在了前面， 没有被理解成代理</span></span><br><span class="line"><span class="keyword">class</span> Langke &#123;</span><br><span class="line">    var delegateScroll: <span class="built_in">UIScrollViewDelegate</span>?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="规则123-xctfail-message"><a href="#规则123-xctfail-message" class="headerlink" title="规则123: xctfail_message"></a>规则123: xctfail_message</h3><p>单元测试中,XCTFail调用应该包括声明描述</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>xctfail_message</td>
<td>启用</td>
<td>no</td>
<td>idiomatic</td>
</tr>
</tbody></table>
<h3 id="规则124-yoda-condition"><a href="#规则124-yoda-condition" class="headerlink" title="规则124: yoda_condition"></a>规则124: yoda_condition</h3><p>执行判断语句时, 变量名应该放在运算符的左边</p>
<table>
<thead>
<tr>
<th>识别码</th>
<th>默认是否启用</th>
<th>是否支持自动更正</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>yoda_condition</td>
<td>未启用</td>
<td>no</td>
<td>lint</td>
</tr>
</tbody></table>
<p>代码示例:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不会触发warning</span></span><br><span class="line"><span class="keyword">if</span> foo == <span class="number">42</span> &#123;&#125;</span><br><span class="line"><span class="keyword">if</span> foo &lt;= <span class="number">42.42</span> &#123;&#125;</span><br><span class="line">guard foo &gt;= <span class="number">42</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">guard foo != <span class="string">&quot;str str&quot;</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//会触发warning</span></span><br><span class="line">↓<span class="keyword">if</span> <span class="number">42</span> == foo &#123;&#125;</span><br><span class="line">↓<span class="keyword">if</span> <span class="number">42.42</span> &gt;= foo &#123;&#125;</span><br><span class="line">↓guard <span class="number">42</span> &lt;= foo <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">↓guard <span class="string">&quot;str str&quot;</span> != foo <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">↓<span class="keyword">while</span> <span class="number">10</span> &gt; foo &#123; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<blockquote>
<p>文中如有不足之处请多指教</p>
</blockquote>
<blockquote>
<p>持续更新中…..</p>
</blockquote>
]]></content>
      <categories>
        <category>iOS组件库</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>SwiftLint</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift之Facebook的POP动画使用和实战</title>
    <url>/post/d88375f6.html</url>
    <content><![CDATA[<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-a85faa1b734ebc00.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<span id="more"></span>



<ul>
<li><a href="https://github.com/facebook/pop">POP</a>是一个来自于Facebook，在iOS与OSX上通用的极具扩展性的动画引擎。它在基本的静态动画的基础上增加的弹簧动画与衰减动画，使之能创造出更真实更具物理性的交互动画。</li>
<li><code>Pop Animation</code>在使用上和<code>Core Animation</code>很相似，都涉及<code>Animation</code>对象以及<code>Animation</code>的载体的概念</li>
<li>关于<code>Core Animation</code>的相关详解, 可参考我的上一篇文章<a href="http://blog.csdn.net/ShmilyCoder/article/details/78219044">Core Animation(核心动画)</a></li>
<li>不同的是<code>Core Animation</code>的载体只能是<code>CALayer</code>，而<code>Pop Animation</code>可以是任意基于<code>NSObject</code>的对象</li>
<li><a href="https://github.com/facebook/pop">POP</a> 使用 <code>Objective-C++</code> 编写，<code>Objective-C++</code> 是对 <code>C++</code> 的扩展</li>
<li><a href="https://github.com/coderQuanjun/POPAnimationDemo">GitHub项目地址</a></li>
</ul>
<h2 id="POP自我介绍"><a href="#POP自我介绍" class="headerlink" title="POP自我介绍"></a>POP自我介绍</h2><ul>
<li><a href="https://github.com/facebook/pop">POP</a> 目前由四部分组成：1. Animations；2. Engine；3. Utility；4. WebCore。</li>
<li><a href="https://github.com/facebook/pop">POP</a> 动画极为流畅，主要在于Enimator 里，POP 通过 CADisplayLink 高达 60 FPS 的特性，打造了一个游戏级的动画引擎。</li>
<li>CADisplayLink 是类似 NSTimer 的定时器，不同之处在于，NSTimer 用于我们定义任务的执行周期、资料的更新周期，他的执行受到 CPU 的阻塞影响，而 CADisplayLink 则用于定义画面的重绘、动画的演变，他的执行基于 frames 的间隔。</li>
<li>通过 CADisplayLink，Apple 允许你将 App 的重绘速度设定到和屏幕刷新频率一致，由此你可以获得非常流畅的交互动画，这项技术的应用在游戏中非常常见，著名的 Cocos-2D 也应用了这个重要的技术。</li>
<li><a href="https://opensource.apple.com/source/WebCore/">WebCore</a> 里包含了一些从 Apple 的开源的网页渲染引擎里拿出的源文件，与 Utility 里的组件一并，提供了 POP 的各项复杂计算的基本支持</li>
</ul>
<h2 id="POP参数介绍"><a href="#POP参数介绍" class="headerlink" title="POP参数介绍"></a>POP参数介绍</h2><ul>
<li>POP默认支持三种动画，但同时也支持自定义动画<ul>
<li><code>POPBasicAnimation</code>   &#x2F;&#x2F;基础动画</li>
<li><code>POPSpringAnimation</code>  &#x2F;&#x2F;弹簧动画</li>
<li><code>POPDecayAnimation</code>   &#x2F;&#x2F;衰减动画</li>
<li><code>POPCustomAnimation</code>  &#x2F;&#x2F;自定义动画</li>
</ul>
</li>
</ul>
<h3 id="相关属性介绍"><a href="#相关属性介绍" class="headerlink" title="相关属性介绍"></a>相关属性介绍</h3><h4 id="属性简单介绍"><a href="#属性简单介绍" class="headerlink" title="属性简单介绍"></a>属性简单介绍</h4><ul>
<li>POP动画大部分属性和CoreAnimation(核心动画)的含义和用法一样</li>
<li>具体可参考<a href="http://blog.csdn.net/ShmilyCoder/article/details/78219044">Core Animation(核心动画)</a></li>
<li>每种动画的特殊属性会在下文中继续介绍</li>
</ul>
<h4 id="动画可配置属性"><a href="#动画可配置属性" class="headerlink" title="动画可配置属性"></a>动画可配置属性</h4><ul>
<li>CALayer层各属性(比较简单,就不加注释了)</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Common CALayer property names.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerBackgroundColor;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerBounds;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerCornerRadius;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerBorderWidth;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerBorderColor;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerOpacity;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerPosition;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerPositionX;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerPositionY;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerRotation;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerRotationX;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerRotationY;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerScaleX;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerScaleXY;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerScaleY;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerSize;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerSubscaleXY;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerSubtranslationX;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerSubtranslationXY;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerSubtranslationY;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerSubtranslationZ;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerTranslationX;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerTranslationXY;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerTranslationY;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerTranslationZ;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerZPosition;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerShadowColor;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerShadowOffset;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerShadowOpacity;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerShadowRadius;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>UIVIew层</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Common UIView property names.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPViewAlpha;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPViewBackgroundColor;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPViewBounds;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPViewCenter;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPViewFrame;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPViewScaleX;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPViewScaleXY;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPViewScaleY;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPViewSize;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPViewTintColor;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>其他层视图层</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Common UINavigationBar property names.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPNavigationBarBarTintColor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Common UIToolbar property names.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPToolbarBarTintColor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Common UITabBar property names.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPTabBarBarTintColor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Common UILabel property names.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLabelTextColor;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>以上仅仅列出了常用的一些属性,更多控件&#x2F;更多参考框架里面类<br>POPAnimatableProperty.h</p>
</blockquote>
<h4 id="POPBasicAnimation可配置的属性与默认值为"><a href="#POPBasicAnimation可配置的属性与默认值为" class="headerlink" title="POPBasicAnimation可配置的属性与默认值为"></a>POPBasicAnimation可配置的属性与默认值为</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">POPBasicAnimation *basic = [POPBasicAnimation linearAnimation];</span><br><span class="line">basic.fromValue = @(<span class="number">0</span>);<span class="comment">//从0开始    basic.toValue = @(3*60);//180秒后结束</span></span><br><span class="line">basic.duration = <span class="number">3</span>*<span class="number">60</span>;<span class="comment">//持续3分钟</span></span><br><span class="line">[lab pop_addAnimation:basic forKey:<span class="literal">nil</span>];</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">let basic1 = POPBasicAnimation(propertyNamed: kPOPLayerPositionX)</span><br><span class="line">basic1?.fromValue = redView.layer.position.x</span><br><span class="line">basic1?.toValue = <span class="number">300</span></span><br><span class="line">basic1?.beginTime = <span class="built_in">CFTimeInterval</span>() + <span class="number">1.0</span></span><br><span class="line">redView.pop_add(basic1, forKey: <span class="string">&quot;position.x&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="POPBasicAnimation基础动画"><a href="#POPBasicAnimation基础动画" class="headerlink" title="POPBasicAnimation基础动画"></a>POPBasicAnimation基础动画</h2><h3 id="先看一下效果-其动画效果如下"><a href="#先看一下效果-其动画效果如下" class="headerlink" title="先看一下效果, 其动画效果如下"></a>先看一下效果, 其动画效果如下</h3><p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-1efeb167ad71b59d.gif?imageMogr2/auto-orient/strip" alt="image"></p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">let basic1 = POPBasicAnimation(propertyNamed: kPOPLayerPositionX)</span><br><span class="line">basic1?.toValue = <span class="number">300</span></span><br><span class="line"><span class="comment">//开始时间</span></span><br><span class="line">basic1?.beginTime = <span class="built_in">CFTimeInterval</span>() + <span class="number">1.0</span></span><br><span class="line">redView.pop_add(basic1, forKey: <span class="string">&quot;position.x&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="可以看到，添加一个动画最少仅需三步"><a href="#可以看到，添加一个动画最少仅需三步" class="headerlink" title="可以看到，添加一个动画最少仅需三步"></a>可以看到，添加一个动画最少仅需三步</h3><ul>
<li>1）定义一个<code>animation</code>对象，并指定对应的动画属性（<code>kPOPLayerPositionX</code>）</li>
<li>2）设置初始值结束值(初始值可以不指定，会默认从当前值开始）</li>
<li>3）添加到想产生动画的对象上</li>
</ul>
<h3 id="Core-Animation-和-POP-运行动画对比"><a href="#Core-Animation-和-POP-运行动画对比" class="headerlink" title="Core Animation 和 POP 运行动画对比"></a>Core Animation 和 POP 运行动画对比</h3><ul>
<li>由于 POP 是基于定时器定时刷新添加动画的原理，那么如果将动画库运行在主线程上，会由于线程阻塞的问题导致动画效果出现卡顿、不流畅的情况。</li>
<li>更为关键的是，你不能将动画效果放在子线程，因为你不能将对 view 和 layer 的操作放到主线程之外</li>
<li>POP 受主线程阻塞的影响很大，在使用过程中，应避免在有可能发生主线程阻塞的情况下使用 POP ，避免制作卡顿的动画效果，产生不好的用户体验</li>
</ul>
<h2 id="POPSpringAnimation弹性动画"><a href="#POPSpringAnimation弹性动画" class="headerlink" title="POPSpringAnimation弹性动画"></a>POPSpringAnimation弹性动画</h2><h3 id="属性介绍"><a href="#属性介绍" class="headerlink" title="属性介绍"></a>属性介绍</h3><ul>
<li><code>velocity</code>: 设置动画开始速度</li>
<li><code>springBounciness</code>: 振幅, 可以设置的范围是0-20，默认为4。值越大振动的幅度越大</li>
<li><code>springSpeed</code>: 速度, 可以设置的范围是0-20，默认为12.值越大速度越快，结束的越快</li>
<li><code>dynamicsMass</code>: 质量, 质量越大，动画的速度越慢，振动的幅度越大，结束的越慢</li>
<li><code>dynamicsTension</code>: 拉力 拉力越大，动画的速度越快，结束的越快</li>
<li><code>dynamicsFriction</code>: 摩擦力, 摩擦力越大，动画的速度越慢，振动的幅度越小。</li>
</ul>
<blockquote>
<p>注意: 以上的六个属性中一般只会设置<code>springBounciness</code>和<code>springSpeed</code>, 如有特殊需求才会设置其他属性</p>
</blockquote>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">let spring = POPSpringAnimation(propertyNamed: kPOPViewScaleXY)</span><br><span class="line"><span class="comment">//注意: 这里改变的是x和y的比例,参数赋值也要传两个; 若只需要其中一个,则可设置</span></span><br><span class="line"><span class="comment">//`spring?.fromValue = 0.4`即可</span></span><br><span class="line">spring?.fromValue = <span class="built_in">CGSize</span>(width: <span class="number">0.3</span>, height: <span class="number">0.3</span>)</span><br><span class="line">spring?.toValue = <span class="built_in">CGSize</span>(width: <span class="number">2</span>, height: <span class="number">2</span>)</span><br><span class="line">spring?.springSpeed = <span class="number">5</span></span><br><span class="line">spring?.springBounciness = <span class="number">15</span></span><br><span class="line">lightBlue.pop_add(spring, forKey: <span class="string">&quot;scale&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="POPDecayAnimation"><a href="#POPDecayAnimation" class="headerlink" title="POPDecayAnimation"></a>POPDecayAnimation</h2><ul>
<li><code>POPDecayAnimation</code>提供一个过阻尼效果（其实<code>Spring</code>是一种欠阻尼效果）可以实现类似<code>UIScrollView</code>的滑动衰减效果（是的你可以靠它来自己实现一个<code>UIScrollView</code>）</li>
</ul>
<blockquote>
<p>属性介绍</p>
</blockquote>
<ul>
<li><code>deceleration</code> （负加速度, 衰减系数(越小则衰减得越快)） 是一个你会很少用到的值，默认是就是我们地球的 0.998，如果你开发APP给火星人用，那么这个值你使用 0.376 会更合适</li>
<li><code>velocity</code> 也是必须和你操作的属性有相同的结构，如果你操作的是 bounds, 传CGRect类型;如果 velocity 是负值，那么就会反向递减</li>
</ul>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">let decay = POPDecayAnimation(propertyNamed: kPOPViewSize)</span><br><span class="line">decay?.velocity = <span class="built_in">CGSize</span>(width: <span class="number">300</span>, height: pictureBtn.frame.height)</span><br><span class="line"><span class="comment">//延迟1秒后执行</span></span><br><span class="line">decay?.beginTime = <span class="built_in">CACurrentMediaTime</span>() + <span class="number">1.0</span></span><br><span class="line">pictureBtn.pop_add(decay, forKey: <span class="string">&quot;size&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="自定义属性"><a href="#自定义属性" class="headerlink" title="自定义属性"></a>自定义属性</h2><p>POP默认支持的三种动画都继承自<code>POPPropertyAnimation</code>,  <code>POPPropertyAnimation</code>中定义了一个叫<code>property</code>的属性（之前没有用到它是因为POP根据不同的默认动画属性帮你生成了默认的<code>property</code>这个属性则是用来驱动POP的动画效果中的重要一环</p>
<h3 id="实力模块"><a href="#实力模块" class="headerlink" title="实力模块"></a>实力模块</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> let proper = POPAnimatableProperty.property(withName: <span class="string">&quot;prop&quot;</span>, initializer: &#123; (prop) <span class="keyword">in</span></span><br><span class="line">    guard let prop = prop <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    <span class="comment">//read</span></span><br><span class="line">    prop.readBlock = &#123; (obj, values) <span class="keyword">in</span></span><br><span class="line">                </span><br><span class="line">    &#125;</span><br><span class="line">            </span><br><span class="line">    <span class="comment">//write</span></span><br><span class="line">    prop.writeBlock = &#123;(obj, values) <span class="keyword">in</span></span><br><span class="line">                </span><br><span class="line">    &#125;</span><br><span class="line">    prop.threshold = <span class="number">0.01</span></span><br><span class="line">            </span><br><span class="line">&#125;) as? POPAnimatableProperty &#123;</span><br><span class="line">    anim.property = proper</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="属性介绍-1"><a href="#属性介绍-1" class="headerlink" title="属性介绍"></a>属性介绍</h3><blockquote>
<p>其组成就是一个readBlock一个writeBlock和一个threashold</p>
</blockquote>
<ul>
<li><code>readBlock</code>告诉POP当前的属性值</li>
<li><code>writeBlock</code>中修改变化后的属性值</li>
<li><code>threashold</code>决定了动画变化间隔的阈值 值越大<code>writeBlock</code>的调用次数越少</li>
</ul>
<p>POPAnimatableProperty其实是POP中一个比较重要的东西 像上面提到的POP自带的动画属性 查看源代码可以看到也只是POP自动帮你设置好了POPAnimatableProperty而已 其作用就是当动画的某个时间片被触发时 告诉系统如何根据当前时间片做出变化</p>
<blockquote>
<p>还是以一个实际的例子来说明如何使用自定义属性 比如我们要实现一个像系统的时钟APP里秒表计时的一个效果</p>
</blockquote>
<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-070c23772942ed82.gif?imageMogr2/auto-orient/strip" alt="计时器效果"></p>
<h3 id="完整代码示例"><a href="#完整代码示例" class="headerlink" title="完整代码示例"></a>完整代码示例</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> let proper = POPAnimatableProperty.property(withName: <span class="string">&quot;prop&quot;</span>, initializer: &#123; (prop) <span class="keyword">in</span></span><br><span class="line">    guard let prop = prop <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    <span class="comment">//read</span></span><br><span class="line">    prop.readBlock = &#123; (obj, values) <span class="keyword">in</span></span><br><span class="line">        guard let array = values <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        print(array[<span class="number">0</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//write</span></span><br><span class="line">    prop.writeBlock = &#123;(obj, values) <span class="keyword">in</span></span><br><span class="line">        guard let button = obj as? <span class="built_in">UIButton</span>, let array = values <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        let value = array[<span class="number">0</span>]</span><br><span class="line">        button.setTitle(String(format: <span class="string">&quot;%02d:%02d:%02d&quot;</span>, Int(value / <span class="number">60</span>), Int(value.truncatingRemainder(dividingBy: <span class="number">60</span>)), Int((value * <span class="number">100</span>).truncatingRemainder(dividingBy: <span class="number">100</span>))), <span class="keyword">for</span>: .normal)</span><br><span class="line">    &#125;</span><br><span class="line">    prop.threshold = <span class="number">0.01</span></span><br><span class="line">    </span><br><span class="line">&#125;) as? POPAnimatableProperty &#123;</span><br><span class="line">    <span class="keyword">if</span> let popBasic = POPBasicAnimation.linear() &#123;</span><br><span class="line">        <span class="comment">//秒表用线性的时间函数初始化</span></span><br><span class="line">        popBasic.property = proper</span><br><span class="line">        popBasic.fromValue = <span class="number">0</span> <span class="comment">//从0开始</span></span><br><span class="line">        popBasic.toValue = <span class="number">18</span>  <span class="comment">//到18秒</span></span><br><span class="line">        popBasic.duration = <span class="number">18</span> <span class="comment">//持续18秒</span></span><br><span class="line">        popBasic.beginTime = <span class="built_in">CACurrentMediaTime</span>() + <span class="number">2</span> <span class="comment">//延迟2秒开始</span></span><br><span class="line">        pictureBtn.pop_add(popBasic, forKey: <span class="string">&quot;linear&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<div class="note warning"><p>注意:</p></div>

<ul>
<li>在Swift4.0版本(4.0之前版本未知)中,初始化出来的对象都是可选类型</li>
<li><a href="https://github.com/facebook/pop">POP</a>官方的建议是添加<code>if</code>条件判断,详情可到GitHub上查看示例</li>
<li>正如上段代码所示: 闭包中涉及的可选类型都添加了<code>guard</code>判断</li>
</ul>
<h2 id="类似微博中间发布按钮弹出动画"><a href="#类似微博中间发布按钮弹出动画" class="headerlink" title="类似微博中间发布按钮弹出动画"></a>类似微博中间发布按钮弹出动画</h2><h3 id="先看一下效果吧"><a href="#先看一下效果吧" class="headerlink" title="先看一下效果吧"></a>先看一下效果吧</h3><p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-737cf17a9cb95542.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt="微博动画效果图"></p>
<blockquote>
<p>动画分为两个部分</p>
</blockquote>
<ul>
<li>中间六个按钮依次执行动画弹出</li>
<li>上面标题图片最后动画落下</li>
</ul>
<h3 id="下面来看一下部分的核心代码"><a href="#下面来看一下部分的核心代码" class="headerlink" title="下面来看一下部分的核心代码"></a>下面来看一下部分的核心代码</h3><h4 id="六个按钮的弹出和消失动画"><a href="#六个按钮的弹出和消失动画" class="headerlink" title="六个按钮的弹出和消失动画"></a>六个按钮的弹出和消失动画</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0.</span>.&lt;titles.count &#123;</span><br><span class="line">    let button = BaseButton()</span><br><span class="line">    button.setTitle(titles[i], <span class="keyword">for</span>: .normal)</span><br><span class="line">    button.setImage(<span class="built_in">UIImage</span>(named: images[i]), <span class="keyword">for</span>: .normal)</span><br><span class="line">    button.addTarget(<span class="keyword">self</span>, action: <span class="meta">#selector(buttonClick(button:)), for: .touchUpInside)</span></span><br><span class="line">    addSubview(button)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//计算X/Y</span></span><br><span class="line">    let row = i / maxCols</span><br><span class="line">    let col = i % maxCols</span><br><span class="line">    let buttonX = btnStsrtX + <span class="built_in">CGFloat</span>(col) * (xMargin + buttonW)</span><br><span class="line">    let buttonEndY = btnStartY + <span class="built_in">CGFloat</span>(row) * buttonH</span><br><span class="line">    let buttonStartY = buttonEndY - kScreenHeight</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//按钮动画</span></span><br><span class="line">    let popSpring = POPSpringAnimation(propertyNamed: kPOPViewFrame)</span><br><span class="line">    popSpring?.fromValue = <span class="built_in">CGRect</span>(x: buttonX, y: buttonStartY, width: buttonW, height: buttonH)</span><br><span class="line">    popSpring?.toValue = <span class="built_in">CGRect</span>(x: buttonX, y: buttonEndY, width: buttonW, height: buttonH)</span><br><span class="line">    popSpring?.springBounciness = kSpringFactor</span><br><span class="line">    popSpring?.springSpeed = kSpringFactor</span><br><span class="line">    popSpring?.beginTime = <span class="built_in">CACurrentMediaTime</span>() + kAnimationDelay * Double(i)</span><br><span class="line">    button.pop_add(popSpring, forKey: <span class="string">&quot;spring&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="最上部分标语的弹出和消失"><a href="#最上部分标语的弹出和消失" class="headerlink" title="最上部分标语的弹出和消失"></a>最上部分标语的弹出和消失</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//z执行动画</span></span><br><span class="line">let imagePOP = POPSpringAnimation(propertyNamed: kPOPViewCenter)</span><br><span class="line">imagePOP?.fromValue = <span class="built_in">CGPoint</span>(x: kScreenWidth * <span class="number">0.5</span>, y: <span class="number">0.2</span> * kScreenHeight - kScreenHeight)</span><br><span class="line">imagePOP?.toValue = <span class="built_in">CGPoint</span>(x: kScreenWidth * <span class="number">0.5</span>, y: <span class="number">0.2</span> * kScreenHeight)</span><br><span class="line">imagePOP?.springSpeed = kSpringFactor</span><br><span class="line">imagePOP?.springBounciness = kSpringFactor</span><br><span class="line">imagePOP?.beginTime = <span class="built_in">CACurrentMediaTime</span>() + Double(btnCount) * kAnimationDelay</span><br><span class="line">imagePOP?.completionBlock = &#123; popAnim, finished <span class="keyword">in</span></span><br><span class="line">    <span class="comment">//所有动画执行完毕,回复View点击事件</span></span><br><span class="line">    kRootView?.isUserInteractionEnabled = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">self</span>.isUserInteractionEnabled = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">topImage.pop_add(imagePOP, forKey: <span class="literal">nil</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>以上是类似微博动画的部分核心代码, 具体代码详见<a href="https://github.com/coderQuanjun/POPAnimationDemo">GitHub项目</a>, 喜欢请star</p>
</blockquote>
<ul>
<li>折叠图片</li>
<li>音量震动条</li>
<li>活动指示器</li>
<li>微博动画</li>
<li>倒计时-计时器</li>
<li>类似QQ信息条数的粘性动画</li>
<li>类似雷达-水波纹动画</li>
</ul>
<blockquote>
<p>注: 项目持续更新中……</p>
</blockquote>
]]></content>
      <categories>
        <category>iOS组件库</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift之删除HTML5页面的广告</title>
    <url>/post/d0212e24.html</url>
    <content><![CDATA[<p>好久没来博客了,最近工作中任务(Bug)比较多!除了改Bug之外发现最近新出的一部电视剧不错, 给大家推荐一下&lt;&lt;&lt;&lt;猎场&gt;&gt;&gt;&gt;</p>
<span id="more"></span>

<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-050601a063e14ce8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="猎场.jpg"></p>
<h2 id="UIWebViewDelegate"><a href="#UIWebViewDelegate" class="headerlink" title="UIWebViewDelegate"></a>UIWebViewDelegate</h2><ul>
<li>好了,言归正传,今天遇到了一个关于UIWebView问题的问题,如何删除H5页面的广告问题(一般出现在第三方的H5页面的情况)</li>
<li>APP中嵌入一个H5的网页，但出现的广告条或是无关头尾，相当大煞风景, 那该如何去掉呢?</li>
<li>嵌入webview 一段JavaScript代码来隐藏，目前Android和iOS都支持此方法(这就是iOS中常说的js和OC交互)</li>
<li>UIWebVIew的基本使用这里就不多做介绍了</li>
<li>下面介绍一下UIWebViewDelegate的一些代理方法</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当网页视图被指示载入内容而得到通知。应当返回YES，这样会进行加载。通过导航类型参数可以得到请求发起的原因</span></span><br><span class="line">optional public func webView(_ webView: <span class="built_in">UIWebView</span>, shouldStartLoadWith request: URLRequest, navigationType: <span class="built_in">UIWebViewNavigationType</span>) -&gt; Bool</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//UIWebView的控件加载网页的监听函数方法：</span></span><br><span class="line"><span class="comment">//1. 当网页视图已经开始加载一个请求后，得到通知。</span></span><br><span class="line">optional public func webViewDidStartLoad(_ webView: <span class="built_in">UIWebView</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 当网页视图结束加载一个请求之后，得到通知。</span></span><br><span class="line">optional public func webViewDidFinishLoad(_ webView: <span class="built_in">UIWebView</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 当前请求加载中发生错误时，得到通知。</span></span><br><span class="line">optional public func webView(_ webView: <span class="built_in">UIWebView</span>, didFailLoadWithError error: Error)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="基于JavaScript的H5代码"><a href="#基于JavaScript的H5代码" class="headerlink" title="基于JavaScript的H5代码"></a>基于JavaScript的H5代码</h2><ul>
<li><p>首先,我们先看一下HTML5在浏览器中的现实情况, <a href="http://mini.eastday.com/mobile/170818161313395.html">参考地址</a></p>
</li>
<li><p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-146823b54ab03b8d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="删除前的原网页"></p>
</li>
<li><p>下面我们就要找到广告或者其他你想删除的部分对应的HTML代码</p>
</li>
<li><p>用浏览器打开<a href="http://mini.eastday.com/mobile/170818161313395.html">参考地址</a>, 建议使用谷歌浏览器</p>
</li>
<li><p>找到浏览器的开发者工具, 按照如下操作</p>
</li>
<li><p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-c3efc0cb6e21f3ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="查看网页代码"></p>
</li>
<li><p>控制网页和js源码的显示方式</p>
</li>
<li><p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-ea333a6efa617e15.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20171111_6.png"></p>
<ul>
<li>调节手机&#x2F;电脑显示: 你要选择在那种情境下显示网页,通俗来说,就是模拟器</li>
<li>放大镜:你可以通过放大镜对网页上的控件进行选取,然后找到html代码</li>
<li>手机:转化为手机模式,但是前提必须要转换Device的模式,要不然,光是视图上的转变,没有实际的转变(注意:我现在拿手机的网页做示例,所有我需要转化,当你做的电脑的就不需要转换这些了)</li>
</ul>
</li>
<li><p>下面这就是要找到广告对应的js源码了(这里以订阅按钮为例)<br><img data-src="http://upload-images.jianshu.io/upload_images/4122543-e8c6dd62b00d9c38.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20171111_8.png"></p>
<ul>
<li>将右侧按钮为选中状态</li>
<li>用鼠标选中你要删除的控件(这里以订阅按钮为例), 这时你会发现右侧代码会有一行背景颜色被加深</li>
<li>我们要做的就是调用js语法删除这行js代码, 从而删除订阅按钮</li>
<li>找到该控件的class标签或者id标签</li>
<li>通过以下代码控制删除</li>
</ul>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//class类型</span></span><br><span class="line">document.getElementsByClassName(<span class="string">&#x27;gg-item news-gg-img3&#x27;</span>).style.display = <span class="string">&#x27;none&#x27;</span></span><br><span class="line"><span class="comment">//id类型</span></span><br><span class="line">document.getElementsById(<span class="string">&#x27;gg-item news-gg-img3&#x27;</span>).style.display = <span class="string">&#x27;none&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果找到的该控件所在的js代码没有class或者id标志, 可以继续找到其父控件,通过以下方式删除</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">document.getElementsByClassName(<span class="string">&#x27;gg-item news-gg-img3&#x27;</span>)[<span class="number">0</span>].style.display=<span class="string">&#x27;none&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="具体核心代码如下"><a href="#具体核心代码如下" class="headerlink" title="具体核心代码如下"></a>具体核心代码如下</h2><ul>
<li>删除广告后的效果如图</li>
</ul>
<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-26d52ecdfceb0f52.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="最终效果图"></p>
<ul>
<li>核心代码</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">extension NoneADViewController: <span class="built_in">UIWebViewDelegate</span>&#123;</span><br><span class="line">    func webViewDidFinishLoad(_ webView: <span class="built_in">UIWebView</span>) &#123;</span><br><span class="line">        <span class="comment">//最顶部的广告</span></span><br><span class="line">        webView.stringByEvaluatingJavaScript(from: <span class="string">&quot;document.getElementsByClassName(&#x27;gg-item news-gg-img3&#x27;)[0].style.display=&#x27;none&#x27;&quot;</span>)</span><br><span class="line">        <span class="comment">//删除页面浮框广告</span></span><br><span class="line">        webView.stringByEvaluatingJavaScript(from: <span class="string">&quot;document.getElementsByClassName(&#x27;dbleleven-wrap&#x27;)[0].style.display=&#x27;none&#x27;&quot;</span>)</span><br><span class="line">        <span class="comment">//第一张图片下面的广告</span></span><br><span class="line">        webView.stringByEvaluatingJavaScript(from: <span class="string">&quot;document.getElementsByClassName(&#x27;baiduimageplusm-title-img-only&#x27;)[0].style.display = &#x27;none&#x27;&quot;</span>)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func webView(_ webView: <span class="built_in">UIWebView</span>, shouldStartLoadWith request: URLRequest, navigationType: <span class="built_in">UIWebViewNavigationType</span>) -&gt; Bool &#123;</span><br><span class="line">        guard let urlStr = request.url?.absoluteString <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">true</span> &#125;</span><br><span class="line">        print(urlStr)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
        <tag>Swift</tag>
        <tag>WebView</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift仿网易新闻首页左右滑动切换页面</title>
    <url>/post/731f92e4.html</url>
    <content><![CDATA[<blockquote>
<p>顶部标题左右滑动切换控制器是一种非常用的左右滚动切换效果,几乎每一个APP都有用到,在这里介绍一下我自己封装的一个Swift版本的简单框架;代码中注释相对详细,故文中没有做过多的解释;废话不多少,直接上效果图:</p>
</blockquote>
<span id="more"></span>

<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-91d007e59b3a6ce5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="效果图1.png"></p>
<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-047cf052039633e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="效果图2.png"></p>
<h2 id="一-框架介绍"><a href="#一-框架介绍" class="headerlink" title="一.框架介绍"></a>一.框架介绍</h2><h2 id="github地址"><a href="#github地址" class="headerlink" title="github地址"></a><a href="https://github.com/coderQuanjun/TJPageView">github地址</a></h2><p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-7f8bb034a432d133.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20170612_18.png"></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">TJTitleStyle.swift  <span class="comment">//控制框架所有显示样式的参数值</span></span><br><span class="line"></span><br><span class="line">TJTitleView.swift <span class="comment">//顶部标题的处理view</span></span><br><span class="line"></span><br><span class="line">TJContentView.swift <span class="comment">//处理所有控制器的view</span></span><br><span class="line"></span><br><span class="line">TJPageView.swift  <span class="comment">//控制整体框架的总试图View</span></span><br></pre></td></tr></table></figure>

<h3 id="TJTitleStyle-swift"><a href="#TJTitleStyle-swift" class="headerlink" title="TJTitleStyle.swift"></a>TJTitleStyle.swift</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/// 是否是滚动的Title</span></span><br><span class="line">var isScrollEnable : Bool = <span class="literal">false</span></span><br><span class="line"><span class="comment">/// 普通Title颜色</span></span><br><span class="line">var normalColor : <span class="built_in">UIColor</span> = <span class="built_in">UIColor</span>(r: <span class="number">0</span>, g: <span class="number">0</span>, b: <span class="number">0</span>)</span><br><span class="line"><span class="comment">/// 选中Title颜色</span></span><br><span class="line">var selectedColor : <span class="built_in">UIColor</span> = <span class="built_in">UIColor</span>(r: <span class="number">255</span>, g: <span class="number">127</span>, b: <span class="number">0</span>)</span><br><span class="line"><span class="comment">/// Title字体大小</span></span><br><span class="line">var font : <span class="built_in">UIFont</span> = <span class="built_in">UIFont</span>.systemFont(ofSize: <span class="number">14.0</span>)</span><br><span class="line"><span class="comment">/// 滚动Title的字体间距</span></span><br><span class="line">var titleMargin : <span class="built_in">CGFloat</span> = <span class="number">20</span></span><br><span class="line"><span class="comment">/// title的高度</span></span><br><span class="line">var titleHeight : <span class="built_in">CGFloat</span> = <span class="number">44</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 是否显示底部滚动条</span></span><br><span class="line">var isShowBottomLine : Bool = <span class="literal">false</span></span><br><span class="line"><span class="comment">/// 底部滚动条的颜色</span></span><br><span class="line">var bottomLineColor : <span class="built_in">UIColor</span> = <span class="built_in">UIColor</span>.orange</span><br><span class="line"><span class="comment">/// 底部滚动条的高度</span></span><br><span class="line">var bottomLineH : <span class="built_in">CGFloat</span> = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 是否进行缩放</span></span><br><span class="line">var isNeedScale : Bool = <span class="literal">false</span></span><br><span class="line">var scaleRange : <span class="built_in">CGFloat</span> = <span class="number">1.2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 是否显示遮盖</span></span><br><span class="line">var isShowCover : Bool = <span class="literal">false</span></span><br><span class="line"><span class="comment">/// 遮盖背景颜色</span></span><br><span class="line">var coverBgColor : <span class="built_in">UIColor</span> = <span class="built_in">UIColor</span>.lightGray</span><br><span class="line"><span class="comment">/// 文字&amp;遮盖间隙</span></span><br><span class="line">var coverMargin : <span class="built_in">CGFloat</span> = <span class="number">5</span></span><br><span class="line"><span class="comment">/// 遮盖的高度</span></span><br><span class="line">var coverH : <span class="built_in">CGFloat</span> = <span class="number">25</span></span><br><span class="line"><span class="comment">/// 设置圆角大小</span></span><br><span class="line">var coverRadius : <span class="built_in">CGFloat</span> = <span class="number">12</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="TJPageCollectionLayout-swift自定义布局"><a href="#TJPageCollectionLayout-swift自定义布局" class="headerlink" title="TJPageCollectionLayout.swift自定义布局"></a>TJPageCollectionLayout.swift自定义布局</h3><blockquote>
<p>代码如下,注释比较详尽,不做赘述</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//    在该方法中设定一些必要的layout的结构和初始需要的参数</span></span><br><span class="line">override func prepare() &#123;</span><br><span class="line">    <span class="variable language_">super</span>.prepare()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//0.计算item的宽度和高度</span></span><br><span class="line">    let itemW = ((collectionView?.bounds.width)! - sectionInset.left - sectionInset.right - minimumInteritemSpacing * <span class="built_in">CGFloat</span>(cols - <span class="number">1</span>)) / <span class="built_in">CGFloat</span>(cols)</span><br><span class="line">    let itemH = ((collectionView?.bounds.height)! - sectionInset.top - sectionInset.bottom - minimumLineSpacing * <span class="built_in">CGFloat</span>(rows - <span class="number">1</span>)) / <span class="built_in">CGFloat</span>(rows)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.获取一共多少个组</span></span><br><span class="line">    let sectionCount = collectionView!.numberOfSections</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.获取每个组中有多少个item</span></span><br><span class="line">    var prePageCount : Int = <span class="number">0</span>    <span class="comment">//页数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0.</span>.&lt;sectionCount &#123;</span><br><span class="line">        let itemCount = collectionView!.numberOfItems(inSection: i)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0.</span>.&lt;itemCount &#123;</span><br><span class="line">            <span class="comment">//2.1获取cell对应的indexPath</span></span><br><span class="line">            let indexpath = IndexPath(item: j, section: i)</span><br><span class="line">            <span class="comment">//2.2根据indexPath创建UICollectionViewLayoutAttributes</span></span><br><span class="line">            let attr = <span class="built_in">UICollectionViewLayoutAttributes</span>(forCellWith: indexpath)</span><br><span class="line">            <span class="comment">// 2.3.计算j在该组中第几页</span></span><br><span class="line">            let page = j / (cols * rows)</span><br><span class="line">            let index = j % (cols * rows)</span><br><span class="line">            <span class="comment">//2.4设置attrs的frame</span></span><br><span class="line">            let itemY = sectionInset.top + (itemH + minimumLineSpacing) * <span class="built_in">CGFloat</span>(index / cols)</span><br><span class="line">            let itemX = <span class="built_in">CGFloat</span>(prePageCount + page) * collectionView!.bounds.width +  sectionInset.left + (itemW + minimumInteritemSpacing) * <span class="built_in">CGFloat</span>(index % cols)</span><br><span class="line">            attr.frame = <span class="built_in">CGRect</span>(x: itemX, y: itemY, width: itemW, height: itemH)</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2.5加入到数组中</span></span><br><span class="line">            cellAttrs.append(attr)</span><br><span class="line">        &#125;</span><br><span class="line">        prePageCount += (itemCount - <span class="number">1</span>) / (cols * rows) + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算最大宽度</span></span><br><span class="line">    maxWidth = <span class="built_in">CGFloat</span>(prePageCount) * collectionView!.bounds.width</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="TJPageCollectionView-swift"><a href="#TJPageCollectionView-swift" class="headerlink" title="TJPageCollectionView.swift"></a>TJPageCollectionView.swift</h3><blockquote>
<p>创建collectionView显示布局内容,设置代理方法和对外暴露的方法</p>
</blockquote>
<h4 id="代理方法"><a href="#代理方法" class="headerlink" title="代理方法"></a>代理方法</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">protocol TJPageCollectionViewDateSource : <span class="keyword">class</span> &#123;</span><br><span class="line">   <span class="comment">//返回section的个数</span></span><br><span class="line">    func numberOfSections(<span class="keyword">in</span> pageCollectionView : TJPageCollectionView) -&gt; Int</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回每个section中item的个数</span></span><br><span class="line">    func pageCollectionView(_ collectionView : TJPageCollectionView, numberOfItemsInSection section : Int) -&gt; Int</span><br><span class="line"></span><br><span class="line">    <span class="comment">//cell</span></span><br><span class="line">    func pageCollectionView(_ pageCollectionView : TJPageCollectionView, _ collectionView : <span class="built_in">UICollectionView</span>, cellForItemAt indexPath : IndexPath) -&gt; <span class="built_in">UICollectionViewCell</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protocol TJPageCollectionViewDelegate : <span class="keyword">class</span> &#123;</span><br><span class="line">    <span class="comment">//cell点击事件处理</span></span><br><span class="line">    func pageCollectionView(_ pageCollectionView : TJPageCollectionView, didSelectorItemAt indexPath : IndexPath)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="二-首页左右滑动调用方法"><a href="#二-首页左右滑动调用方法" class="headerlink" title="二.首页左右滑动调用方法"></a>二.首页左右滑动调用方法</h2><h4 id="1-设置显示样式"><a href="#1-设置显示样式" class="headerlink" title="1.设置显示样式"></a>1.设置显示样式</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">let style  = TJTitleStyle()</span><br><span class="line"><span class="comment">//是否可以滚动</span></span><br><span class="line">style.isScrollEnable = <span class="literal">true</span></span><br><span class="line"><span class="comment">//是否显示下划线</span></span><br><span class="line">style.isShowBottomLine = <span class="literal">true</span></span><br><span class="line"><span class="comment">//是否显示遮挡试图view</span></span><br><span class="line">style.isShowCover = <span class="literal">true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-初始化方法"><a href="#2-初始化方法" class="headerlink" title="2.初始化方法"></a>2.初始化方法</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**初始化方法</span></span><br><span class="line"><span class="comment">* frame    : 坐标</span></span><br><span class="line"><span class="comment">* titles   : 标题数组</span></span><br><span class="line"><span class="comment">* style    : 样式</span></span><br><span class="line"><span class="comment">* childVcs : 自控制器数组</span></span><br><span class="line"><span class="comment">* parentVc : 父控制器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">let pageView = TJPageView(frame: frame, titles: titles, style: style, childVcs: childVcs, parentVc: <span class="keyword">self</span>)</span><br><span class="line"></span><br><span class="line">view.addSubview(pageView)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="三-底部类似表情键盘布局调用方法"><a href="#三-底部类似表情键盘布局调用方法" class="headerlink" title="三.底部类似表情键盘布局调用方法"></a>三.底部类似表情键盘布局调用方法</h2><h4 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1.初始化"></a>1.初始化</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.设置显示样式</span></span><br><span class="line">let style = TJTitleStyle()</span><br><span class="line">style.isShowBottomLine = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.设置cell布局Layout</span></span><br><span class="line">let layout = TJPageCollectionLayout()</span><br><span class="line">layout.cols = <span class="number">7</span> <span class="comment">// 列</span></span><br><span class="line">layout.rows = <span class="number">3</span> <span class="comment">// 行</span></span><br><span class="line">layout.minimumLineSpacing = <span class="number">0</span></span><br><span class="line">layout.minimumInteritemSpacing = <span class="number">0</span></span><br><span class="line">layout.sectionInset = <span class="built_in">UIEdgeInsets</span>(top: <span class="number">10</span>, left: <span class="number">10</span>, bottom: <span class="number">10</span>, right: <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.创建collectionView</span></span><br><span class="line">let pageCollection = TJPageCollectionView(frame: <span class="built_in">CGRect</span>(x: <span class="number">0</span>, y: <span class="built_in">UIScreen</span>.main.bounds.height - <span class="number">250</span>, width: <span class="built_in">UIScreen</span>.main.bounds.width, height: <span class="number">250</span>), style: style, titles: [<span class="string">&quot;普通&quot;</span>, <span class="string">&quot;粉丝&quot;</span>], isTitleInTop: <span class="literal">false</span>, layout: layout)</span><br><span class="line">pageCollection.delegate = <span class="keyword">self</span></span><br><span class="line">pageCollection.dataSource = <span class="keyword">self</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.注册cell</span></span><br><span class="line">pageCollection.register(nib: <span class="built_in">UINib</span>(nibName: <span class="string">&quot;EmoticonViewCell&quot;</span>, bundle: <span class="literal">nil</span>), identifier: kEmoticonCellID)</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.添加到视图中</span></span><br><span class="line">view.addSubview(pageCollection)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-遵循协议"><a href="#2-遵循协议" class="headerlink" title="2.遵循协议"></a>2.遵循协议</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//MARK: TJCollectionViewDateSource</span></span><br><span class="line">extension NextViewController : TJPageCollectionViewDateSource&#123;</span><br><span class="line">    func numberOfSections(<span class="keyword">in</span> pageCollectionView: TJPageCollectionView) -&gt; Int &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span></span><br><span class="line">    &#125;</span><br><span class="line">    func pageCollectionView(_ collectionView: TJPageCollectionView, numberOfItemsInSection section: Int) -&gt; Int &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">40</span></span><br><span class="line">    &#125;</span><br><span class="line">    func pageCollectionView(_ pageCollectionView: TJPageCollectionView, _ collectionView: <span class="built_in">UICollectionView</span>, cellForItemAt indexPath: IndexPath) -&gt; <span class="built_in">UICollectionViewCell</span> &#123;</span><br><span class="line">        let cell = collectionView.dequeueReusableCell(withReuseIdentifier: kEmoticonCellID, <span class="keyword">for</span>: indexPath) as! EmoticonViewCell</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cell</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//MARK: TJPageCollectionViewDelegate</span></span><br><span class="line">extension NextViewController : TJPageCollectionViewDelegate&#123;</span><br><span class="line">    func pageCollectionView(_ pageCollectionView: TJPageCollectionView, didSelectorItemAt indexPath: IndexPath) &#123;</span><br><span class="line">        print(indexPath)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<ul>
<li>框架代码中可能还有不足之处,还望大神多多指教.</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>菜鸟一枚,多多交流.</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><a href="https://github.com/coderQuanjun/TJPageView">github地址</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift函数式编程之高级用法</title>
    <url>/post/a5163306.html</url>
    <content><![CDATA[<ul>
<li>什么是函数式编程呢?<ul>
<li>函数式编程其实是一种编程思想, 代码写出来只是它的表现形式.</li>
<li>在面向对象的编程思想中, 我们将要解决的一个个问题, 抽象成一个个类, 通过给类定义属性和方法, 让类帮助我们解决需要处理的问题.(其实面向对象也叫命令式编程, 就像给对象下一个个命令)</li>
<li>而在函数式编程中, 我们则通过函数描述我们要解决的问题, 以及解决问题需要怎样的方案.</li>
<li>函数本身可以作为变量, 作为参数, 作为返回值(这样说有一点抽象, 下面的解决方案中就是将函数作为函数的参数)</li>
</ul>
</li>
</ul>
<span id="more"></span>

<h3 id="1-Map的介绍"><a href="#1-Map的介绍" class="headerlink" title="1. Map的介绍"></a>1. Map的介绍</h3><blockquote>
<p>map用于将每个数组元素通过某个方法进行转换</p>
</blockquote>
<ul>
<li>Map在此处并非地图的意思, 它的含义是映射<ul>
<li>将一个元素映射成另外一种元素(类似于字典中的Key&#x2F;Value映射)</li>
<li>其实Swift系统本身是有映射的函数, 可以将一个集合映射成另外一个集合</li>
<li>map 方法接受一个闭包作为参数， 然后它会遍历整个数组，并对数组中每一个元素执行闭包中定义的操作。然后再返回一个操作后的数组；相当于对数组中的所有元素做了一个映射</li>
</ul>
</li>
</ul>
<blockquote>
<h4 id="示例分析"><a href="#示例分析" class="headerlink" title="示例分析:"></a>示例分析:</h4></blockquote>
<h5 id="实例一"><a href="#实例一" class="headerlink" title="实例一"></a>实例一</h5><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">let arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">let arr2 = arr.map(&#123; $<span class="number">0</span> * <span class="number">3</span>&#125;)</span><br><span class="line"><span class="comment">//[3, 6, 9, 12, 15, 18]</span></span><br><span class="line">let arr3 = arr.flatMap(&#123; $<span class="number">0</span> + <span class="number">2</span> &#125;)</span><br><span class="line"><span class="comment">//[3, 4, 5, 6, 7, 8]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-flatMap"><a href="#2-flatMap" class="headerlink" title="2. flatMap"></a>2. flatMap</h3><ul>
<li>我们对同样的数组使用 flatMap 进行处理， 得到了同样的结果。 那 flatMap 和 map 到底有什么区别呢？</li>
</ul>
<h4 id="实例二"><a href="#实例二" class="headerlink" title="实例二"></a>实例二</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">let numbersCompound = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]];</span><br><span class="line">var res = numbersCompound.map &#123; $<span class="number">0.</span>map&#123; $<span class="number">0</span> + <span class="number">2</span> &#125; &#125;</span><br><span class="line"><span class="comment">// [[3, 4, 5], [6, 7, 8]]</span></span><br><span class="line">var flatRes = numbersCompound.flatMap &#123; $<span class="number">0.</span>map&#123; $<span class="number">0</span> + <span class="number">2</span> &#125; &#125;</span><br><span class="line"><span class="comment">// [3, 4, 5, 6, 7, 8]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>flatMap 依然会遍历数组的元素，并对这些元素执行闭包中定义的操作。 但唯一不同的是，它对最终的结果进行了所谓的 “降维” 操作。 本来原始数组是一个二维的， 但经过 flatMap 之后，它变成一维的了。</li>
</ul>
<blockquote>
<p>下面咱们再来看一下 flatMap 的定义, 还是抛去 @noescape, rethrows 这些无关逻辑的关键字：</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">func flatMap(transform: (Self.Generator.Element) throws -&gt; T?) -&gt; [T]</span><br><span class="line">func flatMap(transform: (Self.Generator.Element) -&gt; S) -&gt; [S.Generator.Element]</span><br></pre></td></tr></table></figure>
<ul>
<li>和 map 不同， flatMap 有两个重载。 参照我们刚才的示例， 我们调用的其实是第二个重载：flatMap 的闭包接受的是数组的元素，但返回的是一个 SequenceType 类型，也就是另外一个数组<blockquote>
<p>下面让我们来看看flatMap 的另一种重载情况</p>
</blockquote>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">func flatMap</span><br><span class="line">(transform: (Self.Generator.Element) -&gt; T?) -&gt; [T]</span><br></pre></td></tr></table></figure>

<ul>
<li>从定义中我们看出， 它的闭包接收的是 Self.Generator.Element 类型， 返回的是一个 T? 。 我们都知道，在 Swift 中类型后面跟随一个 ?， 代表的是 Optional 值。 也就是说这个重载中接收的闭包返回的是一个 Optional 值。 更进一步来说，就是闭包可以返回 nil。</li>
</ul>
<h4 id="实例三"><a href="#实例三" class="headerlink" title="实例三"></a>实例三</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">let optionalArray: [String?] = [<span class="string">&quot;AA&quot;</span>, <span class="literal">nil</span>, <span class="string">&quot;BB&quot;</span>, <span class="string">&quot;CC&quot;</span>];</span><br><span class="line">print（optionalArray）</span><br><span class="line"><span class="comment">//[Optional(&quot;AA&quot;), nil, Optional(&quot;BB&quot;), Optional(&quot;CC&quot;)]</span></span><br><span class="line"></span><br><span class="line">var optionalResult = optionalArray.flatMap&#123; $<span class="number">0</span> &#125;</span><br><span class="line"><span class="comment">// [&quot;AA&quot;, &quot;BB&quot;, &quot;CC&quot;]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>flatMap 的返回结果中， 成功的将原数组中的 nil 值过滤掉了。 再仔细观察，你会发现更多。 使用 flatMap 调用之后， 数组中的所有元素都被解包了</li>
</ul>
<h4 id="关于-0的解释"><a href="#关于-0的解释" class="headerlink" title="关于$0的解释"></a>关于$0的解释</h4><ul>
<li>$0代表传入的元素本身，而不是下标</li>
<li>$0.0代表传入的元组的第一个值，如果元组被命名过了，则可以直接带名字</li>
<li>$0.age代表传入的模型的age属性</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//元组类型</span></span><br><span class="line">let a1 = [(<span class="number">1</span>,<span class="number">2</span>),(<span class="number">2</span>,<span class="number">3</span>),(<span class="number">3</span>,<span class="number">4</span>),(<span class="number">4</span>,<span class="number">5</span>),(<span class="number">5</span>,<span class="number">6</span>),(<span class="number">6</span>,<span class="number">7</span>)]</span><br><span class="line">let a2 = a1.map(&#123; $<span class="number">0.0</span> * <span class="number">2</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//模型类型</span></span><br><span class="line">let ageArr = modelArr.map(&#123; $<span class="number">0.</span>age &#125;)</span><br><span class="line">let nameArr = modelArr.map(&#123; $<span class="number">0.</span>name &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-zip的使用"><a href="#3-zip的使用" class="headerlink" title="3. zip的使用"></a>3. zip的使用</h3><blockquote>
<p>3-1. zip 是将两个序列的元素，一一对应合并成元组，生成一个新序列。比如</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">let a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">let b = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>]</span><br><span class="line">let c = zip(a, b).map &#123; $<span class="number">0</span> &#125;</span><br><span class="line"><span class="comment">// c = [(1, &quot;a&quot;), (2, &quot;b&quot;), (3, &quot;c&quot;), (4, &quot;d&quot;)]</span></span><br></pre></td></tr></table></figure>
<p>生成的序列，如同原始两个序列的相互咬合，因此函数的名字为 zip。zip 的英文有拉链的意思。生成的序列 count 为原始序列的最小值。</p>
<blockquote>
<p>3-2. zip 生成的序列通常会进行下一步处理。比如</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">func loadColors(colors: [<span class="built_in">UIColor</span>]) &#123;</span><br><span class="line">    zip(<span class="keyword">self</span>.colorButtons, colors).forEach &#123; (bt, color) <span class="keyword">in</span></span><br><span class="line">        bt.color = color</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段的语句，为颜色按钮分别赋予颜色值。相当于：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">func loadColors(colors: [<span class="built_in">UIColor</span>]) &#123;</span><br><span class="line">    let minCount = min(colors.count, <span class="keyword">self</span>.colorButtons.count)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span> ..&lt; minCount &#123;</span><br><span class="line">        <span class="keyword">self</span>.colorButtons[i].color = colors[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再举一段代码。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">let colors = [<span class="built_in">UIColor</span>.red, <span class="built_in">UIColor</span>.blue, <span class="built_in">UIColor</span>.white]</span><br><span class="line">let buttons = zip(<span class="number">0</span> ..&lt; colors.count, colors).map &#123; (i, color) <span class="keyword">in</span></span><br><span class="line">    let button = ColorButton(color: color)</span><br><span class="line">    button.tag = i</span><br><span class="line">    <span class="keyword">return</span> button</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码，创建了颜色按钮，并用索引设置了对应的 tag。</p>
<p>最后</p>
<blockquote>
<p>3-3. 这些简单的函数，配合起来可以达到一些高级的功能。比如:</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">let a = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>]</span><br><span class="line">let b = [<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>]</span><br><span class="line">let c = zip(a, b).flapMap &#123; [$<span class="number">0</span>, $<span class="number">1</span>] &#125;</span><br><span class="line"><span class="comment">// c = [&quot;a&quot;, &quot;A&quot;, &quot;b&quot;, &quot;B&quot;, &quot;c&quot;, &quot;C&quot;, &quot;d&quot;, &quot;D&quot;]</span></span><br></pre></td></tr></table></figure>
<p>这里将两个序列的元素，间隔地插入，合并成一个序列。</p>
<blockquote>
<p>3-4. zip和速记+来通过添加两个冲突的值来解析重复的键</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">let keyNames2 = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>]</span><br><span class="line">let dict = Dictionary(zip(keyNames2, repeatElement(<span class="number">1</span>, count: keyNames2.count)), uniquingKeysWith: +)</span><br><span class="line"><span class="comment">//[&quot;b&quot;: 2, &quot;a&quot;: 2, &quot;c&quot;: 1]</span></span><br></pre></td></tr></table></figure>

<h3 id="二、Filter的使用"><a href="#二、Filter的使用" class="headerlink" title="二、Filter的使用"></a>二、Filter的使用</h3><blockquote>
<p>filter用于选择数组元素中满足某种条件的元素</p>
</blockquote>
<h4 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">let arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">let arr2 = arr.filter(&#123; $<span class="number">0</span> &lt; <span class="number">5</span> &#125;)</span><br><span class="line"><span class="comment">//[1, 2, 3, 4]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="三、Reduce的使用"><a href="#三、Reduce的使用" class="headerlink" title="三、Reduce的使用"></a>三、Reduce的使用</h3><blockquote>
<p>reduce方法把数组元素组合计算为一个值</p>
</blockquote>
<ul>
<li>先看一段传统代码</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">let moneyArray = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">10</span>] </span><br><span class="line">var sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> money <span class="keyword">in</span> moneyArray &#123;</span><br><span class="line">    sum = sum + money</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//再看看数字相乘</span></span><br><span class="line">var product = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> money <span class="keyword">in</span> moneyArray &#123;</span><br><span class="line">    product = product * money</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>Swift中reduct在Array类中的定义为</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">reduce(initial: T, combine: (T, Int) throws -&gt; T)</span><br></pre></td></tr></table></figure>
<ul>
<li>接收两个参数，一个为类型U的初始值，另一个为把类型为U的元素和类型为T的元素组合成一个类型为U的值的函数。最终结果整个数组就变成了一个类型为U的值。</li>
</ul>
<h4 id="reduce简化代码"><a href="#reduce简化代码" class="headerlink" title="reduce简化代码"></a>reduce简化代码</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">sum = moneyArray.reduce(<span class="number">0</span>,&#123;$<span class="number">0</span> + $<span class="number">1</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Swift中操作符可用着函数，可简化成：</span></span><br><span class="line">sum = moneyArray.reduce(<span class="number">0</span>,+)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要注意的是combine函数的两参数类型不同，$0为计算结果类型，$1为数组元素类型</p>
</blockquote>
<h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><blockquote>
<p>1、需要说明的是数据比较大的时候，高阶函数会比传统实现更快，因为它可以并行执行（如运行在多核上），除非真的需要更高定制版本的map，reduce和filter，否则可以一直使用它们以获得更快的执行速度。</p>
</blockquote>
<blockquote>
<p>2、我确信当你使用map，filter，reduct的代码质量会更好。但也需要在合适的场景中使用它们，不要指望用它们来解决任何问题。没有放之四海而皆准的真理。</p>
</blockquote>
<blockquote>
<p>详情参考<a href="http://blog.csdn.net/fish_yan_/article/details/51785441">http://blog.csdn.net/fish_yan_&#x2F;article&#x2F;details&#x2F;51785441</a><br>详情参考<a href="http://www.cocoachina.com/swift/20150619/12173.html">http://www.cocoachina.com/swift/20150619/12173.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Swift底层原理</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift基本语法01</title>
    <url>/post/52f817ad.html</url>
    <content><![CDATA[<ul>
<li>在Swift中规定：在定义一个标识符时必须明确说明该标识符是一个常量还是变量</li>
<li>使用let来定义常量，定义之后不可以修改</li>
<li>使用var来定义变量，定义之后可以修改</li>
</ul>
<span id="more"></span>

<h2 id="常量-amp-变量"><a href="#常量-amp-变量" class="headerlink" title="常量&amp;变量"></a>常量&amp;变量</h2><h3 id="变量的基本使用"><a href="#变量的基本使用" class="headerlink" title="变量的基本使用"></a>变量的基本使用</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">let</span> a : <span class="type">Int</span> <span class="operator">=</span> <span class="number">10</span></span><br><span class="line"><span class="comment">// 错误写法,当一个标识符定义为常量时是不可以修改的</span></span><br><span class="line"><span class="comment">// a = 20</span></span><br><span class="line"><span class="keyword">var</span> b : <span class="type">Int</span> <span class="operator">=</span> <span class="number">20</span></span><br><span class="line"><span class="comment">//因为b定义为变量,因此是可以修改的</span></span><br><span class="line">b <span class="operator">=</span> <span class="number">30</span></span><br></pre></td></tr></table></figure>

<h3 id="常量和变量的使用注意"><a href="#常量和变量的使用注意" class="headerlink" title="常量和变量的使用注意:"></a>常量和变量的使用注意:</h3><ul>
<li>常量使用注意：<ul>
<li>优先使用常量</li>
<li>常量的本质</li>
</ul>
</li>
<li>注意：</li>
<li>在开发中let&#x2F;var在选择时优先使用常量，防止不小被修改掉（let）</li>
<li>如果一个标识符不需要修改，但是声明称了变量，那么编译器会报警告</li>
<li>常量的本质：<ul>
<li>含义：指向的内存地址不可以修改，但是可以通过内存地址，找到对应的对象，之后修改对象内部的属性</li>
</ul>
</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> OC中创建对象：</span></span><br><span class="line"><span class="comment">    UIView *view = [[UIView alloc] init];</span></span><br><span class="line"><span class="comment">    view = [[UIView alloc] init];</span></span><br><span class="line"><span class="comment"> Swift中创建对象：</span></span><br><span class="line"><span class="comment">    var view : UIView = UIView()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 变量的做法</span></span><br><span class="line"><span class="comment">    var view : UIView = UIView()</span></span><br><span class="line"><span class="comment">    view = UIView()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 创建常量View</span></span><br><span class="line"><span class="keyword">let</span> view <span class="operator">=</span> <span class="type">UIView</span>()</span><br><span class="line"><span class="comment">// view = UIView() 错误做法</span></span><br><span class="line">view.alpha <span class="operator">=</span> <span class="number">0.5</span></span><br><span class="line"><span class="comment">// Swift中创建结构体：结构体类型()</span></span><br><span class="line">view.frame <span class="operator">=</span> <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">100</span>, height: <span class="number">100</span>)</span><br><span class="line"><span class="comment">// Swift中调用方法，统一使用点语法</span></span><br><span class="line">view.backgroundColor <span class="operator">=</span> <span class="type">UIColor</span>.red</span><br></pre></td></tr></table></figure>

<h3 id="创建对象补充"><a href="#创建对象补充" class="headerlink" title="创建对象补充"></a>创建对象补充</h3><p>创建UIView对象，并且在UIView中添加UIButton</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="comment">// 1.创建UIView对象</span></span><br><span class="line"><span class="comment">// OC : [[UIView alloc] initWithFrame:CGRect]</span></span><br><span class="line"><span class="keyword">let</span> viewRect <span class="operator">=</span> <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">100</span>, height: <span class="number">100</span>)</span><br><span class="line"><span class="keyword">let</span> view : <span class="type">UIView</span> <span class="operator">=</span> <span class="type">UIView</span>(frame: viewRect)</span><br><span class="line"><span class="comment">// 2.设置UIView的属性</span></span><br><span class="line">view.backgroundColor <span class="operator">=</span> <span class="type">UIColor</span>.orange</span><br><span class="line"><span class="comment">// 3.创建UIButton</span></span><br><span class="line"><span class="keyword">let</span> btn : <span class="type">UIButton</span> <span class="operator">=</span> <span class="type">UIButton</span>(type: .custom)</span><br><span class="line"><span class="comment">// 4.设置UIButton的属性</span></span><br><span class="line">btn.frame <span class="operator">=</span> <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">50</span>, height: <span class="number">50</span>)</span><br><span class="line">btn.backgroundColor <span class="operator">=</span> <span class="type">UIColor</span>.purple</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Swift中枚举类型：</span></span><br><span class="line"><span class="comment"> 1&gt; 如果可以根据上下文推导出类型可以直接.具体的类型</span></span><br><span class="line"><span class="comment"> 2&gt; 如果根据上下文推导不出具体的类型，则需要：类型.具体的类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">btn.setTitle(<span class="string">&quot;按钮&quot;</span>, for: .normal)</span><br><span class="line">btn.setTitleColor(<span class="type">UIColor</span>.white, for: .normal)</span><br><span class="line"><span class="comment">// 5.将btn添加到UIView中</span></span><br><span class="line">view.addSubview(btn)</span><br></pre></td></tr></table></figure>

<h2 id="Swift中数据类型"><a href="#Swift中数据类型" class="headerlink" title="Swift中数据类型"></a>Swift中数据类型</h2><h3 id="Swift类型的介绍"><a href="#Swift类型的介绍" class="headerlink" title="Swift类型的介绍"></a>Swift类型的介绍</h3><ul>
<li>Swift中的数据类型也有:整型&#x2F;浮点型&#x2F;对象类型&#x2F;结构体类型等等<ul>
<li>先了解整型和浮点型</li>
<li>整型<ul>
<li>有符号<ul>
<li>Int8 : 有符号8位整型</li>
<li>Int16 : 有符号16位整型</li>
<li>Int32 : 有符号32位整型</li>
<li>Int64 : 有符号64位整型</li>
<li>Int ： 和平台相关(默认,相当于OC的NSInteger)</li>
</ul>
</li>
<li>无符号<ul>
<li>UInt8 : 无符号8位整型</li>
<li>UInt16 : 无符号16位整型</li>
<li>UInt32 : 无符号32位整型</li>
<li>UInt64 : 无符号64位整型</li>
<li>UInt : 和平台相关(常用,相当于OC的NSUInteger)(默认)</li>
</ul>
</li>
</ul>
</li>
<li>浮点型<ul>
<li>Float : 32位浮点型</li>
<li>Double : 64浮点型(默认)</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个Int类型的变量m,并且赋值为10</span></span><br><span class="line"><span class="keyword">var</span> m : <span class="type">Int</span> <span class="operator">=</span> <span class="number">10</span></span><br><span class="line"><span class="comment">// 定义一个Double类型的常量n,并且赋值为3.14</span></span><br><span class="line"><span class="keyword">let</span> n : <span class="type">Double</span> <span class="operator">=</span> <span class="number">3.14</span></span><br></pre></td></tr></table></figure>

<h3 id="Swift中的类型推导"><a href="#Swift中的类型推导" class="headerlink" title="Swift中的类型推导"></a>Swift中的类型推导</h3><ul>
<li>Swift是强类型的语言<ul>
<li>Swift中任何一个标识符都有明确的类型</li>
<li>注意:<ul>
<li>如果定义一个标识符时有直接进行赋值,那么标识符后面的类型可以省略.</li>
<li>因为Swift有类型推导,会自动根据后面的赋值来决定前面的标识符的数据类型</li>
<li>可以通过option+鼠标左键来查看变量的数据类型</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">let</span> m <span class="operator">=</span> <span class="number">20</span></span><br><span class="line"><span class="keyword">let</span> n <span class="operator">=</span> <span class="number">30.5</span></span><br><span class="line"><span class="comment">// 错误写法 :</span></span><br><span class="line"><span class="comment">// Swift中没有隐式转化，不会自动将一个Int类型转成Double类型，因此不同类型之间不能进行运算</span></span><br><span class="line"><span class="comment">// let result = m + n</span></span><br><span class="line"><span class="comment">// 正确做法</span></span><br><span class="line"><span class="comment">// 1&gt; 将Int类型转成Double ： Double(标识符)</span></span><br><span class="line"><span class="comment">// 2&gt; 将Double类型转成Int ： Int(标识符)</span></span><br><span class="line"><span class="keyword">let</span> result1 <span class="operator">=</span> <span class="type">Double</span>(m) <span class="operator">+</span> n</span><br><span class="line"><span class="keyword">let</span> result2 <span class="operator">=</span> m <span class="operator">+</span> <span class="type">Int</span>(n)</span><br></pre></td></tr></table></figure>


<h2 id="逻辑分支"><a href="#逻辑分支" class="headerlink" title="逻辑分支"></a>逻辑分支</h2><h3 id="分支的介绍"><a href="#分支的介绍" class="headerlink" title="分支的介绍"></a>分支的介绍</h3><ul>
<li>分支即if&#x2F;switch&#x2F;三目运算符等判断语句</li>
<li>通过分支语句可以控制程序的执行流程</li>
</ul>
<h3 id="if分支语句"><a href="#if分支语句" class="headerlink" title="if分支语句"></a>if分支语句</h3><ul>
<li>和OC中if语句有一定的区别<ul>
<li>判断句可以不加()</li>
<li>在Swift的判断句中必须有明确的真假<ul>
<li>不再有非0即真</li>
<li>必须有明确的Bool值</li>
<li>Bool有两个取值:false&#x2F;true</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 演练一:</span></span><br><span class="line"><span class="keyword">let</span> a <span class="operator">=</span> <span class="number">10</span></span><br><span class="line"><span class="comment">// 错误写法:</span></span><br><span class="line"><span class="comment">//if a &#123;</span></span><br><span class="line"><span class="comment">//    print(&quot;a&quot;)</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">// 正确写法</span></span><br><span class="line"><span class="keyword">if</span> a <span class="operator">&gt;</span> <span class="number">9</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 演练二:</span></span><br><span class="line"><span class="keyword">let</span> score <span class="operator">=</span> <span class="number">87</span></span><br><span class="line"><span class="keyword">if</span> score <span class="operator">&lt;</span> <span class="number">60</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;不及格&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> score <span class="operator">&lt;=</span> <span class="number">70</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;及格&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> score <span class="operator">&lt;=</span> <span class="number">80</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;良好&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> score <span class="operator">&lt;=</span> <span class="number">90</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;优秀&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;完美&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="guard的使用"><a href="#guard的使用" class="headerlink" title="guard的使用"></a>guard的使用</h3><ul>
<li>guard是Swift2.0新增的语法<ul>
<li>它与if语句非常类似，它设计的目的是提高程序的可读性</li>
<li>guard语句必须带有else语句，它的语法如下：<ul>
<li>当条件表达式为true时候跳过else语句中的内容，执行语句组内容</li>
<li>条件表达式为false时候执行else语句中的内容，跳转语句一般是return、break、continue和throw</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">guard</span> 条件表达式 <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 条换语句</span></span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">语句组</span><br><span class="line"><span class="comment">//---例子---</span></span><br><span class="line">    <span class="keyword">var</span> age <span class="operator">=</span> <span class="number">18</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">online</span>(<span class="params">age</span> : <span class="type">Int</span>) -&gt; <span class="type">Void</span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> age <span class="operator">&gt;=</span> <span class="number">18</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;回家去&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;可以上网&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">online(age)</span><br></pre></td></tr></table></figure>

<h3 id="switch分支"><a href="#switch分支" class="headerlink" title="switch分支"></a>switch分支</h3><h4 id="switch的介绍"><a href="#switch的介绍" class="headerlink" title="switch的介绍"></a>switch的介绍</h4><ul>
<li>Switch作为选择结构中必不可少的语句也被加入到了Swift中<ul>
<li>只要有过编程经验的人对Switch语句都不会感到陌生</li>
<li>但苹果对Switch进行了大大的增强，使其拥有其他语言中没有的特性</li>
</ul>
</li>
</ul>
<h4 id="switch的简单使用"><a href="#switch的简单使用" class="headerlink" title="switch的简单使用"></a>switch的简单使用</h4><ul>
<li>基本用法和OC用法一致<ul>
<li>不同之处:<ul>
<li>switch后可以不跟()</li>
<li>case后可以不跟break(默认会有break)</li>
</ul>
</li>
<li>例子:</li>
</ul>
</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">let</span> sex <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"> <span class="keyword">switch</span> sex &#123;</span><br><span class="line"> <span class="keyword">case</span> <span class="number">0</span> :</span><br><span class="line">     <span class="built_in">print</span>(<span class="string">&quot;男&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span> :</span><br><span class="line">     <span class="built_in">print</span>(<span class="string">&quot;女&quot;</span>)</span><br><span class="line"> <span class="keyword">default</span> :</span><br><span class="line">     <span class="built_in">print</span>(<span class="string">&quot;其他&quot;</span>)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>简单使用补充:<ul>
<li>一个case判断中,可以判断多个值</li>
<li>多个值以,隔开</li>
</ul>
</li>
</ul>
 <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sex <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">switch</span> sex &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>, <span class="number">1</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;正常人&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;其他&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>简单使用补充:<ul>
<li>如果希望出现之前的case穿透,则可以使用关键字fallthrough</li>
</ul>
</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sex <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">switch</span> sex &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;正常人&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;其他&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="switch支持区间判断"><a href="#switch支持区间判断" class="headerlink" title="switch支持区间判断"></a>switch支持区间判断</h4><ul>
<li>什么是区间?<ul>
<li>通常我们指的是数字区间:0<del>10,100</del>200<br>  swift中的区间常见有两种</li>
<li>半开半闭区间:0..&lt;10 表示:0<del>9,不包括10<br>  闭区间:0…10 表示:0</del>10</li>
</ul>
</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> score <span class="operator">=</span> <span class="number">88</span></span><br><span class="line"><span class="keyword">switch</span> score &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span><span class="operator">..&lt;</span><span class="number">60</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;不及格&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">60</span><span class="operator">..&lt;</span><span class="number">80</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;几个&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">80</span><span class="operator">..&lt;</span><span class="number">90</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;良好&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">90</span><span class="operator">..&lt;</span><span class="number">100</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;优秀&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;满分&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="循环使用"><a href="#循环使用" class="headerlink" title="循环使用"></a>循环使用</h2><h3 id="循环的介绍"><a href="#循环的介绍" class="headerlink" title="循环的介绍"></a>循环的介绍</h3><ul>
<li>在开发中经常会需要循环</li>
<li>常见的循环有:for&#x2F;while&#x2F;do while.</li>
<li>这里我们只介绍for&#x2F;while,因为for&#x2F;while最常见</li>
</ul>
<h3 id="for循环的写法"><a href="#for循环的写法" class="headerlink" title="for循环的写法"></a>for循环的写法</h3><ul>
<li>区间for循环</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span><span class="number">10</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span><span class="operator">...</span><span class="number">10</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//特殊写法:如果在for循环中不需要用到下标i</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">_</span> <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span><span class="number">10</span> &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><a href="http://www.jianshu.com/p/0f75c23773b5">Swift中遍历方法for in 和 forEach的区别</a></p>
</blockquote>
<h3 id="while和do-while循环"><a href="#while和do-while循环" class="headerlink" title="while和do while循环"></a>while和do while循环</h3><ul>
<li>while循环<ul>
<li>while的判断句必须有正确的真假,没有非0即真</li>
<li>while后面的()可以省略</li>
</ul>
</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> a <span class="operator">&lt;</span> <span class="number">10</span> &#123;</span><br><span class="line">    a<span class="operator">++</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//--do while循环:使用repeat关键字来代替了do--</span></span><br><span class="line">    <span class="keyword">let</span> b <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">repeat</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(b)</span><br><span class="line">    b<span class="operator">++</span></span><br><span class="line">&#125; <span class="keyword">while</span> b <span class="operator">&lt;</span> <span class="number">20</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift之二维码的生成、识别和扫描</title>
    <url>/post/433291c1.html</url>
    <content><![CDATA[<blockquote>
<p>最近在项目中遇到了涉及二维码相关的问题, 这里想记录总结一下二维码相关技术</p>
</blockquote>
<span id="more"></span>

<h2 id="二维码的介绍"><a href="#二维码的介绍" class="headerlink" title="二维码的介绍"></a>二维码的介绍</h2><ul>
<li>二维条码&#x2F;二维码是用某种特定的几何图形按一定规律在平面分布的黑白相间的图形记录数据符号信息的</li>
<li>总结: 用图形记录标记一些信息,方便通过图形识别来获取信息</li>
<li>应用场景<ul>
<li>信息获取（名片、地图、WIFI密码、资料）</li>
<li>手机电商（用户扫码、手机直接购物下单）</li>
<li>手机支付（扫描商品二维码，通过银行或第三方支付提供的手机端通道完成支付)</li>
<li>微信添加好友</li>
</ul>
</li>
</ul>
<h2 id="二维码的生成"><a href="#二维码的生成" class="headerlink" title="二维码的生成"></a>二维码的生成</h2><ul>
<li>生成二维码的方式<ul>
<li>采用第三方框架(放弃)<ul>
<li>ZXing&#x2F;ZBar</li>
<li>框架不支持64位(2015年2月1号起, - 不允许不支持64位处理器的APP 上架)</li>
</ul>
</li>
<li>系统自带API</li>
</ul>
</li>
<li>生成二维码的步骤<ul>
<li>创建二维码滤镜–CIFilter</li>
<li>恢复滤镜的默认属性</li>
<li>设置滤镜的输入数据</li>
<li>将传入的字符串转换成Data(OC为NSData)数据</li>
<li>通过KVC来设置输入的内容<code>inputMessage</code></li>
</ul>
</li>
</ul>
<h3 id="二维码容错率"><a href="#二维码容错率" class="headerlink" title="二维码容错率"></a>二维码容错率</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">filter?.setValue(<span class="string">&quot;H&quot;</span>, forKey: <span class="string">&quot;inputCorrectionLevel&quot;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>inputCorrectionLevel</code> 是一个单字母（@”L”, @”M”, @”Q”, @”H” 中的一个），表示不同级别的容错率，默认为 @”M”.</li>
<li>QR码有容错能力，QR码图形如果有破损，仍然可以被机器读取内容，最高可以到7%~30%面积破损仍可被读取,相对而言，容错率愈高，QR码图形面积愈大。所以一般折衷使用15%容错能力。</li>
<li>L水平 7%的字码可被修正.</li>
<li>M水平 15%的字码可被修正</li>
<li>Q水平 25%的字码可被修正</li>
<li>H水平 30%的字码可被修正</li>
<li>代码:</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* *  @param inputMsg 二维码保存的信息</span></span><br><span class="line"><span class="comment">   *  @param fgImage  前景图片  */</span></span><br><span class="line">func generateCode(inputMsg: String, fgImage: <span class="built_in">UIImage</span>?) -&gt; <span class="built_in">UIImage</span> &#123;</span><br><span class="line">    <span class="comment">//1. 将内容生成二维码</span></span><br><span class="line">    <span class="comment">//1.1 创建滤镜</span></span><br><span class="line">    let filter = <span class="built_in">CIFilter</span>(name: <span class="string">&quot;CIQRCodeGenerator&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1.2 恢复默认设置</span></span><br><span class="line">    filter?.setDefaults()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1.3 设置生成的二维码的容错率</span></span><br><span class="line">    <span class="comment">//value = @&quot;L/M/Q/H&quot;</span></span><br><span class="line">    filter?.setValue(<span class="string">&quot;H&quot;</span>, forKey: <span class="string">&quot;inputCorrectionLevel&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.设置输入的内容(KVC)</span></span><br><span class="line">    <span class="comment">// 注意:key = inputMessage, value必须是NSData类型</span></span><br><span class="line">    let inputData = inputMsg.data(using: .utf8)</span><br><span class="line">    filter?.setValue(inputData, forKey: <span class="string">&quot;inputMessage&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3. 获取输出的图片</span></span><br><span class="line">    guard let outImage = filter?.outputImage <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="built_in">UIImage</span>() &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4. 获取高清图片</span></span><br><span class="line">    let hdImage = getHDImage(outImage)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//5. 判断是否有前景图片</span></span><br><span class="line">    <span class="keyword">if</span> fgImage == <span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hdImage</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//6. 获取有前景图片的二维码</span></span><br><span class="line">    <span class="keyword">return</span> getResultImage(hdImage: hdImage, fgImage: fgImage!)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="获取高清图片"><a href="#获取高清图片" class="headerlink" title="获取高清图片"></a>获取高清图片</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//4. 获取高清图片</span></span><br><span class="line">fileprivate func getHDImage(_ outImage: <span class="built_in">CIImage</span>) -&gt; <span class="built_in">UIImage</span> &#123;</span><br><span class="line">    let transform = <span class="built_in">CGAffineTransform</span>(scaleX: <span class="number">10</span>, y: <span class="number">10</span>)</span><br><span class="line">    <span class="comment">//放大图片</span></span><br><span class="line">    let ciImage = outImage.transformed(by: transform)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">UIImage</span>(ciImage: ciImage)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="将图片合成到二维码中"><a href="#将图片合成到二维码中" class="headerlink" title="将图片合成到二维码中"></a>将图片合成到二维码中</h3><ul>
<li>需要用到图形上下文</li>
<li>将二维码画到图形上下文</li>
<li>将图片合成到图行上下文</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取前景图片</span></span><br><span class="line">fileprivate func getResultImage(hdImage: <span class="built_in">UIImage</span>, fgImage: <span class="built_in">UIImage</span>) -&gt; <span class="built_in">UIImage</span> &#123;</span><br><span class="line">    let hdSize = hdImage.size</span><br><span class="line">    <span class="comment">//1. 开启图形上下文</span></span><br><span class="line">    <span class="built_in">UIGraphicsBeginImageContext</span>(hdSize)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2. 将高清图片画到上下文</span></span><br><span class="line">    hdImage.draw(<span class="keyword">in</span>: <span class="built_in">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: hdSize.width, height: hdSize.height))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3. 将前景图片画到上下文</span></span><br><span class="line">    let fgWidth: <span class="built_in">CGFloat</span> = <span class="number">80</span></span><br><span class="line">    fgImage.draw(<span class="keyword">in</span>: <span class="built_in">CGRect</span>(x: (hdSize.width - fgWidth) / <span class="number">2</span>, y: (hdSize.height - fgWidth) / <span class="number">2</span>, width: fgWidth, height: fgWidth))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4. 获取上下文</span></span><br><span class="line">    guard let resultImage = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>() <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="built_in">UIImage</span>() &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//5. 关闭上下文</span></span><br><span class="line">    <span class="built_in">UIGraphicsEndImageContext</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> resultImage</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>后续会研究彩色二维码的黑科技, 敬请期待…</p>
</blockquote>
<h2 id="识别二维码"><a href="#识别二维码" class="headerlink" title="识别二维码"></a>识别二维码</h2><blockquote>
<p>识别图片中二维码步骤</p>
</blockquote>
<ul>
<li>创建探测器<ul>
<li>属于CoreImage框架(CIDetector)</li>
</ul>
</li>
<li>获取CIImage类型的图片</li>
<li>获取图片中所有符合特征的内容(CIQRCodeFeature)</li>
<li>遍历所有的特性(CIQRCodeFeature)</li>
<li>获取特征中代表的信息(messageString)</li>
<li>识别二维码的代码实现</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* *  @param qrCodeImage 二维码的图片</span></span><br><span class="line"><span class="comment">   *  @return 结果的数组 */</span></span><br><span class="line">func recognitionQRCode(qrCodeImage: <span class="built_in">UIImage</span>) -&gt; [String]? &#123;</span><br><span class="line">    <span class="comment">//1. 创建过滤器</span></span><br><span class="line">    let detector = <span class="built_in">CIDetector</span>(ofType: <span class="built_in">CIDetectorTypeQRCode</span>, context: <span class="literal">nil</span>, options: <span class="literal">nil</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2. 获取CIImage</span></span><br><span class="line">    guard let ciImage = <span class="built_in">CIImage</span>(image: qrCodeImage) <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3. 识别二维码</span></span><br><span class="line">    guard let features = detector?.features(<span class="keyword">in</span>: ciImage) <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4. 遍历数组, 获取信息</span></span><br><span class="line">    var resultArr = [String]()</span><br><span class="line">    <span class="keyword">for</span> feature <span class="keyword">in</span> features &#123;</span><br><span class="line">        resultArr.append(feature.type)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> resultArr</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="二维码的扫描"><a href="#二维码的扫描" class="headerlink" title="二维码的扫描"></a>二维码的扫描</h2><ul>
<li>创建输入设备(摄像头)<ul>
<li>获取摄像头设备</li>
<li>创建输入对象</li>
</ul>
</li>
<li>创建输出设置(元数据)<ul>
<li>创建输出对象</li>
<li>设置输出对象的代理(在代理中获取扫描到的数据)</li>
<li>设置输出数据的类型</li>
</ul>
</li>
<li>创建捕捉会话<ul>
<li>将输入添加到会话中</li>
<li>将输出添加到会话中</li>
</ul>
</li>
<li>添加预览图片(方便用于查看)<ul>
<li>创建图层,将图片添加到View图层中</li>
</ul>
</li>
<li>开始扫描</li>
</ul>
<h3 id="懒加载输入输出中间会话"><a href="#懒加载输入输出中间会话" class="headerlink" title="懒加载输入输出中间会话"></a>懒加载输入输出中间会话</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输入输出中间桥梁(会话)</span></span><br><span class="line">fileprivate lazy var session : <span class="built_in">AVCaptureSession</span> = <span class="built_in">AVCaptureSession</span>()</span><br></pre></td></tr></table></figure>
<h3 id="初始化扫描设备"><a href="#初始化扫描设备" class="headerlink" title="初始化扫描设备"></a>初始化扫描设备</h3><h4 id="注意-AVCaptureMetadataOutputObjectsDelegate的代理设置-该协议中的方法会将扫描的结果返回"><a href="#注意-AVCaptureMetadataOutputObjectsDelegate的代理设置-该协议中的方法会将扫描的结果返回" class="headerlink" title="注意: AVCaptureMetadataOutputObjectsDelegate的代理设置, 该协议中的方法会将扫描的结果返回"></a>注意: <code>AVCaptureMetadataOutputObjectsDelegate</code>的代理设置, 该协议中的方法会将扫描的结果返回</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">fileprivate func addScaningVideo()&#123;</span><br><span class="line">    <span class="comment">//1.获取输入设备（摄像头）</span></span><br><span class="line">    guard let device = <span class="built_in">AVCaptureDevice</span>.default(<span class="keyword">for</span>: .video) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.根据输入设备创建输入对象</span></span><br><span class="line">    guard let deviceInput = try? <span class="built_in">AVCaptureDeviceInput</span>(device: device) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.创建原数据的输出对象</span></span><br><span class="line">    let metadataOutput = <span class="built_in">AVCaptureMetadataOutput</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4.设置代理监听输出对象输出的数据，在主线程中刷新</span></span><br><span class="line">    metadataOutput.setMetadataObjectsDelegate(<span class="keyword">self</span>, queue: DispatchQueue.main)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//5.创建会话（桥梁）</span></span><br><span class="line">    <span class="comment">//        let session = AVCaptureSession()</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//6.添加输入和输出到会话</span></span><br><span class="line">    <span class="keyword">if</span> session.canAddInput(deviceInput) &#123;</span><br><span class="line">        session.addInput(deviceInput)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> session.canAddOutput(metadataOutput) &#123;</span><br><span class="line">        session.addOutput(metadataOutput)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//7.告诉输出对象要输出什么样的数据(二维码还是条形码),要先创建会话才能设置</span></span><br><span class="line">    metadataOutput.metadataObjectTypes = [.qr, .code128, .code39, .code93, .code39Mod43, .ean8, .ean13, .upce, .pdf417, .aztec]</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//8.创建预览图层</span></span><br><span class="line">    let previewLayer: <span class="built_in">AVCaptureVideoPreviewLayer</span> = <span class="built_in">AVCaptureVideoPreviewLayer</span>(session: session)</span><br><span class="line">    previewLayer.videoGravity = .resizeAspectFill</span><br><span class="line">    previewLayer.frame = view.bounds</span><br><span class="line">    view.layer.insertSublayer(previewLayer, at: <span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//9.设置有效扫描区域(默认整个屏幕区域)（每个取值0~1, 以屏幕右上角为坐标原点）</span></span><br><span class="line">    let rect = <span class="built_in">CGRect</span>(x: scanImageView.frame.minY / kScreenHeight, y: scanImageView.frame.minX / kScreenWidth, width: scanImageView.frame.height / kScreenHeight, height: scanImageView.frame.width / kScreenWidth)</span><br><span class="line">    metadataOutput.rectOfInterest = rect</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//10. 开始扫描</span></span><br><span class="line">    session.startRunning()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="代理方法的实现"><a href="#代理方法的实现" class="headerlink" title="代理方法的实现"></a>代理方法的实现</h4><ul>
<li>需要将扫描的结果转化成机器可读的编码数据,才能获取二维码的相关信息</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">extension ScaningViewController: <span class="built_in">AVCaptureMetadataOutputObjectsDelegate</span> &#123;</span><br><span class="line">    func metadataOutput(_ output: <span class="built_in">AVCaptureMetadataOutput</span>, didOutput metadataObjects: [<span class="built_in">AVMetadataObject</span>], from connection: <span class="built_in">AVCaptureConnection</span>) &#123;</span><br><span class="line">        <span class="comment">//1. 取出扫描到的数据: metadataObjects</span></span><br><span class="line">        <span class="comment">//2. 以震动的形式告知用户扫描成功</span></span><br><span class="line">        AudioServicesPlaySystemSound(SystemSoundID(kSystemSoundID_Vibrate))</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3. 关闭session</span></span><br><span class="line">        session.stopRunning()</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4. 遍历结果</span></span><br><span class="line">        var resultArr = [String]()</span><br><span class="line">        <span class="keyword">for</span> result <span class="keyword">in</span> metadataObjects &#123;</span><br><span class="line">            <span class="comment">//转换成机器可读的编码数据</span></span><br><span class="line">            <span class="keyword">if</span> let code = result as? <span class="built_in">AVMetadataMachineReadableCodeObject</span> &#123;</span><br><span class="line">                resultArr.append(code.stringValue ?? <span class="string">&quot;&quot;</span>)</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                resultArr.append(result.type.rawValue)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5. 将结果</span></span><br><span class="line">        let vc = ShowViewController()</span><br><span class="line">        vc.scanDataArr = resultArr</span><br><span class="line">        navigationController?.pushViewController(vc, animated: <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="项目地址-Github"><a href="#项目地址-Github" class="headerlink" title="项目地址: Github "></a><a href="https://github.com/coderQuanjun/JunQRCode">项目地址: Github </a></h2><ul>
<li>感谢大家的支持</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>Swift框架</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>CIFilter</tag>
        <tag>CIDetector</tag>
        <tag>AVFoundation</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift之微信朋友圈图片浏览器</title>
    <url>/post/441759ef.html</url>
    <content><![CDATA[<blockquote>
<p>最近闲来无事,突然对微信, 微博, QQ等社交APP的九宫格的图片浏览功能非常感兴趣, 最近就尝试着研究了一下:</p>
</blockquote>
<blockquote>
<p>这里先附上<a href="https://github.com/coderQuanjun/JunPhotoBrowseDemo">Demo地址</a></p>
</blockquote>
<span id="more"></span>

<ul>
<li>在介绍项目之前, 先介绍三个基础知识<ul>
<li><code>CATransition</code>转场动画</li>
<li><code>ViewController</code>自定义转场</li>
<li><code>UIBesization</code>贝塞尔曲线</li>
</ul>
</li>
</ul>
<h2 id="CATransition转场动画"><a href="#CATransition转场动画" class="headerlink" title="CATransition转场动画"></a>CATransition转场动画</h2><blockquote>
<p>示例代码</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//4. 转场动画</span></span><br><span class="line">let transition = <span class="built_in">CATransition</span>()</span><br><span class="line">transition.type = transitionType</span><br><span class="line">transition.subtype = isNext ? kCATransitionFromRight : kCATransitionFromLeft</span><br><span class="line">transition.duration = <span class="number">1</span></span><br><span class="line">downloadImage(url: imageURL)</span><br><span class="line">baseImage.layer.add(transition, forKey: <span class="string">&quot;transition&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>更多关于该动画的详细介绍, 可参考<a href="http://www.jianshu.com/p/2b2f49399b7e">iOS出门必备之CoreAnimation(核心动画)</a>中第七种CA动画, 故这里不多做介绍</p>
<h2 id="ViewController自定义转场"><a href="#ViewController自定义转场" class="headerlink" title="ViewController自定义转场"></a><code>ViewController</code>自定义转场</h2><blockquote>
<p>从iOS7开始，苹果更新了自定义ViewController转场的API,会用到的几个协议<code>protocol</code>:</p>
</blockquote>
<ul>
<li>描述ViewController转场的：<ul>
<li><code>UIViewControllerTransitioningDelegate</code></li>
<li><code>UINavigationControllerDelegate</code></li>
<li><code>UITabBarControllerDelegate</code></li>
</ul>
</li>
<li>定义动画内容的<ul>
<li><code>UIViewControllerAnimatedTransitioning</code></li>
<li><code>UIViewControllerInteractiveTransitioning</code></li>
</ul>
</li>
<li>表示动画上下文的<ul>
<li><code>UIViewControllerContextTransitioning</code></li>
</ul>
</li>
</ul>
<h3 id="描述ViewController转场的"><a href="#描述ViewController转场的" class="headerlink" title="描述ViewController转场的"></a>描述ViewController转场的</h3><ul>
<li>为什么苹果要引入这一套API？因为在iOS7之前，做转场动画很麻烦，要写一大堆代码在ViewController中。</li>
<li>引入这一套API之后，在丰富功能的同时极大程度地降低了代码耦合，实现方式就是将之前在ViewController里面的代码通过protocol分离了出来。</li>
<li>顺着这个思路往下想，实现自定义转场动画首先需要找到ViewController的delegate。</li>
<li>苹果告诉我们切换ViewController有三种形式：<ul>
<li><code>UITabBarController</code>内部切换</li>
<li><code>UINavigationController</code>切换</li>
<li><code>present  ViewController</code></li>
<li>这三种方式是不是需要不同的protocol呢？</li>
</ul>
</li>
</ul>
<h3 id="详解Protocol"><a href="#详解Protocol" class="headerlink" title="详解Protocol"></a>详解Protocol</h3><ul>
<li><p><code>UIViewControllerTransitioningDelegate</code> 自定义模态转场动画时使用。</p>
<ul>
<li>设置<code>UIViewController</code>的属性<code>transitioningDelegate</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">weak open var transitioningDelegate: UIViewControllerTransitioningDelegate?</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>UINavigationControllerDelegate</code> 自定义navigation转场动画时使用</p>
<ul>
<li>设置<code>UINavigationController</code>的属性<code>delegate</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">weak open var delegate: UINavigationControllerDelegate?</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>UITabBarControllerDelegate</code>自定义tab转场动画时使用</p>
<ul>
<li>设置<code>UITabBarController</code>的属性<code>delegate</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">weak open var delegate: UITabBarControllerDelegate?</span><br></pre></td></tr></table></figure></li>
</ul>
<p>实际上这三个protocol干的事情是一样的只不过他们的应用场景不同罢了。我们下面以UINavigationControllerDelegate为例，其他的类似</p>
<ul>
<li><code>UINavigationControllerDelegate</code>主要的方法</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">@available(iOS <span class="number">7.0</span>, *)</span><br><span class="line">optional public func navigationController(_ navigationController: <span class="built_in">UINavigationController</span>, interactionControllerFor animationController: <span class="built_in">UIViewControllerAnimatedTransitioning</span>) -&gt; <span class="built_in">UIViewControllerInteractiveTransitioning</span>?</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@available(iOS <span class="number">7.0</span>, *)</span><br><span class="line">optional public func navigationController(_ navigationController: <span class="built_in">UINavigationController</span>, animationControllerFor operation: <span class="built_in">UINavigationControllerOperation</span>, from fromVC: <span class="built_in">UIViewController</span>, to toVC: <span class="built_in">UIViewController</span>) -&gt; <span class="built_in">UIViewControllerAnimatedTransitioning</span>?</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>两个方法分别返回<code>UIViewControllerInteractiveTransitioning</code>和<code>UIViewControllerAnimatedTransitioning</code>，它们的任务是描述动画行为（转场动画如何执行，就看它俩的）。</li>
<li>从名字可以看出，这两个<code>protocol</code>的区别在于是否是<code>interactive</code>的。如何理解？</li>
<li><code>interactive</code>动画可以根据输入信息的变化改变动画的进程。例如iOS系统为<code>UINavigationController</code>提供的默认右滑退出手势就是一个<code>interactive</code> 动画，整个动画的进程由用户手指的移动距离控制</li>
</ul>
<h3 id="UIViewControllerInteractiveTransitioning协议"><a href="#UIViewControllerInteractiveTransitioning协议" class="headerlink" title="UIViewControllerInteractiveTransitioning协议"></a><code>UIViewControllerInteractiveTransitioning</code>协议</h3><blockquote>
<p>定义了两个属性可以做到平滑过渡</p>
</blockquote>
<ul>
<li><code>completionCurve</code>: 交互结束后剩余动画的速率曲线</li>
<li><code>completionSpeed</code>: 交互结束后动画的开始速率由该参数与原来的速率相乘得到，实际上是个缩放参数，这里应该使用单位变化速率(即你要的速率&#x2F;距离)。</li>
<li>注意：<ul>
<li><code>completionSpeed</code>会影响剩余的动画时间，而不是之前设定的转场动画时间剩下的时间；</li>
<li>当<code>completionSpeed</code>很小时剩余的动画时间可能会被拉伸得很长，所以过滤下较低的速率比较好。</li>
<li>如果不设置两个参数，转场动画将以原来的速率曲线在当前进度的速率继续。</li>
<li>不过从实际使用效果来看，往往不到0.5s的动画时间，基本上看不出什么效果来</li>
</ul>
</li>
</ul>
<h3 id="定义动画内容的UIViewControllerAnimatedTransitioning"><a href="#定义动画内容的UIViewControllerAnimatedTransitioning" class="headerlink" title="定义动画内容的UIViewControllerAnimatedTransitioning"></a>定义动画内容的<code>UIViewControllerAnimatedTransitioning</code></h3><ul>
<li>必须实现的方法</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回动画的执行时间</span></span><br><span class="line">public func transitionDuration(using transitionContext: <span class="built_in">UIViewControllerContextTransitioning</span>?) -&gt; TimeInterval</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理具体的动画  </span></span><br><span class="line">public func animateTransition(using transitionContext: <span class="built_in">UIViewControllerContextTransitioning</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="表示动画上下文UIViewControllerContextTransitioning"><a href="#表示动画上下文UIViewControllerContextTransitioning" class="headerlink" title="表示动画上下文UIViewControllerContextTransitioning"></a>表示动画上下文<code>UIViewControllerContextTransitioning</code></h3><ul>
<li><code>UIViewControllerContextTransitioning提供了一系列方法</code></li>
<li>是唯一一个我们不需要实现的Protocol</li>
<li>下面是一些我们常用的属性和方法:</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//转场动画发生在该View中    </span></span><br><span class="line">public var containerView: <span class="built_in">UIView</span> &#123; get &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上报动画执行完毕</span></span><br><span class="line">public func completeTransition(_ didComplete: Bool)</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据key返回一个ViewController。我们通过`FromViewControllerKey`找到将被替换掉的VC，通过`ToViewControllerKey`找到将要显示的VC</span></span><br><span class="line">public func viewController(forKey key: <span class="built_in">UITransitionContextViewControllerKey</span>) -&gt; <span class="built_in">UIViewController</span>?</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据key返回一个view, 我们通过from找到将要消失的view, 根据to找到将要弹出的view</span></span><br><span class="line">@available(iOS <span class="number">8.0</span>, *)</span><br><span class="line">public func view(forKey key: <span class="built_in">UITransitionContextViewKey</span>) -&gt; <span class="built_in">UIView</span>?</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="UIViewControllerTransitioningDelegate自定义模态转场时使用"><a href="#UIViewControllerTransitioningDelegate自定义模态转场时使用" class="headerlink" title="UIViewControllerTransitioningDelegate自定义模态转场时使用"></a><code>UIViewControllerTransitioningDelegate</code>自定义模态转场时使用</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 该方法是告诉系统,弹出动画交给谁来处理</span></span><br><span class="line">func animationController(forPresented presented: <span class="built_in">UIViewController</span>, presenting: <span class="built_in">UIViewController</span>, source: <span class="built_in">UIViewController</span>) -&gt; <span class="built_in">UIViewControllerAnimatedTransitioning</span>? &#123;</span><br><span class="line">    isPresent = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该方法是告诉系统,消失动画交给谁来处理</span></span><br><span class="line">func animationController(forDismissed dismissed: <span class="built_in">UIViewController</span>) -&gt; <span class="built_in">UIViewControllerAnimatedTransitioning</span>? &#123;</span><br><span class="line">    isPresent = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="图片浏览器项目介绍"><a href="#图片浏览器项目介绍" class="headerlink" title="图片浏览器项目介绍"></a>图片浏览器项目介绍</h2><h3 id="项目结构Alamofire-MVVM"><a href="#项目结构Alamofire-MVVM" class="headerlink" title="项目结构Alamofire + MVVM"></a>项目结构<code>Alamofire + MVVM</code></h3><p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-20b3afa03d389bb7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt="框架结构"></p>
<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-a54d1b9e6d553950.gif?imageMogr2/auto-orient/strip" alt="图片浏览器.gif"></p>
<h3 id="自定义ViewController的弹出和消失动画"><a href="#自定义ViewController的弹出和消失动画" class="headerlink" title="自定义ViewController的弹出和消失动画"></a>自定义<code>ViewController</code>的弹出和消失动画</h3><h4 id="自定义ViewController弹出和消失的Protocol"><a href="#自定义ViewController弹出和消失的Protocol" class="headerlink" title="自定义ViewController弹出和消失的Protocol"></a>自定义<code>ViewController</code>弹出和消失的Protocol</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//MARK: 自定义协议</span></span><br><span class="line">protocol JunBrowsePresentDelefate: <span class="built_in">NSObjectProtocol</span> &#123;</span><br><span class="line">    <span class="comment">/// 1. 提供弹出的imageView</span></span><br><span class="line">    func imageForPresent(indexPath: IndexPath) -&gt; <span class="built_in">UIImageView</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 2. 提供弹出的imageView的frame</span></span><br><span class="line">    func startImageRectForpresent(indexPath: IndexPath) -&gt; <span class="built_in">CGRect</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 3.提供弹出后imageView的frame</span></span><br><span class="line">    func endImageRectForpresent(indexPath: IndexPath) -&gt; <span class="built_in">CGRect</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protocol JunBrowserDismissDelegate &#123;</span><br><span class="line">    <span class="comment">/// 1.提供推出的imageView</span></span><br><span class="line">    func imageViewForDismiss() -&gt; <span class="built_in">UIImageView</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 2. 提供推出的indexPath</span></span><br><span class="line">    func indexPathForDismiss() -&gt; IndexPath</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="遵循协议"><a href="#遵循协议" class="headerlink" title="遵循协议"></a>遵循协议</h3><ul>
<li><code>UIViewControllerTransitioningDelegate</code>告诉系统弹出&#x2F;消失动画的处理页面</li>
<li><code>UIViewControllerAnimatedTransitioning</code><ul>
<li>需要返回动画的执行时间</li>
<li>需要在弹出和消失页面的时候分别执行不同的动画</li>
</ul>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//MARK: UIViewControllerTransitioningDelegate</span></span><br><span class="line">extension PhotoBrowseAnimation: <span class="built_in">UIViewControllerTransitioningDelegate</span> &#123;</span><br><span class="line">    <span class="comment">// 该方法是告诉系统,弹出动画交给谁来处理</span></span><br><span class="line">    func animationController(forPresented presented: <span class="built_in">UIViewController</span>, presenting: <span class="built_in">UIViewController</span>, source: <span class="built_in">UIViewController</span>) -&gt; <span class="built_in">UIViewControllerAnimatedTransitioning</span>? &#123;</span><br><span class="line">        isPresent = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该方法是告诉系统,消失动画交给谁来处理</span></span><br><span class="line">    func animationController(forDismissed dismissed: <span class="built_in">UIViewController</span>) -&gt; <span class="built_in">UIViewControllerAnimatedTransitioning</span>? &#123;</span><br><span class="line">        isPresent = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//MARK: 继承AnimatedTransitioning协议</span></span><br><span class="line">extension PhotoBrowseAnimation: <span class="built_in">UIViewControllerAnimatedTransitioning</span> &#123;</span><br><span class="line">    <span class="comment">//返回动画的执行时间</span></span><br><span class="line">    func transitionDuration(using transitionContext: <span class="built_in">UIViewControllerContextTransitioning</span>?) -&gt; TimeInterval &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.6</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理具体的动画</span></span><br><span class="line">    func animateTransition(using transitionContext: <span class="built_in">UIViewControllerContextTransitioning</span>) &#123;</span><br><span class="line">        isPresent ? presentAnimation(transitionContext) : dismissAnimation(transitionContext)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="图片列表界面"><a href="#图片列表界面" class="headerlink" title="图片列表界面"></a>图片列表界面</h3><h4 id="在点击需要展示的imageView的时候-调用下面的方法"><a href="#在点击需要展示的imageView的时候-调用下面的方法" class="headerlink" title="在点击需要展示的imageView的时候,调用下面的方法"></a>在点击需要展示的imageView的时候,调用下面的方法</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MARK:- 弹出照片浏览器</span></span><br><span class="line">extension JunScrollViewController &#123;</span><br><span class="line">    fileprivate func presentPhotoBrowse(indexPath: IndexPath) &#123;</span><br><span class="line">        <span class="comment">//1. 创建图片浏览器</span></span><br><span class="line">        let photoBrowseVC = BrowseViewController(images: imageVM.imageArray, currentIndexP: indexPath)</span><br><span class="line">        <span class="comment">//2. 设置弹出样式为自定义</span></span><br><span class="line">        photoBrowseVC.modalPresentationStyle = .custom</span><br><span class="line">        <span class="comment">//3. 设置转场动画代理</span></span><br><span class="line">        photoBrowseVC.transitioningDelegate = photoAnimation</span><br><span class="line">        <span class="comment">//4. 设置broseAnimation的属性</span></span><br><span class="line">        photoAnimation.setProperty(indexPath: indexPath, <span class="keyword">self</span>, photoBrowseVC)</span><br><span class="line">        <span class="comment">//5. 弹出图片浏览器</span></span><br><span class="line">        present(photoBrowseVC, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="遵循并实现自定义的协议方法"><a href="#遵循并实现自定义的协议方法" class="headerlink" title="遵循并实现自定义的协议方法"></a>遵循并实现自定义的协议方法</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//MARK: JunBrowsePresentDelefate</span></span><br><span class="line">extension JunScrollViewController: JunBrowsePresentDelefate &#123;</span><br><span class="line">    func imageForPresent(indexPath: IndexPath) -&gt; <span class="built_in">UIImageView</span> &#123;</span><br><span class="line">        let imageV = <span class="built_in">UIImageView</span>()</span><br><span class="line">        imageV.contentMode = .scaleAspectFill</span><br><span class="line">        imageV.clipsToBounds = <span class="literal">true</span></span><br><span class="line">        <span class="comment">//设置图片</span></span><br><span class="line">        imageV.kf.setImage(with: URL(string: imageVM.imageArray[indexPath.item].pic74), placeholder: <span class="built_in">UIImage</span>(named: <span class="string">&quot;coderJun&quot;</span>))</span><br><span class="line">        <span class="keyword">return</span> imageV</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func startImageRectForpresent(indexPath: IndexPath) -&gt; <span class="built_in">CGRect</span> &#123;</span><br><span class="line">        <span class="comment">// 1.取出cell</span></span><br><span class="line">        guard let cell = imageCollection.cellForItem(at: indexPath) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">CGRect</span>(x: imageCollection.bounds.width * <span class="number">0.5</span>, y: kScreenHeight + <span class="number">50</span>, width: <span class="number">0</span>, height: <span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.计算转化为UIWindow上时的frame</span></span><br><span class="line">        <span class="keyword">return</span> imageCollection.convert( cell.frame, to: <span class="built_in">UIApplication</span>.shared.keyWindow)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func endImageRectForpresent(indexPath: IndexPath) -&gt; <span class="built_in">CGRect</span> &#123;</span><br><span class="line">        <span class="comment">//1. 取出对应的image的url</span></span><br><span class="line">        let imageUrl = URL(string: imageVM.imageArray[indexPath.item].pic74)!</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.从缓存中取出image</span></span><br><span class="line">        var image = KingfisherManager.shared.cache.retrieveImageInDiskCache(forKey: imageUrl.absoluteString)</span><br><span class="line">        <span class="keyword">if</span> image == <span class="literal">nil</span> &#123;</span><br><span class="line">            image = <span class="built_in">UIImage</span>(named: <span class="string">&quot;coderJun&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.根据image计算位置</span></span><br><span class="line">        let imageH = kScreenWidth / image!.size.width * image!.size.height</span><br><span class="line">        let y: <span class="built_in">CGFloat</span> = imageH &lt; kScreenHeight ? (kScreenHeight - imageH) / <span class="number">2</span> : <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">CGRect</span>(x: <span class="number">0</span>, y: y, width: kScreenWidth, height: imageH)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="在图片展示界面"><a href="#在图片展示界面" class="headerlink" title="在图片展示界面"></a>在图片展示界面</h3><ul>
<li>遵循并实现相关dismiss协议方法</li>
<li>该协议主要实现viewController返回到该图片对应的<code>IndexPath</code>所在的位置</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//MARK: JunBrowserDismissDelegate</span></span><br><span class="line">extension JunTranstionPhotoController: JunBrowserDismissDelegate&#123;</span><br><span class="line">    func imageViewForDismiss() -&gt; <span class="built_in">UIImageView</span> &#123;</span><br><span class="line">        let imageV = <span class="built_in">UIImageView</span>()</span><br><span class="line">        imageV.contentMode = .scaleAspectFill</span><br><span class="line">        imageV.clipsToBounds = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置图片</span></span><br><span class="line">        imageV.image = baseImage.image</span><br><span class="line">        imageV.frame = baseImage.convert(baseImage.frame, to: <span class="built_in">UIApplication</span>.shared.keyWindow)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> imageV</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func indexPathForDismiss() -&gt; IndexPath &#123;</span><br><span class="line">        <span class="keyword">return</span> IndexPath(item: currentIndex, section: <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="GitHubDemo地址"><a href="#GitHubDemo地址" class="headerlink" title="GitHubDemo地址"></a>GitHub<a href="https://github.com/coderQuanjun/JunPhotoBrowseDemo">Demo地址</a></h3><ul>
<li>注意:  </li>
<li>这里只是列出了主要的核心代码,具体的代码逻辑请参考demo</li>
<li>文中相关介绍有的地方如果有不是很详细或者有更好建议的,欢迎联系小编</li>
</ul>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift基本语法03</title>
    <url>/post/bcf67681.html</url>
    <content><![CDATA[<h2 id="willSet和didSet"><a href="#willSet和didSet" class="headerlink" title="willSet和didSet"></a>willSet和didSet</h2><ul>
<li>属性观察器控制和响应属性的变化，当属性被设置的时候回调用属性观察器，主要有以下几个特点：<ul>
<li>属性改变之前触发willSet方法，属性改变之后触发didSet方法</li>
<li>在给属性添加观察者之前必须要明确申明属性的类型，否则编译器会报错</li>
<li>属性初始化时，willSet和didSet都不会调用，只有在设置属性值时才会调用</li>
<li>当设置的值和原来的值一样时，willSet和didSet也会被调用</li>
<li>willSet有一个newValue参数，didSet有一个oldvalue参数<br>&lt;Excerpt in index | 首页摘要&gt;<span id="more"></span></li>
</ul>
</li>
</ul>
<blockquote>
<p>代码如下</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> age:<span class="type">Int</span> <span class="operator">=</span> <span class="number">18</span>&#123;</span><br><span class="line">    <span class="keyword">didSet</span>&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;didSet   <span class="subst">\(oldValue)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">willSet</span>&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;willSet  <span class="subst">\(newValue)</span>&quot;</span>)</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  age重新赋值并打印     */</span></span><br><span class="line">age <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;   <span class="subst">\(age)</span>&quot;</span>)</span><br><span class="line"><span class="comment">/*输出</span></span><br><span class="line"><span class="comment">willSet 10</span></span><br><span class="line"><span class="comment">didSet  18</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">age <span class="operator">=</span> <span class="number">100</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;   <span class="subst">\(age)</span>&quot;</span>)</span><br><span class="line"><span class="comment">/*输出</span></span><br><span class="line"><span class="comment">willSet 100</span></span><br><span class="line"><span class="comment">didSet  10</span></span><br><span class="line"><span class="comment">100</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">age <span class="operator">=</span> <span class="number">200</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;   <span class="subst">\(age)</span>&quot;</span>)</span><br><span class="line"><span class="comment">/*输出</span></span><br><span class="line"><span class="comment">willSet 200</span></span><br><span class="line"><span class="comment">didSet  100</span></span><br><span class="line"><span class="comment">200</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">age <span class="operator">=</span> <span class="number">18</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;    <span class="subst">\(age)</span>&quot;</span>)</span><br><span class="line"><span class="comment">/*输出</span></span><br><span class="line"><span class="comment">willSet 18</span></span><br><span class="line"><span class="comment">didSet  200</span></span><br><span class="line"><span class="comment">18</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>实例应用</p>
</blockquote>
<ul>
<li>cell内部,模型赋值</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HomeViewCell</span>: <span class="title class_">UICollectionViewCell</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MARK: 控件属性</span></span><br><span class="line">    <span class="keyword">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> albumImageView: <span class="type">UIImageView</span>!</span><br><span class="line">    <span class="keyword">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> liveImageView: <span class="type">UIImageView</span>!</span><br><span class="line">    <span class="keyword">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> nickNameLabel: <span class="type">UILabel</span>!</span><br><span class="line">    <span class="keyword">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> onlinePeopleLabel: <span class="type">UIButton</span>!</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MARK: 定义属性</span></span><br><span class="line">    <span class="keyword">var</span> anchorModel : <span class="type">AnchorModel</span>?&#123;</span><br><span class="line">        <span class="keyword">didSet</span>&#123;</span><br><span class="line">            albumImageView.setImage(anchorModel<span class="operator">!</span>.isEvenIndex <span class="operator">?</span> anchorModel<span class="operator">?</span>.pic74 : anchorModel<span class="operator">?</span>.pic51, <span class="string">&quot;home_pic_default&quot;</span>)</span><br><span class="line">            liveImageView.isHidden <span class="operator">=</span> anchorModel<span class="operator">?</span>.live <span class="operator">==</span> <span class="number">0</span></span><br><span class="line">            nickNameLabel.text <span class="operator">=</span> anchorModel<span class="operator">?</span>.name</span><br><span class="line">            onlinePeopleLabel.setTitle(<span class="string">&quot;<span class="subst">\(anchorModel<span class="operator">?</span>.focus <span class="operator">??</span> <span class="number">0</span>)</span>&quot;</span>, for: .normal)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Swift中的set和get方法"><a href="#Swift中的set和get方法" class="headerlink" title="Swift中的set和get方法"></a>Swift中的set和get方法</h2><ul>
<li>OC中我们常重写set和get方法来改变UI，Swift中重写set和get方法是下面这种。<ul>
<li>先定义一个变量，当调用set方法的时候，系统会有一个newValue，将newVaule赋值给我们定义的变量，然后从get方法里面返回去。</li>
<li>Swift中一般重写比较少</li>
</ul>
</li>
</ul>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个变量</span></span><br><span class="line"><span class="keyword">var</span> _tittle: <span class="type">String</span>?</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> tittle: <span class="type">String</span>?&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">get</span>&#123;</span><br><span class="line">            <span class="keyword">return</span>  _tittle <span class="operator">+</span> <span class="string">&quot;123&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span>&#123;</span><br><span class="line">            _tittle <span class="operator">=</span> newValue <span class="operator">+</span> <span class="string">&quot;789&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h2 id="swift单例"><a href="#swift单例" class="headerlink" title="swift单例"></a>swift单例</h2><ul>
<li>单例模式单例模式是设计模式中最简单的一种，甚至有些模式大师都不称其为模式，称其为一种实现技巧</li>
<li>因为设计模式讲究对象之间的关系的抽象，而单例模式只有自己一个对象</li>
<li>下面看看swift中的几种实现方式：</li>
</ul>
<h3 id="静态常量"><a href="#静态常量" class="headerlink" title="静态常量"></a>静态常量</h3><p>一句话搞定，静态常理。所有地方用到的都是同一个</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingleOne</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//单例</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> shareSingleOne <span class="operator">=</span> <span class="type">SingleOne</span>()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h3 id="dispatch-once"><a href="#dispatch-once" class="headerlink" title="dispatch_once"></a>dispatch_once</h3><p>使用<code>dispatch_once</code>可以保证其中的代码只执行一次</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingleTwo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//单例</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">func</span> <span class="title class_">shareSingleTwo</span>()-&gt;<span class="title class_">SingleTwo</span>&#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">            <span class="keyword">static</span> <span class="keyword">var</span> onceToken : dispatch_once_t <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">static</span> <span class="keyword">var</span> single:<span class="type">SingleTwo</span>?</span><br><span class="line">        &#125;</span><br><span class="line">        dispatch_once(<span class="operator">&amp;</span><span class="type">Singleton</span>.onceToken,&#123;</span><br><span class="line">            <span class="type">Singleton</span>.single<span class="operator">=</span>shareSingleTwo()</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Singleton</span>.single<span class="operator">!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="全局常量"><a href="#全局常量" class="headerlink" title="全局常量"></a>全局常量</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局的常量</span></span><br><span class="line"><span class="keyword">let</span> single <span class="operator">=</span> <span class="type">SingleThree</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleThree</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">var</span> <span class="title class_">sharedInstance</span> : <span class="title class_">SingleThree</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> single</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="静态常量-1"><a href="#静态常量-1" class="headerlink" title="静态常量"></a>静态常量</h3><p>在方法内定义静态常量</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingleFour</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> sharedInstance : <span class="type">SingleFour</span> &#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">Static</span> &#123;</span><br><span class="line">            <span class="keyword">static</span> <span class="keyword">let</span> instance : <span class="type">SingleFour</span> <span class="operator">=</span> <span class="type">SingleFour</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Static</span>.instance</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift开发之3DTouch实用演练</title>
    <url>/post/cedeaa9d.html</url>
    <content><![CDATA[<blockquote>
<p>2015年，苹果发布了iOS9以及<code>iphone6s/iphone6s Plus</code>，其中最具有创新的就是新的触控方式3D Touch,相对于多点触摸在平面二维空间的操作，3D Touch技术增加了对力度和手指面积的感知，可以通过长按快速预览、查看你想要的短信、图片或者超链接等内容，Peek和Pop手势的响应时间可迅捷到 10ms和15ms等。</p>
</blockquote>
<span id="more"></span>

<ul>
<li>用户现在可以按主屏幕图标立即访问应用程序提供的功能。</li>
<li>在您的应用程序中，用户现在可以按视图来查看其他内容的预览，并获得对功能的加速访问</li>
<li>在日常开发中,我们经常需要使用3D Touch中的两个功能<ul>
<li>在主屏幕上对应用图标使用3DTouch操作</li>
<li>在应用程序内对某一控件使用3DTouch操作</li>
</ul>
</li>
<li>功能需要iOS9以上系统和<code>iphone6s/iphone6s Plus</code>及以上机型(模拟机现在也是可以的)</li>
<li><a href="https://github.com/coderQuanjun/DouYuTV">demo地址</a></li>
</ul>
<h2 id="效果演练"><a href="#效果演练" class="headerlink" title="效果演练"></a>效果演练</h2><h3 id="主屏幕快速操作"><a href="#主屏幕快速操作" class="headerlink" title="主屏幕快速操作"></a>主屏幕快速操作</h3><ul>
<li>通过按下iPhone 6s或iPhone 6s Plus上的应用程序图标，用户可以获得一组快速操作。</li>
<li>当用户选择快速操作时，您的应用程序激活或启动，并跳转到相应界面<br><img data-src="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/Adopting3DTouchOniPhone/Art/maps_directions_home_2x.png" alt="主屏幕快速操作"></li>
</ul>
<h3 id="Peek-and-Pop"><a href="#Peek-and-Pop" class="headerlink" title="Peek and Pop"></a>Peek and Pop</h3><blockquote>
<ul>
<li>对界面内某一控件的3DTouch操作</li>
<li>Peek和Pop是应用内的一种全新交互模式,当用户不断增加力量在控件上按压,会依次进入四个阶段</li>
</ul>
</blockquote>
<ul>
<li>轻按控件,除触发Peek的控件外,其他区域全部虚化</li>
<li>继续用力Peek被触发,展示Pop界面快照</li>
<li>向上滑动展示快捷选项</li>
<li>继续用力跳转进入Pop界面</li>
</ul>
<p><img data-src="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/Adopting3DTouchOniPhone/Art/preview_available_2_2x.png" alt="轻按控件,除触发Peek的控件外,其他区域全部虚化"></p>
<p><img data-src="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/Adopting3DTouchOniPhone/Art/peek_2x.png" alt="继续用力Peek被触发,展示Pop界面快照"></p>
<p><img data-src="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/Adopting3DTouchOniPhone/Art/peek_quick_actions_2x.png" alt="向上滑动展示快捷选项"></p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul>
<li>3D Touch仅在3D Touch设备上可用，如果启用。在iOS 9以上，默认情况下启用3D Touch。</li>
<li>用户可以在设置&gt;常规&gt;辅助功能&gt; 3D触摸中关闭3D触摸。</li>
<li>当3D Touch可用时，利用其功能。当它不可用时，提供替代方法，例如通过使用触摸和保持。</li>
<li>3D Touch功能支持VoiceOver。</li>
</ul>
<h2 id="主屏幕操作"><a href="#主屏幕操作" class="headerlink" title="主屏幕操作"></a>主屏幕操作</h2><ul>
<li><code>ShortcutItem</code>功能允许用户在主屏幕上对应用图标使用<code>3DTouch</code>操作,如果本次操作有效,则会给出几个快捷可选项允许用户进行操作</li>
<li>主屏幕icon上的快捷标签的实现方式有两种，一种是在工程文件info.plist里静态设置，另一种是代码的动态实现</li>
<li>优先显示静态添加，总数达到4个不再显示</li>
</ul>
<h3 id="静态设置"><a href="#静态设置" class="headerlink" title="静态设置"></a>静态设置</h3><ul>
<li>在info.plist中添加<code>UIApplicationShortcutItems</code>关键字,以如下方式配置即可</li>
</ul>
<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-e90081ad823f9859.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="UIApplicationShortcutItems配置"></p>
<blockquote>
<p>其中各个关键字释义如下:</p>
</blockquote>
<ul>
<li><code>UIApplicationShortcutItemType</code>: 快捷可选项的特定字符串(必填)</li>
<li><code>UIApplicationShortcutItemTitle</code>: 快捷可选项的标题(必填)</li>
<li><code>UIApplicationShortcutItemSubtitle</code>: 快捷可选项的子标题(可选)</li>
<li><code>UIApplicationShortcutItemIconType</code>: 快捷可选项的图标(可选)</li>
<li><code>UIApplicationShortcutItemIconFile</code>: 快捷可选项的自定义图标(可选)</li>
<li><code>UIApplicationShortcutItemUserInfo</code>: 快捷可选项的附加信息(可选)</li>
</ul>
<h3 id="动态添加UIApplicationShortcutItem"><a href="#动态添加UIApplicationShortcutItem" class="headerlink" title="动态添加UIApplicationShortcutItem"></a>动态添加<code>UIApplicationShortcutItem</code></h3><h4 id="UIApplicationShortcutItem初始化方法"><a href="#UIApplicationShortcutItem初始化方法" class="headerlink" title="UIApplicationShortcutItem初始化方法"></a><code>UIApplicationShortcutItem</code>初始化方法</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UIApplicationShortcutItem</span>(type: String, localizedTitle: String, localizedSubtitle: String?, icon: <span class="built_in">UIApplicationShortcutIcon</span>?, userInfo: [AnyHashable : Any]?)</span><br></pre></td></tr></table></figure>
<ul>
<li>参数介绍<ul>
<li><code>type</code>: 快捷可选项的特定字符串(必填)</li>
<li><code>localizedTitle</code>: 快捷可选项的标题(必填)</li>
<li><code>localizedSubtitle</code>: 快捷可选项的子标题(可选)</li>
<li><code>icon</code>: 快捷可选项的图标(可选)</li>
<li><code>userInfo</code>: 快捷可选项的附加信息(可选)</li>
</ul>
</li>
</ul>
<h4 id="图标"><a href="#图标" class="headerlink" title="图标"></a>图标</h4><h5 id="初始化方式"><a href="#初始化方式" class="headerlink" title="初始化方式"></a>初始化方式</h5><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式一: 自定义图标</span></span><br><span class="line"><span class="comment">//注: 自定义图标需要使用镂空图标,同时建议1倍图标大小为35*35</span></span><br><span class="line"><span class="built_in">UIApplicationShortcutIcon</span>(templateImageName: String)</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二: 使用系统图标</span></span><br><span class="line"><span class="built_in">UIApplicationShortcutIcon</span>(type: <span class="built_in">UIApplicationShortcutIconType</span>)</span><br></pre></td></tr></table></figure>
<h5 id="系统图标样式如下"><a href="#系统图标样式如下" class="headerlink" title="系统图标样式如下"></a>系统图标样式如下</h5><p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-50ce942abc9a5174.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="系统图片一览表"></p>
<h4 id="具体实现代码如下"><a href="#具体实现代码如下" class="headerlink" title="具体实现代码如下"></a>具体实现代码如下</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">func application(_ application: <span class="built_in">UIApplication</span>, didFinishLaunchingWithOptions launchOptions: [<span class="built_in">UIApplicationLaunchOptionsKey</span>: Any]?) -&gt; Bool &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3D Touch</span></span><br><span class="line">    let homeIcon = <span class="built_in">UIApplicationShortcutIcon</span>(type: .compose)</span><br><span class="line">    let homeItem = <span class="built_in">UIApplicationShortcutItem</span>(type: <span class="string">&quot;homeAnchor&quot;</span>, localizedTitle: <span class="string">&quot;首页&quot;</span>, localizedSubtitle: <span class="string">&quot;点击进入首页&quot;</span>, icon: homeIcon, userInfo: <span class="literal">nil</span>)</span><br><span class="line">    let playIcon = <span class="built_in">UIApplicationShortcutIcon</span>(type: .play)</span><br><span class="line">    let playItem = <span class="built_in">UIApplicationShortcutItem</span>(type: <span class="string">&quot;play&quot;</span>, localizedTitle: <span class="string">&quot;播放&quot;</span>, localizedSubtitle: <span class="string">&quot;&quot;</span>, icon: playIcon, userInfo: <span class="literal">nil</span>)</span><br><span class="line">    let userIcon = <span class="built_in">UIApplicationShortcutIcon</span>(type: .search)</span><br><span class="line">    let userItem = <span class="built_in">UIApplicationShortcutItem</span>(type: <span class="string">&quot;username&quot;</span>, localizedTitle: <span class="string">&quot;用户名&quot;</span>, localizedSubtitle: <span class="string">&quot;&quot;</span>, icon: userIcon, userInfo: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UIApplication</span>.shared.shortcutItems = [homeItem, playItem, userItem]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="item点击跳转"><a href="#item点击跳转" class="headerlink" title="item点击跳转"></a>item点击跳转</h4><ul>
<li>可根据<code>type</code>标识判断</li>
<li>可根据<code>localizedTitle</code>标识判断</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//菜单跳转</span></span><br><span class="line">func application(_ application: <span class="built_in">UIApplication</span>, performActionFor shortcutItem: <span class="built_in">UIApplicationShortcutItem</span>, completionHandler: @escaping (Bool) -&gt; Void) &#123;</span><br><span class="line">    guard let tabBarVC = window?.rootViewController as? MainViewController <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据type唯一标识进行判断跳转, 或者根据localizedTitle判断</span></span><br><span class="line">    <span class="keyword">switch</span> shortcutItem.type &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;homeAnchor&quot;</span>:</span><br><span class="line">        tabBarVC.selectedIndex = <span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;play&quot;</span>:</span><br><span class="line">        let username = ShowRoomViewController()</span><br><span class="line">        username.hidesBottomBarWhenPushed = <span class="literal">true</span></span><br><span class="line">        tabBarVC.selectedViewController?.childViewControllers.first?.present(username, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;username&quot;</span>:</span><br><span class="line">        let username = NameViewController()</span><br><span class="line">        username.hidesBottomBarWhenPushed = <span class="literal">true</span></span><br><span class="line">        tabBarVC.selectedViewController?.childViewControllers.last?.navigationController?.pushViewController(username, animated: <span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        tabBarVC.selectedIndex = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Peek-and-Pop-1"><a href="#Peek-and-Pop-1" class="headerlink" title="Peek and Pop"></a>Peek and Pop</h2><ul>
<li>Peek和Pop是应用内的一种全新交互模式,当用户不断增加力量在控件上按压,会依次进入四个阶段</li>
<li>这里小编将通过ViewController里面的UITableViewCell进行延时功能</li>
</ul>
<hr>
<blockquote>
<p>注意: 在动态添加快捷可选项前,需要用判断是否支持3D Touch功能,以免在不支持的设备上运行程序导致闪退</p>
</blockquote>
<h3 id="判断是否支持3D-Touch功能"><a href="#判断是否支持3D-Touch功能" class="headerlink" title="判断是否支持3D Touch功能"></a>判断是否支持3D Touch功能</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">func tableView(_ tableView: <span class="built_in">UITableView</span>, cellForRowAt indexPath: IndexPath) -&gt; <span class="built_in">UITableViewCell</span> &#123;</span><br><span class="line">    var cell = tableView.dequeueReusableCell(withIdentifier: <span class="string">&quot;cell&quot;</span>)</span><br><span class="line">    let model = happyVM.anchorGroups[indexPath.section].anchors[indexPath.row]</span><br><span class="line">    <span class="keyword">if</span> cell == <span class="literal">nil</span> &#123;</span><br><span class="line">        cell = <span class="built_in">UITableViewCell</span>(style: .default, reuseIdentifier: <span class="string">&quot;cell&quot;</span>)</span><br><span class="line">        cell?.textLabel?.text = model.room_name</span><br><span class="line">        cell?.accessoryType = .disclosureIndicator</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里是添加判断是否支持3D Touch的代码</span></span><br><span class="line">    <span class="keyword">if</span> <span class="meta">#available(iOS 9.0, *) &#123;</span></span><br><span class="line">        <span class="keyword">if</span> traitCollection.forceTouchCapability == .available &#123;</span><br><span class="line">            <span class="comment">//支持3D Touch</span></span><br><span class="line">            <span class="comment">//注册Peek &amp; Pop功能</span></span><br><span class="line">            registerForPreviewing(with: <span class="keyword">self</span>, sourceView: cell!)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cell!</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>检测是否支持3D Touch：UIForceTouchCapability是一个枚举值,取值如下：</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> unknown      <span class="comment">//3D Touch检测失败</span></span><br><span class="line"><span class="keyword">case</span> unavailable <span class="comment">//3D Touch不可用</span></span><br><span class="line"><span class="keyword">case</span> available  <span class="comment">//3D Touch可用</span></span><br></pre></td></tr></table></figure>


<h3 id="给对应view注册3Dtouch事件"><a href="#给对应view注册3Dtouch事件" class="headerlink" title="给对应view注册3Dtouch事件"></a>给对应view注册3Dtouch事件</h3><ul>
<li>在判断支持3Dtouch里面注册</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注册Peek &amp; Pop功能</span></span><br><span class="line"><span class="keyword">self</span>.registerForPreviewing(with: <span class="keyword">self</span>, sourceView: cell!)</span><br></pre></td></tr></table></figure>

<h3 id="遵守UIViewControllerPreviewingDelegate协议"><a href="#遵守UIViewControllerPreviewingDelegate协议" class="headerlink" title="遵守UIViewControllerPreviewingDelegate协议"></a>遵守<code>UIViewControllerPreviewingDelegate</code>协议</h3><ul>
<li>需要实现Peek &amp; Pop交互的控件所在的控制器遵循协议并实现两个代理方法</li>
</ul>
<h4 id="当进入Peek状态时-系统会回调如下方法"><a href="#当进入Peek状态时-系统会回调如下方法" class="headerlink" title="当进入Peek状态时,系统会回调如下方法"></a>当进入Peek状态时,系统会回调如下方法</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">func previewingContext(_ previewingContext: <span class="built_in">UIViewControllerPreviewing</span>, viewControllerForLocation location: <span class="built_in">CGPoint</span>) -&gt; <span class="built_in">UIViewController</span>? &#123;</span><br><span class="line">    <span class="comment">//1. 获取按压的cell所在的行</span></span><br><span class="line">    guard let cell = previewingContext.sourceView as? <span class="built_in">UITableViewCell</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="built_in">UIViewController</span>() &#125;</span><br><span class="line">    let indexPath = tableVIew.indexPath(<span class="keyword">for</span>: cell) ?? IndexPath(row: <span class="number">0</span>, section: <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 设定预览界面</span></span><br><span class="line">    let vc = ShowRoomViewController()</span><br><span class="line">    <span class="comment">// 预览区域大小(可不设置), 0为默认尺寸</span></span><br><span class="line">    vc.preferredContentSize = <span class="built_in">CGSize</span>(width: <span class="number">0</span>, height: <span class="number">0</span>)</span><br><span class="line">    vc.showStr =  <span class="string">&quot;我是第\(indexPath.row)行用力按压进来的&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//调整不被虚化的范围，按压的那个cell不被虚化（轻轻按压时周边会被虚化，再少用力展示预览，再加力跳页至设定界面）</span></span><br><span class="line">    let rect = <span class="built_in">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: kScreenWidth, height: <span class="number">44</span>)</span><br><span class="line">    <span class="comment">//设置触发操作的视图的不被虚化的区域</span></span><br><span class="line">    previewingContext.sourceRect = rect</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回预览界面</span></span><br><span class="line">    <span class="keyword">return</span> vc</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="当进入Pop状态时-系统会回调如下方法"><a href="#当进入Pop状态时-系统会回调如下方法" class="headerlink" title="当进入Pop状态时,系统会回调如下方法"></a>当进入Pop状态时,系统会回调如下方法</h4><ul>
<li>用力按压进入<code>viewControllerToCommit</code></li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">func previewingContext(_ previewingContext: <span class="built_in">UIViewControllerPreviewing</span>, commit viewControllerToCommit: <span class="built_in">UIViewController</span>) &#123;</span><br><span class="line">    viewControllerToCommit.hidesBottomBarWhenPushed = <span class="literal">true</span></span><br><span class="line">    show(viewControllerToCommit, sender: <span class="keyword">self</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>来看看效果</p>
</blockquote>
<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-e093ea0e213ef573.gif?imageMogr2/auto-orient/strip" alt="3D Touch1演示.gif"></p>
<h4 id="当弹出预览时，上滑预览视图，出现预览视图中快捷选项"><a href="#当弹出预览时，上滑预览视图，出现预览视图中快捷选项" class="headerlink" title="当弹出预览时，上滑预览视图，出现预览视图中快捷选项"></a>当弹出预览时，上滑预览视图，出现预览视图中快捷选项</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">var previewActionItems: [<span class="built_in">UIPreviewActionItem</span>] &#123; get &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>previewActionItems</code>用户在3D Touch预览上向上滑动时显示的快速操作</li>
<li>在将要弹出的页面内重写previewActionItems的get属性</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">extension ShowRoomViewController &#123;</span><br><span class="line">    <span class="comment">//重写previewActionItems的get方法</span></span><br><span class="line">    override var previewActionItems: [<span class="built_in">UIPreviewActionItem</span>] &#123;</span><br><span class="line">        let action1 = <span class="built_in">UIPreviewAction</span>(title: <span class="string">&quot;跳转&quot;</span>, style: .default) &#123; (action, previewViewController) <span class="keyword">in</span></span><br><span class="line">            let showVC = ShowRoomViewController()</span><br><span class="line">            showVC.hidesBottomBarWhenPushed = <span class="literal">true</span></span><br><span class="line">            previewViewController.navigationController?.pushViewController(showVC, animated: <span class="literal">true</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        let action3 = <span class="built_in">UIPreviewAction</span>(title: <span class="string">&quot;取消&quot;</span>, style: .destructive) &#123; (action, previewViewController) <span class="keyword">in</span></span><br><span class="line">            print(<span class="string">&quot;我是取消按钮&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">////该按钮可以是一个组，点击该组时，跳到组里面的按钮。</span></span><br><span class="line">        let subAction1 = <span class="built_in">UIPreviewAction</span>(title: <span class="string">&quot;测试1&quot;</span>, style: .selected) &#123; (action, previewViewController) <span class="keyword">in</span></span><br><span class="line">            print(<span class="string">&quot;我是测试按钮1&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        let subAction2 = <span class="built_in">UIPreviewAction</span>(title: <span class="string">&quot;测试2&quot;</span>, style: .selected) &#123; (action, previewViewController) <span class="keyword">in</span></span><br><span class="line">            print(<span class="string">&quot;我是测试按钮2&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        let subAction3 = <span class="built_in">UIPreviewAction</span>(title: <span class="string">&quot;测试3&quot;</span>, style: .selected) &#123; (action, previewViewController) <span class="keyword">in</span></span><br><span class="line">            print(<span class="string">&quot;我是测试按钮3&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        let groupAction = <span class="built_in">UIPreviewActionGroup</span>(title: <span class="string">&quot;更多&quot;</span>, style: .default, actions: [subAction1, subAction2, subAction3])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [action1, action3, groupAction]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>action的各种样式</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">enum</span> <span class="built_in">UIPreviewActionStyle</span> : Int &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认样式</span></span><br><span class="line">    <span class="keyword">case</span> `<span class="keyword">default</span>`</span><br><span class="line">    <span class="comment">//右侧有对勾的样式</span></span><br><span class="line">    <span class="keyword">case</span> selected</span><br><span class="line">    <span class="comment">//红色字体的样式</span></span><br><span class="line">    <span class="keyword">case</span> destructive</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="force-和-maximumPossibleForce"><a href="#force-和-maximumPossibleForce" class="headerlink" title="force 和 maximumPossibleForce"></a><code>force</code> 和 <code>maximumPossibleForce</code></h4><blockquote>
<p>到此，3DTouch在APP中的集成就先介绍这些，3DTouch中还有个重要的属性–压力属性（force 和 maximumPossibleForce）这里简单介绍下</p>
</blockquote>
<ul>
<li>手指在屏幕上慢慢增加力度在减少力度，可以看到view背景色的变化</li>
<li>程序运行后找到<code>我的</code> -&gt; <code>头像(用户名)</code>查看效果</li>
<li>代码找到<code>NameViewController.swift</code>查看</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">override func touchesMoved(_ touches: Set&lt;<span class="built_in">UITouch</span>&gt;, with event: <span class="built_in">UIEvent</span>?) &#123;</span><br><span class="line">    let touch = touches.first ?? <span class="built_in">UITouch</span>()</span><br><span class="line">    <span class="comment">//获取重按力度</span></span><br><span class="line">    print(<span class="string">&quot;平均触摸的力--\(touch.force)&quot;</span>)</span><br><span class="line">    print(<span class="string">&quot;触摸的最大可能力--\(touch.maximumPossibleForce)&quot;</span>)</span><br><span class="line"></span><br><span class="line">    let change = touch.force / touch.maximumPossibleForce</span><br><span class="line">        view.backgroundColor = <span class="built_in">UIColor</span>(red: <span class="number">0.5</span>, green: <span class="number">0.5</span>, blue: change, alpha: <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>此外还有以下属性, 详细可参考<a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/Adopting3DTouchOniPhone/3DTouchAPIs.html#//apple_ref/doc/uid/TP40016543-CH4-SW1">3D Touch官方文档</a></p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">var tapCount: Int</span><br><span class="line"><span class="comment">//手指触摸此次触摸的次数。</span></span><br><span class="line"></span><br><span class="line">var timestamp: TimeInterval</span><br><span class="line"><span class="comment">//触摸发生的时间或最后一次突变的时间。</span></span><br><span class="line"></span><br><span class="line">var type: <span class="built_in">UITouchType</span></span><br><span class="line"><span class="comment">//触摸的类型。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="built_in">UITouchType</span></span><br><span class="line"><span class="comment">//接收的触摸类型。</span></span><br><span class="line"></span><br><span class="line">var phase: <span class="built_in">UITouchPhase</span></span><br><span class="line"><span class="comment">//触摸的阶段。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="built_in">UITouchPhase</span></span><br><span class="line"><span class="comment">//手指触摸的阶段。</span></span><br><span class="line"></span><br><span class="line">var maximumPossibleForce: <span class="built_in">CGFloat</span></span><br><span class="line"><span class="comment">//触摸的最大可能力。</span></span><br><span class="line"></span><br><span class="line">var force: <span class="built_in">CGFloat</span></span><br><span class="line"><span class="comment">//触摸力，其中值表示平均触摸的力（由系统预定，不是用户特定的）。1.0</span></span><br><span class="line"></span><br><span class="line">var altitudeAngle: <span class="built_in">CGFloat</span></span><br><span class="line"><span class="comment">//手写笔的高度（弧度）。</span></span><br><span class="line"></span><br><span class="line">func azimuthAngle(<span class="keyword">in</span>: <span class="built_in">UIView</span>?)</span><br><span class="line"><span class="comment">//返回触控笔的方位角（弧度）。</span></span><br><span class="line"></span><br><span class="line">func azimuthUnitVector(<span class="keyword">in</span>: <span class="built_in">UIView</span>?)</span><br><span class="line"><span class="comment">//返回指向触控笔方位角方向的单位向量。</span></span><br></pre></td></tr></table></figure>

<h3 id="最后附上Demo地址"><a href="#最后附上Demo地址" class="headerlink" title="最后附上Demo地址"></a>最后附上<a href="https://github.com/coderQuanjun/DouYuTV">Demo地址</a></h3><hr>
<blockquote>
<p>参考资料</p>
</blockquote>
<p><a href="http://liuyanwei.jumppo.com/2016/04/01/iOS-3DTouch-2.html">iOS 3D touch开发 </a></p>
<p><a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/Adopting3DTouchOniPhone/3DTouchAPIs.html#//apple_ref/doc/uid/TP40016543-CH4-SW1">3D Touch官方文档</a></p>
]]></content>
      <categories>
        <category>Swift框架</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift基本语法02</title>
    <url>/post/cbf14617.html</url>
    <content><![CDATA[<blockquote>
<p>上一篇介绍了Swift的常量&#x2F;变量和循环,详情见: <a href="https://www.titanjun.top/categories/Swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">Swift语法</a></p>
</blockquote>
<span id="more"></span>

<h2 id="字符串的介绍"><a href="#字符串的介绍" class="headerlink" title="字符串的介绍"></a>字符串的介绍</h2><ul>
<li>字符串在任何的开发中使用都是非常频繁的<ul>
<li>OC和Swift中字符串的区别<ul>
<li>在OC中字符串类型时NSString,在Swift中字符串类型是String</li>
<li>OC中字符串@””,Swift中字符串””</li>
</ul>
</li>
<li>使用 String 的原因<ul>
<li>String 是一个结构体，性能更高</li>
<li>NSString 是一个 OC 对象，性能略差</li>
<li>String 支持直接遍历</li>
<li>Swift 提供了 String 和 NSString 之间的无缝转换</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1&gt; 定义不可变字符串 : 使用let修饰</span></span><br><span class="line"><span class="comment">// let str : String = &quot;hello swift&quot;</span></span><br><span class="line"><span class="keyword">let</span> str <span class="operator">=</span> <span class="string">&quot;Hello Swift&quot;</span></span><br><span class="line"><span class="comment">// str = &quot;hello Objective-C&quot;</span></span><br><span class="line"><span class="comment">// 2&gt; 定义可变字符串 : 使用var修饰</span></span><br><span class="line"><span class="keyword">var</span> strM <span class="operator">=</span> <span class="string">&quot;Hello World&quot;</span></span><br><span class="line">strM <span class="operator">=</span> <span class="string">&quot;Hello China&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="字符串的使用"><a href="#字符串的使用" class="headerlink" title="字符串的使用"></a>字符串的使用</h2><ul>
<li>获取字符串的长度<ul>
<li>获取字符集合,再获取集合的count属性</li>
</ul>
</li>
</ul>
<blockquote>
<p>let length &#x3D; str.characters.count</p>
</blockquote>
<h3 id="字符串的拼接"><a href="#字符串的拼接" class="headerlink" title="字符串的拼接"></a>字符串的拼接</h3><p>两个字符串的拼接</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str1 <span class="operator">=</span> <span class="string">&quot;字符串&quot;</span></span><br><span class="line"><span class="keyword">let</span> str2 <span class="operator">=</span> <span class="string">&quot;拼接&quot;</span></span><br><span class="line"><span class="comment">// OC拼接方式 NSString stringwithFormat:@&quot;%@%@&quot;, str1, str2</span></span><br><span class="line"><span class="keyword">let</span> str3 <span class="operator">=</span> str1 <span class="operator">+</span> str2</span><br></pre></td></tr></table></figure>

<ul>
<li>字符串和其他数据类型的拼接</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name <span class="operator">=</span> <span class="string">&quot;tqj&quot;</span></span><br><span class="line"><span class="keyword">let</span> age <span class="operator">=</span> <span class="number">19</span></span><br><span class="line"><span class="keyword">let</span> height <span class="operator">=</span> <span class="number">1.87</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> infoStr <span class="operator">=</span> <span class="string">&quot;my nams is <span class="subst">\(name)</span>, age is <span class="subst">\(age)</span>, height is <span class="subst">\(height)</span>&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>字符串的格式化::比如时间:01:02</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> min <span class="operator">=</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> second <span class="operator">=</span> <span class="number">4</span></span><br><span class="line"><span class="keyword">let</span> timeStr <span class="operator">=</span> <span class="type">String</span>(format: <span class="string">&quot;%02d:%02d&quot;</span>, min, second)</span><br></pre></td></tr></table></figure>

<h3 id="字符串的判断"><a href="#字符串的判断" class="headerlink" title="字符串的判断"></a>字符串的判断</h3><p>判断字符串是否为空</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str <span class="operator">=</span> <span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="comment">//输出false</span></span><br><span class="line"><span class="built_in">print</span>(str.isEmpty)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="comment">//输出为true</span></span><br><span class="line"><span class="built_in">print</span>(str.isEmpty)</span><br></pre></td></tr></table></figure>

<p>其他判断和操作(Swift3.0特性)</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断是否包含某字符</span></span><br><span class="line"><span class="keyword">let</span> str <span class="operator">=</span> <span class="string">&quot;Hello, playground&quot;</span></span><br><span class="line"><span class="keyword">let</span> is1 <span class="operator">=</span> str.contains(<span class="string">&quot;ell&quot;</span>)</span><br><span class="line"><span class="comment">//输出true</span></span><br><span class="line"><span class="built_in">print</span>(is1)</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定字符串的替换</span></span><br><span class="line"><span class="keyword">let</span> str2 <span class="operator">=</span> str.replacingOccurrences(of: <span class="string">&quot;Hello&quot;</span>, with: <span class="string">&quot;HELLO&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(str2)   </span><br><span class="line"><span class="comment">//输出HELLO, playground</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//转为大写</span></span><br><span class="line"><span class="keyword">let</span> s1 <span class="operator">=</span> str.localizedUppercase</span><br><span class="line"><span class="comment">//转为小写</span></span><br><span class="line"><span class="keyword">let</span> s2 <span class="operator">=</span> str.localizedLowercase</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="字符串的截取"><a href="#字符串的截取" class="headerlink" title="字符串的截取"></a>字符串的截取</h3><ul>
<li>Swift中提供了特殊的截取方式<ul>
<li>该方式非常麻烦</li>
<li>Index创建较为麻烦</li>
</ul>
</li>
<li>简单的方式是将String转成NSString来使用<ul>
<li>在标识符后加:as NSString即可</li>
</ul>
</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> urlString <span class="operator">=</span> <span class="string">&quot;www.titanjun.top&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.1.方式一:</span></span><br><span class="line"><span class="comment">// 将String类型转成NSString类型,再进行截取: as NSString</span></span><br><span class="line"><span class="keyword">let</span> header1 <span class="operator">=</span> (urlString <span class="keyword">as</span> <span class="type">NSString</span>).substring(to: <span class="number">3</span>)</span><br><span class="line"><span class="keyword">let</span> range1 <span class="operator">=</span> <span class="type">NSMakeRange</span>(<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">let</span> middle1 <span class="operator">=</span> (urlString <span class="keyword">as</span> <span class="type">NSString</span>).substring(with: range1)</span><br><span class="line"><span class="keyword">let</span> footer1 <span class="operator">=</span> (urlString <span class="keyword">as</span> <span class="type">NSString</span>).substring(from: <span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p>swift截取方式</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 4.2.方式二:</span></span><br><span class="line"><span class="keyword">let</span> headerIndex <span class="operator">=</span> urlString.index(urlString.startIndex, offsetBy: <span class="number">3</span>)</span><br><span class="line"><span class="keyword">let</span> header2 <span class="operator">=</span> urlString.substring(to: headerIndex)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> startIndex <span class="operator">=</span> urlString.index(urlString.startIndex, offsetBy: <span class="number">4</span>)</span><br><span class="line"><span class="keyword">let</span> endIndex <span class="operator">=</span> urlString.index(urlString.startIndex, offsetBy: <span class="number">9</span>)</span><br><span class="line"><span class="keyword">let</span> range <span class="operator">=</span> <span class="type">Range</span>(startIndex<span class="operator">..&lt;</span>endIndex)</span><br><span class="line"><span class="keyword">let</span> middle2 <span class="operator">=</span> urlString.substring(with: range)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> footerIndex <span class="operator">=</span> urlString.index(urlString.endIndex, offsetBy: <span class="operator">-</span><span class="number">3</span>)</span><br><span class="line"><span class="keyword">let</span> footer2 <span class="operator">=</span> urlString.substring(from: footerIndex)</span><br></pre></td></tr></table></figure>

<h3 id="drop方式截取"><a href="#drop方式截取" class="headerlink" title="drop方式截取"></a>drop方式截取</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取截取之后的字符串</span></span><br><span class="line"><span class="keyword">let</span> path <span class="operator">=</span> <span class="string">&quot;https://www.titanjun.top&quot;</span></span><br><span class="line"><span class="keyword">let</span> str1 <span class="operator">=</span> path.dropFirst()</span><br><span class="line"><span class="comment">// ttps://www.titanjun.top</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str2 <span class="operator">=</span> path.dropLast()</span><br><span class="line"><span class="comment">// https://www.titanjun.to</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str3 <span class="operator">=</span> path.dropFirst(<span class="number">5</span>)</span><br><span class="line"><span class="comment">// ://www.titanjun.top</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str4 <span class="operator">=</span> path.dropLast(<span class="number">3</span>)</span><br><span class="line"><span class="comment">// https://www.titanjun.</span></span><br></pre></td></tr></table></figure>


<h2 id="数组的使用"><a href="#数组的使用" class="headerlink" title="数组的使用"></a>数组的使用</h2><h3 id="数组的介绍"><a href="#数组的介绍" class="headerlink" title="数组的介绍"></a>数组的介绍</h3><ul>
<li>数组（Array）是一串有序的由相同类型元素构成的集合<ul>
<li>数组中的集合元素是有序的，可以重复出现</li>
<li>Swift中的数组<ul>
<li>swift数组类型是Array，是一个泛型集合</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="数组的初始化"><a href="#数组的初始化" class="headerlink" title="数组的初始化"></a>数组的初始化</h3><ul>
<li>数组分成:可变数组和不可变数组<ul>
<li>使用let修饰的数组是不可变数组</li>
<li>使用var修饰的数组是可变数组</li>
</ul>
</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1&gt; 定义不可变数组</span></span><br><span class="line"><span class="keyword">let</span> array : [<span class="keyword">Any</span>] <span class="operator">=</span> [<span class="string">&quot;why&quot;</span>, <span class="number">18</span>, <span class="number">1.88</span>]</span><br><span class="line"><span class="comment">// 2&gt; 定义可变数组: 使用var修饰</span></span><br><span class="line"><span class="keyword">var</span> arrayM <span class="operator">=</span> [<span class="keyword">Any</span>]()</span><br></pre></td></tr></table></figure>

<h3 id="对数组的基本操作"><a href="#对数组的基本操作" class="headerlink" title="对数组的基本操作"></a>对数组的基本操作</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 增删改查</span></span><br><span class="line"><span class="comment">// 2.1.添加元素</span></span><br><span class="line">arrayM.append(<span class="string">&quot;why&quot;</span>)</span><br><span class="line"><span class="comment">// 2.2.删除元素</span></span><br><span class="line">arrayM.remove(at: <span class="number">0</span>)</span><br><span class="line"><span class="comment">// 2.3.修改元素</span></span><br><span class="line">arrayM[<span class="number">0</span>] <span class="operator">=</span> <span class="string">&quot;yz&quot;</span></span><br><span class="line"><span class="comment">// 2.4.获取元素</span></span><br><span class="line"><span class="keyword">let</span> item <span class="operator">=</span> arrayM[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h3 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3.1.获取数组的长度</span></span><br><span class="line"><span class="keyword">let</span> count <span class="operator">=</span> array.count</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.2.对数组进行遍历(可以获取到下标值)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span> count &#123;</span><br><span class="line">    <span class="built_in">print</span>(array[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3.3.对数组进行遍历(设置遍历区间)</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> array &#123;</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3.3.对数组进行遍历(不需要获取下标值)</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> array[<span class="number">0</span><span class="operator">..&lt;</span><span class="number">2</span>] &#123;</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3.5.对数组进行遍历(既获取下标值,又获取元素)</span></span><br><span class="line"><span class="keyword">for</span> (index, item) <span class="keyword">in</span> array.enumerated() &#123;</span><br><span class="line">    <span class="built_in">print</span>(index)</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组的合并"><a href="#数组的合并" class="headerlink" title="数组的合并"></a>数组的合并</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果两个数组中存放的是相同的元素,那么在swift中可以对两个数组进行相加,直接合并</span></span><br><span class="line"><span class="keyword">let</span> array1 <span class="operator">=</span> [<span class="string">&quot;why&quot;</span>, <span class="string">&quot;yz&quot;</span>]</span><br><span class="line"><span class="keyword">let</span> array2 <span class="operator">=</span> [<span class="string">&quot;lmj&quot;</span>, <span class="string">&quot;lnj&quot;</span>]</span><br><span class="line"><span class="keyword">let</span> array3 <span class="operator">=</span> [<span class="number">12</span>, <span class="number">20</span>, <span class="number">30</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> resultArray <span class="operator">=</span> array1 <span class="operator">+</span> array2</span><br><span class="line"><span class="comment">// let result = array1 + array3 错误写法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不建议一个数组中存放多种类型的数据</span></span><br><span class="line"><span class="keyword">var</span> array3 <span class="operator">=</span> [<span class="number">2</span>, <span class="number">3</span>, <span class="string">&quot;why&quot;</span>]</span><br><span class="line"><span class="keyword">var</span> array4 <span class="operator">=</span> [<span class="string">&quot;yz&quot;</span>, <span class="number">23</span>]</span><br><span class="line">array3 <span class="operator">+</span> array4</span><br></pre></td></tr></table></figure>


<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><h3 id="字典的介绍"><a href="#字典的介绍" class="headerlink" title="字典的介绍"></a>字典的介绍</h3><ul>
<li>字典允许按照某个键来访问元素<ul>
<li>字典是由两部分集合构成的，一个是键（key）集合，一个是值（value）集合</li>
<li>键集合是不能有重复元素的，而值集合是可以重复的，键和值是成对出现的</li>
<li>Swift中的字典<ul>
<li>Swift字典类型是Dictionary，也是一个泛型集合</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="字典的初始化"><a href="#字典的初始化" class="headerlink" title="字典的初始化"></a>字典的初始化</h3><ul>
<li>Swift中的可变和不可变字典<ul>
<li>使用let修饰的数组是不可变字典</li>
<li>使用var修饰的数组是可变字典</li>
</ul>
</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个可变字典</span></span><br><span class="line"><span class="keyword">var</span> dict1 : [<span class="type">String</span> : <span class="keyword">Any</span>] <span class="operator">=</span> [<span class="type">String</span> : <span class="keyword">Any</span>]()</span><br><span class="line"><span class="comment">// 定义一个不可变字典</span></span><br><span class="line"><span class="keyword">let</span> dict2 : [<span class="type">String</span> : <span class="keyword">Any</span>] <span class="operator">=</span> [<span class="string">&quot;name&quot;</span> : <span class="string">&quot;why&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">18</span>]</span><br></pre></td></tr></table></figure>

<h3 id="字典的基本使用"><a href="#字典的基本使用" class="headerlink" title="字典的基本使用"></a>字典的基本使用</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2.1.添加元素</span></span><br><span class="line">dictM[<span class="string">&quot;name&quot;</span>] <span class="operator">=</span> <span class="string">&quot;why&quot;</span></span><br><span class="line">dictM[<span class="string">&quot;age&quot;</span>] <span class="operator">=</span> <span class="number">18</span></span><br><span class="line">dictM[<span class="string">&quot;height&quot;</span>] <span class="operator">=</span> <span class="number">1.88</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.2.删除元素</span></span><br><span class="line">dictM.removeValue(forKey: <span class="string">&quot;height&quot;</span>)</span><br><span class="line">dictM</span><br><span class="line"><span class="comment">// 2.3.修改元素</span></span><br><span class="line">dictM[<span class="string">&quot;name&quot;</span>] <span class="operator">=</span> <span class="string">&quot;lmj&quot;</span></span><br><span class="line">dictM.updateValue(<span class="string">&quot;lnj&quot;</span>, forKey: <span class="string">&quot;name&quot;</span>)</span><br><span class="line">dictM</span><br><span class="line"><span class="comment">// 2.4.查找元素</span></span><br><span class="line">dictM[<span class="string">&quot;age&quot;</span>]</span><br></pre></td></tr></table></figure>

<h3 id="字典的遍历"><a href="#字典的遍历" class="headerlink" title="字典的遍历"></a>字典的遍历</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3.1.遍历字典中所有的key</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> dict.keys &#123;</span><br><span class="line">    <span class="built_in">print</span>(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.2.遍历字典中所有的value</span></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> dict.values &#123;</span><br><span class="line">    <span class="built_in">print</span>(value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.3.遍历字典中所有的key/value</span></span><br><span class="line"><span class="keyword">for</span> (key, value) <span class="keyword">in</span> dict &#123;</span><br><span class="line">    <span class="built_in">print</span>(key, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字典的合并"><a href="#字典的合并" class="headerlink" title="字典的合并"></a>字典的合并</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dict1 : [<span class="type">String</span> : <span class="keyword">Any</span>] <span class="operator">=</span> [<span class="string">&quot;name&quot;</span> : <span class="string">&quot;why&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">18</span>]</span><br><span class="line"><span class="keyword">let</span> dict2 : [<span class="type">String</span> : <span class="keyword">Any</span>] <span class="operator">=</span> [<span class="string">&quot;height&quot;</span> : <span class="number">1.88</span>, <span class="string">&quot;phoneNum&quot;</span> : <span class="string">&quot;+86 110&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">//let resultDict = dict1 + dict2字典不可以相加合并，只能遍历</span></span><br><span class="line"><span class="keyword">for</span> (key, value) <span class="keyword">in</span> dict2 &#123;</span><br><span class="line">    dict1[key] <span class="operator">=</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="元组的使用"><a href="#元组的使用" class="headerlink" title="元组的使用"></a>元组的使用</h2><h3 id="元组的介绍"><a href="#元组的介绍" class="headerlink" title="元组的介绍"></a>元组的介绍</h3><ul>
<li>元组是Swift中特有的,OC中并没有相关类型</li>
<li>它是什么呢?<ul>
<li>它是一种数据结构，在数学中应用广泛<br>  类似于数组或者字典</li>
<li>可以用于定义一组数据</li>
<li>组成元组类型的数据可以称为“元素”</li>
</ul>
</li>
</ul>
<h3 id="元组的定义"><a href="#元组的定义" class="headerlink" title="元组的定义"></a>元组的定义</h3><p>元组的常见写法</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3.使用元组保存信息(取出数据时,更加方便)</span></span><br><span class="line"><span class="comment">// 3.1.写法一:</span></span><br><span class="line"><span class="keyword">let</span> infoTuple0 <span class="operator">=</span> (<span class="string">&quot;why&quot;</span>, <span class="number">18</span>, <span class="number">1.88</span>)</span><br><span class="line"><span class="keyword">let</span> tupleName <span class="operator">=</span> infoTuple0.<span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> tupleAge <span class="operator">=</span> infoTuple0.<span class="number">1</span></span><br><span class="line">infoTuple0.<span class="number">0</span></span><br><span class="line">infoTuple0.<span class="number">1</span></span><br><span class="line">infoTuple0.<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.2.写法二:</span></span><br><span class="line"><span class="keyword">let</span> infoTuple1 <span class="operator">=</span> (name : <span class="string">&quot;why&quot;</span>,age : <span class="number">18</span>, height : <span class="number">1.88</span>)</span><br><span class="line">infoTuple1.age</span><br><span class="line">infoTuple1.name</span><br><span class="line">infoTuple1.height</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.3.写法三:</span></span><br><span class="line"><span class="keyword">let</span> (name, age, height) <span class="operator">=</span> (<span class="string">&quot;why&quot;</span>, <span class="number">18</span>, <span class="number">1.88</span>)</span><br><span class="line">name</span><br><span class="line">age</span><br><span class="line">height</span><br></pre></td></tr></table></figure>


<h2 id="可选类型"><a href="#可选类型" class="headerlink" title="可选类型"></a>可选类型</h2><h3 id="可选类型的介绍"><a href="#可选类型的介绍" class="headerlink" title="可选类型的介绍"></a>可选类型的介绍</h3><ul>
<li>注意:<ul>
<li>可选类型时swift中较理解的一个知识点</li>
<li>暂时先了解,多利用Xcode的提示来使用</li>
<li>随着学习的深入,慢慢理解其中的原理和好处</li>
</ul>
</li>
<li>概念:<ul>
<li>在OC开发中,如果一个变量暂停不使用,可以赋值为0(基本属性类型)或者赋值为空(对象类型)</li>
<li>在swift开发中,nil也是一个特殊的类型.因为和真实的类型不匹配是不能赋值的(swift是强类型语言)</li>
<li>但是开发中赋值nil,在所难免.因此推出了可选类型</li>
</ul>
</li>
<li>可选类型的取值:<ul>
<li>空值</li>
<li>有值</li>
</ul>
</li>
</ul>
<h3 id="定义可选类型"><a href="#定义可选类型" class="headerlink" title="定义可选类型"></a>定义可选类型</h3><ul>
<li>定义一个可选类型有两种写法<ul>
<li>最基本的写法</li>
<li>语法糖(常用)</li>
</ul>
</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误写法</span></span><br><span class="line"><span class="comment">// let string : String = nil</span></span><br><span class="line"><span class="comment">// 正确写法:</span></span><br><span class="line"><span class="comment">// 注意:name的类型是一个可选类型,但是该可选类型中可以存放字符串.</span></span><br><span class="line"><span class="comment">// 写法一:定义可选类型</span></span><br><span class="line"><span class="keyword">let</span> name : <span class="type">Optional</span>&lt;<span class="type">String</span>&gt; <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line"><span class="comment">// 写法二:定义可选类型,语法糖(常用)</span></span><br><span class="line"><span class="keyword">let</span> name : <span class="type">String</span>? <span class="operator">=</span> <span class="literal">nil</span></span><br></pre></td></tr></table></figure>


<h3 id="可选类型的使用"><a href="#可选类型的使用" class="headerlink" title="可选类型的使用"></a>可选类型的使用</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 演练一:给可选类型赋值</span></span><br><span class="line"><span class="comment">// 定义可选类型</span></span><br><span class="line"><span class="keyword">var</span> string : <span class="type">Optional</span>&lt;<span class="type">String</span>&gt; <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line"><span class="comment">// 给可选类型赋值</span></span><br><span class="line"><span class="comment">// 错误写法:因此该可选类型中只能存放字符串</span></span><br><span class="line">string <span class="operator">=</span> <span class="number">123</span></span><br><span class="line"><span class="comment">// 正确写法:</span></span><br><span class="line">string <span class="operator">=</span> <span class="string">&quot;Hello world&quot;</span></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line"><span class="built_in">print</span>(string)</span><br><span class="line"><span class="comment">// 结果:Optional(&quot;Hello world&quot;)\n</span></span><br><span class="line"><span class="comment">// 因为打印出来的是可选类型,所有会带Optional</span></span><br><span class="line"><span class="comment">// 演练二:取出可选类型的值</span></span><br><span class="line"><span class="comment">// 取出可选类型的真实值(解包)</span></span><br><span class="line"><span class="built_in">print</span>(string<span class="operator">!</span>)</span><br><span class="line"><span class="comment">// 结果:Hello world\n</span></span><br><span class="line"><span class="comment">// 注意:如果可选类型为nil,强制取出其中的值(解包),会出错</span></span><br><span class="line">string <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line"><span class="built_in">print</span>(string<span class="operator">!</span>) <span class="comment">// 报错</span></span><br><span class="line"><span class="comment">// 正确写法:</span></span><br><span class="line"><span class="keyword">if</span> string <span class="operator">!=</span> <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(string<span class="operator">!</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 简单写法:为了让在if语句中可以方便使用string</span></span><br><span class="line"><span class="comment">// 可选绑定</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> str <span class="operator">=</span> string &#123;</span><br><span class="line">    <span class="built_in">print</span>(str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="真实应用场景"><a href="#真实应用场景" class="headerlink" title="真实应用场景"></a>真实应用场景</h3><p>目的:让代码更加严谨</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.将字符串类型转成Int类型</span></span><br><span class="line"><span class="keyword">let</span> str <span class="operator">=</span> <span class="string">&quot;123&quot;</span></span><br><span class="line"><span class="keyword">let</span> result : <span class="type">Int</span>? <span class="operator">=</span> <span class="type">Int</span>(str) <span class="comment">// nil/Int</span></span><br><span class="line"><span class="comment">// 2.根据文件名称,读取路径</span></span><br><span class="line"><span class="keyword">let</span> path : <span class="type">String</span>? <span class="operator">=</span> <span class="type">Bundle</span>.main.path(forResource: <span class="string">&quot;123.plist&quot;</span>, ofType: <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">// 3.根据string,创建URL</span></span><br><span class="line"><span class="keyword">let</span> url <span class="operator">=</span> <span class="type">URL</span>(string: <span class="string">&quot;http://www.520it.com/小码哥&quot;</span>)</span><br><span class="line"><span class="comment">// 4.从字典中取内容</span></span><br><span class="line"><span class="keyword">let</span> dict : [<span class="type">String</span> : <span class="keyword">Any</span>] <span class="operator">=</span> [<span class="string">&quot;name&quot;</span> : <span class="string">&quot;why&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">18</span>]</span><br><span class="line">dict[<span class="string">&quot;name&quot;</span>]</span><br><span class="line">dict[<span class="string">&quot;height&quot;</span>]</span><br></pre></td></tr></table></figure>

<h2 id="类型转化"><a href="#类型转化" class="headerlink" title="类型转化"></a>类型转化</h2><h3 id="类型转化-1"><a href="#类型转化-1" class="headerlink" title="类型转化"></a>类型转化</h3><ul>
<li>常见的类型转化符号<ul>
<li>as : 将实例转成某一种类型</li>
</ul>
</li>
</ul>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.定义数组</span></span><br><span class="line"><span class="keyword">let</span> array : [<span class="type">AnyObject</span>] <span class="operator">=</span> [<span class="number">12</span>, <span class="string">&quot;why&quot;</span>, <span class="number">1.88</span>]</span><br><span class="line"><span class="comment">// 2.取出第二个元素</span></span><br><span class="line"><span class="keyword">let</span> objc <span class="operator">=</span> array[<span class="number">1</span>]</span><br><span class="line"><span class="comment">// 3.将objc转成真正的类型来使用</span></span><br><span class="line"><span class="comment">// 3.1.as? 将AnyObject转成可选类型,通过判断可选类型是否有值,来决定是否转化成功了</span></span><br><span class="line"><span class="keyword">let</span> age <span class="operator">=</span> objc <span class="keyword">as?</span> <span class="type">Int</span></span><br><span class="line"><span class="built_in">print</span>(age) <span class="comment">// 结果:Optional(12)</span></span><br><span class="line"><span class="comment">// 3.2.as! 将AnyObject转成具体的类型,但是注意:如果不是该类型,那么程序会崩溃</span></span><br><span class="line"><span class="keyword">let</span> age1 <span class="operator">=</span> objc <span class="keyword">as!</span> <span class="type">Int</span></span><br><span class="line"><span class="built_in">print</span>(age1) <span class="comment">// 结果:12</span></span><br></pre></td></tr></table></figure>

<h2 id="try-throw"><a href="#try-throw" class="headerlink" title="try throw"></a>try throw</h2><p>throw catch 是 Xcode 7.0 对错误处理的一个非常大的变化</p>
<p>代码示例</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2. 反序列化</span></span><br><span class="line"><span class="comment">// 1.获取json文件路径</span></span><br><span class="line">        <span class="keyword">let</span> jsonPath <span class="operator">=</span> <span class="type">NSBundle</span>.mainBundle().pathForResource(<span class="string">&quot;MainVCSettings.json&quot;</span>, ofType: <span class="literal">nil</span>)</span><br><span class="line">        <span class="comment">// 2.加载json数据</span></span><br><span class="line">        <span class="keyword">let</span> jsonData <span class="operator">=</span> <span class="type">NSData</span>(contentsOfFile: jsonPath<span class="operator">!</span>)</span><br><span class="line">        <span class="comment">// 3.序列化json</span></span><br><span class="line">        <span class="keyword">do</span>&#123;<span class="comment">//解析成功</span></span><br><span class="line">             <span class="comment">// throw是Xcode7最明显的一个变化, Xcode7之前都是通过传入error指针捕获异常, Xocode7开始通过try/catch捕获异常</span></span><br><span class="line">            <span class="keyword">let</span> dictArray <span class="operator">=</span> <span class="keyword">try</span> <span class="type">NSJSONSerialization</span>.<span class="type">JSONObjectWithData</span>(jsonData<span class="operator">!</span>, options: <span class="type">NSJSONReadingOptions</span>.<span class="type">MutableContainers</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历字典时候需要明确指明数组中的数据类型</span></span><br><span class="line">            <span class="keyword">for</span> dict <span class="keyword">in</span> dictArray  <span class="keyword">as!</span> [[<span class="type">String</span>:<span class="type">String</span>]]</span><br><span class="line">            &#123;</span><br><span class="line">                 <span class="comment">// 由于addChildVC方法参数不能为nil, 但是字典中取出来的值可能是nil, 所以需要加上!</span></span><br><span class="line">                addChildViewController(dict[<span class="string">&quot;vcName&quot;</span>]<span class="operator">!</span>, title: dict[<span class="string">&quot;title&quot;</span>]<span class="operator">!</span>, imageName: dict[<span class="string">&quot;imageName&quot;</span>]<span class="operator">!</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>&#123;<span class="comment">//解析失败</span></span><br><span class="line">            <span class="built_in">print</span>(error)</span><br><span class="line">            addChildViewController(<span class="string">&quot;HomeTableViewController&quot;</span>, title: <span class="string">&quot;首页&quot;</span>, imageName: <span class="string">&quot;tabbar_home&quot;</span>)</span><br><span class="line">            addChildViewController(<span class="string">&quot;MessageTableViewController&quot;</span>, title: <span class="string">&quot;消息&quot;</span>, imageName: <span class="string">&quot;tabbar_message_center&quot;</span>)</span><br><span class="line">            addChildViewController(<span class="string">&quot;DiscoverTableViewController&quot;</span>, title: <span class="string">&quot;发现&quot;</span>, imageName: <span class="string">&quot;tabbar_discover&quot;</span>)</span><br><span class="line">            addChildViewController(<span class="string">&quot;ProfileTableViewController&quot;</span>, title: <span class="string">&quot;我&quot;</span>, imageName: <span class="string">&quot;tabbar_profile&quot;</span>)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>如果能确保代码执行正确，可以强行 try!</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array <span class="operator">=</span> <span class="keyword">try!</span> <span class="type">NSJSONSerialization</span>.<span class="type">JSONObjectWithData</span>(jsonData, options: <span class="type">NSJSONReadingOptions</span>.<span class="type">MutableContainers</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>不过需要注意的是，一旦解析错误，程序会直接崩溃！</p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift版-H5页面实现长按保存图片</title>
    <url>/post/fe709246.html</url>
    <content><![CDATA[<ul>
<li>刚开始拿到需求的第一反应是:H5页面还可以保存图片??</li>
<li>随即想了一下,好像微信里好多H5页面都有这样的功能</li>
<li>然后查阅了一下相关资料,有咨询了前端大神发现两行核心代码</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//获取长按所在点</span></span><br><span class="line">let urlString = <span class="string">&quot;document.elementFromPoint(\(touchPoint.x), \(touchPoint.y)).src&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//根据该点的参数获取对应图片的链接</span></span><br><span class="line">let saveUrl = webView.stringByEvaluatingJavaScriptFromString(urlString)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h3 id="下面来一起啊看一下完整的代码步骤"><a href="#下面来一起啊看一下完整的代码步骤" class="headerlink" title="下面来一起啊看一下完整的代码步骤"></a>下面来一起啊看一下完整的代码步骤</h3><blockquote>
<h4 id="首先给UiWebView加一个长按手势"><a href="#首先给UiWebView加一个长按手势" class="headerlink" title="首先给UiWebView加一个长按手势"></a>首先给UiWebView加一个长按手势</h4></blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//添加长按手势</span></span><br><span class="line">let longPressGes = <span class="built_in">UILongPressGestureRecognizer</span>(target: <span class="keyword">self</span>, action: <span class="meta">#selector(longPressedGesture(_:)))</span></span><br><span class="line"><span class="comment">//一定要遵循代理</span></span><br><span class="line">longPressGes.delegate = <span class="keyword">self</span></span><br><span class="line">webView.addGestureRecognizer(longPressGes)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<h4 id="实现代理方法"><a href="#实现代理方法" class="headerlink" title="实现代理方法"></a>实现代理方法</h4></blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//不实现该代理方法,长按无效</span></span><br><span class="line">func gestureRecognizer(gestureRecognizer: <span class="built_in">UIGestureRecognizer</span>, shouldRecognizeSimultaneouslyWithGestureRecognizer otherGestureRecognizer: <span class="built_in">UIGestureRecognizer</span>) -&gt; Bool &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<h4 id="接着在手势响应方法里面实现相应的功能"><a href="#接着在手势响应方法里面实现相应的功能" class="headerlink" title="接着在手势响应方法里面实现相应的功能"></a>接着在手势响应方法里面实现相应的功能</h4></blockquote>
<ul>
<li>注意:</li>
<li>一定要判断手势的state属性</li>
<li>判断saveUrl是否是一个nil值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@objc func longPressedGesture(recognizer: UILongPressGestureRecognizer)&#123;</span><br><span class="line">    if recognizer.state != .Began &#123; return &#125;</span><br><span class="line"></span><br><span class="line">    let touchPoint = recognizer.locationInView(webView)</span><br><span class="line"></span><br><span class="line">    //核心代码</span><br><span class="line">    let urlString = &quot;document.elementFromPoint(\(touchPoint.x), \(touchPoint.y)).src&quot;</span><br><span class="line">    if let saveUrl = webView.stringByEvaluatingJavaScriptFromString(urlString) &#123;</span><br><span class="line">        //判断图片的链接是否为空,长度是否为o</span><br><span class="line">        if saveUrl.characters.count == 0 &#123; return &#125;</span><br><span class="line">        addAlertAction(saveUrl)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<h4 id="调用保存图片功能按钮"><a href="#调用保存图片功能按钮" class="headerlink" title="调用保存图片功能按钮"></a>调用保存图片功能按钮</h4></blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">fileprivate func addAlertAction(imageStr: String)&#123;</span><br><span class="line">    let alertV = <span class="built_in">UIAlertController</span>()</span><br><span class="line">    let saveAction = <span class="built_in">UIAlertAction</span>(title: <span class="string">&quot;保存图片&quot;</span>, style: .Default) &#123; (alertV) <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">self</span>.saveImageToPhoto(imageStr)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//取消保存不作处理</span></span><br><span class="line">    let cancelAction = <span class="built_in">UIAlertAction</span>(title: <span class="string">&quot;取消&quot;</span>, style: .Cancel, handler: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">    alertV.addAction(saveAction)</span><br><span class="line">    alertV.addAction(cancelAction)</span><br><span class="line">    controller.presentViewController(alertV, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<h4 id="使用SDWebImage保存图片"><a href="#使用SDWebImage保存图片" class="headerlink" title="使用SDWebImage保存图片"></a>使用SDWebImage保存图片</h4></blockquote>
<ul>
<li>注意使用SDWebImage的缓存机制</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">fileprivate func saveImageToPhoto(imageStr: String)&#123;</span><br><span class="line">    guard let imageUrl = <span class="built_in">NSURL</span>(string: imageStr) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line"></span><br><span class="line">    let sdManager = SDWebImageManager.sharedManager()</span><br><span class="line"></span><br><span class="line">    var image : <span class="built_in">UIImage</span>!</span><br><span class="line">    <span class="keyword">if</span> sdManager.diskImageExistsForURL(imageUrl) &#123;</span><br><span class="line">        <span class="comment">//先判断缓存中的图片</span></span><br><span class="line">        image = sdManager.imageCache.imageFromDiskCacheForKey(imageUrl.absoluteString)</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//缓存没有在进行下载</span></span><br><span class="line">        let data = <span class="built_in">NSData</span>(contentsOfURL: imageUrl)</span><br><span class="line">        image = <span class="built_in">UIImage</span>(data: data!)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存图片到相册中</span></span><br><span class="line">    <span class="built_in">UIImageWriteToSavedPhotosAlbum</span>(image, <span class="keyword">self</span>, <span class="meta">#selector(self.image(_:didFinishSavingWithError:contextInfo:)), nil)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<h4 id="最后是一个保存成功与否的回调方法"><a href="#最后是一个保存成功与否的回调方法" class="headerlink" title="最后是一个保存成功与否的回调方法"></a>最后是一个保存成功与否的回调方法</h4></blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">func image(image: <span class="built_in">UIImage</span>, didFinishSavingWithError: <span class="built_in">NSError</span>?, contextInfo: AnyObject) &#123;</span><br><span class="line">    <span class="keyword">if</span> didFinishSavingWithError != <span class="literal">nil</span> &#123;</span><br><span class="line">        MBProgressHUD.show(string: <span class="string">&quot;请开启访问相册权限后使用此功能&quot;</span>, inView: <span class="keyword">self</span>.view)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        MBProgressHUD.show(string: <span class="string">&quot;图片保存成功&quot;</span>, inView: <span class="keyword">self</span>.view)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<blockquote>
<p> 以上如有不妥之处还望多多指正</p>
</blockquote>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift语音和文本的转换</title>
    <url>/post/fdb6338a.html</url>
    <content><![CDATA[<blockquote>
<p>谈到语音和文本的转换, 就要说到语音转文本和文本转语音两大技术</p>
</blockquote>
<ul>
<li>文本转语音是iOS7以后的技术, 用到的是AVFoundation框架</li>
<li>语音转文本是iOS10以后, 苹果发布的一个<a href="https://developer.apple.com/documentation/speech">Speech</a>框架</li>
</ul>
<span id="more"></span>

<ul>
<li>下面先介绍一下简单的文本转语音</li>
<li><a href="https://github.com/CoderTitan/TextAndVoice">GitHub上Demo地址</a></li>
<li>项目包括<ul>
<li>文本转语音</li>
<li>实时语音转文本</li>
<li>本地语音转文本</li>
<li>录音保存本地,转文本</li>
</ul>
</li>
</ul>
<h2 id="文本转语音"><a href="#文本转语音" class="headerlink" title="文本转语音"></a>文本转语音</h2><ul>
<li>文本转语音技术, 简称TTS (是<code>Text To Speech</code>的缩写), <a href="https://developer.apple.com/documentation/avfoundation/speech_synthesis">语音合成苹果官方文档</a></li>
<li>是苹果iOS7以后新增的功能, 使用AVFoundation 库</li>
<li>下面介绍一下需要用到的类</li>
</ul>
<h3 id="AVSpeechSynthesizer-语音合成器"><a href="#AVSpeechSynthesizer-语音合成器" class="headerlink" title="AVSpeechSynthesizer: 语音合成器"></a><code>AVSpeechSynthesizer</code>: 语音合成器</h3><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//是否正在语音播放</span></span><br><span class="line">open var isSpeaking: Bool &#123; get &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//是否停止语音播放</span></span><br><span class="line">open var isPaused: Bool &#123; get &#125;</span><br></pre></td></tr></table></figure>

<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//播放语音</span></span><br><span class="line">open func speak(_ utterance: <span class="built_in">AVSpeechUtterance</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//停止语音播放</span></span><br><span class="line">open func stopSpeaking(at boundary: <span class="built_in">AVSpeechBoundary</span>) -&gt; Bool</span><br><span class="line"></span><br><span class="line"><span class="comment">//暂停语音播放</span></span><br><span class="line">open func pauseSpeaking(at boundary: <span class="built_in">AVSpeechBoundary</span>) -&gt; Bool</span><br><span class="line"></span><br><span class="line"><span class="comment">//继续语音播放</span></span><br><span class="line">open func continueSpeaking() -&gt; Bool</span><br><span class="line"></span><br><span class="line"><span class="comment">//(iOS10以上, 输出通道)</span></span><br><span class="line">open var outputChannels: [<span class="built_in">AVAudioSessionChannelDescription</span>]?</span><br></pre></td></tr></table></figure>

<h3 id="AVSpeechBoundary"><a href="#AVSpeechBoundary" class="headerlink" title="AVSpeechBoundary"></a>AVSpeechBoundary</h3><ul>
<li>描述语音可能被暂停或停止的枚举值</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> immediate</span><br><span class="line"><span class="comment">//表示发言应该暂停或立即停止。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> word</span><br><span class="line"><span class="comment">//说完整个词语之后再暂停或者停止</span></span><br></pre></td></tr></table></figure>

<h3 id="AVSpeechUtterance"><a href="#AVSpeechUtterance" class="headerlink" title="AVSpeechUtterance"></a>AVSpeechUtterance</h3><ul>
<li>可以将文本和成一段语音的类, 或者说就是一段要播放的语音</li>
</ul>
<h4 id="3-1-属性"><a href="#3-1-属性" class="headerlink" title="3-1. 属性"></a>3-1. 属性</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用的声音</span></span><br><span class="line">open var voice: <span class="built_in">AVSpeechSynthesisVoice</span>?</span><br><span class="line"></span><br><span class="line"><span class="comment">//文本属性    </span></span><br><span class="line">open var speechString: String &#123; get &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//富文本属性</span></span><br><span class="line">@available(iOS <span class="number">10.0</span>, *)</span><br><span class="line">open var attributedSpeechString: <span class="built_in">NSAttributedString</span> &#123; get &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//说话的速度    </span></span><br><span class="line">open var rate: Float </span><br><span class="line"><span class="comment">//提供了两个语速 AVSpeechUtteranceMinimumSpeechRate和 AVSpeechUtteranceMaximumSpeechRate和AVSpeechUtteranceDefaultSpeechRate</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//说话的基线音高, [0.5 - 2] Default = 1   </span></span><br><span class="line">open var pitchMultiplier: Float </span><br><span class="line"></span><br><span class="line"><span class="comment">//说话音量, [0-1] Default = 1</span></span><br><span class="line">open var volume: Float </span><br><span class="line"></span><br><span class="line"><span class="comment">//开始一段语音之前等待的时间</span></span><br><span class="line">open var preUtteranceDelay: TimeInterval </span><br><span class="line"></span><br><span class="line"><span class="comment">//语音合成器在当前语音结束之后处理下一个排队的语音之前需要等待的时间, 默认0.0 </span></span><br><span class="line">open var postUtteranceDelay: TimeInterval</span><br></pre></td></tr></table></figure>

<h4 id="初始化方法"><a href="#初始化方法" class="headerlink" title="初始化方法"></a>初始化方法</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">public init(string: String)</span><br><span class="line"></span><br><span class="line">@available(iOS <span class="number">10.0</span>, *)</span><br><span class="line">public init(attributedString string: <span class="built_in">NSAttributedString</span>)</span><br></pre></td></tr></table></figure>

<h3 id="AVSpeechSynthesisVoice"><a href="#AVSpeechSynthesisVoice" class="headerlink" title="AVSpeechSynthesisVoice"></a>AVSpeechSynthesisVoice</h3><ul>
<li>用于语音合成的独特声音, 主要是不同的语言和地区</li>
<li>所支持的所有语言种类详见最底部附录</li>
</ul>
<h4 id="相关属性"><a href="#相关属性" class="headerlink" title="相关属性"></a>相关属性</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获得当前的语言</span></span><br><span class="line">open var language: String &#123; get &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回用户当前语言环境的代码</span></span><br><span class="line">@available(iOS <span class="number">9.0</span>, *)</span><br><span class="line">open var identifier: String &#123; get &#125;</span><br><span class="line"></span><br><span class="line">@available(iOS <span class="number">9.0</span>, *)</span><br><span class="line">open var name: String &#123; get &#125;</span><br><span class="line"></span><br><span class="line">@available(iOS <span class="number">9.0</span>, *)</span><br><span class="line">open var quality: <span class="built_in">AVSpeechSynthesisVoiceQuality</span> &#123; get &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="相关方法"><a href="#相关方法" class="headerlink" title="相关方法"></a>相关方法</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">init?(language: String?)</span><br><span class="line"><span class="comment">//返回指定语言和语言环境的语音对象。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> func speechVoices()</span><br><span class="line"><span class="comment">//返回所有可用的语音。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> func currentLanguageCode()</span><br><span class="line"><span class="comment">//返回用户当前语言环境的代码。</span></span><br></pre></td></tr></table></figure>


<h3 id="AVSpeechSynthesizerDelegate代理"><a href="#AVSpeechSynthesizerDelegate代理" class="headerlink" title="AVSpeechSynthesizerDelegate代理"></a>AVSpeechSynthesizerDelegate代理</h3><ul>
<li>所有代理方法都是支持iOS7.0以上的系统</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//开始播放</span></span><br><span class="line">optional public func speechSynthesizer(_ synthesizer: <span class="built_in">AVSpeechSynthesizer</span>, didStart utterance: <span class="built_in">AVSpeechUtterance</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//播放完成</span></span><br><span class="line">optional public func speechSynthesizer(_ synthesizer: <span class="built_in">AVSpeechSynthesizer</span>, didFinish utterance: <span class="built_in">AVSpeechUtterance</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//暂停播放</span></span><br><span class="line">optional public func speechSynthesizer(_ synthesizer: <span class="built_in">AVSpeechSynthesizer</span>, didPause utterance: <span class="built_in">AVSpeechUtterance</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//继续播放</span></span><br><span class="line">optional public func speechSynthesizer(_ synthesizer: <span class="built_in">AVSpeechSynthesizer</span>, didContinue utterance: <span class="built_in">AVSpeechUtterance</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//取消播放</span></span><br><span class="line">optional public func speechSynthesizer(_ synthesizer: <span class="built_in">AVSpeechSynthesizer</span>, didCancel utterance: <span class="built_in">AVSpeechUtterance</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//将要播放某一段话  </span></span><br><span class="line">optional public func speechSynthesizer(_ synthesizer: <span class="built_in">AVSpeechSynthesizer</span>, willSpeakRangeOfSpeechString characterRange: <span class="built_in">NSRange</span>, utterance: <span class="built_in">AVSpeechUtterance</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="6-具体功能的核心代码"><a href="#6-具体功能的核心代码" class="headerlink" title="6. 具体功能的核心代码"></a>6. 具体功能的核心代码</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//MARK: 开始/停止转换</span></span><br><span class="line">extension TextToVoiceController&#123;</span><br><span class="line">    <span class="comment">//开始转换</span></span><br><span class="line">    fileprivate func startTranslattion()&#123;</span><br><span class="line">        <span class="comment">//1. 创建需要合成的声音类型</span></span><br><span class="line">        let voice = <span class="built_in">AVSpeechSynthesisVoice</span>(language: <span class="string">&quot;zh-CN&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2. 创建合成的语音类</span></span><br><span class="line">        let utterance = <span class="built_in">AVSpeechUtterance</span>(string: textView.text)</span><br><span class="line">        utterance.rate = <span class="built_in">AVSpeechUtteranceDefaultSpeechRate</span></span><br><span class="line">        utterance.voice = voice</span><br><span class="line">        utterance.volume = <span class="number">1</span></span><br><span class="line">        utterance.postUtteranceDelay = <span class="number">0.1</span></span><br><span class="line">        utterance.pitchMultiplier = <span class="number">1</span></span><br><span class="line">        <span class="comment">//开始播放</span></span><br><span class="line">        avSpeech.speak(utterance)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//暂停播放</span></span><br><span class="line">    fileprivate func pauseTranslation()&#123;</span><br><span class="line">        avSpeech.pauseSpeaking(at: .immediate)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//继续播放</span></span><br><span class="line">    fileprivate func continueSpeek()&#123;</span><br><span class="line">        avSpeech.continueSpeaking()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//取消播放</span></span><br><span class="line">    fileprivate func cancleSpeek()&#123;</span><br><span class="line">        avSpeech.stopSpeaking(at: .immediate)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="语音转文本"><a href="#语音转文本" class="headerlink" title="语音转文本"></a>语音转文本</h2><ul>
<li>在2016 WWDC大会上，Apple公司介绍了一个很好的语音识别的API,那就是Speech框架</li>
<li>Speech框架支持iOS10以上系统</li>
<li><a href="https://developer.apple.com/documentation/speech">Speech框架官方文档</a></li>
<li>下面简单介绍一下主要的操作类</li>
</ul>
<h3 id="SFSpeechRecognizer-语音识别器"><a href="#SFSpeechRecognizer-语音识别器" class="headerlink" title="SFSpeechRecognizer: 语音识别器"></a><code>SFSpeechRecognizer</code>: 语音识别器</h3><ul>
<li>这个类是语音识别的操作类</li>
<li>用于语音识别用户权限的申请，语言环境的设置，语音模式的设置以及向Apple服务发送语音识别的请求</li>
<li>初始化方法</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这个初始化方法将默认以设备当前的语言环境作为语音识别的语言环境</span></span><br><span class="line">public convenience init?() </span><br><span class="line"></span><br><span class="line"><span class="comment">//根据支持的语言初始化</span></span><br><span class="line">public init?(locale: Locale) </span><br><span class="line"><span class="comment">//示例</span></span><br><span class="line">let recognize = SFSpeechRecognizer(locale: Locale(identifier: <span class="string">&quot;zh-CN&quot;</span>))</span><br></pre></td></tr></table></figure>
<ul>
<li>类方法</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取所有支持的语言</span></span><br><span class="line">open <span class="keyword">class</span> func supportedLocales() -&gt; Set&lt;Locale&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取当前用户权限状态</span></span><br><span class="line">open <span class="keyword">class</span> func authorizationStatus() -&gt; SFSpeechRecognizerAuthorizationStatus</span><br><span class="line"></span><br><span class="line"><span class="comment">//申请语音识别用户权限</span></span><br><span class="line">open <span class="keyword">class</span> func requestAuthorization(_ handler: @escaping (SFSpeechRecognizerAuthorizationStatus) -&gt; Swift.Void)</span><br></pre></td></tr></table></figure>

<ul>
<li>其他属性</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">var isAvailable: Bool</span><br><span class="line"><span class="comment">//指示语音识别器是否可用</span></span><br><span class="line"></span><br><span class="line">var locale: Locale</span><br><span class="line"><span class="comment">//当前语音识别器的语言环境</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> func supportedLocales()</span><br><span class="line"><span class="comment">//获取语音识别所有支持的语言</span></span><br><span class="line"></span><br><span class="line">var queue: OperationQueue</span><br><span class="line"><span class="comment">//语音识别器用于识别任务处理程序和委托消息的队列</span></span><br></pre></td></tr></table></figure>

<ul>
<li>相关方法</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//识别与指定请求关联的音频来源的语音，使用指定的协议返回结果</span></span><br><span class="line">open func recognitionTask(with request: SFSpeechRecognitionRequest, resultHandler: @escaping (SFSpeechRecognitionResult?, Error?) -&gt; Swift.Void) -&gt; SFSpeechRecognitionTask</span><br><span class="line"></span><br><span class="line"><span class="comment">//识别与指定请求关联的音频源的语音, 使用闭包结果</span></span><br><span class="line">open func recognitionTask(with request: SFSpeechRecognitionRequest, delegate: SFSpeechRecognitionTaskDelegate) -&gt; SFSpeechRecognitionTask</span><br></pre></td></tr></table></figure>
<ul>
<li>代理</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">weak</span> var delegate: SFSpeechRecognizerDelegate? &#123; get set &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理方法: 监视语音识别器的可用性</span></span><br><span class="line">func speechRecognizer(SFSpeechRecognizer, availabilityDidChange: Bool)</span><br></pre></td></tr></table></figure>

<h3 id="2-SFSpeechRecognitionRequest"><a href="#2-SFSpeechRecognitionRequest" class="headerlink" title="2. SFSpeechRecognitionRequest"></a>2. <code>SFSpeechRecognitionRequest</code></h3><ul>
<li>语音识别请求类，需要通过其子类来进行实例化</li>
<li>相关属性</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">var contextualStrings: [String]</span><br><span class="line"><span class="comment">//一系列应该被识别的语言种类</span></span><br><span class="line"></span><br><span class="line">var shouldReportPartialResults: Bool</span><br><span class="line"><span class="comment">//是否获取每个语句的最终结果。</span></span><br><span class="line"></span><br><span class="line">var taskHint: SFSpeechRecognitionTaskHint</span><br><span class="line"><span class="comment">//正在执行的语音识别的类型</span></span><br><span class="line"></span><br><span class="line">var interactionIdentifier: String?</span><br><span class="line"><span class="comment">//标识与请求关联的识别请求对象的字符串</span></span><br></pre></td></tr></table></figure>
<ul>
<li>子类<ul>
<li><code>SFSpeechURLRecognitionRequest</code></li>
<li><code>SFSpeechAudioBufferRecognitionRequest</code></li>
</ul>
</li>
</ul>
<h4 id="SFSpeechURLRecognitionRequest"><a href="#SFSpeechURLRecognitionRequest" class="headerlink" title="SFSpeechURLRecognitionRequest"></a><code>SFSpeechURLRecognitionRequest</code></h4><ul>
<li>通过制定的URL路径识别本地的语音</li>
<li>方法和属性</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个语音识别请求，使用指定的URL进行初始化</span></span><br><span class="line">public init(url URL: URL)</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取当前的usl路径    </span></span><br><span class="line">open var url: URL &#123; get &#125;</span><br></pre></td></tr></table></figure>

<h4 id="SFSpeechAudioBufferRecognitionRequest"><a href="#SFSpeechAudioBufferRecognitionRequest" class="headerlink" title="SFSpeechAudioBufferRecognitionRequest"></a><code>SFSpeechAudioBufferRecognitionRequest</code></h4><ul>
<li>识别音频缓冲区中提供的语音的请求</li>
<li>识别即时语音, 类似于iPhone 中的Siri</li>
<li><a href="https://developer.apple.com/documentation/speech/sfspeechaudiobufferrecognitionrequest">官方文档</a></li>
<li>音频缓冲区相关方法属性</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">func append(<span class="built_in">AVAudioPCMBuffer</span>)</span><br><span class="line"><span class="comment">//将PCM格式的音频追加到识别请求的末尾。</span></span><br><span class="line"></span><br><span class="line">func appendAudioSampleBuffer(<span class="built_in">CMSampleBuffer</span>)</span><br><span class="line"><span class="comment">//将音频附加到识别请求的末尾。</span></span><br><span class="line"></span><br><span class="line">func endAudio()</span><br><span class="line"><span class="comment">//完成输入</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>获取音频格式</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">var nativeAudioFormat: <span class="built_in">AVAudioFormat</span></span><br><span class="line"><span class="comment">//用于最佳语音识别的首选音频格式。</span></span><br></pre></td></tr></table></figure>

<h3 id="SFSpeechRecognitionTask"><a href="#SFSpeechRecognitionTask" class="headerlink" title="SFSpeechRecognitionTask"></a><code>SFSpeechRecognitionTask</code></h3><ul>
<li>语音识别请求结果类</li>
<li>语音识别任务，监视识别进度</li>
<li>相关方法属性</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">func cancel()</span><br><span class="line"><span class="comment">//取消当前的语音识别任务。</span></span><br><span class="line"></span><br><span class="line">var isCancelled: Bool</span><br><span class="line"><span class="comment">//语音识别任务是否已被取消。</span></span><br><span class="line"></span><br><span class="line">func finish()</span><br><span class="line"><span class="comment">//停止接受新的音频，并完成已接受的音频输入处理</span></span><br><span class="line"></span><br><span class="line">var isFinishing: Bool</span><br><span class="line"><span class="comment">//音频输入是否已停止。</span></span><br><span class="line"></span><br><span class="line">var state: SFSpeechRecognitionTaskState</span><br><span class="line"><span class="comment">//获取语音识别任务的当前状态。</span></span><br><span class="line"></span><br><span class="line">var error: Error?</span><br><span class="line"><span class="comment">//在语音识别任务期间发生的错误的错误对象。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="SFSpeechRecognitionTaskDelegate协议"><a href="#SFSpeechRecognitionTaskDelegate协议" class="headerlink" title="SFSpeechRecognitionTaskDelegate协议"></a><code>SFSpeechRecognitionTaskDelegate</code>协议</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当开始检测音频源中的语音时首先调用此方法</span></span><br><span class="line">optional public func speechRecognitionDidDetectSpeech(_ task: SFSpeechRecognitionTask)</span><br><span class="line"></span><br><span class="line"><span class="comment">//当识别出一条可用的信息后 会调用</span></span><br><span class="line"><span class="comment">//apple的语音识别服务会根据提供的音频源识别出多个可能的结果 每有一条结果可用 都会调用此方法</span></span><br><span class="line">optional public func speechRecognitionTask(_ task: SFSpeechRecognitionTask, didHypothesizeTranscription transcription: SFTranscription)</span><br><span class="line"></span><br><span class="line"><span class="comment">//当识别完成所有可用的结果后调用</span></span><br><span class="line">optional public func speechRecognitionTask(_ task: SFSpeechRecognitionTask, didFinishRecognition recognitionResult: SFSpeechRecognitionResult)</span><br><span class="line"></span><br><span class="line"><span class="comment">//当不再接受音频输入时调用 即开始处理语音识别任务时调用   </span></span><br><span class="line">optional public func speechRecognitionTaskFinishedReadingAudio(_ task: SFSpeechRecognitionTask)</span><br><span class="line"></span><br><span class="line"><span class="comment">//当语音识别任务被取消时调用    </span></span><br><span class="line">optional public func speechRecognitionTaskWasCancelled(_ task: SFSpeechRecognitionTask)</span><br><span class="line"></span><br><span class="line"><span class="comment">//语音识别任务完成时被调用    </span></span><br><span class="line">optional public func speechRecognitionTask(_ task: SFSpeechRecognitionTask, didFinishSuccessfully successfully: Bool)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="SFTranscription"><a href="#SFTranscription" class="headerlink" title="SFTranscription"></a>SFTranscription</h3><ul>
<li>语音转换后的信息类, 包含改短语音信息的类</li>
<li>你所说的一句话，可能是有好几个词语拼成的，<code>formattedString</code>就是你所说的那句话，<code>segments</code>就是你所说的你那句话的组成每个单词的集合</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回了一条表达语音译文的字符数据</span></span><br><span class="line">open var formattedString: String &#123; get &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//所有的可能的识别数据</span></span><br><span class="line">open var segments: [SFTranscriptionSegment] &#123; get &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="SFTranscriptionSegment"><a href="#SFTranscriptionSegment" class="headerlink" title="SFTranscriptionSegment"></a>SFTranscriptionSegment</h3><ul>
<li>语音转换中的音频节点类</li>
<li>相关属性</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当前节点识别后的文本信息</span></span><br><span class="line">open var substring: String &#123; get &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前节点识别后的文本信息在整体识别语句中的位置</span></span><br><span class="line">open var substringRange: <span class="built_in">NSRange</span> &#123; get &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前节点的音频时间戳</span></span><br><span class="line">open var timestamp: TimeInterval &#123; get &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前节点音频的持续时间</span></span><br><span class="line">open var duration: TimeInterval &#123; get &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可信度/准确度 0-1之间</span></span><br><span class="line">open var confidence: Float &#123; get &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关于此节点的其他可能的识别结果 </span></span><br><span class="line">open var alternativeSubstrings: [String] &#123; get &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="SFSpeechRecognitionResult-语音识别结果类"><a href="#SFSpeechRecognitionResult-语音识别结果类" class="headerlink" title="SFSpeechRecognitionResult: 语音识别结果类"></a><code>SFSpeechRecognitionResult</code>: 语音识别结果类</h3><ul>
<li>是语音识别结果的封装，其中包含了许多套平行的识别信息，其每一份识别信息都有可信度属性来描述其准确程度</li>
<li>该类只是语音识别结果的一个封装，真正的识别信息定义在SFTranscription类中</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//准确性最高的识别实例</span></span><br><span class="line">@<span class="built_in">NSCopying</span> open var bestTranscription: SFTranscription &#123; get &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//识别到的多套语音转换信息数组 其会按照准确度进行排序</span></span><br><span class="line">open var transcriptions: [SFTranscription] &#123; get &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//是否已经完成 如果YES 则所有所有识别信息都已经获取完成</span></span><br><span class="line">open var isFinal: Bool &#123; get &#125;</span><br></pre></td></tr></table></figure>

<h2 id="语音识别转文本"><a href="#语音识别转文本" class="headerlink" title="语音识别转文本"></a>语音识别转文本</h2><ul>
<li>添加Speech框架<ul>
<li><code>import Speech</code></li>
</ul>
</li>
<li><code>info.plist</code>必须添加相关权限</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Privacy - Speech Recognition Usage Description</span><br><span class="line"><span class="comment">//语音识别权限</span></span><br><span class="line"></span><br><span class="line">Privacy - Microphone Usage Description</span><br><span class="line"><span class="comment">//麦克风使用权限</span></span><br></pre></td></tr></table></figure>
<ul>
<li>判断用户授权<ul>
<li>在使用speech framework做语音识别之前，你必须首先得到用户的允许</li>
<li>因为不仅仅只有本地的ios设备会进行识别，苹果的服务器也会识别</li>
<li>所有的语音数据都会被传递到苹果的后台进行处理</li>
<li>因此，获取用户授权是强制必须的</li>
</ul>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">///语音识别权限认证</span></span><br><span class="line">fileprivate func addSpeechRecordLimit()&#123;</span><br><span class="line">    SFSpeechRecognizer.requestAuthorization &#123; (state) <span class="keyword">in</span></span><br><span class="line">        var isEnable = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">switch</span> state &#123;</span><br><span class="line">        <span class="keyword">case</span> .authorized:</span><br><span class="line">            isEnable = <span class="literal">true</span></span><br><span class="line">            print(<span class="string">&quot;已授权语音识别&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> .notDetermined:</span><br><span class="line">            isEnable = <span class="literal">false</span></span><br><span class="line">            print(<span class="string">&quot;没有授权语音识别&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> .denied:</span><br><span class="line">            isEnable = <span class="literal">false</span></span><br><span class="line">            print(<span class="string">&quot;用户已拒绝访问语音识别&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> .restricted:</span><br><span class="line">            isEnable = <span class="literal">false</span></span><br><span class="line">            print(<span class="string">&quot;不能在该设备上进行语音识别&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        DispatchQueue.main.async &#123;</span><br><span class="line">            <span class="keyword">self</span>.recordBtn.isEnabled = isEnable</span><br><span class="line">            <span class="keyword">self</span>.recordBtn.backgroundColor = isEnable ? <span class="built_in">UIColor</span>(red: <span class="number">255</span>/<span class="number">255.0</span>, green: <span class="number">64</span>/<span class="number">255.0</span>, blue: <span class="number">64</span>/<span class="number">255.0</span>, alpha: <span class="number">1</span>) : <span class="built_in">UIColor</span>.lightGray</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>再然后就是初始化相关请求和识别类处理相关语音</li>
<li><a href="https://github.com/CoderTitan/TextAndVoice">详细代码参考GitHub的Demo地址</a></li>
</ul>
<hr>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录:"></a>附录:</h2><h3 id="AVSpeechSynthesisVoice支持的语言种类"><a href="#AVSpeechSynthesisVoice支持的语言种类" class="headerlink" title="AVSpeechSynthesisVoice支持的语言种类"></a><code>AVSpeechSynthesisVoice</code>支持的语言种类</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">ar-SA  沙特阿拉伯（阿拉伯文）</span><br><span class="line"></span><br><span class="line">en-ZA, 南非（英文）</span><br><span class="line"></span><br><span class="line">nl-BE, 比利时（荷兰文）</span><br><span class="line"></span><br><span class="line">en-AU, 澳大利亚（英文）</span><br><span class="line"></span><br><span class="line">th-TH, 泰国（泰文）</span><br><span class="line"></span><br><span class="line">de-DE, 德国（德文）</span><br><span class="line"></span><br><span class="line">en-US, 美国（英文）</span><br><span class="line"></span><br><span class="line">pt-BR, 巴西（葡萄牙文）</span><br><span class="line"></span><br><span class="line">pl-PL, 波兰（波兰文）</span><br><span class="line"></span><br><span class="line">en-IE, 爱尔兰（英文）</span><br><span class="line"></span><br><span class="line">el-GR, 希腊（希腊文）</span><br><span class="line"></span><br><span class="line"><span class="type">id</span>-ID, 印度尼西亚（印度尼西亚文）</span><br><span class="line"></span><br><span class="line">sv-SE, 瑞典（瑞典文）</span><br><span class="line"></span><br><span class="line">tr-TR, 土耳其（土耳其文）</span><br><span class="line"></span><br><span class="line">pt-PT, 葡萄牙（葡萄牙文）</span><br><span class="line"></span><br><span class="line">ja-JP, 日本（日文）</span><br><span class="line"></span><br><span class="line">ko-KR, 南朝鲜（朝鲜文）</span><br><span class="line"></span><br><span class="line">hu-HU, 匈牙利（匈牙利文）</span><br><span class="line"></span><br><span class="line">cs-CZ, 捷克共和国（捷克文）</span><br><span class="line"></span><br><span class="line">da-DK, 丹麦（丹麦文）</span><br><span class="line"></span><br><span class="line">es-MX, 墨西哥（西班牙文）</span><br><span class="line"></span><br><span class="line">fr-CA, 加拿大（法文）</span><br><span class="line"></span><br><span class="line">nl-NL, 荷兰（荷兰文）</span><br><span class="line"></span><br><span class="line">fi-FI, 芬兰（芬兰文）</span><br><span class="line"></span><br><span class="line">es-ES, 西班牙（西班牙文）</span><br><span class="line"></span><br><span class="line">it-IT, 意大利（意大利文）</span><br><span class="line"></span><br><span class="line">he-IL, 以色列（希伯莱文，阿拉伯文）</span><br><span class="line"></span><br><span class="line">no-<span class="literal">NO</span>, 挪威（挪威文）</span><br><span class="line"></span><br><span class="line">ro-RO, 罗马尼亚（罗马尼亚文）</span><br><span class="line"></span><br><span class="line">zh-HK, 香港（中文）</span><br><span class="line"></span><br><span class="line">zh-TW, 台湾（中文）</span><br><span class="line"></span><br><span class="line">sk-SK, 斯洛伐克（斯洛伐克文）</span><br><span class="line"></span><br><span class="line">zh-CN, 中国（中文）</span><br><span class="line"></span><br><span class="line">ru-RU, 俄罗斯（俄文）</span><br><span class="line"></span><br><span class="line">en-GB, 英国（英文）</span><br><span class="line"></span><br><span class="line">fr-FR, 法国（法文）</span><br><span class="line"></span><br><span class="line">hi-IN  印度（印度文）</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Swift框架</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>Speech</tag>
      </tags>
  </entry>
  <entry>
    <title>Xcode代码规范之SwiftLint配置</title>
    <url>/post/321bd392.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>最近公司大佬考虑将项目代码规范化, 然而自Xcode9之后,Xcode的插件基本处于废弃的状态大部分插件都是在一年前就停止更新了;</li>
<li>于是在谷歌找到了一款强大的代码规范工具<a href="https://github.com/realm/SwiftLint">SwiftLint</a></li>
<li><a href="https://github.com/realm/SwiftLint">SwiftLint</a>是 <a href="https://realm.io/">Realm</a> 推出的一款 Swift 代码规范检查工具, SwiftLint 基于 <a href="https://github.com/Artwalk/swift-style-guide/blob/master/README_CN.md">Github 公布的 Swift 代码规范</a>进行代码检查，并且能够很好的和 Xcode 整合</li>
<li><a href="https://github.com/github/swift-style-guide">Github 公布的 Swift 代码规范–原文</a></li>
<li><a href="https://github.com/Artwalk/swift-style-guide/blob/master/README_CN.md">Github 公布的 Swift 代码规范–中文</a></li>
<li>配置好所有的设置之后，在 Xcode 中执行编译时，SwiftLint 会自动运行检查，不符合规范的代码会通过警告或者 红色错误 的形式指示出来</li>
<li>支持自定义规则,可禁用或者开启某一些规则</li>
</ul>
<span id="more"></span>

<h2 id="安装SwiftLint"><a href="#安装SwiftLint" class="headerlink" title="安装SwiftLint"></a>安装SwiftLint</h2><ul>
<li>SwiftLint目前有三种安装方式可供选择,可以根据自己的项目需要自行选择</li>
</ul>
<h3 id="安装全局配置-Homebrew-安装"><a href="#安装全局配置-Homebrew-安装" class="headerlink" title="安装全局配置(Homebrew 安装)"></a>安装全局配置(Homebrew 安装)</h3><h4 id="Homebrew"><a href="#Homebrew" class="headerlink" title="Homebrew"></a>Homebrew</h4><ul>
<li>Homebrew, Mac系统的包管理器，用于安装NodeJS和一些其他必需的工具软件, 输入以下代码安装:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure>
<p>译注：在Max OS X 10.11（El Capitan)版本中，homebrew在安装软件时可能会碰到&#x2F;usr&#x2F;local目录不可写的权限问题。可以使用下面的命令修复：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo chown -R `whoami` /usr/local</span><br></pre></td></tr></table></figure>

<ul>
<li>Homebrew 会自动安装最新版本</li>
<li>打开终端输入以下代码:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew install swiftlint</span><br></pre></td></tr></table></figure>
<h4 id="安装成功-如下图所示"><a href="#安装成功-如下图所示" class="headerlink" title="安装成功,如下图所示:"></a>安装成功,如下图所示:</h4><p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-aaabe87320b6b9f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Homebrew 安装"></p>
<h3 id="使用-CocoaPods-安装"><a href="#使用-CocoaPods-安装" class="headerlink" title="使用 CocoaPods 安装"></a>使用 CocoaPods 安装</h3><ul>
<li>这种方式只能针对单个项目有效,如果你想要针对不同的项目使用不同的<code>SwiftLint</code> 版本，这是一种很好的解决方案</li>
<li>需要注意的是使用这种方案会将整个<code>SwiftLint</code>以及他的依赖包的完整资源文件都安装到 Pods&#x2F; 目录中去，所以在使用版本管理工具比如 <code>git/svn</code> 时要注意设置忽略相关目录</li>
<li>CocosPods安装和安装第三方框架一样</li>
<li>在根目录创建<code>Podfile</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pod &#x27;SwiftLint&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="使用安装包"><a href="#使用安装包" class="headerlink" title="使用安装包"></a>使用安装包</h3><p><code>SwiftLint</code> 还支持使用 <code>pkg</code> 安装包进行安装，在官方的 Github 页面可以找到最新发布的<a href="https://github.com/realm/SwiftLint/releases/tag/0.17.0">安装包</a></p>
<h2 id="查看SwiftLint的全部命令"><a href="#查看SwiftLint的全部命令" class="headerlink" title="查看SwiftLint的全部命令"></a>查看SwiftLint的全部命令</h2><ul>
<li>等待安装完成，在终端输入 <code>swiftlint help</code> 可以查看所有可用的命令：</li>
</ul>
<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-a9eaa0ae5b92f67b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="SwiftLint的所有命令"></p>
<p><strong>各个命令注释</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查看所有命令</span></span><br><span class="line">swiftlint help</span><br><span class="line"></span><br><span class="line"><span class="comment">//忽略空格导致的警告和错误</span></span><br><span class="line">swiftlint autocorrect</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出所有的警告和错误</span></span><br><span class="line">swiftlint lint</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看所有可获得的规则以及对应的 ID</span></span><br><span class="line">swiftlint rules</span><br><span class="line"></span><br><span class="line"><span class="comment">//产看当前版本号</span></span><br><span class="line">swiftlint version</span><br></pre></td></tr></table></figure>

<ul>
<li>我们将目录切换到工程的根目录之下，然后敲击如下命令:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">swiftlint autocorrect</span><br></pre></td></tr></table></figure>
<p>然后我们就会发现，所有的空格符Warning都消失了。这都得益于我们刚刚所进行的命令行操作，它会将已知的能够自动修复的Error和Warning都自动修复，大大的减轻了我们的工作量。</p>
<h2 id="SwiftLint的使用"><a href="#SwiftLint的使用" class="headerlink" title="SwiftLint的使用"></a>SwiftLint的使用</h2><blockquote>
<p>安装完成后,需要在Xcode中配置相关设置,才能使 SwiftLint 在 Xcode 中自动检测代码规范。配置也很简单，只需要在 Xcode 的 Build Phases 中新建一个 Run Script Phase 配置项，在里面添加相关代码后,编译即可!</p>
</blockquote>
<ul>
<li>配置代码添加步骤</li>
<li>需要将相关脚本添加到红色框内</li>
</ul>
<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-9fcfc0ce421210db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt="配置代码添加步骤"></p>
<p><strong>1. 全局安装脚本添加方式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if which swiftlint &gt;/dev/null; then</span><br><span class="line">  swiftlint</span><br><span class="line">else</span><br><span class="line">  echo &quot;warning: SwiftLint not installed, download from https://github.com/realm/SwiftLint&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p><strong>2. CocoaPods安装脚本添加</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;$&#123;PODS_ROOT&#125;/SwiftLint/swiftlint&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>这里其实是设置了一个自动编译脚本，每次运行编译都会自动执行这个脚本</li>
<li>如果正确安装了 SwiftLint，就会执行 SwiftLint 中的代码规范检查，如果没有安装，脚本会抛出一个没有安装 SwiftLint 并提示下载的警告，方便提醒团队团队中没有安装的成员。</li>
<li>当然，你也可以设置为强制要求安装，这时如果没有安装则无法通过编译。只需要在脚本中<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;warning: ...&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>之后添加一行代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exit 1</span><br></pre></td></tr></table></figure>

<ul>
<li>这样一来，如果没有安装 SwiftLint，编译时会直接抛出一个编译错误而非警告，提示需要安装 SwiftLint。</li>
</ul>
<p><strong>3. 配置完成后,<code>command+B</code>编译</strong></p>
<ul>
<li><p>如果你的是正在开发中的项目, 你可能会发现你的项目提示999+的黄色警告和999+的红色错误</p>
</li>
<li><p>甚至你会发现甚至一些空格和一些系统的方法和注释也会报错或者警告</p>
</li>
<li><p><code>SwiftLint</code>默认方法名或者注释不得超过120个字符</p>
</li>
<li><p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-271410cb5d83bea3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="测试项目"></p>
</li>
<li><p>Swift Lint 在完成上述操作之后，便已经生效。但是，如果觉得默认的风格过于严格，或者项目组有另外的要求，Swift Lint 也可以定制相应的风格，或者禁用某些规则。</p>
</li>
<li><p><a href="https://github.com/realm/SwiftLint">SwiftLint</a> 的全部规则可以在：<a href="https://github.com/realm/SwiftLint/tree/master/Source/SwiftLintFramework/Rules">Source&#x2F;SwiftLintFramework&#x2F;Rules</a> 目录内找到</p>
</li>
<li></li>
</ul>
<h2 id="自定义配置"><a href="#自定义配置" class="headerlink" title="自定义配置"></a>自定义配置</h2><ul>
<li>当你编译过项目后,看到999+的警告和错误,是不是第一反应就是要放弃了,其实不然</li>
<li>仔细看一下具体的错误，会发现好多都是第三方库的代码规范问题，而且好多问题的级别被设置成为了 error</li>
<li>第三方库的代码规范问题,这个锅我们可不能背</li>
<li>这里我们可以做一些配置，让 <code>SwiftLint</code> 在做代码规范检查的时候自动忽略 <code>CocoaPods</code>、<code>Carthage</code> 等包管理器引入的第三方库（当然，手动导入的第三方库也能设置忽略）</li>
</ul>
<h3 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h3><ul>
<li>首先需要在项目的根目录下新建一个名为 .swiftlint.yml 的配置文件</li>
<li>打开终端, cd 到项目根目录下</li>
<li>输入: <code>touch .swiftlint.yml</code></li>
<li>执行完该命令后, 在文件夹中你可能找不到该yml格式文件,那是因为文件被隐藏了</li>
<li>关于隐藏&#x2F;显示隐藏文件(命令一样): <code>command + shift + .</code></li>
<li>下面我们来认识一下主要的几个配置选项</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">disabled_rules: # 禁用指定的规则</span><br><span class="line">  - colon</span><br><span class="line">  - comma</span><br><span class="line">  - control_statement</span><br><span class="line">opt_in_rules: # 启用指定的规则</span><br><span class="line">  - empty_count</span><br><span class="line">  - missing_docs</span><br><span class="line">  # 可以通过执行如下指令来查找所有可用的规则:</span><br><span class="line">  <span class="meta"># swiftlint rules</span></span><br><span class="line">included: # 执行 linting 时包含的路径。如果出现这个 `--path` 会被忽略。</span><br><span class="line">  - Source</span><br><span class="line">excluded: # 执行 linting 时忽略的路径。 优先级比 `included` 更高。</span><br><span class="line">  - Carthage</span><br><span class="line">  - Pods</span><br><span class="line">  - Source/ExcludedFolder</span><br><span class="line">  - Source/ExcludedFile.swift</span><br></pre></td></tr></table></figure>

<h3 id="在代码中关闭某个规则"><a href="#在代码中关闭某个规则" class="headerlink" title="在代码中关闭某个规则"></a>在代码中关闭某个规则</h3><p>可以通过在一个源文件中定义一个如下格式的注释来关闭某个规则：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// swiftlint:disable &lt;rule&gt;</span><br></pre></td></tr></table></figure>
<p>在该文件结束之前或者在定义如下格式的匹配注释之前，这条规则都会被禁用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// swiftlint:enable &lt;rule&gt;</span><br></pre></td></tr></table></figure>
<p>例如:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// swiftlint:disable opening_brace</span><br><span class="line">func initTakeScreenshot(launchOptions: [AnyHashable: Any]?)&#123;</span><br><span class="line">    // swiftlint:enable opening_brace</span><br><span class="line">    if let options = launchOptions &#123;</span><br><span class="line">        let userInfo = options[UIApplicationLaunchOptionsKey.remoteNotification]</span><br><span class="line">        NotificationCenter.default.post(name: Notification.Name.UIApplicationUserDidTakeScreenshot, object: userInfo)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>规则关闭之前</p>
<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-21790882f651fa95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20180207_1.png"></p>
<p>规则关闭之后<br><img data-src="http://upload-images.jianshu.io/upload_images/4122543-6ba8e782746c0849.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20180207_2.png"></p>
<p>也可以通过添加 :previous, :this 或者 :next 来使关闭或者打开某条规则的命令分别应用于前一行，当前或者后一行代码。</p>
<p>例如:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// swiftlint:disable:next force_cast</span><br><span class="line">let noWarning = NSNumber() as! Int</span><br><span class="line">let hasWarning = NSNumber() as! Int</span><br><span class="line">let noWarning2 = NSNumber() as! Int // swiftlint:disable:this force_cast</span><br><span class="line">let noWarning3 = NSNumber() as! Int</span><br><span class="line">// swiftlint:disable:previous force_cast</span><br></pre></td></tr></table></figure>

<h3 id="忽略引入的第三方库"><a href="#忽略引入的第三方库" class="headerlink" title="忽略引入的第三方库"></a>忽略引入的第三方库</h3><ul>
<li>1). 忽略<code>CocoaPods</code>导入的第三方库</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">excluded: </span><br><span class="line">  - Pods</span><br></pre></td></tr></table></figure>

<ul>
<li>2). excluded 配置项用来设置忽略代码规范检查的路径，可以指定整个文件夹</li>
<li>比如如果你的项目使用 Carthage 管理第三方库的话，可以将 Carthage 目录添加到忽略列表：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">excluded: </span><br><span class="line">  - Pods</span><br><span class="line">  - Carthage</span><br></pre></td></tr></table></figure>

<ul>
<li>3). 指定精确路径下的文件，通过 - xxxx 的形式列在下面就可以了</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">excluded: # 执行 linting 时忽略的路径。 优先级比 `included` 更高。</span><br><span class="line">  - Source/ExcludedFolder</span><br><span class="line">  - Source/ExcludedFile.swift</span><br></pre></td></tr></table></figure>

<h3 id="嵌套配置"><a href="#嵌套配置" class="headerlink" title="嵌套配置"></a>嵌套配置</h3><p><code>SwiftLint</code> 支持通过嵌套配置文件的方式来对代码分析过程进行更加细致的控制。</p>
<ul>
<li>在你的根 <code>.swiftlint.yml</code> 文件里设置 <code>use_nested_configs: true</code> 值。</li>
<li>在目录结构必要的地方引入额外的 <code>.swiftlint.yml</code> 文件。</li>
<li>每个文件被检查时会使用在文件所在目录下的或者父目录的更深层目录下的配置文件。否则根配置文件将会生效。</li>
<li><code>excluded</code>，<code>included</code>，和 <code>use_nested_configs</code> 在嵌套结构中会被忽略。</li>
</ul>
<h3 id="自动更正"><a href="#自动更正" class="headerlink" title="自动更正"></a>自动更正</h3><ul>
<li><code>SwiftLint</code> 可以自动修正某些错误，磁盘上的文件会被一个修正后的版本覆盖。</li>
<li>请确保在对文件执行 <code>swiftlint autocorrect</code> 之前有对它们做过备份，否则的话有可能导致重要数据的丢失。</li>
<li>因为在执行自动更正修改某个文件后很有可能导致之前生成的代码检查信息无效或者不正确，所以当在执行代码更正时标准的检查是无法使用的。</li>
</ul>
<h2 id="最后贴上官方示例"><a href="#最后贴上官方示例" class="headerlink" title="最后贴上官方示例"></a>最后贴上官方示例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">disabled_rules: # 执行时排除掉的规则</span><br><span class="line">  - colon</span><br><span class="line">  - comma</span><br><span class="line">  - control_statement</span><br><span class="line">opt_in_rules: # 一些规则仅仅是可选的</span><br><span class="line">  - empty_count</span><br><span class="line">  - missing_docs</span><br><span class="line">  # 可以通过执行如下指令来查找所有可用的规则:</span><br><span class="line">  # swiftlint rules</span><br><span class="line">included: # 执行 linting 时包含的路径。如果出现这个 `--path` 会被忽略。</span><br><span class="line">  - Source</span><br><span class="line">excluded: # 执行 linting 时忽略的路径。 优先级比 `included` 更高。</span><br><span class="line">  - Carthage</span><br><span class="line">  - Pods</span><br><span class="line">  - Source/ExcludedFolder</span><br><span class="line">  - Source/ExcludedFile.swift</span><br><span class="line"></span><br><span class="line"># 可配置的规则可以通过这个配置文件来自定义</span><br><span class="line"># 二进制规则可以设置他们的严格程度</span><br><span class="line">force_cast: warning # 隐式</span><br><span class="line">force_try:</span><br><span class="line">  severity: warning # 显式</span><br><span class="line"># 同时有警告和错误等级的规则，可以只设置它的警告等级</span><br><span class="line"># 隐式</span><br><span class="line">line_length: 110</span><br><span class="line"># 可以通过一个数组同时进行隐式设置</span><br><span class="line">type_body_length:</span><br><span class="line">  - 300 # warning</span><br><span class="line">  - 400 # error</span><br><span class="line"># 或者也可以同时进行显式设置</span><br><span class="line">file_length:</span><br><span class="line">  warning: 500</span><br><span class="line">  error: 1200</span><br><span class="line"># 命名规则可以设置最小长度和最大程度的警告/错误</span><br><span class="line"># 此外它们也可以设置排除在外的名字</span><br><span class="line">type_name:</span><br><span class="line">  min_length: 4 # 只是警告</span><br><span class="line">  max_length: # 警告和错误</span><br><span class="line">    warning: 40</span><br><span class="line">    error: 50</span><br><span class="line">  excluded: iPhone # 排除某个名字</span><br><span class="line">variable_name:</span><br><span class="line">  min_length: # 只有最小长度</span><br><span class="line">    error: 4 # 只有错误</span><br><span class="line">  excluded: # 排除某些名字</span><br><span class="line">    - id</span><br><span class="line">    - URL</span><br><span class="line">    - GlobalAPIKey</span><br><span class="line">reporter: &quot;xcode&quot; # 报告类型 (xcode, json, csv, checkstyle)</span><br></pre></td></tr></table></figure>

<h2 id="附录"><a href="#附录" class="headerlink" title="附录:"></a>附录:</h2><blockquote>
<p>原文链接：<a href="https://github.com/realm/SwiftLint/blob/master/README.md">https://github.com/realm/SwiftLint/blob/master/README.md</a><br>译文链接：<a href="https://github.com/realm/SwiftLint/blob/master/README_CN.md">https://github.com/realm/SwiftLint/blob/master/README_CN.md</a></p>
</blockquote>
]]></content>
      <categories>
        <category>iOS组件库</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>SwiftLint</tag>
      </tags>
  </entry>
  <entry>
    <title>Tkinter之组件布局和事件绑定</title>
    <url>/post/27aa90ef.html</url>
    <content><![CDATA[<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-9f31000a70814ea9?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Tkinter"></p>
<span id="more"></span>



<ul>
<li><a href="https://www.titanjun.top/categories/Python/">前面的一些文章</a>介绍了<code>Tkinter</code>模块和大部分组建的使用</li>
<li>这里主要介绍数据的操作和组件布局等</li>
<li><a href="https://github.com/CoderTitan/PythonDemo">GitHub代码示例目地址</a></li>
</ul>
<h2 id="数据显示"><a href="#数据显示" class="headerlink" title="数据显示"></a>数据显示</h2><p>在<code>tkinter</code>中的数据展示方式有两种表格数据和树状数据, 但是都用到同一个组件<code>Treeview</code>, 下面介绍组建的使用</p>
<h3 id="表格数据"><a href="#表格数据" class="headerlink" title="表格数据"></a>表格数据</h3><ul>
<li>表格数据, 顾名思义就是用表格形式展示数据</li>
<li>要使用<code>Treeview</code>首先要引用<code>tkinter</code>中的<code>ttk</code>模块</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tkinter <span class="keyword">import</span> ttk</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此处省略window的相关代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建表格</span></span><br><span class="line">tree = ttk.Treeview(window)</span><br><span class="line">tree.pack()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义列title(接受一个元组)</span></span><br><span class="line">tree[<span class="string">&quot;columns&quot;</span>] = (<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>, <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;height&#x27;</span>, <span class="string">&#x27;weight&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置列宽度</span></span><br><span class="line">tree.column(<span class="string">&#x27;name&#x27;</span>, width=<span class="number">100</span>)</span><br><span class="line">tree.column(<span class="string">&#x27;sex&#x27;</span>, width=<span class="number">50</span>)</span><br><span class="line">tree.column(<span class="string">&#x27;age&#x27;</span>, width=<span class="number">50</span>)</span><br><span class="line">tree.column(<span class="string">&#x27;height&#x27;</span>, width=<span class="number">80</span>)</span><br><span class="line">tree.column(<span class="string">&#x27;weight&#x27;</span>, width=<span class="number">80</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置表头(列名)</span></span><br><span class="line">tree.heading(<span class="string">&#x27;name&#x27;</span>, text=<span class="string">&#x27;姓名&#x27;</span>)</span><br><span class="line">tree.heading(<span class="string">&#x27;sex&#x27;</span>, text=<span class="string">&#x27;性别&#x27;</span>)</span><br><span class="line">tree.heading(<span class="string">&#x27;age&#x27;</span>, text=<span class="string">&#x27;年龄&#x27;</span>)</span><br><span class="line">tree.heading(<span class="string">&#x27;height&#x27;</span>, text=<span class="string">&#x27;身高(CM)&#x27;</span>)</span><br><span class="line">tree.heading(<span class="string">&#x27;weight&#x27;</span>, text=<span class="string">&#x27;体重(KG)&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加数据</span></span><br><span class="line">tree.insert(<span class="string">&#x27;&#x27;</span>, <span class="number">0</span>, text=<span class="string">&#x27;line1&#x27;</span>, values=(<span class="string">&#x27;Titan&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="number">20</span>, <span class="number">180</span>, <span class="number">80</span>))</span><br><span class="line">tree.insert(<span class="string">&#x27;&#x27;</span>, <span class="number">1</span>, text=<span class="string">&#x27;line2&#x27;</span>, values=(<span class="string">&#x27;Jun&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="number">19</span>, <span class="number">170</span>, <span class="number">65</span>))</span><br><span class="line">tree.insert(<span class="string">&#x27;&#x27;</span>, <span class="number">2</span>, text=<span class="string">&#x27;line3&#x27;</span>, values=(<span class="string">&#x27;Coder&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="number">20</span>, <span class="number">170</span>, <span class="number">70</span>))</span><br><span class="line">tree.insert(<span class="string">&#x27;&#x27;</span>, <span class="number">3</span>, text=<span class="string">&#x27;line4&#x27;</span>, values=(<span class="string">&#x27;Che&#x27;</span>, <span class="string">&#x27;W&#x27;</span>, <span class="number">18</span>, <span class="number">165</span>, <span class="number">45</span>))</span><br><span class="line"><span class="comment"># 上面第一个参数为第一层级, 这里目前用不到, 后面树状结构中会用到</span></span><br></pre></td></tr></table></figure>

<div class="note success"><p>效果图如下</p></div>

<p><img data-src="https://upload-images.jianshu.io/upload_images/4122543-6852de768c9564c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="表格数据"></p>
<h3 id="树状数据"><a href="#树状数据" class="headerlink" title="树状数据"></a>树状数据</h3><p>树状数据这里指的是,类似文件夹的层级目录一样</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建表格</span></span><br><span class="line">tree = ttk.Treeview(window)</span><br><span class="line">tree.pack()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加一级树枝</span></span><br><span class="line">treeA1 = tree.insert(<span class="string">&#x27;&#x27;</span>, <span class="number">0</span>, <span class="string">&#x27;浙&#x27;</span>, text=<span class="string">&#x27;浙江&#x27;</span>, values=(<span class="string">&#x27;A1&#x27;</span>))</span><br><span class="line">treeA2 = tree.insert(<span class="string">&#x27;&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;鲁&#x27;</span>, text=<span class="string">&#x27;山东&#x27;</span>, values=(<span class="string">&#x27;A2&#x27;</span>))</span><br><span class="line">treeA3 = tree.insert(<span class="string">&#x27;&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;苏&#x27;</span>, text=<span class="string">&#x27;江苏&#x27;</span>, values=(<span class="string">&#x27;A3&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加二级树枝</span></span><br><span class="line">treeA1_1 = tree.insert(treeA1, <span class="number">0</span>, <span class="string">&#x27;H&#x27;</span>, text=<span class="string">&#x27;杭州&#x27;</span>, values=(<span class="string">&#x27;A1_1&#x27;</span>))</span><br><span class="line">treeA1_2 = tree.insert(treeA1, <span class="number">1</span>, <span class="string">&#x27;Z&#x27;</span>, text=<span class="string">&#x27;舟山&#x27;</span>, values=(<span class="string">&#x27;A1_2&#x27;</span>))</span><br><span class="line">treeA1_3 = tree.insert(treeA1, <span class="number">2</span>, <span class="string">&#x27;J&#x27;</span>, text=<span class="string">&#x27;嘉兴&#x27;</span>, values=(<span class="string">&#x27;A1_3&#x27;</span>))</span><br><span class="line"></span><br><span class="line">treeA2_1 = tree.insert(treeA2, <span class="number">0</span>, <span class="string">&#x27;N&#x27;</span>, text=<span class="string">&#x27;济南&#x27;</span>, values=(<span class="string">&#x27;A2_1&#x27;</span>))</span><br><span class="line">treeA2_2 = tree.insert(treeA2, <span class="number">1</span>, <span class="string">&#x27;L&#x27;</span>, text=<span class="string">&#x27;临沂&#x27;</span>, values=(<span class="string">&#x27;A2_2&#x27;</span>))</span><br><span class="line">treeA2_3 = tree.insert(treeA2, <span class="number">2</span>, <span class="string">&#x27;Q&#x27;</span>, text=<span class="string">&#x27;青岛&#x27;</span>, values=(<span class="string">&#x27;A2_3&#x27;</span>))</span><br><span class="line">treeA2_4 = tree.insert(treeA2, <span class="number">3</span>, <span class="string">&#x27;Y&#x27;</span>, text=<span class="string">&#x27;烟台&#x27;</span>, values=(<span class="string">&#x27;A2_4&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 三级树枝</span></span><br><span class="line">treeA1_1_1 = tree.insert(treeA1_1, <span class="number">0</span>, <span class="string">&#x27;G&#x27;</span>, text=<span class="string">&#x27;江干&#x27;</span>, values=(<span class="string">&#x27;A1_1_1&#x27;</span>))</span><br><span class="line">treeA1_1_1 = tree.insert(treeA1_1, <span class="number">1</span>, <span class="string">&#x27;X&#x27;</span>, text=<span class="string">&#x27;萧山&#x27;</span>, values=(<span class="string">&#x27;A1_1_2&#x27;</span>))</span><br></pre></td></tr></table></figure>

<div class="note warning"><p>注意事项</p></div>

<ul>
<li><code>insert</code>: 参数介绍<ul>
<li>参数1: 上一层级的目录</li>
<li>参数2: 当前数据在当前层级的中的索引值</li>
<li>参数3: 当前数据的标识, 所有层及数据的该标识不能相同, 否则报错</li>
<li>参数4: 显示的数据</li>
</ul>
</li>
<li>注: 所有数据的参数3(标识)不能相同</li>
</ul>
<div class="note success"><p>效果图如下</p></div>

<p><img data-src="https://upload-images.jianshu.io/upload_images/4122543-52e077a1441f83fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="树状数据"></p>
<h2 id="布局方式"><a href="#布局方式" class="headerlink" title="布局方式"></a>布局方式</h2><ul>
<li>所谓布局，就是指控制窗体容器中各个控件（组件）的位置关系。</li>
<li>在<code>tkinter</code>中目前存在的布局方式有三种: 绝对布局(<code>place</code>), 相对布局(<code>pack</code>)和表格布局(<code>grid</code>)</li>
</ul>
<h3 id="绝对布局"><a href="#绝对布局" class="headerlink" title="绝对布局"></a>绝对布局</h3><ul>
<li>绝对布局: 窗口的变化对位置没有影响</li>
<li>这里先介绍<code>place</code>布局涉及到的相关属性和函数</li>
</ul>
<h4 id="属性介绍"><a href="#属性介绍" class="headerlink" title="属性介绍"></a>属性介绍</h4><table>
<thead>
<tr>
<th>属性名</th>
<th>属性简析</th>
<th>取值</th>
<th>取值说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>anchor</code></td>
<td>锚点, 当可用空间大于所需求的尺寸时，决定组件被放置于容器的何处</td>
<td>N、E、S、W、NW、NE、SW、SE、<code>CENTER</code>(默认值)</td>
<td>表示八个方向以及中心</td>
</tr>
<tr>
<td><code>x、y</code></td>
<td>组件左上角的x、y坐标</td>
<td>整数，默认值0</td>
<td>绝对位置坐标，单位像素</td>
</tr>
<tr>
<td><code>relx/rely</code></td>
<td>组件相对于父容器的x、y坐标</td>
<td>0~1之间浮点数</td>
<td>相对位置，0.0表示左边缘（或上边缘），1.0表示右边缘（或下边缘）</td>
</tr>
<tr>
<td><code>width/height</code></td>
<td>组件的宽度、高度</td>
<td>非负整数</td>
<td>单位像素</td>
</tr>
<tr>
<td><code>relwidth、relheight</code></td>
<td>组件相对于父容器的宽度、高度</td>
<td>0~1之间浮点数</td>
<td>与<code>relx(rely)</code>取值相似</td>
</tr>
<tr>
<td><code>bordermode</code></td>
<td>如果设置为<code>INSIDE</code>，组件内部的大小和位置是相对的，不包括边框；如果是<code>OUTSIDE</code>，组件的外部大小是相对的，包括边框</td>
<td><code>INSIDE</code>(默认)、<code>OUTSIDE</code></td>
<td>可以使用常量<code>INSIDE</code>、<code>OUTSIDE</code>，也可以使用字符串形式<code>inside</code>、<code>outside</code></td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建四个label</span></span><br><span class="line">label1 = Label(window, text=<span class="string">&#x27;11111&#x27;</span>, bg=<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">label2 = Label(window, text=<span class="string">&#x27;22222&#x27;</span>, bg=<span class="string">&#x27;yellow&#x27;</span>)</span><br><span class="line">label3 = Label(window, text=<span class="string">&#x27;33333&#x27;</span>, bg=<span class="string">&#x27;blue&#x27;</span>)</span><br><span class="line">label4 = Label(window, text=<span class="string">&#x27;44444&#x27;</span>, bg=<span class="string">&#x27;orange&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绝对布局</span></span><br><span class="line">label1.place(x=<span class="number">10</span>, y=<span class="number">10</span>, width=<span class="number">200</span>)</span><br><span class="line">label2.place(x=<span class="number">30</span>, y=<span class="number">30</span>)</span><br><span class="line">label3.place(x=<span class="number">60</span>, y=<span class="number">61</span>)</span><br><span class="line">label4.place(x=<span class="number">91</span>, y=<span class="number">91</span>, width=<span class="number">200</span>, height=<span class="number">50</span>)</span><br></pre></td></tr></table></figure>

<p>如下图组件位置固定</p>
<div class="note success"><p>如下图组件位置固定</p></div>

<p><img data-src="https://upload-images.jianshu.io/upload_images/4122543-0bd83fa3642d52ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="place布局"></p>
<h4 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h4><p><code>place</code>类提供了下列函数（使用组件实例对象调用）</p>
<ul>
<li><code>place_slaves()</code>: 以列表方式返回本组件的所有子组件对象</li>
<li><code>place_configure(option=value)</code>: 给<code>place</code>布局管理器设置属性，使用属性<code>option=value</code>方式设置</li>
<li><code>propagate(boolean)</code>: 设置为<code>True</code>表示父组件的几何大小由子组件决定(默认值)，反之则无关</li>
<li><code>place_info()</code>: 返回<code>place</code>提供的选项所对应得值</li>
<li><code>grid_forget()</code>: <code>Unpack</code>组件，将组件隐藏并且忽略原有设置，对象依旧存在，可以用<code>pack(option, …)</code>，将其显示</li>
<li><code>location(x, y)</code>: <code>x/y</code>为以像素为单位的点，函数返回此点是否在单元格中，在哪个单元格中。返回单元格行列坐标，(-1, -1)表示不在其中</li>
<li><code>size()</code>: 返回组件所包含的单元格，揭示组件大小</li>
</ul>
<h3 id="相对布局"><a href="#相对布局" class="headerlink" title="相对布局"></a>相对布局</h3><h4 id="属性介绍-1"><a href="#属性介绍-1" class="headerlink" title="属性介绍"></a>属性介绍</h4><ul>
<li>相对布局: 组件位置或大小的变化会随着窗口的变化而变化</li>
<li>这里先介绍<code>pack</code>布局涉及到的相关属性和函数</li>
</ul>
<table>
<thead>
<tr>
<th>属性名</th>
<th>属性简析</th>
<th>取值</th>
<th>取值说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>fill</code></td>
<td>设置组件是否向水平或垂直方向填充</td>
<td><code>X、Y、BOTH和NONE</code></td>
<td><code>fill=X</code>(水平方向填充),<code>BOTH</code>(水平和垂直),<code>NONE</code>不填充</td>
</tr>
<tr>
<td><code>expand</code></td>
<td>设置组件是否展开</td>
<td>YES、NO（1、0）</td>
<td><code>expand=YES</code></td>
</tr>
<tr>
<td><code>side</code></td>
<td>设置组件的对齐方式</td>
<td><code>LEFT、TOP、RIGHT、BOTTOM</code></td>
<td>值为左、上、右、下</td>
</tr>
<tr>
<td><code>ipadx/ipady</code></td>
<td>设置x方向（或者y方向）内部间隙（子组件之间的间隔）</td>
<td>可设置数值，默认是0</td>
<td>非负整数，单位为像素</td>
</tr>
<tr>
<td><code>padx/pady</code></td>
<td>设置x方向（或者y方向）外部间隙（与之并列的组件之间的间隔）</td>
<td>可设置数值，默认是0</td>
<td>非负整数，单位为像素</td>
</tr>
<tr>
<td><code>anchor</code></td>
<td>锚选项，当可用空间大于所需求的尺寸时，决定组件被放置于容器的何处</td>
<td>N、E、S、W、NW、NE、SW、SE、CENTER（默认值为CENTER）</td>
<td>表示八个方向以及中心</td>
</tr>
</tbody></table>
<div class='note warning'><p>需要注意的是</p></div>

<p><code>expand</code>: 设置组件是否展开，当值为YES时，<code>side</code>选项无效。组件显示在父容器中心位置；若<code>fill</code>选项为<code>BOTH</code>,则填充父组件的剩余空间。默认为不展开</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建四个label</span></span><br><span class="line">label1 = Label(window, text=<span class="string">&#x27;11111&#x27;</span>, bg=<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">label2 = Label(window, text=<span class="string">&#x27;22222&#x27;</span>, bg=<span class="string">&#x27;yellow&#x27;</span>)</span><br><span class="line">label3 = Label(window, text=<span class="string">&#x27;33333&#x27;</span>, bg=<span class="string">&#x27;blue&#x27;</span>)</span><br><span class="line">label4 = Label(window, text=<span class="string">&#x27;44444&#x27;</span>, bg=<span class="string">&#x27;orange&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 布局</span></span><br><span class="line">label1.pack(side=LEFT, fill=Y)</span><br><span class="line">label2.pack(side=RIGHT, fill=Y)</span><br><span class="line">label3.pack(side=TOP, fill=X)</span><br><span class="line">label4.pack(side=BOTTOM, fill=X)</span><br></pre></td></tr></table></figure>


<div class="note success"><p>效果如图</p></div>

<p><img data-src="https://upload-images.jianshu.io/upload_images/4122543-fdb25319dfb38d3b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="pack"></p>
<h4 id="函数介绍"><a href="#函数介绍" class="headerlink" title="函数介绍"></a>函数介绍</h4><p><code>pack</code>类提供了下列函数（使用组件实例对象调用）</p>
<ul>
<li><code>pack_slaves()</code>: 以列表方式返回本组件的所有子组件对象</li>
<li><code>pack_configure(option=value)</code>: 给<code>pack</code>布局管理器设置属性，使用属性<code>option=value</code>方式设置</li>
<li><code>propagate(boolean)</code>: 设置为  True    表示父组件的几何大小由子组件决定（默认值），反之则无关。</li>
<li><code>ack_info()</code>:	返回pack提供的选项所对应得值。</li>
<li><code>pack_forget()</code>:	<code>Unpack</code>组件，将组件隐藏并且忽略原有设置，对象依旧存在，可以用<code>pack(option, …)</code>，将其显示。</li>
<li><code>location(x, y)</code>:	x, y为以像素为单位的点，函数返回此点是否在单元格中，在哪个单元格中。返回单元格行列坐标，(-1, -1)表示不在其中</li>
<li><code>size()</code>:	返回组件所包含的单元格，揭示组件大小</li>
</ul>
<h3 id="表格布局"><a href="#表格布局" class="headerlink" title="表格布局"></a>表格布局</h3><ul>
<li><code>grid</code>布局又被称作网格布局，是最被推荐使用的布局。</li>
<li>程序大多数都是矩形的界面，我们可以很容易把它划分为一个几行几列的网格，然后根据行号和列号，将组件放置于网格之中</li>
<li>使用<code>grid</code>布局时，需要在里面指定两个参数，分别用<code>row</code> 表示行，<code>column</code>表示列</li>
<li>需要注意的是<code>row</code>和<code>column</code>的序号都从0开始</li>
</ul>
<h4 id="属性介绍-2"><a href="#属性介绍-2" class="headerlink" title="属性介绍"></a>属性介绍</h4><table>
<thead>
<tr>
<th>属性名</th>
<th>属性简析</th>
<th>取值</th>
<th>取值说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>row/column</code></td>
<td><code>row</code>为行号，<code>column</code>为列号，设置将组件放置于第几行第几列</td>
<td>取值为行、列的序号，不是行数与列数</td>
<td><code>row</code>和<code>column</code> 的序号都从0 开始</td>
</tr>
<tr>
<td><code>sticky</code></td>
<td>设置组件在网格中的对齐方式</td>
<td><code>N、E、S、W、NW、NE、SW、SE、CENTER</code></td>
<td>类似于<code>pack</code>布局中的锚选项</td>
</tr>
<tr>
<td><code>rowspan</code></td>
<td>组件所跨越的行数</td>
<td>跨越的行数</td>
<td>取值为跨越占用的行数，而不是序号</td>
</tr>
<tr>
<td><code>columnspan</code></td>
<td>组件所跨越的列数</td>
<td>跨越的列数</td>
<td>取值为跨越占用的列数，而不是序号</td>
</tr>
<tr>
<td><code>ipadx/ipady</code></td>
<td>设置x方向（或者y方向）内部间隙（子组件之间的间隔）</td>
<td>可设置数值，默认是0</td>
<td>非负整数，单位为像素</td>
</tr>
<tr>
<td><code>padx/pady</code></td>
<td>设置x方向（或者y方向）外部间隙（与之并列的组件之间的间隔）</td>
<td>可设置数值，默认是0</td>
<td>非负整数，单位为像素</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建四个label</span></span><br><span class="line">label1 = Label(window, text=<span class="string">&#x27;11111&#x27;</span>, bg=<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">label2 = Label(window, text=<span class="string">&#x27;22222&#x27;</span>, bg=<span class="string">&#x27;yellow&#x27;</span>)</span><br><span class="line">label3 = Label(window, text=<span class="string">&#x27;33333&#x27;</span>, bg=<span class="string">&#x27;blue&#x27;</span>)</span><br><span class="line">label4 = Label(window, text=<span class="string">&#x27;44444&#x27;</span>, bg=<span class="string">&#x27;orange&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 布局</span></span><br><span class="line">label1.grid(row=<span class="number">0</span>, column=<span class="number">0</span>)</span><br><span class="line">label2.grid(row=<span class="number">0</span>, column=<span class="number">1</span>)</span><br><span class="line">label3.grid(row=<span class="number">1</span>, column=<span class="number">0</span>)</span><br><span class="line">label4.grid(row=<span class="number">1</span>, column=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<div class="note success"><p>效果如图</p></div>

<p><img data-src="https://upload-images.jianshu.io/upload_images/4122543-53d892edb51941ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="grid"></p>
<h4 id="函数介绍-1"><a href="#函数介绍-1" class="headerlink" title="函数介绍"></a>函数介绍</h4><p><code>grid</code>类提供了下列函数（使用组件实例对象调用）：</p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>grid_slaves()</code></td>
<td>以列表方式返回本组件的所有子组件对象。</td>
</tr>
<tr>
<td><code>grid_configure(option=value)</code></td>
<td>给<code>grid</code>布局管理器设置属性</td>
</tr>
<tr>
<td><code>grid_propagate(boolean)</code></td>
<td>设置为<code>True</code>表示父组件的几何大小由子组件决定(默认值)，反之则无关。</td>
</tr>
<tr>
<td><code>grid_info()</code></td>
<td>返回<code>grid</code>提供的选项所对应得值。</td>
</tr>
<tr>
<td><code>grid_forget()</code></td>
<td>将组件隐藏并且忽略原有设置，对象依旧存在</td>
</tr>
<tr>
<td><code>grid_location(x, y)</code></td>
<td><code>x/y</code>为以像素为单位的点，函数返回此点是否在单元格中</td>
</tr>
<tr>
<td><code>size()</code></td>
<td>返回组件所包含的单元格，揭示组件大小</td>
</tr>
</tbody></table>
<h2 id="鼠标和键盘事件"><a href="#鼠标和键盘事件" class="headerlink" title="鼠标和键盘事件"></a>鼠标和键盘事件</h2><ul>
<li>一个<code>Tkinter</code>应用生命周期中的大部分时间都处在一个消息循环中</li>
<li>它等待事件的发生: 事件可能是按键按下, 鼠标点击, 鼠标移动等. </li>
<li><code>Tkinter</code>提供了用以处理相关事件的机制, 处理函数可以被绑定给各个控件的各种事件</li>
<li>如果相关事件发生, <code>handler</code>函数会被触发, 事件对象<code>event</code>会传递给<code>handler</code>函数</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">button.bind(event, handler) </span><br></pre></td></tr></table></figure>

<h3 id="鼠标点击事件"><a href="#鼠标点击事件" class="headerlink" title="鼠标点击事件"></a>鼠标点击事件</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">buttonAction</span>(<span class="params">event</span>):</span><br><span class="line">    <span class="built_in">print</span>(event.x, event.y)</span><br><span class="line"></span><br><span class="line">button = Button(window, text=<span class="string">&#x27;这是一个按钮&#x27;</span>)</span><br><span class="line">button.bind(<span class="string">&#x27;&lt;Button-4&gt;&#x27;</span>, buttonAction)</span><br><span class="line">button.pack()</span><br></pre></td></tr></table></figure>


<div class='note info'><p>其中`event`的事件类型和描述如下</p></div>

<table>
<thead>
<tr>
<th>Event</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;Button-1&gt;</code></td>
<td>鼠标左键</td>
</tr>
<tr>
<td><code>&lt;Button-3&gt;</code></td>
<td>鼠标右键</td>
</tr>
<tr>
<td><code>&lt;Button-2&gt;</code></td>
<td>鼠标中键</td>
</tr>
<tr>
<td><code>&lt;Button-4&gt;</code></td>
<td>鼠标向上滚动</td>
</tr>
<tr>
<td><code>&lt;Button-5&gt;</code></td>
<td>鼠标向下滚动</td>
</tr>
<tr>
<td><code>&lt;Double-Button-1&gt;</code></td>
<td>鼠标左键双击</td>
</tr>
<tr>
<td><code>&lt;Double-Button-3&gt;</code></td>
<td>鼠标右键双击</td>
</tr>
<tr>
<td><code>&lt;Double-Button-2&gt;</code></td>
<td>鼠标中键双击</td>
</tr>
<tr>
<td><code>&lt;Triple-Button-1&gt;</code></td>
<td>鼠标左键三击</td>
</tr>
<tr>
<td><code>&lt;Triple-Button-3&gt;</code></td>
<td>鼠标右键三击</td>
</tr>
<tr>
<td><code>&lt;Triple-Button-2&gt;</code></td>
<td>鼠标中键三击</td>
</tr>
</tbody></table>
<h3 id="鼠标在某个按键被按下后的移动事件"><a href="#鼠标在某个按键被按下后的移动事件" class="headerlink" title="鼠标在某个按键被按下后的移动事件"></a>鼠标在某个按键被按下后的移动事件</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">label = Label(window, text=<span class="string">&#x27;https://www.titanjun.top&#x27;</span>, bg=<span class="string">&#x27;orange&#x27;</span>)</span><br><span class="line">label.place(x=<span class="number">100</span>, y=<span class="number">50</span>, height=<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">labelAction</span>(<span class="params">event</span>):</span><br><span class="line">    <span class="built_in">print</span>(event.x, event.y)</span><br><span class="line">label.bind(<span class="string">&#x27;&lt;B1-Motion&gt;&#x27;</span>, labelAction)</span><br></pre></td></tr></table></figure>

<div class='note info'><p>其中`event`的事件类型和描述如下</p></div>

<table>
<thead>
<tr>
<th>Event</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;B1-Motion&gt;</code></td>
<td>左键移动</td>
</tr>
<tr>
<td><code>&lt;B3-Motion&gt;</code></td>
<td>右键移动</td>
</tr>
<tr>
<td><code>&lt;B2-Motion&gt;</code></td>
<td>中键移动</td>
</tr>
</tbody></table>
<h3 id="按钮点击释放事件"><a href="#按钮点击释放事件" class="headerlink" title="按钮点击释放事件"></a>按钮点击释放事件</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">label = Label(window, text=<span class="string">&#x27;https://www.titanjun.top&#x27;</span>, bg=<span class="string">&#x27;orange&#x27;</span>)</span><br><span class="line">label.place(x=<span class="number">100</span>, y=<span class="number">50</span>, height=<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">labelAction</span>(<span class="params">event</span>):</span><br><span class="line">    <span class="built_in">print</span>(event.x, event.y)</span><br><span class="line">label.bind(<span class="string">&#x27;&lt;ButtonRelease-1&gt;&#x27;</span>, labelAction)</span><br></pre></td></tr></table></figure>

<div class='note info'><p>其中`event`的事件类型和描述如下</p></div>

<table>
<thead>
<tr>
<th>Event</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;ButtonRelease-1&gt;</code></td>
<td>释放鼠标左键</td>
</tr>
<tr>
<td><code>&lt;ButtonRelease-3&gt;</code></td>
<td>释放鼠标右键</td>
</tr>
<tr>
<td><code>&lt;ButtonRelease-2&gt;</code></td>
<td>释放鼠标中键</td>
</tr>
</tbody></table>
<div class='note warning'><p>需要注意的是</p></div>

<ul>
<li>以上鼠标操作中, 苹果鼠标没有中键这一说, 所以在苹果鼠标操作中</li>
<li>正常鼠标的中键操作(例如<code>&lt;Button-2&gt;</code>等<code>-2</code>操作), 响应苹果鼠标的右键操作</li>
<li>正常鼠标的右键操作(例如<code>&lt;Button-3&gt;</code>等<code>-3</code>操作), 在苹果鼠标中无响应</li>
</ul>
<h3 id="鼠标进入-x2F-离开控件事件"><a href="#鼠标进入-x2F-离开控件事件" class="headerlink" title="鼠标进入&#x2F;离开控件事件"></a>鼠标进入&#x2F;离开控件事件</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 按钮点击释放事件</span></span><br><span class="line">label3 = Label(window, text=<span class="string">&#x27;加油: https://www.titanjun.top&#x27;</span>, bg=<span class="string">&#x27;yellow&#x27;</span>)</span><br><span class="line">label3.place(x=<span class="number">100</span>, y=<span class="number">150</span>, height=<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">labelAction</span>(<span class="params">event</span>):</span><br><span class="line">    <span class="built_in">print</span>(event.x, event.y)</span><br><span class="line">label3.bind(<span class="string">&#x27;&lt;Leave&gt;&#x27;</span>, labelAction)</span><br></pre></td></tr></table></figure>


<div class='note info'><p>其中`event`的事件类型和描述如下</p></div>

<table>
<thead>
<tr>
<th>Event</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;Enter&gt;</code></td>
<td>鼠标光标进入控件时触发</td>
</tr>
<tr>
<td><code>&lt;Leave&gt;</code></td>
<td>鼠标光标离开控件时触发</td>
</tr>
</tbody></table>
<h3 id="键盘响应事件"><a href="#键盘响应事件" class="headerlink" title="键盘响应事件"></a>键盘响应事件</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 响应所有的按键</span></span><br><span class="line">label = Label(window, text=<span class="string">&#x27;https://www.titanjun.top&#x27;</span>, bg=<span class="string">&#x27;orange&#x27;</span>)</span><br><span class="line"><span class="comment"># 设置焦点</span></span><br><span class="line">label.focus_set()</span><br><span class="line">label.place(x=<span class="number">100</span>, y=<span class="number">50</span>, height=<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">labelAction</span>(<span class="params">event</span>):</span><br><span class="line">    <span class="built_in">print</span>(event.char, event.keycode)</span><br><span class="line">label.bind(<span class="string">&#x27;&lt;Key&gt;&#x27;</span>, labelAction)</span><br></pre></td></tr></table></figure>

<div class='note primary'><p>其中`event`的事件类型和描述如下</p></div>


<table>
<thead>
<tr>
<th>Event</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;Key&gt;</code></td>
<td>响应所有的按键(按下)</td>
</tr>
<tr>
<td><code>&lt;KeyRelease&gt;</code></td>
<td>响应所有的按键(松开)</td>
</tr>
<tr>
<td><code>&lt;FocusIn&gt;</code></td>
<td>控件或控件的子空间获得键盘焦点.</td>
</tr>
<tr>
<td><code>&lt;FocusOut&gt;</code></td>
<td>控件丢失键盘焦点 (焦点移动到另一个控件).</td>
</tr>
</tbody></table>
<h3 id="指定按键操作"><a href="#指定按键操作" class="headerlink" title="指定按键操作"></a>指定按键操作</h3><table>
<thead>
<tr>
<th>Event</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;Return&gt;/&lt;Enter&gt;</code></td>
<td>只有回车键响应</td>
</tr>
<tr>
<td><code>&lt;Escape&gt;</code></td>
<td>esc键</td>
</tr>
<tr>
<td><code>&lt;space&gt;</code></td>
<td>空格键</td>
</tr>
<tr>
<td><code>&lt;Tab&gt;</code></td>
<td>Tab键</td>
</tr>
<tr>
<td><code>&lt;Up&gt;/&lt;Down&gt;/&lt;Left&gt;/&lt;Right&gt;</code></td>
<td>上下左右键</td>
</tr>
<tr>
<td><code>&lt;Shitf_L&gt;/&lt;Shift_R&gt;</code></td>
<td>左右<code>Shift</code>键(类似有左右两个键的, 添加<code>_L/_R</code>区分)</td>
</tr>
<tr>
<td><code>&lt;BackSpace&gt;</code></td>
<td>退格</td>
</tr>
<tr>
<td><code>&lt;a&gt;/&lt;b&gt;</code></td>
<td>指定的小写字母键</td>
</tr>
<tr>
<td><code>&lt;A&gt;/&lt;Z&gt;</code></td>
<td>指定的大写字母键</td>
</tr>
<tr>
<td><code>&lt;Control-Alt-a&gt;</code></td>
<td>组合键(可识别任意组合键)</td>
</tr>
</tbody></table>
<div class='note warning'><p>需要注意的是</p></div>

<p>识别组合键时, 一般是按下组合键的最后一个键才会触发操作</p>
<h3 id="event事件的相应参数"><a href="#event事件的相应参数" class="headerlink" title="event事件的相应参数"></a><code>event</code>事件的相应参数</h3><table>
<thead>
<tr>
<th>时间属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>char</code></td>
<td>从键盘输入的和按键事件的相关字符</td>
</tr>
<tr>
<td><code>keycode</code></td>
<td>从按键输入的和按键事件的键代码(ASCII码)</td>
</tr>
<tr>
<td><code>keysym</code></td>
<td>从按键输入的和按键事件的键符号(即字符)</td>
</tr>
<tr>
<td><code>num</code></td>
<td>按键数字(1, 2, 3)表明按下的是哪个鼠标键</td>
</tr>
<tr>
<td><code>widget</code></td>
<td>触发这个事件的小构件对象</td>
</tr>
<tr>
<td><code>x和y</code></td>
<td>当前鼠标在小构件中以像素为单位的位置</td>
</tr>
<tr>
<td><code>x_root和y_root</code></td>
<td>当前鼠标相对于屏幕左上角的以像素为单位的位置</td>
</tr>
</tbody></table>
<hr>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Tkinter</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS9之UIStackView的使用</title>
    <url>/post/b2ac06fb.html</url>
    <content><![CDATA[<p>苹果在iOS9新增了一个简易的布局控件UIStackView,它是一个基于 Auto Layout 的抽象层从而使布局属性的创建简单化,它可以将一组 UIView 视图进行垂直或水平方向的排列。</p>
<ul>
<li>UIStackView 既可以用代码编写也可以在 Interface Builder 中设计(简易xib更方便适用)。</li>
<li>你可以在一个主 UIStackView 中嵌套 UIStackView 从而让视图精确放置到相应的位置</li>
</ul>
<span id="more"></span>

<blockquote>
<p>下面就具体介绍一下UIStackView的一些方法和属性</p>
</blockquote>
<h2 id="一-方法"><a href="#一-方法" class="headerlink" title="一.方法"></a>一.方法</h2><h3 id="1-初始化数组"><a href="#1-初始化数组" class="headerlink" title="1.初始化数组"></a>1.初始化数组</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//OC中</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithArrangedSubviews:(<span class="built_in">NSArray</span>&lt;__kindof <span class="built_in">UIView</span> *&gt; *)views;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Swift</span></span><br><span class="line"></span><br><span class="line">let stackView1 = <span class="built_in">UIStackView</span>(arrangedSubviews: subViews)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-添加子视图"><a href="#2-添加子视图" class="headerlink" title="2.添加子视图"></a>2.添加子视图</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//OC</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)addArrangedSubview:(<span class="built_in">UIView</span> *)view;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Swift</span></span><br><span class="line"></span><br><span class="line">stackView.addArrangedSubview(<span class="built_in">UIView</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-移除子视图"><a href="#3-移除子视图" class="headerlink" title="3.移除子视图"></a>3.移除子视图</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//OC</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)removeArrangedSubview:(<span class="built_in">UIView</span> *)view;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Swift</span></span><br><span class="line"></span><br><span class="line">stackView1.removeArrangedSubview(<span class="built_in">UIView</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4-根据下标插入子视图"><a href="#4-根据下标插入子视图" class="headerlink" title="4.根据下标插入子视图"></a>4.根据下标插入子视图</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//OC</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)insertArrangedSubview:(<span class="built_in">UIView</span> *)view atIndex:(<span class="built_in">NSUInteger</span>)stackIndex;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Swift</span></span><br><span class="line"></span><br><span class="line">stackView1.insertArrangedSubview(<span class="built_in">UIView</span>, atIndex: Int)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="二-属性"><a href="#二-属性" class="headerlink" title="二.属性"></a>二.属性</h2><h3 id="1-布局方向"><a href="#1-布局方向" class="headerlink" title="1.布局方向"></a>1.布局方向</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">stackView.axis = .Horizontal</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************/</span></span><br><span class="line"></span><br><span class="line">Horizontal -&gt; <span class="built_in">UILayoutConstraintAxisHorizontal</span></span><br><span class="line"></span><br><span class="line">水平方向布局</span><br><span class="line"></span><br><span class="line">Vertical  -&gt; <span class="built_in">UILayoutConstraintAxisVertical</span></span><br><span class="line"></span><br><span class="line">垂直方向布局</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-内容物填充样式"><a href="#2-内容物填充样式" class="headerlink" title="2.内容物填充样式"></a>2.内容物填充样式</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">stackView.distribution = .FillEqually</span><br><span class="line"></span><br><span class="line"><span class="comment">/****************/</span></span><br><span class="line"></span><br><span class="line">Fill -&gt; <span class="built_in">UIStackViewDistributionFill</span></span><br><span class="line"></span><br><span class="line">填充整个<span class="built_in">UIStackView</span>，并且根据内部子视图尺寸对子视图尺寸进行动态调整。</span><br><span class="line"></span><br><span class="line">Fill Equally -&gt; <span class="built_in">UIStackViewDistributionFillEqually</span></span><br><span class="line"></span><br><span class="line">根据视图大小平均分配<span class="built_in">UIStackView</span>尺寸，等比例填充<span class="built_in">UIStackView</span>，过程中会根据分配的大小改变子视图尺寸。</span><br><span class="line"></span><br><span class="line">Fill Proportionally -&gt; <span class="built_in">UIStackViewDistributionFillProportionally</span></span><br><span class="line"></span><br><span class="line">根据之前的比例填充<span class="built_in">UIStackView</span>。</span><br><span class="line"></span><br><span class="line">Equal Spacing -&gt; <span class="built_in">UIStackViewDistributionEqualSpacing</span></span><br><span class="line"></span><br><span class="line">填充整个<span class="built_in">UIStackView</span>，子视图没有占满<span class="built_in">UIStackView</span>将会用空白平均填充子视图中间的间距，超出<span class="built_in">UIStackView</span>将会根据arrangedSubviews数组下标压缩子视图。</span><br><span class="line"></span><br><span class="line">Equal Centering -&gt; <span class="built_in">UIStackViewDistributionEqualCentering</span></span><br><span class="line"></span><br><span class="line">平均分配子视图得到每个视图的中心点，使用这个中心点来布局每个子视图，并且保持spacing距离，超出将会重新布局子视图，并压缩部分子视图。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-视图填充样式"><a href="#3-视图填充样式" class="headerlink" title="3.视图填充样式"></a>3.视图填充样式</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">stackView.alignment = .Fill</span><br><span class="line"></span><br><span class="line"><span class="comment">/****************/</span></span><br><span class="line"></span><br><span class="line">Fill -&gt; <span class="built_in">UIStackViewAlignmentFill</span></span><br><span class="line"></span><br><span class="line">视图纵向填充</span><br><span class="line"></span><br><span class="line">Top -&gt; <span class="built_in">UIStackViewAlignmentTop</span></span><br><span class="line"></span><br><span class="line">视图向上对其(适用于Horizontal模式)</span><br><span class="line"></span><br><span class="line">Center -&gt; <span class="built_in">UIStackViewAlignmentCenter</span></span><br><span class="line"></span><br><span class="line">视图居中对其</span><br><span class="line"></span><br><span class="line">Bottom -&gt; <span class="built_in">UIStackViewAlignmentBottom</span></span><br><span class="line"></span><br><span class="line">视图向下对其(适用于Horizontal模式)</span><br><span class="line"></span><br><span class="line">First Baseline -&gt; <span class="built_in">UIStackViewAlignmentFirstBaseline</span></span><br><span class="line"></span><br><span class="line">根据上方基线布局所有子视图的y值(适用于Horizontal模式)</span><br><span class="line"></span><br><span class="line">Last Baseline -&gt; <span class="built_in">UIStackViewAlignmentLastBaseline</span></span><br><span class="line"></span><br><span class="line">根据下方基线布局所有子视图的y值(适用于Horizontal模式)</span><br><span class="line"></span><br><span class="line">trailing -&gt; <span class="built_in">UIStackViewAlignmentTrailing</span></span><br><span class="line"></span><br><span class="line">视图向左对齐(适用于Vertical模式)</span><br><span class="line"></span><br><span class="line">leading -&gt; <span class="built_in">UIStackViewAlignmentLeading</span></span><br><span class="line"></span><br><span class="line">视图向右对齐(适用于Vertical模式)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4-子控件之间最小距离"><a href="#4-子控件之间最小距离" class="headerlink" title="4.子控件之间最小距离"></a>4.子控件之间最小距离</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">stackView.spacing = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/****************/</span></span><br><span class="line"></span><br><span class="line">spacing -&gt; <span class="built_in">CGFloat</span> spacing</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5-基线相对布局"><a href="#5-基线相对布局" class="headerlink" title="5.基线相对布局"></a>5.基线相对布局</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public var baselineRelativeArrangement: Bool</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果YES，则从顶视图的最后基线到底视图的顶部测量两个视图之间的垂直间距。</p>
</blockquote>
<h3 id="6-边界相对布局"><a href="#6-边界相对布局" class="headerlink" title="6.边界相对布局"></a>6.边界相对布局</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public var layoutMarginsRelativeArrangement: Bool</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>决定了 stack 视图平铺其管理的视图时是否要参照它的布局边距，选中 Layout Margins Relative 将相对于标准边界空白来调整subview位置</p>
</blockquote>
<p>##Xib创建</p>
<ul>
<li>择UIStackView控件直接拖到XIB中。可以选择Horizontal和Vertical两个方向的UIStackView，也可以在拖到XIB中之后手动修改。</li>
<li>父视图可以将UIStackView作为子视图来进行多层UIStackView嵌套，这也是苹果推荐的做法。</li>
</ul>
<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-477dcb03e40d295a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="示例图片1.png"></p>
<blockquote>
<ul>
<li>打开右侧设置面板来设置UIStackView的一些对应属性，达到更好的布局效果。</li>
</ul>
</blockquote>
<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-002b7b5799b9aeee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="示例图片2.png"></p>
<blockquote>
<ul>
<li>除了上面的方法也可以在XIB中直接选择多个View，然后点击右下方的Stack按钮，系统会自动推断布局方式,平均分配空间布局，帮我们自动布局子视图，我们可以在系统布局之后在手动进行调整。</li>
</ul>
</blockquote>
<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-304660a3ee85070d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="示例图片3.png"></p>
<blockquote>
<p>作为一枚小菜鸟,不足之处还望大家多多指正,互相学起,共同进步!</p>
</blockquote>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>UIStackView</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS13适配深色模式(Dark Mode)</title>
    <url>/post/da0e549f.html</url>
    <content><![CDATA[<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/ios/ios13icon.jpeg" alt="iOS 13"></p>
<span id="more"></span>


<ul>
<li>好像大概也许是一年前, <code>Mac OS</code>系统发布了深色模式外观, 看着挺刺激, 时至今日用着也还挺爽的</li>
<li>终于, 随着<code>iPhone11</code>等新手机的发售, <code>iOS 13</code>系统也正式发布了, 伴随着手机版的深色模式也出现在了大众视野</li>
<li>我们这些<code>iOS</code>程序猿也有事情做了, 原有项目适配<code>iOS13</code>系统, 适配<code>Dark Mode</code>深色模式</li>
<li>虽然现在并没有要求强制适配<code>Dark Mode</code>, 但是<code>DarK</code>适配却也迫在眉睫</li>
</ul>
<blockquote>
<p>Apps on iOS 13 are expected to support dark mode Use system colors and materials Create your own dynamic colors and images Leverage flexible infrastructure</p>
</blockquote>
<h2 id="获取当前模式"><a href="#获取当前模式" class="headerlink" title="获取当前模式"></a>获取当前模式</h2><blockquote>
<p>提供两种方式设置手机当前外观模式</p>
</blockquote>
<ul>
<li>设置 –&gt; 显示与亮度</li>
<li>控制中心, 长按亮度调节按钮</li>
</ul>
<h3 id="获取当前模式-1"><a href="#获取当前模式-1" class="headerlink" title="获取当前模式"></a>获取当前模式</h3><p>我们需要选获取到当前出于什么模式, 在根据不同的模式进行适配, <code>iOS 13</code>中新增了获取当前模式的<code>API</code></p>
<blockquote>
<p>Swift</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取当前模式</span></span><br><span class="line"><span class="keyword">let</span> currentMode <span class="operator">=</span> <span class="type">UITraitCollection</span>.current.userInterfaceStyle</span><br><span class="line"><span class="keyword">if</span> (currentMode <span class="operator">==</span> .dark) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;深色模式&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (currentMode <span class="operator">==</span> .light) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;浅色模式&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;未知模式&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">var</span> userInterfaceStyle: <span class="type">UIUserInterfaceStyle</span> &#123; <span class="keyword">get</span> &#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">UIUserInterfaceStyle</span> : <span class="title class_">Int</span> &#123;</span><br><span class="line">    <span class="comment">// 未指明的</span></span><br><span class="line">    <span class="keyword">case</span> unspecified</span><br><span class="line">    <span class="comment">// 浅色模式</span></span><br><span class="line">    <span class="keyword">case</span> light</span><br><span class="line">    <span class="comment">// 深色模式</span></span><br><span class="line">    <span class="keyword">case</span> dark</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>OC语言</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (@available(iOS <span class="number">13.0</span>, *)) &#123;</span><br><span class="line">    <span class="built_in">UIUserInterfaceStyle</span> mode = <span class="built_in">UITraitCollection</span>.currentTraitCollection.userInterfaceStyle;</span><br><span class="line">    <span class="keyword">if</span> (mode == <span class="built_in">UIUserInterfaceStyleDark</span>) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;深色模式&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mode == <span class="built_in">UIUserInterfaceStyleLight</span>) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;浅色模式&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;未知模式&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 各种枚举值</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">UIUserInterfaceStyle</span>) &#123;</span><br><span class="line">    <span class="built_in">UIUserInterfaceStyleUnspecified</span>,</span><br><span class="line">    <span class="built_in">UIUserInterfaceStyleLight</span>,</span><br><span class="line">    <span class="built_in">UIUserInterfaceStyleDark</span>,</span><br><span class="line">&#125; API_AVAILABLE(tvos(<span class="number">10.0</span>)) API_AVAILABLE(ios(<span class="number">12.0</span>)) API_UNAVAILABLE(watchos);</span><br></pre></td></tr></table></figure>

<h3 id="监听系统模式的变化"><a href="#监听系统模式的变化" class="headerlink" title="监听系统模式的变化"></a>监听系统模式的变化</h3><p>在<code>iOS13</code>系统中, <code>UIViewController</code>遵循了两个协议: <code>UITraitEnvironment</code>和<code>UIContentContainer</code>协议</p>
<p>在<code>UITraitEnvironment</code>协议中, 为我们提供了一个监听当前模式变化的方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">UITraitEnvironment</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="comment">// 当前模式</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">UITraitCollection</span> *traitCollection API_AVAILABLE(ios(<span class="number">8.0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写该方法监听模式的改变</span></span><br><span class="line">- (<span class="type">void</span>)traitCollectionDidChange:(<span class="keyword">nullable</span> <span class="built_in">UITraitCollection</span> *)previousTraitCollection API_AVAILABLE(ios(<span class="number">8.0</span>));</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">protocol</span> <span class="title class_">UITraitEnvironment</span> : <span class="title class_">NSObjectProtocol</span> &#123;</span><br><span class="line">    <span class="comment">// 当前模式</span></span><br><span class="line">    <span class="keyword">@available</span>(<span class="keyword">iOS</span> <span class="number">8.0</span>, <span class="operator">*</span>)</span><br><span class="line">    <span class="keyword">var</span> traitCollection: <span class="type">UITraitCollection</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写该方法监听模式的改变</span></span><br><span class="line">    <span class="keyword">@available</span>(<span class="keyword">iOS</span> <span class="number">8.0</span>, <span class="operator">*</span>)</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">traitCollectionDidChange</span>(<span class="keyword">_</span> <span class="params">previousTraitCollection</span>: <span class="type">UITraitCollection</span>?)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方法</span></span><br><span class="line"><span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">traitCollectionDidChange</span>(<span class="keyword">_</span> <span class="params">previousTraitCollection</span>: <span class="type">UITraitCollection</span>?) &#123;</span><br><span class="line">    <span class="keyword">super</span>.traitCollectionDidChange(previousTraitCollection)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 每次模式改变的时候, 这里都会执行</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;模式改变了&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="颜色相关适配"><a href="#颜色相关适配" class="headerlink" title="颜色相关适配"></a>颜色相关适配</h2><ul>
<li>不同模式的适配主要涉及颜色和图片两个方面的适配</li>
<li>其中颜色适配, 包括相关背景色和字体颜色</li>
<li>当系统模式切换的时候, 我们不需要如何操作, 系统会自动渲染页面, 只需要做好不同模式的颜色和图片即可</li>
</ul>
<h3 id="UIColor"><a href="#UIColor" class="headerlink" title="UIColor"></a>UIColor</h3><ul>
<li><code>iOS13</code>之前<code>UIColor</code>只能表示一种颜色，从<code>iOS13</code>开始<code>UIColor</code>是一个动态的颜色，在不同模式下可以分别代表不同的颜色</li>
<li>下面是<code>iOS13</code>系统提供的动态颜色种类, 使用以下颜色值, 在模式切换时, 则不需要做特殊处理</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UIColor</span> (<span class="title">UIColorSystemColors</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark System colors</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">class</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">UIColor</span> *systemRedColor          API_AVAILABLE(ios(<span class="number">7.0</span>), tvos(<span class="number">9.0</span>)) API_UNAVAILABLE(watchos);</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">class</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">UIColor</span> *systemGreenColor        API_AVAILABLE(ios(<span class="number">7.0</span>), tvos(<span class="number">9.0</span>)) API_UNAVAILABLE(watchos);</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">class</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">UIColor</span> *systemBlueColor         API_AVAILABLE(ios(<span class="number">7.0</span>), tvos(<span class="number">9.0</span>)) API_UNAVAILABLE(watchos);</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">class</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">UIColor</span> *systemOrangeColor       API_AVAILABLE(ios(<span class="number">7.0</span>), tvos(<span class="number">9.0</span>)) API_UNAVAILABLE(watchos);</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">class</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">UIColor</span> *systemYellowColor       API_AVAILABLE(ios(<span class="number">7.0</span>), tvos(<span class="number">9.0</span>)) API_UNAVAILABLE(watchos);</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">class</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">UIColor</span> *systemPinkColor         API_AVAILABLE(ios(<span class="number">7.0</span>), tvos(<span class="number">9.0</span>)) API_UNAVAILABLE(watchos);</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">class</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">UIColor</span> *systemPurpleColor       API_AVAILABLE(ios(<span class="number">9.0</span>), tvos(<span class="number">9.0</span>)) API_UNAVAILABLE(watchos);</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">class</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">UIColor</span> *systemTealColor         API_AVAILABLE(ios(<span class="number">7.0</span>), tvos(<span class="number">9.0</span>)) API_UNAVAILABLE(watchos);</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">class</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">UIColor</span> *systemIndigoColor       API_AVAILABLE(ios(<span class="number">13.0</span>), tvos(<span class="number">13.0</span>)) API_UNAVAILABLE(watchos);</span><br><span class="line"><span class="comment">// 灰色种类, 在Light模式下, systemGray6Color更趋向于白色</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">class</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">UIColor</span> *systemGrayColor         API_AVAILABLE(ios(<span class="number">7.0</span>), tvos(<span class="number">9.0</span>)) API_UNAVAILABLE(watchos);</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">class</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">UIColor</span> *systemGray2Color        API_AVAILABLE(ios(<span class="number">13.0</span>)) API_UNAVAILABLE(tvos, watchos);</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">class</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">UIColor</span> *systemGray3Color        API_AVAILABLE(ios(<span class="number">13.0</span>)) API_UNAVAILABLE(tvos, watchos);</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">class</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">UIColor</span> *systemGray4Color        API_AVAILABLE(ios(<span class="number">13.0</span>)) API_UNAVAILABLE(tvos, watchos);</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">class</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">UIColor</span> *systemGray5Color        API_AVAILABLE(ios(<span class="number">13.0</span>)) API_UNAVAILABLE(tvos, watchos);</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">class</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">UIColor</span> *systemGray6Color        API_AVAILABLE(ios(<span class="number">13.0</span>)) API_UNAVAILABLE(tvos, watchos);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark Foreground colors</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">class</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">UIColor</span> *labelColor              API_AVAILABLE(ios(<span class="number">13.0</span>), tvos(<span class="number">13.0</span>)) API_UNAVAILABLE(watchos);</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">class</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">UIColor</span> *secondaryLabelColor     API_AVAILABLE(ios(<span class="number">13.0</span>), tvos(<span class="number">13.0</span>)) API_UNAVAILABLE(watchos);</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">class</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">UIColor</span> *tertiaryLabelColor      API_AVAILABLE(ios(<span class="number">13.0</span>), tvos(<span class="number">13.0</span>)) API_UNAVAILABLE(watchos);</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">class</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">UIColor</span> *quaternaryLabelColor    API_AVAILABLE(ios(<span class="number">13.0</span>), tvos(<span class="number">13.0</span>)) API_UNAVAILABLE(watchos);</span><br><span class="line"><span class="comment">// 系统链接的前景色</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">class</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">UIColor</span> *linkColor               API_AVAILABLE(ios(<span class="number">13.0</span>), tvos(<span class="number">13.0</span>)) API_UNAVAILABLE(watchos);</span><br><span class="line"><span class="comment">// 占位文字的颜色</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">class</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">UIColor</span> *placeholderTextColor    API_AVAILABLE(ios(<span class="number">13.0</span>), tvos(<span class="number">13.0</span>)) API_UNAVAILABLE(watchos);</span><br><span class="line"><span class="comment">// 边框或者分割线的颜色</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">class</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">UIColor</span> *separatorColor          API_AVAILABLE(ios(<span class="number">13.0</span>), tvos(<span class="number">13.0</span>)) API_UNAVAILABLE(watchos);</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">class</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">UIColor</span> *opaqueSeparatorColor    API_AVAILABLE(ios(<span class="number">13.0</span>), tvos(<span class="number">13.0</span>)) API_UNAVAILABLE(watchos);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark Background colors</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">class</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">UIColor</span> *systemBackgroundColor                   API_AVAILABLE(ios(<span class="number">13.0</span>)) API_UNAVAILABLE(tvos, watchos);</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">class</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">UIColor</span> *secondarySystemBackgroundColor          API_AVAILABLE(ios(<span class="number">13.0</span>)) API_UNAVAILABLE(tvos, watchos);</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">class</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">UIColor</span> *tertiarySystemBackgroundColor           API_AVAILABLE(ios(<span class="number">13.0</span>)) API_UNAVAILABLE(tvos, watchos);</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">class</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">UIColor</span> *systemGroupedBackgroundColor            API_AVAILABLE(ios(<span class="number">13.0</span>)) API_UNAVAILABLE(tvos, watchos);</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">class</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">UIColor</span> *secondarySystemGroupedBackgroundColor   API_AVAILABLE(ios(<span class="number">13.0</span>)) API_UNAVAILABLE(tvos, watchos);</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">class</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">UIColor</span> *tertiarySystemGroupedBackgroundColor    API_AVAILABLE(ios(<span class="number">13.0</span>)) API_UNAVAILABLE(tvos, watchos);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark Fill colors</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">class</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">UIColor</span> *systemFillColor                         API_AVAILABLE(ios(<span class="number">13.0</span>)) API_UNAVAILABLE(tvos, watchos);</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">class</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">UIColor</span> *secondarySystemFillColor                API_AVAILABLE(ios(<span class="number">13.0</span>)) API_UNAVAILABLE(tvos, watchos);</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">class</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">UIColor</span> *tertiarySystemFillColor                 API_AVAILABLE(ios(<span class="number">13.0</span>)) API_UNAVAILABLE(tvos, watchos);</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">class</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">UIColor</span> *quaternarySystemFillColor               API_AVAILABLE(ios(<span class="number">13.0</span>)) API_UNAVAILABLE(tvos, watchos);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark Other colors</span></span><br><span class="line"><span class="comment">// 这两个是非动态颜色值</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">class</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">UIColor</span> *lightTextColor API_UNAVAILABLE(tvos);    <span class="comment">// for a dark background</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">class</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">UIColor</span> *darkTextColor API_UNAVAILABLE(tvos);     <span class="comment">// for a light background</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">class</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">UIColor</span> *groupTableViewBackgroundColor API_DEPRECATED_WITH_REPLACEMENT(<span class="string">&quot;systemGroupedBackgroundColor&quot;</span>, ios(<span class="number">2.0</span>, <span class="number">13.0</span>), tvos(<span class="number">13.0</span>, <span class="number">13.0</span>));</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">class</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">UIColor</span> *viewFlipsideBackgroundColor API_DEPRECATED(<span class="string">&quot;&quot;</span>, ios(<span class="number">2.0</span>, <span class="number">7.0</span>)) API_UNAVAILABLE(tvos);</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">class</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">UIColor</span> *scrollViewTexturedBackgroundColor API_DEPRECATED(<span class="string">&quot;&quot;</span>, ios(<span class="number">3.2</span>, <span class="number">7.0</span>)) API_UNAVAILABLE(tvos);</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">class</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">UIColor</span> *underPageBackgroundColor API_DEPRECATED(<span class="string">&quot;&quot;</span>, ios(<span class="number">5.0</span>, <span class="number">7.0</span>)) API_UNAVAILABLE(tvos);</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<ul>
<li>上面系统提供的这些颜色种类, 根本不能满足我们正常开发的需要, 大部分的颜色值也都是自定义</li>
<li>系统也为我们提供了创建自定义颜色的方法</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@available</span>(<span class="keyword">iOS</span> <span class="number">13.0</span>, <span class="operator">*</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">init</span>(<span class="params">dynamicProvider</span>: <span class="keyword">@escaping</span> (<span class="type">UITraitCollection</span>) -&gt; <span class="type">UIColor</span>)</span><br></pre></td></tr></table></figure>

<p>在OC中</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">UIColor</span> *)colorWithDynamicProvider:(<span class="built_in">UIColor</span> * (^)(<span class="built_in">UITraitCollection</span> *traitCollection))dynamicProvider API_AVAILABLE(ios(<span class="number">13.0</span>), tvos(<span class="number">13.0</span>)) API_UNAVAILABLE(watchos);</span><br><span class="line">- (<span class="built_in">UIColor</span> *)initWithDynamicProvider:(<span class="built_in">UIColor</span> * (^)(<span class="built_in">UITraitCollection</span> *traitCollection))dynamicProvider API_AVAILABLE(ios(<span class="number">13.0</span>), tvos(<span class="number">13.0</span>)) API_UNAVAILABLE(watchos);</span><br></pre></td></tr></table></figure>

<ul>
<li>上面的方法接受一个闭包(<code>block</code>)</li>
<li>当系统在<code>LightMode</code>和<code>DarkMode</code>之间相互切换时就会自动触发此回调</li>
<li>回调返回一个<code>UITraitCollection</code>, 可根据改对象判断是那种模式</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fileprivate</span> <span class="keyword">func</span> <span class="title function_">getColor</span>() -&gt; <span class="type">UIColor</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">UIColor</span> &#123; (collection) -&gt; <span class="type">UIColor</span> <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">if</span> (collection.userInterfaceStyle <span class="operator">==</span> .dark) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="type">UIColor</span>.red</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">UIColor</span>.green</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>除了上述两个方法之外, <code>UIColor</code>还增加了一个实例方法</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过当前traitCollection得到对应UIColor</span></span><br><span class="line"><span class="keyword">@available</span>(<span class="keyword">iOS</span> <span class="number">13.0</span>, <span class="operator">*</span>)</span><br><span class="line"><span class="keyword">open</span> <span class="keyword">func</span> <span class="title function_">resolvedColor</span>(<span class="params">with</span> <span class="params">traitCollection</span>: <span class="type">UITraitCollection</span>) -&gt; <span class="type">UIColor</span></span><br></pre></td></tr></table></figure>

<h3 id="CGColor"><a href="#CGColor" class="headerlink" title="CGColor"></a>CGColor</h3><ul>
<li><code>UIColor</code>只是设置背景色和文字颜色的类, 可以动态的设置</li>
<li>可是如果是需要设置类似边框颜色等属性时, 又该如何处理呢</li>
<li>设置上述边框属性, 需要用到<code>CGColor</code>类, 但是在<code>iOS13</code>中<code>CGColor</code>并不是动态颜色值, 只能表示一种颜色</li>
<li>在监听模式改变的方法中<code>traitCollectionDidChange</code>, 根据不同的模式进行处理</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">traitCollectionDidChange</span>(<span class="keyword">_</span> <span class="params">previousTraitCollection</span>: <span class="type">UITraitCollection</span>?) &#123;</span><br><span class="line">    <span class="keyword">super</span>.traitCollectionDidChange(previousTraitCollection)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 每次模式改变的时候, 这里都会执行</span></span><br><span class="line">    <span class="keyword">if</span> (previousTraitCollection<span class="operator">?</span>.userInterfaceStyle <span class="operator">==</span> .dark) &#123;</span><br><span class="line">        redView.layer.borderColor <span class="operator">=</span> <span class="type">UIColor</span>.red.cgColor</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        redView.layer.borderColor <span class="operator">=</span> <span class="type">UIColor</span>.green.cgColor</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="图片适配"><a href="#图片适配" class="headerlink" title="图片适配"></a>图片适配</h2><ul>
<li>在<code>iOS</code>中, 图片基本都是放在<code>Assets.xcassets</code>里面, 所以图片的适配, 我们就相对麻烦一些了</li>
<li>正常情况下都是下面这中处理方式</li>
</ul>
<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/ios/ios13-1.png" alt="image"></p>
<ul>
<li>需要适配不同模式的情况下, 需要两套不同的图片, 并做如下设置</li>
<li>在设置<code>Appearances</code>时, 我们选择<code>Any, Dark</code>就可以了(只需要适配深色模式和非深色模式)</li>
</ul>
<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/ios/io13-2.png" alt="image"></p>
<h2 id="适配相关"><a href="#适配相关" class="headerlink" title="适配相关"></a>适配相关</h2><h3 id="当前页面模式"><a href="#当前页面模式" class="headerlink" title="当前页面模式"></a>当前页面模式</h3><ul>
<li>原项目中如果没有适配<code>Dark Mode</code>, 当你切换到<code>Dark Mode</code>后, 你可能会发现, 有些部分页面的颜色自动适配了</li>
<li>未设置过背景颜色或者文字颜色的组件, 在<code>Dark Mode</code>模式下, 就是黑色的</li>
<li>这里我们就需要真对该单独<code>App</code>强制设置成<code>Light Mode</code>模式</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置改属性, 只会影响当前的视图, 不会影响前面的controller和后续present的controller</span></span><br><span class="line"><span class="keyword">@available</span>(<span class="keyword">iOS</span> <span class="number">13.0</span>, <span class="operator">*</span>)</span><br><span class="line"><span class="keyword">open</span> <span class="keyword">var</span> overrideUserInterfaceStyle: <span class="type">UIUserInterfaceStyle</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">traitCollectionDidChange</span>(<span class="keyword">_</span> <span class="params">previousTraitCollection</span>: <span class="type">UITraitCollection</span>?) &#123;</span><br><span class="line">    <span class="keyword">super</span>.traitCollectionDidChange(previousTraitCollection)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 每次模式改变的时候, 这里都会执行</span></span><br><span class="line">    <span class="keyword">if</span> (previousTraitCollection<span class="operator">?</span>.userInterfaceStyle <span class="operator">==</span> .dark) &#123;</span><br><span class="line">        <span class="comment">// 在Dark模式下, 强制改成Light模式</span></span><br><span class="line">        overrideUserInterfaceStyle <span class="operator">=</span> .light</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="强制项目的显示模式"><a href="#强制项目的显示模式" class="headerlink" title="强制项目的显示模式"></a>强制项目的显示模式</h3><ul>
<li>上面这种方式只能针对某一个页面修改, 如果需要对整个项目禁用<code>Dark</code>模式</li>
<li>可以通过修改<code>window</code>的<code>overrideUserInterfaceStyle</code>属性</li>
<li>在<code>Xcode11</code>创建的项目中, <code>window</code>从<code>AppDelegate</code>移到<code>SceneDelegate</code>中, 添加下面这段代码, 就会做到全局修改显示模式</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> scene <span class="operator">=</span> <span class="type">UIApplication</span>.shared.connectedScenes.first<span class="operator">?</span>.delegate <span class="keyword">as?</span> <span class="type">SceneDelegate</span></span><br><span class="line">scene<span class="operator">?</span>.window<span class="operator">?</span>.overrideUserInterfaceStyle <span class="operator">=</span> .light</span><br></pre></td></tr></table></figure>

<p>在之前的项目中, 可以在<code>AppDelegate</code>设置如下代码</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">window.overrideUserInterfaceStyle <span class="operator">=</span> .light</span><br></pre></td></tr></table></figure>

<p>我创建的简单项目, 上述代码的确会强制改变当前的模式, 但是状态栏的显示不会被修改, 不知道是不是漏了什么</p>
<h4 id="终极方案"><a href="#终极方案" class="headerlink" title="终极方案"></a>终极方案</h4><ul>
<li>需要在<code>info.plist</code>文件中添加<code>User Interface Style</code>配置, 并设置为<code>Light</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;key&gt;UIUserInterfaceStyle&lt;/key&gt;</span><br><span class="line">&lt;string&gt;Light&lt;/string&gt;</span><br></pre></td></tr></table></figure>

<p>问题又来了, 即使做了上面的修改, 在<code>React Native</code>中, 状态栏的依然是根据不同的模式显示不同的颜色, 该如何处理嘞?</p>
<h2 id="Status-Bar更新"><a href="#Status-Bar更新" class="headerlink" title="Status Bar更新"></a>Status Bar更新</h2><p>在<code>iOS13</code>中苹果对于<code>Status Bar</code>也做了部分修改, 在<code>iOS13</code>之前</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">UIStatusBarStyle</span> : <span class="title class_">Int</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> `default` <span class="comment">// 默认文字黑色</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">@available</span>(<span class="keyword">iOS</span> <span class="number">7.0</span>, <span class="operator">*</span>)</span><br><span class="line">    <span class="keyword">case</span> lightContent <span class="comment">// 文字白色</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从<code>iOS13</code>开始<code>UIStatusBarStyle</code>一共有三种状态</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">UIStatusBarStyle</span> : <span class="title class_">Int</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> `default` <span class="comment">// 自动选择黑色或白色</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">@available</span>(<span class="keyword">iOS</span> <span class="number">7.0</span>, <span class="operator">*</span>)</span><br><span class="line">    <span class="keyword">case</span> lightContent <span class="comment">// 文字白色</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">@available</span>(<span class="keyword">iOS</span> <span class="number">13.0</span>, <span class="operator">*</span>)</span><br><span class="line">    <span class="keyword">case</span> darkContent <span class="comment">// 文字黑色</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>React Native</code>的代码中, 设置状态栏的颜色为黑色, 代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;StatusBar barStyle=&#123;&#x27;dark-content&#x27;&#125; /&gt;</span><br></pre></td></tr></table></figure>


<ul>
<li>上面这段代码在<code>iOS13</code>系统的手机中是无效的</li>
<li>虽然上面的代码中设置了<code>dark-content</code>模式, 但是在<code>iOS</code>原生代码中<code>dark-content</code>实际是<code>UIStatusBarStyleDefault</code></li>
<li>在文件<code>RCTStatusBarManager.m</code>中</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">RCT_ENUM_CONVERTER(<span class="built_in">UIStatusBarStyle</span>, (@&#123;</span><br><span class="line">  <span class="string">@&quot;default&quot;</span>: @(<span class="built_in">UIStatusBarStyleDefault</span>),</span><br><span class="line">  <span class="string">@&quot;light-content&quot;</span>: @(<span class="built_in">UIStatusBarStyleLightContent</span>),</span><br><span class="line">  <span class="string">@&quot;dark-content&quot;</span>: @(<span class="built_in">UIStatusBarStyleDefault</span>),</span><br><span class="line">&#125;), <span class="built_in">UIStatusBarStyleDefault</span>, integerValue);</span><br></pre></td></tr></table></figure>

<p>修改上面代码即可</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="string">@&quot;dark-content&quot;</span>: @(@available(iOS <span class="number">13.0</span>, *) ? <span class="built_in">UIStatusBarStyleDarkContent</span> : <span class="built_in">UIStatusBarStyleDefault</span>),</span><br></pre></td></tr></table></figure>

<h2 id="iOS13-其他更新"><a href="#iOS13-其他更新" class="headerlink" title="iOS13 其他更新"></a>iOS13 其他更新</h2><h3 id="苹果登录"><a href="#苹果登录" class="headerlink" title="苹果登录"></a>苹果登录</h3><blockquote>
<p>Sign In with Apple will be available for beta testing this summer. It will be required as an option for users in apps that support third-party sign-in when it is commercially available later this year.</p>
</blockquote>
<ul>
<li>如果<code>APP</code>支持三方登陆(<code>Facbook</code>、<code>Google</code>、微信、<code>QQ</code>、支付宝等），就必须支持苹果登陆，且要放前边</li>
<li>至于<code>Apple</code>登录按钮的样式, 建议支持使用<code>Apple</code>提供的按钮样式，已经适配各类设备, 可参考<a href="https://developer.apple.com/design/human-interface-guidelines/sign-in-with-apple/overview/">Sign In with Apple</a></li>
</ul>
<h3 id="LaunchImage"><a href="#LaunchImage" class="headerlink" title="LaunchImage"></a>LaunchImage</h3><blockquote>
<p>即将被废弃的<code>LaunchImage</code></p>
</blockquote>
<ul>
<li>从<code>iOS 8</code>的时候，苹果就引入了<code>LaunchScreen</code>，我们可以设置<code>LaunchScreen</code>来作为启动页。</li>
<li>现在你还可以使用<code>LaunchImage</code>来设置启动图, 但是随着苹果设备尺寸越来越多, 适配显然相对麻烦一些</li>
<li>使用<code>LaunchScreen</code>的话，情况会变的很简单，<code>LaunchScreen</code>是支持<code>AutoLayout</code>和<code>SizeClass</code>的，所以适配各种屏幕都不在话下。</li>
<li>⚠️从2020年4月开始，所有<code>App</code>将必须提供<code>LaunchScreen</code>，而<code>LaunchImage</code>即将退出历史舞台</li>
</ul>
<h3 id="UIWebView"><a href="#UIWebView" class="headerlink" title="UIWebView"></a>UIWebView</h3><blockquote>
<p><code>&#39;UIWebView&#39; was deprecated in iOS 12.0: No longer supported; please adopt WKWebView.</code></p>
</blockquote>
<blockquote>
<p>从<code>iOS 13</code>开始也不再支持<code>UIWebView</code>控件了, 尽快替换成<code>WKWebView</code>吧</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@available</span>(<span class="keyword">iOS</span>, introduced: <span class="number">2.0</span>, deprecated: <span class="number">12.0</span>, message: <span class="string">&quot;No longer supported; please adopt WKWebView.&quot;</span>)</span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">UIWebView</span> : <span class="title class_">UIView</span>, <span class="title class_">NSCoding</span>, <span class="title class_">UIScrollViewDelegate</span> &#123; &#125;</span><br></pre></td></tr></table></figure>


<hr>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS之UIMenuController的简单使用</title>
    <url>/post/2bfa0929.html</url>
    <content><![CDATA[<h2 id="UIMenuController须知"><a href="#UIMenuController须知" class="headerlink" title="UIMenuController须知"></a>UIMenuController须知</h2><ul>
<li>默认情况下, 有以下控件已经支持UIMenuController<ul>
<li>UITextField</li>
<li>UITextView</li>
<li>UIWebView</li>
</ul>
</li>
</ul>
<span id="more"></span>

<h2 id="让其他控件也支持UIMenuController-比如UILabel"><a href="#让其他控件也支持UIMenuController-比如UILabel" class="headerlink" title="让其他控件也支持UIMenuController(比如UILabel)"></a>让其他控件也支持UIMenuController(比如UILabel)</h2><ol>
<li>自定义UILabel</li>
</ol>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)setUp &#123;</span><br><span class="line">  <span class="comment">// 1.设置label可以交互</span></span><br><span class="line">  <span class="keyword">self</span>.userInteractionEnabled = <span class="literal">YES</span>;  </span><br><span class="line">  <span class="comment">// 2.添加点击手势</span></span><br><span class="line">  [<span class="keyword">self</span> addGestureRecognizer:[[<span class="built_in">UITapGestureRecognizer</span> alloc] initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(lableClick)]];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">void</span>)lableClick &#123;</span><br><span class="line">  <span class="comment">// 3.设置label为第一响应者,只有成为响应者才能够将MenuController显示在其上面</span></span><br><span class="line">  [<span class="keyword">self</span> becomeFirstResponder];</span><br><span class="line">  <span class="comment">// 4.初始化UIMenuController</span></span><br><span class="line">  <span class="built_in">UIMenuController</span> *menuController = [<span class="built_in">UIMenuController</span> sharedMenuController];  </span><br><span class="line">  <span class="comment">// 5.设置UIMenuController显示的位置</span></span><br><span class="line">  <span class="comment">// targetRect : 将要显示所在label的frame;</span></span><br><span class="line">  <span class="comment">// view : targetRect所在的坐标系参照物(父view或self)</span></span><br><span class="line">  [menuController setTargetRect:<span class="keyword">self</span>.frame inView:<span class="keyword">self</span>.superview];</span><br><span class="line">  <span class="comment">// [menuController setTargetRect:self.bounds inView:self];作用同上  </span></span><br><span class="line">  <span class="comment">// 6.显示UIMenuController</span></span><br><span class="line">  [menuController setMenuVisible:<span class="literal">YES</span> animated:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>在UILable内重写2个方法</li>
</ol>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 让label有资格成为第一响应者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="type">BOOL</span>)canBecomeFirstResponder</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * label能执行哪些操作(比如copy, paste等等)</span></span><br><span class="line"><span class="comment"> * @return  YES:支持这种操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="type">BOOL</span>)canPerformAction:(SEL)action withSender:(<span class="type">id</span>)sender</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (action == <span class="keyword">@selector</span>(cut:) || action == <span class="keyword">@selector</span>(<span class="keyword">copy</span>:) || action == <span class="keyword">@selector</span>(paste:)) <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.实现各种操作方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)cut:(<span class="built_in">UIMenuController</span> *)menu</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将自己的文字复制到粘贴板</span></span><br><span class="line">    <span class="built_in">UIPasteboard</span> *board = [<span class="built_in">UIPasteboard</span> generalPasteboard];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空文字</span></span><br><span class="line">    <span class="keyword">self</span>.text = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)<span class="keyword">copy</span>:(<span class="built_in">UIMenuController</span> *)menu</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将自己的文字复制到粘贴板</span></span><br><span class="line">    <span class="built_in">UIPasteboard</span> *board = [<span class="built_in">UIPasteboard</span> generalPasteboard];</span><br><span class="line">    board.string = <span class="keyword">self</span>.text;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)paste:(<span class="built_in">UIMenuController</span> *)menu</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将粘贴板的文字 复制 到自己身上</span></span><br><span class="line">    <span class="built_in">UIPasteboard</span> *board = [<span class="built_in">UIPasteboard</span> generalPasteboard];</span><br><span class="line">    <span class="keyword">self</span>.text = board.string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自定义UIMenuController内部的Item-在cell中"><a href="#自定义UIMenuController内部的Item-在cell中" class="headerlink" title="自定义UIMenuController内部的Item(在cell中)"></a>自定义UIMenuController内部的Item(在cell中)</h2><ul>
<li>由于手动添加的MenuItem默认触发控制器中的方法,所以将MenuController的显示&#x2F;隐藏,添加MenuItem写到控制器</li>
</ul>
<ol>
<li>添加item</li>
</ol>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)tableView:(<span class="built_in">UITableView</span> *)tableView didSelectRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</span><br><span class="line">  <span class="comment">// 点击cell弹出UIMenuController</span></span><br><span class="line">  <span class="comment">// 1.如果menuController已经在显示,就隐藏他</span></span><br><span class="line">  <span class="comment">// 注意,如果有一个cell正在显示menuController,这时再点击另外一个cell,上一个cell的menuController会消失,当前点击cell会显示,这是因为上一个cell不再是第一响应者了,menuController会自动释放</span></span><br><span class="line">  <span class="built_in">UIMenuController</span> *menuController = [<span class="built_in">UIMenuController</span> sharedMenuController];</span><br><span class="line">  <span class="keyword">if</span> (menuController.isMenuVisible) &#123;</span><br><span class="line">    [menuController setMenuVisible:<span class="literal">NO</span> animated:<span class="literal">YES</span>];  </span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 2.显示MenuController</span></span><br><span class="line">    <span class="comment">// 先设置cell为第一响应者,同时不要忘记在cell中重写canBecomeFirstResponder和canPerformAction:withSender:</span></span><br><span class="line">    JCMTopicCommentCell *cell = [tableView cellForRowAtIndexPath:indexPath];</span><br><span class="line">    [cell becomeFirstResponder];</span><br><span class="line">    <span class="comment">// 添加menuItem</span></span><br><span class="line">    <span class="built_in">UIMenuItem</span> *item01 = [[<span class="built_in">UIMenuItem</span> alloc]initWithTitle:<span class="string">@&quot;赞&quot;</span> action:<span class="keyword">@selector</span>(zanClick:)];</span><br><span class="line">    <span class="built_in">UIMenuItem</span> *item02 = [[<span class="built_in">UIMenuItem</span> alloc]initWithTitle:<span class="string">@&quot;回复&quot;</span> action:<span class="keyword">@selector</span>(responseClick:)];</span><br><span class="line">    <span class="built_in">UIMenuItem</span> *item03 = [[<span class="built_in">UIMenuItem</span> alloc]initWithTitle:<span class="string">@&quot;举报&quot;</span> action:<span class="keyword">@selector</span>(reportClick:)];</span><br><span class="line">    menuController.menuItems = @[item01,item02,item03];</span><br><span class="line">    <span class="comment">// 设置menuControoler显示位置</span></span><br><span class="line">     <span class="built_in">CGRect</span> showRect = <span class="built_in">CGRectMake</span>(cell.x, cell.y + cell.height/<span class="number">2</span>, cell.width, cell.height);</span><br><span class="line">     [menuController setTargetRect:showRect inView:cell.superview];</span><br><span class="line">    <span class="comment">// 显示menuController [menuController setMenuVisible:YES animated:YES];  </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>cell中实现两个方法</li>
</ol>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 让label有资格成为第一响应者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="type">BOOL</span>)canBecomeFirstResponder</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * label能执行哪些操作(比如copy, paste等等)</span></span><br><span class="line"><span class="comment"> * @return  YES:支持这种操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="type">BOOL</span>)canPerformAction:(SEL)action withSender:(<span class="type">id</span>)sender</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (action == <span class="keyword">@selector</span>(cut:) || action == <span class="keyword">@selector</span>(<span class="keyword">copy</span>:) || action == <span class="keyword">@selector</span>(paste:)) <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>处理方法的实现</li>
</ol>
<pre><code class="objc">#pragma mark - MenuControllerClick
// MenuController手动添加的item的方法实现必须放在controller中
- (void)zanClick:(UIMenuController *)menu &#123;
    NSIndexPath *indexPath = [self.tableView indexPathForSelectedRow];
    NSLog(@&quot;%s %@&quot;, __func__, [self commentInIndexPath:indexPath].content);
&#125;
- (void)responseClick:(UIMenuController *)menu &#123;
  NSIndexPath *indexPath = [self.tableView indexPathForSelectedRow];
  NSLog(@&quot;%s %@&quot;, __func__, [self commentInIndexPath:indexPath].content);
&#125;
- (void)reportClick:(UIMenuController *)menu &#123;
  NSIndexPath *indexPath = [self.tableView indexPathForSelectedRow];
  NSLog(@&quot;%s %@&quot;, __func__, [self commentInIndexPath:indexPath].content);
&#125;```
</code></pre>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS的静态库和动态库</title>
    <url>/post/128c2f48.html</url>
    <content><![CDATA[<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/ios/staticFramework.jpg?x-oss-process=style/titanjun" alt="staticFramework"></p>
<span id="more"></span>

<h2 id="静态库简介"><a href="#静态库简介" class="headerlink" title="静态库简介"></a>静态库简介</h2><h3 id="什么是库"><a href="#什么是库" class="headerlink" title="什么是库?"></a>什么是库?</h3><ul>
<li>库从本质上来说是一种可执行代码的二进制格式，可以被载入内存中执行</li>
<li>库就是程序代码的集合, 是共享程序代码的一种方式</li>
<li>库从广义上可分为开源库和闭源库, 而闭源库才分为静态库和动态库<ul>
<li>开源库: 对外公开源代码, 能看到具体的代码实现, 例如<code>Github</code>上面的第三方开源库都称之为开源库</li>
<li>闭源库: 不公开源代码, 文件是经过编译后的二进制文件, 看不到具体实现, 例如<code>.a</code>文件和<code>.framework</code>文件</li>
</ul>
</li>
</ul>
<h3 id="静态库与动态库"><a href="#静态库与动态库" class="headerlink" title="静态库与动态库"></a>静态库与动态库</h3><ul>
<li>静态库：链接时完整地拷贝至可执行文件中，被多次使用就有多份冗余拷贝<ul>
<li>静态库有两种存在形式: <code>.a</code>和<code>.framework</code></li>
</ul>
</li>
<li>动态库：动态库则不会复制, 只有一份. 程序运行时动态加载到内存; 系统只加载一次, 多个程序共用, 节省内存<ul>
<li>动态库有两种存在形式: <code>.dylib</code>和<code>.framework</code></li>
<li>需要注意的是: 系统的<code>.framework</code>是动态库，我们自己建立的<code>.framework</code>是静态库</li>
</ul>
</li>
<li>但是项目中如果使用到自己的动态库, 苹果是不允许上架!</li>
<li>再但是<code>WWDC2014</code>上公布的苹果对<code>ios8</code>开放动态加载<code>dylib</code>的接口 也就是说 开放了动态库挂载, 但是目前几乎没有上架的项目使用</li>
</ul>
 <div class="note info"><p>`.a`与`.framework`的区别</p></div>

<ul>
<li><code>.a</code>是一个纯二进制文件不能直接使用, 必须要有<code>.h</code>文件才能使用, <code>.h</code>文件对外提供接口, <code>.a</code>文件是代码的具体实现, 即<code>.m</code></li>
<li><code>.framework</code>中除了有二进制文件之外还有资源文件, 可以直接使用</li>
<li>所以开发中建议使用<code>.framework</code></li>
</ul>
<h3 id="为什么要使用静态库？"><a href="#为什么要使用静态库？" class="headerlink" title="为什么要使用静态库？"></a>为什么要使用静态库？</h3><ul>
<li>保护自己的核心代码, 国内的企业，掌握有核心技术，同时是又希望更多的程序员来使用其技术，因此采用”闭源”的方式开发使用</li>
<li>实现iOS项目的组件化, 可以把固定的业务模块编译成静态库</li>
<li>开发第三方SDK, 例如: 友盟SDK, 百度地图SDK….</li>
<li>提高项目的编译速度, 比如项目的组件化, 虽然使用了组件化, 但依然是源码, 如果工程庞大, 编译速度依然非常慢, 但是如果把响应的功能和业务组件编译成静态库, 将会大大提高项目的编译速度</li>
</ul>
<h2 id="a静态库的生成和使用"><a href="#a静态库的生成和使用" class="headerlink" title=".a静态库的生成和使用"></a><code>.a</code>静态库的生成和使用</h2><p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-b8f9c74fc0185ddd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="staticLibrary"></p>
<ul>
<li>生成<code>.a</code>静态库, 这里我们选择第二个创建</li>
<li>静态库分真机和模拟机两种环境<ul>
<li>在真机环境下编译出来的是只适用于真机的静态库</li>
<li>在模拟机环境下编译出来的是只使用模拟机的静态库</li>
<li>同事使用真机和模拟机的静态库, 后面会提到, 暂不赘述</li>
</ul>
</li>
<li>在不同的环境下静态库支持的架构也是不同的, 模拟器下的静态库和真机下的静态库不能共用, 不同型号编译的静态库也是不能共用的</li>
<li>不同设备使用的CPU不同，从而使用的CPU架构（指令集）也不同，静态库有其支持的CPU架构，若静态库在不支持的CPU架构上运行程序就会崩溃</li>
</ul>
<h3 id="静态库的架构"><a href="#静态库的架构" class="headerlink" title="静态库的架构"></a>静态库的架构</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 模拟器使用的CPU架构： </span></span><br><span class="line">iphone4s - iphone5 : i386 </span><br><span class="line">iPhone5s - iPhoneX ：x86_64</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 真机使用的CPU架构： </span></span><br><span class="line">iPhone3gs - iPhone4s：armv7 </span><br><span class="line">iPhone5 - iPhone5c：armv7s </span><br><span class="line">iPhone5s - iPhoneX：armv64 </span><br></pre></td></tr></table></figure>


<ul>
<li>如果想要查看不同的机型所支持的架构, 可分别使用不同的模拟器或者真机, 编译出不同的静态库</li>
<li>然后使用终端, cd 到静态库所在的目录</li>
<li>在执行<code>lipo -info 静态库名称</code>即可</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行lipo -info的输出结果</span></span><br><span class="line">$ lipo -info libStateLib.a </span><br><span class="line">input file libStateLib.a is not a fat file</span><br><span class="line">Non-fat file: libStateLib.a is architecture: x86_64</span><br></pre></td></tr></table></figure>

<h3 id="编译多架构静态库"><a href="#编译多架构静态库" class="headerlink" title="编译多架构静态库"></a>编译多架构静态库</h3><ul>
<li>在调试不同机型的过程中, 需要选中每一个模拟器进行编译, 生成支持对应架构的静态库然后合并, 非常蛋疼</li>
<li>怎样一次编译支持多个架构的的静态库?</li>
</ul>
<p><img data-src="https://upload-images.jianshu.io/upload_images/4122543-086dd1629ebb028b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/697/format/webp" alt="bundleActive"></p>
<ul>
<li>该选项默认是<code>YES</code>, 也就是只编译当前活跃环境的架构, 设置成<code>No</code>即可</li>
<li>模拟器环境编译出来的就支持所有的模拟机型号, 真机亦是如此</li>
</ul>
<h3 id="静态库的版本"><a href="#静态库的版本" class="headerlink" title="静态库的版本"></a>静态库的版本</h3><ul>
<li>和<code>iOS</code>证书一样分调试版本(<code>Debug</code>)和发布版本<code>Release</code></li>
<li>真机-<code>Debug</code>版本 </li>
<li>真机-<code>Release</code>版本 </li>
<li>模拟器-<code>Debug</code>版本 </li>
<li>模拟器-<code>Release</code>版本</li>
</ul>
<div class="note info"><p>调试版本`Debug`</p></div>

<ul>
<li>真机-<code>Debug</code>版本和模拟器-<code>Debug</code>版本 </li>
<li>调试版本的特点<ul>
<li>调试版本会包含完整的符号信息，以方便调试</li>
<li>调试版本不会对代码进行优化</li>
</ul>
</li>
</ul>
<div class="note info"><p>发布版本`Release`</p></div>

<ul>
<li>真机-<code>Release</code>版本和模拟器-<code>Release</code>版本 </li>
<li>发布版本的特点<ul>
<li>发布版本不会包含完整的符号信息， </li>
<li>发布版本的执行代码是进行过优化的， </li>
<li>发布版本的大小会比调试版本的略小， </li>
<li>在执行速度方面，发布版本会更快些，但不意味着会有显著的提升</li>
</ul>
</li>
</ul>
<div class="note primary"><p>生成不同版本的静态库</p></div>

<p>选择项目 <code>-&gt; Edit Scheme -&gt; Run -&gt; Release/Debug</code> 分别进行编译, 即可得到不同版本的静态库</p>
<p><img data-src="https://upload-images.jianshu.io/upload_images/4122543-1b00f7f45a6654c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/930/format/webp" alt="EditScheme"></p>
<h3 id="生成-a和-h文件"><a href="#生成-a和-h文件" class="headerlink" title="生成.a和.h文件"></a>生成<code>.a</code>和<code>.h</code>文件</h3><ul>
<li>正常情况下, 生成的<code>.h</code>文件是在<code>../include/$(PRODUCT_NAME)</code>目录下的, <code>$(PRODUCT_NAME)</code>指的是项目的名字</li>
<li>修改图中2处的路径地址, 即可修改<code>.h</code>文件生成的路径, 填空即为和<code>.a</code>文件在同级目录下</li>
</ul>
<p><img data-src="https://upload-images.jianshu.io/upload_images/4122543-727056aa929e2c7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/707/format/webp" alt="image"></p>
<p>最后编写好代码, <code>command+B</code>编译之后, 如图所示操作即可找到生成的静态库</p>
<p><img data-src="https://upload-images.jianshu.io/upload_images/4122543-b1f80d56eccf1990.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/331/format/webp" alt="image"></p>
<div class="note success"><p>合并静态库</p></div>

<ul>
<li>因为静态库针对于模拟器和真机生成了不同版本(支持不同架构), 所以没法同时运行</li>
<li>合并后的静态库既可以在真机上调试，也可以在模拟器上调试, 省去了来回切换的诸多烦恼</li>
<li>但是合并后的静态库大小是模拟器和真机的大小之和，如果静态库太大，合并打包后，会非常大，因此很多第三方的静态库的<code>.a</code>是区分版本的</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下所有方式得到的静态库都可以通过lipo -info xx.a方式检测现有的架构, 注意要在xx.a所在的目录下</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 合并静态库</span></span><br><span class="line">lipo -create 静态库<span class="number">1</span>路径 静态库<span class="number">2</span>路径 -output 合并后的静态库名称</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line">lipo -create /Users/xxx/Debug-iphoneos/libStateLib.a /Users/xxx/Debug-iphonesimulator/libStateLib.a -output hahah.a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 移除某一个架构</span></span><br><span class="line">lipo -remove 架构名称 静态库绝对路径 -output 新的静态库名字</span><br><span class="line">lipo -remove arm64 /Users/xxx/Build/Products/hahah.a -output ha_arm64.a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 拆分出一个单独架构的静态库</span></span><br><span class="line">lipo -thin 架构名称 静态库绝对路径 -output 新的静态库名字</span><br><span class="line">lipo -thin arm64 /Users/xxx/Build/Products/hahah.a -output only_arm64.a</span><br></pre></td></tr></table></figure>


<h2 id="framework静态库"><a href="#framework静态库" class="headerlink" title=".framework静态库"></a><code>.framework</code>静态库</h2><h3 id="生成-framework静态库"><a href="#生成-framework静态库" class="headerlink" title="生成.framework静态库"></a>生成<code>.framework</code>静态库</h3><h4 id="选择framework"><a href="#选择framework" class="headerlink" title="选择framework"></a>选择<code>framework</code></h4><p>创建新工程, 选择第一个创建<code>Framework</code>工程</p>
<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-88dc3d5139099895.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="staticLibrary"></p>
<h4 id="选择编译环境"><a href="#选择编译环境" class="headerlink" title="选择编译环境"></a>选择编译环境</h4><p>选择适配所有真机或者适配所有模拟器(编译所有架构), <code>Build Settings -&gt; Build Active Architecture Only</code>选项设为<code>NO</code></p>
<h4 id="手动设置静态库"><a href="#手动设置静态库" class="headerlink" title="手动设置静态库"></a>手动设置静态库</h4><p>刚创建的工程默认创建的是动态库, 需要手动设置链接类型, <code>Build Settings -&gt; Mach-o Type</code>设置成<code>Static Library</code></p>
<p><img data-src="https://upload-images.jianshu.io/upload_images/4122543-88dc3d5139099895.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/764/format/webp" alt="machtype"></p>
<h4 id="静态库版本"><a href="#静态库版本" class="headerlink" title="静态库版本"></a>静态库版本</h4><p>设置静态库的版本, 选择项目 -&gt; <code>Edit Scheme -&gt; Run -&gt; Release/Debug</code> 分别进行编译, 即可得到不同版本的静态库</p>
<h4 id="添加公开头文件"><a href="#添加公开头文件" class="headerlink" title="添加公开头文件"></a>添加公开头文件</h4><p><code>Target-&gt;Build Phases-&gt;Headers</code>中的<code>Project</code>中要暴露的头文件拖拽到<code>Pulic</code>里面： </p>
<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-6e40f428fc01b99b.gif?imageMogr2/auto-orient/strip" alt="headerfile"></p>
<h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><p>分别选择<code>Generic iOS Device</code>和任意一个模拟器各编译一次。编译完，工程中<code>Products</code>文件夹下的<code>xxx.framework</code>由红色变成了黑色，然后<code>show in finder</code>，看看生成的文件 </p>
<div class="note warning"><p>注意事项</p></div>

<ul>
<li>如果静态库中有<code>category</code>类，则在使用静态库的项目配置中<code>Other Linker Flags</code>需要添加参数<code>-ObjC</code>或者<code>-all_load</code> </li>
<li>如果创建的<code>framework</code>类中使用了<code>.tbd</code>，则需要在实际项目中导入<code>.tbd</code>动态库。</li>
<li><code>.framework</code>静态库的合并和拆分和<code>.a</code>静态库的方式一样, 就不在赘述了</li>
</ul>
<h3 id="bundle加载资源"><a href="#bundle加载资源" class="headerlink" title="bundle加载资源"></a><code>bundle</code>加载资源</h3><ul>
<li>由于<code>Xcode</code>默认在编译时会把所有的素材文件导入到<code>mainBundle</code>中，可能会让宿主工程与使用静态库的程序冲突。</li>
<li>在创建静态库的项目中又是难免会用到一些图片或者<code>xib</code>等资源, 类似这些资源在静态库中又如何进行管理呢</li>
<li>这里我们就要引入一个<code>bundle</code>文件, 对资源进行管理, 用以存放<code>xib</code>文件或者图片等资源</li>
<li><code>bundle</code>文件是是静态的，不进行编译的资源文件, 所以使用时需要找到相应的资源路径</li>
</ul>
<div class="note success"><p>创建方式</p></div>

<ul>
<li>把包含资源文件的文件夹的后缀改为<code>.bundle</code>, 这时他就变成一个<code>bundle</code>文件</li>
<li>或者右键显示包内容就可以把对应的图片资源等放进文件中，然后把他丢进工程中就可以使用了</li>
<li>调用该图片时, 需要在图片名前加上<code>xxx.bundle</code>前缀</li>
</ul>
<h3 id="静态库的测试"><a href="#静态库的测试" class="headerlink" title="静态库的测试"></a>静态库的测试</h3><ul>
<li>静态库本身就是一个小项目, 实现某些功能, 但是这些功能在开发中也需要测试. 而测试代码又不能作为静态库的一部分</li>
<li>建议创建一个复合项目, 在宿主工程中添加一个静态库的工程</li>
</ul>
<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-768361c8b9d2c1a7.gif?imageMogr2/auto-orient/strip" alt="allStatic"></p>
<h3 id="自动打包"><a href="#自动打包" class="headerlink" title="自动打包"></a>自动打包</h3><ul>
<li>上面介绍的都是手动打包的方式, 虽然麻烦一些, 但是相对更不容易出错, 而且可以对本地代码打包</li>
<li>还有一种自动打包方式, 只需一条命令<code>package</code>, 便可对静态库进行打包, 但是前提是: 代码必须已经上传到远程仓库</li>
<li>首先安装<code>package</code>: <ul>
<li><code>sudo gem install cocoapods-packager</code></li>
</ul>
</li>
<li>使用</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前提是代码必须已经上传到远程仓库, 否则报错不会成功</span></span><br><span class="line"><span class="comment">// 1. cd 到podspec文件所在的根目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 执行</span></span><br><span class="line">pod package xxx.podspec</span><br></pre></td></tr></table></figure>



<h2 id="私有库的二进制"><a href="#私有库的二进制" class="headerlink" title="私有库的二进制"></a>私有库的二进制</h2><ul>
<li>在组件化开发的过程选中, 虽然使用了组件化, 但依然是源码, 如果工程庞大, 编译速度依然非常慢</li>
<li>所以,为了加快编译速度可以直接把私有库打包成为一个静态库库文件, 进行使用</li>
<li>在每一个私有库里面都有一个这样的测试工程, 但是这个工程不能打包成静态库</li>
<li>但是, 如果为了打包静态库单独分离出一个工程用于打包, 那么我们后期就需要维护和更新两套代码, 过于繁琐</li>
<li>所以我们可以用符合工程进行处理, 在<code>Example</code>所在的测试工程中添加一个静态库的工程, 如<a href="#%E9%9D%99%E6%80%81%E5%BA%93%E7%9A%84%E6%B5%8B%E8%AF%95">静态库的测试</a>所示</li>
</ul>
<p><img data-src="https://upload-images.jianshu.io/upload_images/4122543-b71694440807f1f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/424/format/webp" alt="exampleTest"></p>
<h3 id="打包静态库"><a href="#打包静态库" class="headerlink" title="打包静态库"></a>打包静态库</h3><p>这里我们是以<code>framework</code>静态库为例, 静态库工程添加之后, 左侧会多出一个类似<code>BaseLib</code>的文件夹, 该文件夹用于存放需要打包的文件, 即<code>TitanBase/Classes</code>目录下的文件</p>
<p><img data-src="https://upload-images.jianshu.io/upload_images/4122543-dc1006500bfeecb7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/454/format/webp" alt="image"></p>
<ul>
<li>导入文件的时候需要注意, 一定不能勾选<code>Copy Items</code>选项, 因为我们需要的是引用<code>Classes</code>目录下的文件, 而不是拷贝</li>
<li>如果是拷贝, 静态库和<code>Classes</code>目录使用的将会是两套不同的代码(虽然内容可能一样), 由乙方改变, 另一方的代码不会改变</li>
<li>引用则可以做到一改全改</li>
</ul>
<p><img data-src="https://upload-images.jianshu.io/upload_images/4122543-f60b374e5952d639.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/764/format/webp" alt="copyItem"></p>
<ul>
<li>接下来选择静态库的工程, 并修改打包静态库的相应的配置, 步骤参考<a href="#%E7%94%9F%E6%88%90.framework%E9%9D%99%E6%80%81%E5%BA%93">生成.framework静态库</a></li>
<li>这里生成的静态库的目录是系统默认, 我们也可以自行设置: <code>File -&gt; WorkSpace Setting</code></li>
</ul>
<p><img data-src="https://upload-images.jianshu.io/upload_images/4122543-7b193d311de70e01.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/412/format/webp" alt="selectLib"></p>
<ul>
<li>最后在<code>Classes</code>的统计目录下创建一个<code>Products</code>的目录(自定义创建, 你开心就好)</li>
<li>把打包好的<code>.framework</code>或者<code>.a</code>的静态库, 放到<code>Products</code>目录下</li>
</ul>
<h3 id="修改podspec文件"><a href="#修改podspec文件" class="headerlink" title="修改podspec文件"></a>修改<code>podspec</code>文件</h3><h4 id="引入静态库"><a href="#引入静态库" class="headerlink" title="引入静态库"></a>引入静态库</h4><p>完成了静态库的打包, 下面就是修改<code>podspec</code>文件中相应的配置了</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">s.source_files = <span class="string">&#x27;TitanBase/Classes/**/*.h&#x27;</span></span><br><span class="line">s.vendored_frameworks = <span class="string">&quot;TitanBase/Products/BaseLib.framework&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>source_files</code>: 需要导入的文件, 现在只需要导入<code>.h</code>文件即可</li>
<li><code>vendored_frameworks</code>: 需要导入的<code>framework</code>静态库</li>
<li>最后重新对测试工程进行<code>pod install</code>即可, 更多配置相关信息可参考<a href="https://guides.cocoapods.org/syntax/podspec.html#specification">官方文档</a></li>
</ul>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 表示依赖的系统类库，比如libz.dylib等</span></span><br><span class="line">s.libraries     = <span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27;sqlite3&#x27;</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 表示依赖系统的框架</span></span><br><span class="line">s.frameworks    = <span class="string">&#x27;UIKit&#x27;</span>,<span class="string">&#x27;AVFoundation&#x27;</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 依赖的第三方/自己的framework静态库</span></span><br><span class="line">s.vendored_frameworks = <span class="string">&#x27;YJKit/YJKit.framework&#x27;</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 表示依赖第三方/自己的静态库（比如libWeChatSDK.a）</span></span><br><span class="line">s.vendored_libraries = <span class="string">&#x27;Library/Classes/libWeChatSDK.a&#x27;</span> </span><br><span class="line"><span class="comment"># 依赖的第三方的或者自己的静态库文件必须以lib为前缀进行命名，否则会出现找不到的情况，这一点非常重要</span></span><br></pre></td></tr></table></figure>


<h4 id="切换静态库和源码"><a href="#切换静态库和源码" class="headerlink" title="切换静态库和源码"></a>切换静态库和源码</h4><ul>
<li>开发过程中如果需要调试代码的时候, 需要查看源码进行调试</li>
<li>但是静态库却只能看到头文件, 没有源码, 无法进行调试</li>
<li>在导入的私有库中, 静态库和源码如何进行切换呢</li>
<li>这里我们在<code>podspec</code>配置文件中引入一个<code>if-else</code>语句, 如下所示</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="variable constant_">ENV</span>[<span class="string">&#x27;IS_SOURCE&#x27;</span>]</span><br><span class="line">    s.source_files = <span class="string">&#x27;TitanBase/Classes/**/*&#x27;</span></span><br><span class="line">    s.dependency <span class="string">&#x27;AFNetworking&#x27;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    s.source_files = <span class="string">&#x27;TitanBase/Classes/**/*.h&#x27;</span></span><br><span class="line">    s.vendored_frameworks = <span class="string">&quot;TitanBase/Products/BaseLib.framework&quot;</span></span><br><span class="line">    s.dependency <span class="string">&#x27;AFNetworking&#x27;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<ul>
<li>此时如果需要切换为源码, 只需要执行<code>IS_SOURCE=1 pod install</code>即可(或者任意非0的数字, 非0即为真)</li>
<li>执行<code>pod install</code>, 就会执行<code>else</code>后面的语句, 即导入静态库</li>
<li>但是如果所有的组件都加了类似的判断, 切判断条件都是<code>IS_SOURCE</code>, 那么每次重新切换, 所有的组件都会导入源码或者导入静态库</li>
<li>建议每一语句可以加两个判断条件, 一个统一的判断条件, 一个只对每一个组件的条件</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="variable constant_">ENV</span>[<span class="string">&#x27;IS_SOURCE&#x27;</span>] |<span class="params"></span>| <span class="variable constant_">ENV</span>[<span class="string">&#x27;IS_BASE&#x27;</span>]</span><br><span class="line">   ...</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>


<h3 id="有依赖关系的静态库"><a href="#有依赖关系的静态库" class="headerlink" title="有依赖关系的静态库"></a>有依赖关系的静态库</h3><ul>
<li>对单独的静态库工程打包静态库的时候, 默认不会将第三方库的内容打包进去, 是可以使用的</li>
<li>对包含静态库工程的复合工程打包的时候, 可能会出现引用的第三方头文件找不到的问题或者出现打包出的静态库包含第三方库的代码和资源, 这样打包出来的静态库<ul>
<li>第一: 打包好的静态库应该是不能使用的</li>
<li>第二: 打包好的静态库中包含第三方库的所有代码和资源, 所以打包的静态库会很大</li>
</ul>
</li>
<li>所以我们打包静态库, 是不需要把第三方的任何东西打包进去的</li>
<li>在复合工程中建议的办法: 修改<code>Podfile</code>文件, 如下</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">target <span class="string">&#x27;CoreImage_Example&#x27;</span> <span class="keyword">do</span></span><br><span class="line">  pod <span class="string">&#x27;CoreImage&#x27;</span>, <span class="symbol">:path</span> =&gt; <span class="string">&#x27;../&#x27;</span></span><br><span class="line"></span><br><span class="line">  target <span class="string">&#x27;CoreImage_Tests&#x27;</span> <span class="keyword">do</span></span><br><span class="line">    inherit! <span class="symbol">:search_paths</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 以下添加的部分, CoreImgLib: 为静态库的名称, 需要在静态库中重新引用pod库的部分</span></span><br><span class="line">  target <span class="string">&#x27;CoreImgLib&#x27;</span> <span class="keyword">do</span></span><br><span class="line">      </span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>在引用第三方头文件的地方</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果使用&quot;&quot;方式报错</span></span><br><span class="line"><span class="meta">#import <span class="string">&quot;AFNetworking.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可改成以下方式引用</span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;AFNetworking/AFNetworking.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>接下来在重新打包就可以了</p>
<h3 id="多分类的静态库打包"><a href="#多分类的静态库打包" class="headerlink" title="多分类的静态库打包"></a>多分类的静态库打包</h3><p>类似<code>AFNetworking</code>的多分类框架</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">-&gt; AFNetworking (<span class="number">3.2</span>.<span class="number">1</span>)</span><br><span class="line">   A delightful iOS <span class="keyword">and</span> <span class="variable constant_">OS</span> X networking framework.</span><br><span class="line">   pod <span class="string">&#x27;AFNetworking&#x27;</span>, <span class="string">&#x27;~&gt; 3.2.1&#x27;</span></span><br><span class="line">   - <span class="symbol">Homepage:</span> <span class="symbol">https:</span>/<span class="regexp">/github.com/</span>AFNetworking/AFNetworking</span><br><span class="line">   - <span class="symbol">Source:</span>   <span class="symbol">https:</span>/<span class="regexp">/github.com/</span>AFNetworking/AFNetworking.git</span><br><span class="line">   - <span class="symbol">Versions:</span> <span class="number">3.2</span>.<span class="number">1</span>, ......,<span class="number">0.5</span>.<span class="number">1</span> [master repo]</span><br><span class="line">   - <span class="symbol">Subspecs:</span></span><br><span class="line">     - AFNetworking/Serialization (<span class="number">3.2</span>.<span class="number">1</span>)</span><br><span class="line">     - AFNetworking/Security (<span class="number">3.2</span>.<span class="number">1</span>)</span><br><span class="line">     - AFNetworking/Reachability (<span class="number">3.2</span>.<span class="number">1</span>)</span><br><span class="line">     - AFNetworking/NSURLSession (<span class="number">3.2</span>.<span class="number">1</span>)</span><br><span class="line">     - AFNetworking/UIKit (<span class="number">3.2</span>.<span class="number">1</span>)</span><br></pre></td></tr></table></figure>


<ul>
<li>对于有多个分类的私有库, 如果要打包成静态库<ul>
<li>一: 可以每个分类单独处理, 分别打包, 很麻烦不建议这么做(也没必要)</li>
<li>二: 把分类整合到一起, 打包成一个静态库</li>
</ul>
</li>
<li>如下, 如果使用源码, 按照分类导入, 如果使用静态库, 打包成一个静态库导入</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="variable constant_">ENV</span>[<span class="string">&#x27;IS_SOURCE&#x27;</span>]</span><br><span class="line">    <span class="comment"># 静态库</span></span><br><span class="line">    s.source_files = <span class="string">&#x27;TKDownloadPlayer/Classes/**/*.h&#x27;</span></span><br><span class="line">    s.vendored_frameworks = <span class="string">&#x27;TKDownloadPlayer/Products/TKDownPlayerLib.framework&#x27;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment"># 源码</span></span><br><span class="line">    s.subspec <span class="string">&#x27;TKDownload&#x27;</span> <span class="keyword">do</span> |<span class="params">dl</span>|</span><br><span class="line">        dl.source_files = <span class="string">&#x27;TKDownloadPlayer/Classes/TKDownload/**/*&#x27;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    s.subspec <span class="string">&#x27;TKRemotePlayer&#x27;</span> <span class="keyword">do</span> |<span class="params">rp</span>|</span><br><span class="line">        rp.source_files = <span class="string">&#x27;TKDownloadPlayer/Classes/TKRemotePlayer/**/*&#x27;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>


<hr>
]]></content>
      <categories>
        <category>组件化开发</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS私有Api检测</title>
    <url>/post/824e217a.html</url>
    <content><![CDATA[<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-a28717a02e83f9c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<span id="more"></span>

<ul>
<li>最近提交<code>APP</code>审核被苹果的审核人员是虐的不要不要的, 一直都说是使用了私有<code>API</code></li>
<li>但是我使出了浑身解数, 也没找到自己写的代码里哪里用到了私有<code>API</code>, 最后网上找了一些检测私有<code>API</code>的方法才发现在SDK里面涉及到了</li>
<li>下面就检测私有<code>API</code>的方法简单介绍一下</li>
</ul>
<h2 id="指定私有API"><a href="#指定私有API" class="headerlink" title="指定私有API"></a>指定私有<code>API</code></h2><ul>
<li>这是最显而易见的, 也是最方便解决的可能出现私有<code>API</code>的情况</li>
<li>当然这种方法首先你要知道使用了那些私有<code>API</code>, 然后在代码中进行全局搜索, 修改, 此方法暂不赘述</li>
<li>这些方法, 我在查找的时候基本能定位到使用私有api的第三方库的位置</li>
</ul>
<h3 id="终端命令"><a href="#终端命令" class="headerlink" title="终端命令"></a>终端命令</h3><p>首先要<code>cd</code>到工程目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd 到工程的目录</span><br></pre></td></tr></table></figure>

<p>全局搜索的命令(注意后面有一个点), 其中<code>prefs</code>即为你要搜索的私有<code>API</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep -r prefs .</span><br></pre></td></tr></table></figure>

<p>如果私有<code>api</code>属于类似<code>GraphicsServices.framework</code>等<code>.framework</code>第三方库中，然后全局搜索后发现无法检测到这个库的存在，应该是私有库之类的, 也可以使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep -r GraphicsServices .</span><br></pre></td></tr></table></figure>

<p>到这里, 解决上述第三方库的私有<code>API</code>的问题, 就是直接替换掉新的<code>SDK</code>, 当然如果新的第三方库也有私有<code>API</code>的话, 那就只能舍弃了, 否则基本无解</p>
<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-0e4ccc38035be38b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h3 id="strings检测"><a href="#strings检测" class="headerlink" title="strings检测"></a><code>strings</code>检测</h3><p>此方法是利用已经打包的<code>ipa</code>包检测</p>
<ul>
<li>首先你有个可以提交审核的<code>ipa</code>，就是需要提交到苹果审核的包，不是测试的<code>release</code></li>
<li>将<code>ipa</code>重命名为<code>zip</code>格式，也可以直接使用解压工具解压, 如果有两个文件夹<code>Payload</code>、<code>Symbols</code>，就OK</li>
<li><code>cd</code>到<code>Payload</code>里面的<code>app</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /Users/xxx/Downloads/xxx\ 2018-07-16\ 15-00-36/zcmlc/Payload/xxx.app</span><br></pre></td></tr></table></figure>

<p>然后执行, 其中<code>test</code>为你要搜索的<code>app</code>的名字, <code>api</code>为你要搜索的私有的<code>API</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">strings - -a -arch armv7 &quot;test&quot; | grep api</span><br></pre></td></tr></table></figure>

<p>除了上述这命令之外, 这里还有第二种命令搜索, 生成一个文件, 自己去找即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">strings - -a -arch armv7 &quot;test&quot; &gt; test.txt</span><br></pre></td></tr></table></figure>



<h3 id="私有API检测工具"><a href="#私有API检测工具" class="headerlink" title="私有API检测工具"></a>私有API检测工具</h3><p>主要介绍使用<code>iOS-private-api-checker</code>进行检测详情可参考: <a href="https://www.jianshu.com/p/07779e293ca7">iOS-private-api-checker私有API检测工具使用详细步骤</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS之Scanner字符串扫描类</title>
    <url>/post/82865b70.html</url>
    <content><![CDATA[<blockquote>
<p> 注:  本文主要语法为Swift4.0</p>
</blockquote>
<ul>
<li>Scanner继承自NSObject，遵守NSCopying协议。是一个用于扫描指定字符串的抽象类</li>
<li>可以创建Scanner时制定他的String属性，然后scanner会按照你的要求从头到尾扫描这个字符串的每个字符</li>
<li>扫描操作从上次扫描的位置开始，并且继续往后扫描直到指定的内容出现为止（如果有的话）</li>
</ul>
<span id="more"></span>

<h2 id="1-部分属性的相关解释"><a href="#1-部分属性的相关解释" class="headerlink" title="1. 部分属性的相关解释"></a>1. 部分属性的相关解释</h2><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"> open var string: String &#123; get &#125;</span><br><span class="line"> <span class="comment">// (只读)返回当前被扫描的字符串</span></span><br><span class="line"></span><br><span class="line">open var scanLocation: Int</span><br><span class="line"><span class="comment">// 当前扫描的位置，默认是从0开始的。通过设置这个属性值，可以自定义扫描的位置</span></span><br><span class="line"></span><br><span class="line">open var charactersToBeSkipped: CharacterSet?</span><br><span class="line"><span class="comment">// 这个集合是用来设置我们需要跳过扫描的一个字符集合</span></span><br><span class="line"></span><br><span class="line">open var caseSensitive: Bool</span><br><span class="line"><span class="comment">// 是否大小写敏感</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">public init(string: String)</span><br><span class="line"><span class="comment">// 用给定扫描字符串初始化</span></span><br></pre></td></tr></table></figure>

<h2 id="2-部分方法的相关解释"><a href="#2-部分方法的相关解释" class="headerlink" title="2. 部分方法的相关解释"></a>2. 部分方法的相关解释</h2><h3 id="2-1-以下方法的作用都是"><a href="#2-1-以下方法的作用都是" class="headerlink" title="2-1 以下方法的作用都是"></a>2-1 以下方法的作用都是</h3><ul>
<li>扫描该类型的字符串,并将扫描结果赋值给result</li>
<li>判断该字符串的第一个字符(默认第一个,可根据scanLocation属性设置)是否为该类型</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">open func scanInt32(_ result: UnsafeMutablePointer&lt;Int32&gt;?) -&gt; Bool</span><br><span class="line"></span><br><span class="line">@available(iOS <span class="number">2.0</span>, *)</span><br><span class="line">open func scanInt(_ result: UnsafeMutablePointer&lt;Int&gt;?) -&gt; Bool</span><br><span class="line"></span><br><span class="line">open func scanInt64(_ result: UnsafeMutablePointer&lt;Int64&gt;?) -&gt; Bool</span><br><span class="line"></span><br><span class="line">@available(iOS <span class="number">7.0</span>, *)</span><br><span class="line">open func scanUnsignedLongLong(_ result: UnsafeMutablePointer&lt;<span class="built_in">UInt64</span>&gt;?) -&gt; Bool</span><br><span class="line"></span><br><span class="line">open func scanFloat(_ result: UnsafeMutablePointer&lt;Float&gt;?) -&gt; Bool</span><br><span class="line"></span><br><span class="line">open func scanDouble(_ result: UnsafeMutablePointer&lt;Double&gt;?) -&gt; Bool</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-1-1-包含纯数字的字符串"><a href="#2-1-1-包含纯数字的字符串" class="headerlink" title="2-1-1 包含纯数字的字符串"></a>2-1-1 包含纯数字的字符串</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">var int1: Int = <span class="number">0</span></span><br><span class="line">var int64: Int64 = <span class="number">0</span></span><br><span class="line">var int32: Int32 = <span class="number">0</span></span><br><span class="line">var float1: Float = <span class="number">0.0</span></span><br><span class="line">var double1: Double = <span class="number">0.0</span></span><br><span class="line"><span class="comment">//判断字符串包含的类型(输出结果为true)</span></span><br><span class="line">print(Scanner(string: <span class="string">&quot;987&quot;</span>).scanInt(&amp;int1))</span><br><span class="line">print(Scanner(string: <span class="string">&quot;897&quot;</span>).scanInt64(&amp;int64))</span><br><span class="line">print(Scanner(string: <span class="string">&quot;99&quot;</span>).scanInt32(&amp;int32))</span><br><span class="line">print(Scanner(string: <span class="string">&quot;90.99&quot;</span>).scanFloat(&amp;float1))</span><br><span class="line">print(Scanner(string: <span class="string">&quot;98.09&quot;</span>).scanDouble(&amp;double1))</span><br><span class="line"><span class="comment">//输出扫描后的结果</span></span><br><span class="line">int1 = <span class="number">98</span></span><br><span class="line">int64 = <span class="number">897</span></span><br><span class="line">int32 = <span class="number">99</span></span><br><span class="line"><span class="type">float</span> = <span class="number">90.99</span></span><br><span class="line"><span class="type">double</span> = <span class="number">98.09</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-1-2-非纯数字的字符串"><a href="#2-1-2-非纯数字的字符串" class="headerlink" title="2-1-2  非纯数字的字符串"></a>2-1-2  非纯数字的字符串</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">var int1: Int = <span class="number">0</span></span><br><span class="line">let scanner = Scanner(string: <span class="string">&quot;m998k23l&quot;</span>)</span><br><span class="line">scanner.scanLocation = <span class="number">1</span></span><br><span class="line">print(scanner.scanInt(&amp;int1)) <span class="comment">// true</span></span><br><span class="line"><span class="comment">//int1 = 998</span></span><br><span class="line"></span><br><span class="line">var double1: Double = <span class="number">0.0</span></span><br><span class="line">let scanner = Scanner(string: <span class="string">&quot;ms9.98k45l&quot;</span>)</span><br><span class="line">scanner.scanLocation = <span class="number">1</span></span><br><span class="line">print(scanner.scanDouble(&amp;double1)) <span class="literal">false</span></span><br><span class="line"><span class="comment">//double1 = 0.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="2-2-以下方法的作用都是"><a href="#2-2-以下方法的作用都是" class="headerlink" title="2-2 以下方法的作用都是"></a>2-2 以下方法的作用都是</h3><ul>
<li>扫描字符串前缀是否是”0x”或者”0X”,返回true或false</li>
<li>将0x(0X)字符后面符合十六进制数的字符串转化成十进制数(可运用到UIColor关于十六进制数的转化)</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">open func scanHexInt32(_ result: UnsafeMutablePointer&lt;<span class="built_in">UInt32</span>&gt;?) -&gt; Bool <span class="comment">// Optionally prefixed with &quot;0x&quot; or &quot;0X&quot;</span></span><br><span class="line"></span><br><span class="line">@available(iOS <span class="number">2.0</span>, *)</span><br><span class="line">open func scanHexInt64(_ result: UnsafeMutablePointer&lt;<span class="built_in">UInt64</span>&gt;?) -&gt; Bool <span class="comment">// Optionally prefixed with &quot;0x&quot; or &quot;0X&quot;</span></span><br><span class="line"></span><br><span class="line">@available(iOS <span class="number">2.0</span>, *)</span><br><span class="line">open func scanHexFloat(_ result: UnsafeMutablePointer&lt;Float&gt;?) -&gt; Bool <span class="comment">// Corresponding to %a or %A formatting. Requires &quot;0x&quot; or &quot;0X&quot; prefix.</span></span><br><span class="line"></span><br><span class="line">@available(iOS <span class="number">2.0</span>, *)</span><br><span class="line">open func scanHexDouble(_ result: UnsafeMutablePointer&lt;Double&gt;?) -&gt; Bool <span class="comment">// Corresponding to %a or %A formatting. Requires &quot;0x&quot; or &quot;0X&quot; prefix.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-2-1-代码示例"><a href="#2-2-1-代码示例" class="headerlink" title="2-2-1 代码示例"></a>2-2-1 代码示例</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">print(Scanner(string: <span class="string">&quot;xdd&quot;</span>).scanHexInt64(&amp;uint64))  <span class="comment">//false</span></span><br><span class="line">print(Scanner(string: <span class="string">&quot;0xdd&quot;</span>).scanHexInt64(&amp;uint64))  <span class="comment">//true</span></span><br><span class="line">print(uint64) <span class="comment">//221</span></span><br><span class="line">print(Scanner(string: <span class="string">&quot;0xax&quot;</span>).scanHexInt32(&amp;uint32))  <span class="comment">//true</span></span><br><span class="line">print(uint32)  <span class="comment">// 10</span></span><br><span class="line">print(Scanner(string: <span class="string">&quot;0X991&quot;</span>).scanHexFloat(&amp;float1))  <span class="comment">//true</span></span><br><span class="line">print(float1)  <span class="comment">//2449.0</span></span><br><span class="line">print(Scanner(string: <span class="string">&quot;0X99&quot;</span>).scanHexDouble(&amp;double1))  <span class="comment">//true</span></span><br><span class="line">print(double1)  <span class="comment">//153.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="2-3-从给定的字符串中找到相同的字符"><a href="#2-3-从给定的字符串中找到相同的字符" class="headerlink" title="2-3 从给定的字符串中找到相同的字符"></a>2-3 从给定的字符串中找到相同的字符</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">open func scanString(_ string: String, into result: AutoreleasingUnsafeMutablePointer&lt;<span class="built_in">NSString</span>?&gt;?) -&gt; Bool</span><br></pre></td></tr></table></figure>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">var sstring: <span class="built_in">NSString</span>?</span><br><span class="line">let scan = Scanner(string: <span class="string">&quot;32jingki&quot;</span>)</span><br><span class="line"><span class="keyword">while</span> !scan.isAtEnd&#123; <span class="comment">// 判断是否扫描到最后</span></span><br><span class="line">    scan.scanLocation += <span class="number">1</span></span><br><span class="line">    print(scan.scanLocation)</span><br><span class="line">    scan.scanString(<span class="string">&quot;i&quot;</span>, into: &amp;sstring)</span><br><span class="line">    print(sstring)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-4-Scanner的其他方法"><a href="#2-4-Scanner的其他方法" class="headerlink" title="2-4 Scanner的其他方法"></a>2-4 Scanner的其他方法</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">open func scanCharacters(from set: CharacterSet, into result: AutoreleasingUnsafeMutablePointer&lt;<span class="built_in">NSString</span>?&gt;?) -&gt; Bool</span><br><span class="line"><span class="comment">////从scan中扫描出string放入result中，如果不需要存储string，则result传NULL</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">open func scanUpTo(_ string: String, into result: AutoreleasingUnsafeMutablePointer&lt;<span class="built_in">NSString</span>?&gt;?) -&gt; Bool</span><br><span class="line"><span class="comment">//从scan中扫描出string之外的数据放入result中，如果不需要存储string，则result传NULL</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">open func scanUpToCharacters(from set: CharacterSet, into result: AutoreleasingUnsafeMutablePointer&lt;<span class="built_in">NSString</span>?&gt;?) -&gt; Bool</span><br><span class="line"><span class="comment">//从scan中扫描出set之外的数据放入result中，如果不需要存储string，则result传NULL</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="2-5-关于使用Scanner处理UIColor十六进制数值的问题"><a href="#2-5-关于使用Scanner处理UIColor十六进制数值的问题" class="headerlink" title="2-5  关于使用Scanner处理UIColor十六进制数值的问题"></a>2-5  关于使用Scanner处理UIColor十六进制数值的问题</h2><ul>
<li>可在UIColor的extension中添加扩展方法</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 十六进制颜色扩充</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">convenience init?(hex : String, alpha : <span class="built_in">CGFloat</span> = <span class="number">1.0</span>) &#123;</span><br><span class="line">    <span class="comment">//1.判断字符串长度是否符合</span></span><br><span class="line">    guard hex.characters.count &gt;= <span class="number">6</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.将字符串转成大写</span></span><br><span class="line">    var tempHex = hex.uppercased()</span><br><span class="line">    <span class="comment">//3.判断开头</span></span><br><span class="line">    <span class="keyword">if</span> tempHex.hasPrefix(<span class="string">&quot;0x&quot;</span>) || tempHex.hasPrefix(<span class="string">&quot;##&quot;</span>) || tempHex.hasPrefix(<span class="string">&quot;0X&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">//去掉开头</span></span><br><span class="line">        tempHex = tempHex.dropFirst(<span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> tempHex.hasPrefix(<span class="string">&quot;#&quot;</span>) &#123;</span><br><span class="line">        tempHex = tempHex.dropFirst()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.分别截取RGB</span></span><br><span class="line">    var range = <span class="built_in">NSRange</span>(location: <span class="number">0</span>, length: <span class="number">2</span>)</span><br><span class="line">    let rHex = (tempHex as <span class="built_in">NSString</span>).substring(with: range)</span><br><span class="line">    range.location = <span class="number">2</span></span><br><span class="line">    let gHex = (tempHex as <span class="built_in">NSString</span>).substring(with: range)</span><br><span class="line">    range.location = <span class="number">4</span></span><br><span class="line">    let bHex = (tempHex as <span class="built_in">NSString</span>).substring(with: range)</span><br><span class="line">    <span class="comment">//5.将字符串转化成数字  emoji也是十六进制表示(此处也可用Float类型)</span></span><br><span class="line">    var r : <span class="built_in">UInt32</span> = <span class="number">0</span>, g : <span class="built_in">UInt32</span> = <span class="number">0</span>, b : <span class="built_in">UInt32</span> = <span class="number">0</span></span><br><span class="line">    <span class="comment">//创建扫描器,将字符串的扫描结果赋值给:r,g,b</span></span><br><span class="line">    Scanner(string: rHex).scanHexInt32(&amp;r)</span><br><span class="line">    Scanner(string: gHex).scanHexInt32(&amp;g)</span><br><span class="line">    Scanner(string: bHex).scanHexInt32(&amp;b)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.init(r : <span class="built_in">CGFloat</span>(r), g : <span class="built_in">CGFloat</span>(g), b : <span class="built_in">CGFloat</span>(b))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**RGB三原色</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">convenience init(r : <span class="built_in">CGFloat</span>, g : <span class="built_in">CGFloat</span>, b : <span class="built_in">CGFloat</span>, alpha : <span class="built_in">CGFloat</span> = <span class="number">1.0</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.init(red: r / <span class="number">255.0</span>, green: g / <span class="number">255.0</span>, blue: b / <span class="number">255.0</span>, alpha: alpha)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS出门必备之CoreAnimation(核心动画)</title>
    <url>/post/b47e4a7d.html</url>
    <content><![CDATA[<ul>
<li>前段时间接触到了一个牛逼的动画框架<a href="https://github.com/facebook/pop">POP</a>,本来想来装装逼,突然发现,苹果大大的CoreAnimation我还不会用呢!</li>
<li>依稀记得乔帮主在2007年的WWDC大会上亲自为你演示Core Animation的强大：<a href="http://v.youku.com/v_show/id_XMzQ2MTcwNDQ0.html">点击查看视频</a>(不好意思,又装逼了)</li>
<li>言归正传,我只是来温习一下CoreAnimation,还望路过的大神不要吐槽我太low</li>
<li><a href="https://github.com/coderQuanjun/POPAnimationDemo">GitHub项目地址</a></li>
</ul>
<span id="more"></span>


<h2 id="Core-Animation简介"><a href="#Core-Animation简介" class="headerlink" title="Core Animation简介"></a>Core Animation简介</h2><ul>
<li><code>Core Animation</code>，中文翻译为核心动画，它是一组非常强大的动画处理API，使用它能做出非常炫丽的动画效果，而且往往是事半功倍。也就是说，使用少量的代码就可以实现非常强大的功能。</li>
<li><code>Core Animation</code>可以用在<code>Mac OS X和iOS</code>平台。</li>
<li><code>Core Animation</code>的动画执行过程都是在后台操作的，不会阻塞主线程。</li>
<li>要注意的是，Core Animation是直接作用在<code>CALayer</code>上的，并非UIView</li>
<li>通过调用<code>CALayer</code>的<code>addAnimation:forKey:</code>方法增加<code>CAAnimation</code>对象到<code>CALayer</code>中，这样就能开始执行动画了</li>
<li>通过调用<code>CALayer</code>的<code>removeAnimationForKey:</code>方法可以停止<code>CALayer</code>中的动画</li>
</ul>
<h3 id="Core-Animation及其相关属性"><a href="#Core-Animation及其相关属性" class="headerlink" title="Core Animation及其相关属性"></a>Core Animation及其相关属性</h3><ul>
<li>要想执行动画，就必须初始化一个<code>CAAnimation</code>对象。</li>
<li>一般情况下，我们使用的比较多的是<code>CAAnimation</code>的子类，因此，先大致看看<code>CAAnimation</code>的继承结构</li>
<li>黑线代表继承，黑色文字代表类名，白色文字代表属性。其中<code>CAMediaTiming</code>是一个协议(<code>protocol</code>)</li>
</ul>
<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-7bc6a9dcfc3ff80f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="Core Animation结构划分.png"></p>
<div class="note warning"><p>需要注意</p></div>

<ul>
<li>CAAnimation是所有动画类的父类，但是它不能直接使用，应该使用它的子类</li>
<li>CAPropertyAnimation也是不能直接使用的，也要使用它的子类</li>
<li>能用的动画类只剩下4个：CABasicAnimation、CAKeyframeAnimation、CATransition、CAAnimationGroup</li>
</ul>
<h3 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h3><p><strong>1). <code>removedOnCompletion</code>：默认为true，代表动画执行完毕后就从图层上移除</strong></p>
<ul>
<li>图形会恢复到动画执行前的状态。如果想让图层保持显示动画执行后的状态，那就设置为false，不过还要设置<code>fillMode</code>为<code>kCAFillModeForwards</code></li>
</ul>
<p><strong>2). timingFunction：控制动画运行的节奏</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** timingFunction可选的值 **/</span></span><br><span class="line">@available(iOS <span class="number">2.0</span>, *)</span><br><span class="line">public let kCAMediaTimingFunctionLinear: String</span><br><span class="line"><span class="comment">//1.(匀速): 在整个动画时间内动画都是以一个相同的速度来改变</span></span><br><span class="line"></span><br><span class="line">@available(iOS <span class="number">2.0</span>, *)</span><br><span class="line">public let kCAMediaTimingFunctionEaseIn: String</span><br><span class="line"><span class="comment">//2. (渐进): 缓慢进入, 加速离开</span></span><br><span class="line"></span><br><span class="line">@available(iOS <span class="number">2.0</span>, *)</span><br><span class="line">public let kCAMediaTimingFunctionEaseOut: String</span><br><span class="line"><span class="comment">//3. (渐出): 快速进入, 减速离开</span></span><br><span class="line"></span><br><span class="line">@available(iOS <span class="number">2.0</span>, *)</span><br><span class="line">public let kCAMediaTimingFunctionEaseInEaseOut: String</span><br><span class="line"><span class="comment">//4. (渐进渐出): 缓慢进入, 中间加速, 减速离开</span></span><br><span class="line"></span><br><span class="line">@available(iOS <span class="number">3.0</span>, *)</span><br><span class="line">public let kCAMediaTimingFunctionDefault: String</span><br><span class="line"><span class="comment">//5. (默认): 效果基本等同于EaseOut(渐出)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>3). fillMode决定当前对象在非active时间段的行为。</strong></p>
<ul>
<li>要想fillMode有效，需设置removedOnCompletion &#x3D; false</li>
<li>fillMode可选的值</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* `fillMode&#x27; options. */</span></span><br><span class="line">@available(iOS <span class="number">2.0</span>, *)</span><br><span class="line">public let kCAFillModeForwards: String</span><br><span class="line"><span class="comment">//1. 当动画结束后，layer会一直保持着动画最后的状态</span></span><br><span class="line"></span><br><span class="line">@available(iOS <span class="number">2.0</span>, *)</span><br><span class="line">public let kCAFillModeBackwards: String</span><br><span class="line"><span class="comment">//2. 设置为该值，将会立即执行动画的第一帧，不论是否设置了 beginTime属性。观察发现，设置该值，刚开始视图不见，还不知道应用在哪里</span></span><br><span class="line"></span><br><span class="line">@available(iOS <span class="number">2.0</span>, *)</span><br><span class="line">public let kCAFillModeBoth: String</span><br><span class="line"><span class="comment">//3. 该值是 kCAFillModeForwards 和 kCAFillModeBackwards的组合状态; 动画加入后开始之前，layer便处于动画初始状态，动画结束后layer保持动画最后的状态</span></span><br><span class="line"></span><br><span class="line">@available(iOS <span class="number">2.0</span>, *)</span><br><span class="line">public let kCAFillModeRemoved: String</span><br><span class="line"><span class="comment">//4. 默认值，动画将在设置的 beginTime 开始执行（如没有设置beginTime属性，则动画立即执行），动画执行完成后会将layer的改变恢复原状</span></span><br></pre></td></tr></table></figure>
<p><strong>4). <code>delegate</code>：动画代理，用来监听动画的执行过程</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">public protocol <span class="built_in">CAAnimationDelegate</span> : <span class="built_in">NSObjectProtocol</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动画开始执行的时候触发这个方法</span></span><br><span class="line">    @available(iOS <span class="number">2.0</span>, *)</span><br><span class="line">    optional public func animationDidStart(_ anim: <span class="built_in">CAAnimation</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动画执行完毕的时候触发这个方法</span></span><br><span class="line">    @available(iOS <span class="number">2.0</span>, *)</span><br><span class="line">    optional public func animationDidStop(_ anim: <span class="built_in">CAAnimation</span>, finished flag: Bool)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>5). 其他相关属性</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">duration    动画的时长</span><br><span class="line">repeatCount    重复的次数。不停重复设置为 HUGE_VALF</span><br><span class="line">repeatDuration    设置动画的时间。在该时间内动画一直执行，不计次数。</span><br><span class="line">beginTime    指定动画开始的时间。从开始延迟几秒的话，设置为【<span class="built_in">CACurrentMediaTime</span>() + 秒数】 的方式</span><br><span class="line">timingFunction    设置动画的速度变化</span><br><span class="line">autoreverses    动画结束时是否执行逆动画</span><br><span class="line">fromValue    所改变属性的起始值(Swift中为Any类型,OC中要包装成<span class="built_in">NSValue</span>对象)</span><br><span class="line">toValue    所改变属性的结束时的值(类型与fromValue相同)</span><br><span class="line">byValue    所改变属性相同起始值的改变量(类型与fromValue相同)</span><br></pre></td></tr></table></figure>

<h2 id="CABasicAnimation"><a href="#CABasicAnimation" class="headerlink" title="CABasicAnimation"></a>CABasicAnimation</h2><ul>
<li>CABasicAnimation是CAPropertyAnimation的子类，使用它可以实现一些基本的动画效果，它可以让CALayer的某个属性从某个值渐变到另一个值。下面就用CABasicAnimation实现几个简单的动画</li>
</ul>
<h3 id="平移动画"><a href="#平移动画" class="headerlink" title="平移动画"></a>平移动画</h3><h4 id="方法一-改变label的position"><a href="#方法一-改变label的position" class="headerlink" title="方法一: 改变label的position"></a>方法一: 改变label的position</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">let caBasic = <span class="built_in">CABasicAnimation</span>(keyPath: <span class="string">&quot;position&quot;</span>)</span><br><span class="line">caBasic.duration = <span class="number">2</span></span><br><span class="line">caBasic.fromValue = redLabel.layer.position</span><br><span class="line">caBasic.toValue = <span class="built_in">CGPoint</span>(x: kScreenWidth - <span class="number">50</span>, y: <span class="number">200</span>)</span><br><span class="line">caBasic.delegate = <span class="keyword">self</span></span><br><span class="line">caBasic.isRemovedOnCompletion = <span class="literal">false</span></span><br><span class="line">caBasic.fillMode = kCAFillModeForwards</span><br><span class="line">redLabel.layer.add(caBasic, forKey: <span class="string">&quot;redLabel1&quot;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>初始化方法中是@”position”，说明要修改的是CALayer的position属性，也就是会执行平移动画</li>
<li>默认情况下，动画执行完毕后，动画会自动从CALayer上移除，CALayer又会回到原来的状态。为了保持动画执行后的状态，可以加入第6、7行代码</li>
<li>第8行后面的@”redLabel1”是给动画对象起个名称，以后可以调用CALayer的removeAnimationForKey:方法根据动画名称停止相应的动画</li>
<li>遵循的代理方法</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">extension ViewController: <span class="built_in">CAAnimationDelegate</span> &#123;</span><br><span class="line">    <span class="comment">//开始执行</span></span><br><span class="line">    func animationDidStart(_ anim: <span class="built_in">CAAnimation</span>) &#123;</span><br><span class="line">        print(<span class="string">&quot;开始动画--layer:&quot;</span>, redLabel.layer.position)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//结束之行</span></span><br><span class="line">    func animationDidStop(_ anim: <span class="built_in">CAAnimation</span>, finished flag: Bool) &#123;</span><br><span class="line">        print(<span class="string">&quot;结束动画--layer:&quot;</span>, redLabel.layer.position)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//打印结果为:</span></span><br><span class="line"><span class="comment">//开始动画--layer: (35.0, 213.0)</span></span><br><span class="line"><span class="comment">//结束动画--layer: (35.0, 213.0)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>从打印信息可以看出，实际上，动画执行完毕后，并没有真正改变CALayer的position属性的值！</p>
</blockquote>
<h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二."></a>方法二.</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"> let basic = <span class="built_in">CABasicAnimation</span>(keyPath: <span class="string">&quot;transform&quot;</span>)</span><br><span class="line">basic.duration = <span class="number">2</span></span><br><span class="line">let form = <span class="built_in">CATransform3DMakeTranslation</span>(<span class="number">350</span>, <span class="number">400</span>, <span class="number">0</span>)</span><br><span class="line">basic.toValue = form</span><br><span class="line">blueLabel.layer.add(basic, forKey: <span class="string">&quot;blueLabel&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="旋转动画"><a href="#旋转动画" class="headerlink" title="旋转动画"></a>旋转动画</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">let basic1 = <span class="built_in">CABasicAnimation</span>(keyPath: <span class="string">&quot;transform&quot;</span>)</span><br><span class="line">basic1.duration = <span class="number">1</span></span><br><span class="line">basic1.toValue = <span class="built_in">CATransform3DMakeRotation</span>(<span class="number">0.25</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">basic1.isRemovedOnCompletion = <span class="literal">false</span></span><br><span class="line">basic1.fillMode = kCAFillModeForwards</span><br><span class="line">blueLabel.layer.add(basic1, forKey: <span class="string">&quot;basic1&quot;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>可以不用设置fromValue，这里只设置了toValue</li>
</ul>
<h3 id="缩放动画"><a href="#缩放动画" class="headerlink" title="缩放动画"></a>缩放动画</h3><ul>
<li>CALayer的宽度从0.5倍变为2倍</li>
<li>CALayer的高度从0.5倍变为1.5倍</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">let basic1 = <span class="built_in">CABasicAnimation</span>(keyPath: <span class="string">&quot;transform&quot;</span>)</span><br><span class="line">basic1.duration = <span class="number">1</span></span><br><span class="line">basic1.toValue = <span class="built_in">CATransform3DMakeScale</span>(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">1</span>)</span><br><span class="line">basic1.toValue = <span class="built_in">CATransform3DMakeScale</span>(<span class="number">2</span>, <span class="number">1.5</span>, <span class="number">1</span>)</span><br><span class="line">basic1.isRemovedOnCompletion = <span class="literal">false</span></span><br><span class="line">basic1.fillMode = kCAFillModeForwards</span><br><span class="line">blueLabel.layer.add(basic1, forKey: <span class="string">&quot;basic1&quot;</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
</blockquote>
<ul>
<li>CABasicAnimation虽然能够做很多基本的动画效果，但是有个局限性，只能让CALayer的属性从某个值渐变到另一个值，仅仅是在2个值之间渐变</li>
<li>总结一些常用的animationKeyPath值的</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
<th>使用形式</th>
</tr>
</thead>
<tbody><tr>
<td>transform.scale</td>
<td>比例转化</td>
<td>0.5</td>
</tr>
<tr>
<td>transform.scale.x</td>
<td>宽的比例</td>
<td>0.5</td>
</tr>
<tr>
<td>transform.rotation.x</td>
<td>围绕x轴旋转</td>
<td>@(M_PI_4)(OC), 0.25(Swift)</td>
</tr>
<tr>
<td>cornerRadius</td>
<td>圆角的设置</td>
<td>30</td>
</tr>
<tr>
<td>backgroundColor</td>
<td>背景颜色的变化</td>
<td>UIColor.purpleColor.cgColor</td>
</tr>
<tr>
<td>bounds</td>
<td>大小，中心不变</td>
<td>CGRect</td>
</tr>
<tr>
<td>position</td>
<td>位置(中心点的改变)</td>
<td>CGPoint</td>
</tr>
<tr>
<td>contents</td>
<td>内容，比如UIImageView的图片</td>
<td>imageAnima.toValue &#x3D; UIImage(named: “toImage”)?.cgImage</td>
</tr>
<tr>
<td>opacity</td>
<td>透明度</td>
<td>0.7</td>
</tr>
<tr>
<td>contentsRect.size.width</td>
<td>横向拉伸缩放</td>
<td>最好是0~1之间的</td>
</tr>
</tbody></table>
<h2 id="CAKeyframeAnimation——关键帧动画"><a href="#CAKeyframeAnimation——关键帧动画" class="headerlink" title="CAKeyframeAnimation——关键帧动画"></a>CAKeyframeAnimation——关键帧动画</h2><ul>
<li>关键帧动画，也是<code>CAPropertyAnimation</code>的子类，与<code>CABasicAnimation</code>的区别是：<ul>
<li><code>CABasicAnimation</code>只能从一个数值（fromValue）变到另一个数值（toValue）</li>
<li>而<code>CAKeyframeAnimation</code>会使用一个Array保存这些数值</li>
</ul>
</li>
<li>属性说明：<ul>
<li><code>values</code>：上述的Array对象。里面的元素称为“关键帧”(keyframe)。动画对象会在指定的时间（duration）内，依次显示values数组中的每一个关键帧</li>
<li><code>path</code>：可以设置一个<code>CGPathRef、CGMutablePathRef</code>，让图层按照路径轨迹移动。path只对CALayer的<code>anchorPoint</code>和<code>position</code>起作用。如果设置了path，那么values将被忽略</li>
<li><code>keyTimes</code>：可以为对应的关键帧指定对应的时间点，其取值范围为0到1.0，keyTimes中的每一个时间值都对应values中的每一帧。如果没有设置keyTimes，各个关键帧的时间是平分的</li>
<li><code>calculationMode</code>: 该属性决定了物体在每个子路径下是跳着走还是匀速走，跟<code>timeFunctions</code>属性有点类似<ul>
<li><code>kCAAnimationLinear</code>默认值,表示当关键帧为座标点的时候,关键帧之间直接直线相连进行插值计算;</li>
<li><code>kCAAnimationDiscrete</code> 离散的,就是不进行插值计算,所有关键帧直接逐个进行显示;</li>
<li><code>kCAAnimationPaced</code> 使得动画均匀进行,而不是按<code>keyTimes</code>设置的或者按关键帧平分时间,此时<code>keyTimes</code>和timingFunctions&#96;无效;</li>
<li><code>kCAAnimationCubic</code> 对关键帧为座标点的关键帧进行圆滑曲线相连后插值计算,对于曲线的形状还可以通过<code>tensionValues,continuityValues,biasValues</code>来进行调整自定义主要目的是使得运行的轨迹变得圆滑;</li>
<li><code>kCAAnimationCubicPaced</code> 看这个名字就知道和<code>kCAAnimationCubic</code>有一定联系,其实就是在<code>kCAAnimationCubic</code>的基础上使得动画运行变得均匀,就是系统时间内运动的距离相同,此时<code>keyTimes</code>以及<code>timingFunctions</code>也是无效的.</li>
</ul>
</li>
</ul>
</li>
<li><code>CABasicAnimation</code>可看做是只有2个关键帧的<code>CAKeyframeAnimation</code></li>
</ul>
<h3 id="values方式"><a href="#values方式" class="headerlink" title="values方式"></a>values方式</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">let key = <span class="built_in">CAKeyframeAnimation</span>(keyPath: <span class="string">&quot;position&quot;</span>)</span><br><span class="line">key.duration = <span class="number">3</span></span><br><span class="line">key.repeatCount = HUGE <span class="comment">//无线循环</span></span><br><span class="line">key.calculationMode = kCAAnimationPaced</span><br><span class="line">key.values = [redLabel.frame.origin, <span class="built_in">CGPoint</span>(x: <span class="number">180</span>, y: <span class="number">70</span>), <span class="built_in">CGPoint</span>(x: <span class="number">180</span>, y: <span class="number">200</span>), redLabel.frame.origin]</span><br><span class="line">key.keyTimes = [<span class="built_in">NSNumber</span>(value: <span class="number">0.0</span>), <span class="built_in">NSNumber</span>(value: <span class="number">0.6</span>), <span class="built_in">NSNumber</span>(value: <span class="number">0.7</span>), <span class="built_in">NSNumber</span>(value: <span class="number">0.8</span>)]</span><br><span class="line">redLabel.layer.add(key, forKey: <span class="string">&quot;key&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="CASpringAnimation"><a href="#CASpringAnimation" class="headerlink" title="CASpringAnimation"></a>CASpringAnimation</h2><ul>
<li><code>CASpringAnimation</code>是iOS 9 新出的</li>
<li><code>CASpringAnimation</code> 继承于<code>CABaseAnimation</code></li>
<li><code>CASpringAnimation</code>是苹果专门解决开发者关于弹簧动画的这个需求而封装的类。</li>
</ul>
<h3 id="CASpringAnimation相关属性"><a href="#CASpringAnimation相关属性" class="headerlink" title="CASpringAnimation相关属性"></a>CASpringAnimation相关属性</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 质量，影响图层运动时的弹簧惯性，质量越大，弹簧拉伸和压缩的幅度越大, 默认值: 1</span></span><br><span class="line">open var mass: <span class="built_in">CGFloat</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 刚度系数(劲度系数/弹性系数)，刚度系数越大，形变产生的力就越大，运动越快(默认值: 100)</span></span><br><span class="line">open var stiffness: <span class="built_in">CGFloat</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 阻尼系数，阻止弹簧伸缩的系数，阻尼系数越大，停止越快(默认值: 10)</span></span><br><span class="line">open var damping: <span class="built_in">CGFloat</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 初始速率，动画视图的初始速度大小, 默认0</span></span><br><span class="line"><span class="comment">//速率为正数时，速度方向与运动方向一致，速率为负数时，速度方向与运动方向相反(默认值: 0)</span></span><br><span class="line">open var initialVelocity: <span class="built_in">CGFloat</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//5. 估算时间 返回弹簧动画到停止时的估算时间，根据当前的动画参数估算(只读)</span></span><br><span class="line">open var settlingDuration: <span class="built_in">CFTimeInterval</span> &#123; get &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">let spring = <span class="built_in">CASpringAnimation</span>(keyPath: <span class="string">&quot;position.y&quot;</span>)</span><br><span class="line">spring.mass = <span class="number">5</span></span><br><span class="line">spring.stiffness = <span class="number">100</span></span><br><span class="line">spring.damping = <span class="number">5</span></span><br><span class="line">spring.initialVelocity = <span class="number">2</span></span><br><span class="line">spring.fromValue = blueLabel.layer.position.y</span><br><span class="line">spring.toValue = kScreenHeight - <span class="number">150</span></span><br><span class="line">spring.duration = spring.settlingDuration</span><br><span class="line">blueLabel.layer.add(spring, forKey: <span class="string">&quot;spring&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="CAAnimationGroup动画组"><a href="#CAAnimationGroup动画组" class="headerlink" title="CAAnimationGroup动画组"></a>CAAnimationGroup动画组</h2><ul>
<li>是CAAnimation的子类，可以保存一组动画对象，将CAAnimationGroup对象加入层后，组中所有动画对象可以同时并发运行</li>
<li>属性说明：<ul>
<li>animations：用来保存一组动画对象的Array</li>
</ul>
</li>
<li>默认情况下，一组动画对象是同时运行的，也可以通过设置动画对象的beginTime属性来更改动画的开始时间</li>
</ul>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例:"></a>代码示例:</h3><ul>
<li>同时执行：平移、缩放、位移动画 -&gt; 使用动画组</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//动画组</span></span><br><span class="line">fileprivate func getCAAnimationGroup()&#123;</span><br><span class="line">    <span class="comment">//0. 初始化动画组</span></span><br><span class="line">    let group = <span class="built_in">CAAnimationGroup</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1. 平移动画</span></span><br><span class="line">    let basic1 = <span class="built_in">CABasicAnimation</span>(keyPath: <span class="string">&quot;position&quot;</span>)</span><br><span class="line">    basic1.fromValue = blueLabel.layer.position</span><br><span class="line">    basic1.toValue = <span class="built_in">CGPoint</span>(x: <span class="built_in">CGFloat</span>(arc4random_uniform(<span class="number">200</span>)), y: <span class="built_in">CGFloat</span>(arc4random_uniform(<span class="number">500</span>)))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2. 缩放动画</span></span><br><span class="line">    let basic2 = <span class="built_in">CABasicAnimation</span>(keyPath: <span class="string">&quot;transform.scale&quot;</span>)</span><br><span class="line">    var scale: <span class="built_in">CGFloat</span> = <span class="number">0.1</span></span><br><span class="line">    scale = scale &lt; <span class="number">1</span> ? <span class="number">1.5</span> : <span class="number">0.5</span></span><br><span class="line">    basic2.toValue = scale</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3. 旋转动画</span></span><br><span class="line">    let basic3 = <span class="built_in">CABasicAnimation</span>(keyPath: <span class="string">&quot;transform.rotation&quot;</span>)</span><br><span class="line">    basic3.toValue = <span class="built_in">CGFloat</span>(arc4random_uniform(<span class="number">360</span>)) / <span class="number">180.0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4. 添加到动画组</span></span><br><span class="line">    group.animations = [basic1, basic2, basic3]</span><br><span class="line">    <span class="comment">//取消反弹</span></span><br><span class="line">    group.isRemovedOnCompletion = <span class="literal">false</span></span><br><span class="line">    group.fillMode = kCAFillModeForwards</span><br><span class="line">    group.duration = <span class="number">0.5</span></span><br><span class="line">    blueLabel.layer.add(group, forKey: <span class="string">&quot;group&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="转场动画——CATransition"><a href="#转场动画——CATransition" class="headerlink" title="转场动画——CATransition"></a>转场动画——CATransition</h2><ul>
<li><code>CATransition</code>是<code>CAAnimation</code>的子类，用于做转场动画，能够为layer层提供移出屏幕和移入屏幕的动画效果。</li>
<li>iOS比Mac OS X的转场动画效果少一点<br><code>UINavigationController</code>就是通过<code>CATransition</code>实现了将控制器的视图推入屏幕的动画效果</li>
<li>动画属性:<ul>
<li><code>type</code>：动画过渡类型</li>
<li><code>subtype</code>：动画过渡方向</li>
<li><code>startProgress</code>：动画起点(在整体动画的百分比)</li>
<li><code>endProgress</code>：动画终点(在整体动画的百分比)</li>
</ul>
</li>
</ul>
<h3 id="type和subtype属性说明"><a href="#type和subtype属性说明" class="headerlink" title="type和subtype属性说明"></a><code>type</code>和<code>subtype</code>属性说明</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* type类型 */</span></span><br><span class="line">@available(iOS <span class="number">2.0</span>, *)</span><br><span class="line">public let kCATransitionFade: String</span><br><span class="line"><span class="comment">//交叉淡化过渡</span></span><br><span class="line"></span><br><span class="line">@available(iOS <span class="number">2.0</span>, *)</span><br><span class="line">public let kCATransitionMoveIn: String</span><br><span class="line"><span class="comment">//新视图移到旧视图上面</span></span><br><span class="line"></span><br><span class="line">@available(iOS <span class="number">2.0</span>, *)</span><br><span class="line">public let kCATransitionPush: String</span><br><span class="line"><span class="comment">//新视图把旧视图推出去</span></span><br><span class="line"></span><br><span class="line">@available(iOS <span class="number">2.0</span>, *)</span><br><span class="line">public let kCATransitionReveal: String</span><br><span class="line"><span class="comment">//将旧视图移开,显示下面的新视图</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* subtypes类型 */</span></span><br><span class="line">@available(iOS <span class="number">2.0</span>, *)</span><br><span class="line">public let kCATransitionFromRight: String</span><br><span class="line"><span class="comment">//从右侧转场</span></span><br><span class="line"></span><br><span class="line">@available(iOS <span class="number">2.0</span>, *)</span><br><span class="line">public let kCATransitionFromLeft: String</span><br><span class="line"><span class="comment">//从左侧转场</span></span><br><span class="line"></span><br><span class="line">@available(iOS <span class="number">2.0</span>, *)</span><br><span class="line">public let kCATransitionFromTop: String</span><br><span class="line"><span class="comment">//从上部转场</span></span><br><span class="line"></span><br><span class="line">@available(iOS <span class="number">2.0</span>, *)</span><br><span class="line">public let kCATransitionFromBottom: String</span><br><span class="line"><span class="comment">//从底部转场</span></span><br></pre></td></tr></table></figure>

<div class="note warning"><p> 注意：</p></div>

<ul>
<li>除了上述四种效果之外,还有很多私有API效果，使用的时候要小心，可能会导致app审核不被通过</li>
<li>使用的时候要以字符串的形式</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">cube     <span class="comment">//立方体翻滚效果</span></span><br><span class="line">oglFlip  <span class="comment">//上下左右翻转效果</span></span><br><span class="line">suckEffect   <span class="comment">//收缩效果，如一块布被抽走(不支持过渡方向)</span></span><br><span class="line">rippleEffect <span class="comment">//滴水效果(不支持过渡方向)</span></span><br><span class="line">pageCurl     <span class="comment">//向上翻页效果</span></span><br><span class="line">pageUnCurl   <span class="comment">//向下翻页效果</span></span><br><span class="line">cameraIrisHollowOpen  <span class="comment">//相机镜头打开效果(不支持过渡方向)</span></span><br><span class="line">cameraIrisHollowClose <span class="comment">//相机镜头关上效果(不支持过渡方向)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>效果参考</p>
</blockquote>
<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-48e5ec518c8f535e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="各参数动画效果.png"></p>
<h3 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例:"></a>代码示例:</h3><ul>
<li>展示立方体翻滚效果的图片浏览</li>
</ul>
<h4 id="初始化变量"><a href="#初始化变量" class="headerlink" title="初始化变量"></a>初始化变量</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化变量</span></span><br><span class="line">fileprivate var imageView = <span class="built_in">UIImageView</span>(frame: <span class="built_in">UIScreen</span>.main.bounds)</span><br><span class="line">fileprivate var currentIndex = <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="需要在viewDidLoad中调用一下方法"><a href="#需要在viewDidLoad中调用一下方法" class="headerlink" title="需要在viewDidLoad中调用一下方法"></a>需要在<code>viewDidLoad</code>中调用一下方法</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//转场动画</span></span><br><span class="line">    fileprivate func imageCATransition()&#123;</span><br><span class="line">        <span class="comment">//0.初始化ImageView</span></span><br><span class="line">        imageView.isUserInteractionEnabled = <span class="literal">true</span></span><br><span class="line">        imageView.image = <span class="built_in">UIImage</span>(named: <span class="string">&quot;0.jpg&quot;</span>)</span><br><span class="line">        view.addSubview(imageView)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1. 添加滑动手势</span></span><br><span class="line">        let left = <span class="built_in">UISwipeGestureRecognizer</span>(target: <span class="keyword">self</span>, action: <span class="meta">#selector(leftSwipe(gesture:)))</span></span><br><span class="line">        left.direction = .left</span><br><span class="line">        imageView.addGestureRecognizer(left)</span><br><span class="line">        let right = <span class="built_in">UISwipeGestureRecognizer</span>(target: <span class="keyword">self</span>, action: <span class="meta">#selector(rightSwipe(gesture:)))</span></span><br><span class="line">        right.direction = .right</span><br><span class="line">        imageView.addGestureRecognizer(right)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="滑动后执行的方法"><a href="#滑动后执行的方法" class="headerlink" title="滑动后执行的方法"></a>滑动后执行的方法</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//MARK: 手势相关方法</span></span><br><span class="line"><span class="comment">//左滑</span></span><br><span class="line">@objc fileprivate func leftSwipe(gesture: <span class="built_in">UIGestureRecognizer</span>) &#123;</span><br><span class="line">    print(<span class="string">&quot;左滑动&quot;</span>)</span><br><span class="line">    transitionAnimation(isNext: <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//右滑</span></span><br><span class="line">@objc fileprivate func rightSwipe(gesture: <span class="built_in">UIGestureRecognizer</span>) &#123;</span><br><span class="line">    print(<span class="string">&quot;右滑动&quot;</span>)</span><br><span class="line">    transitionAnimation(isNext: <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置转场动画</span></span><br><span class="line">fileprivate func transitionAnimation(isNext: Bool)&#123;</span><br><span class="line">    let transition = <span class="built_in">CATransition</span>()</span><br><span class="line">    transition.type = kCATransitionFade</span><br><span class="line">    transition.subtype = isNext ? kCATransitionFromRight : kCATransitionFromLeft</span><br><span class="line">    transition.duration = <span class="number">1</span></span><br><span class="line">    imageView.image = getImage(isNext)</span><br><span class="line">    imageView.layer.add(transition, forKey: <span class="string">&quot;transition&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取下/上一张图片</span></span><br><span class="line">fileprivate func getImage(_ isNext: Bool) -&gt; <span class="built_in">UIImage</span> &#123;</span><br><span class="line">    currentIndex = isNext ? currentIndex + <span class="number">1</span> : currentIndex - <span class="number">1</span></span><br><span class="line">    currentIndex = currentIndex &lt; <span class="number">0</span> ? <span class="number">7</span> : currentIndex</span><br><span class="line">    currentIndex = currentIndex &gt; <span class="number">7</span> ? <span class="number">0</span> : currentIndex</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">UIImage</span>(named: <span class="string">&quot;\(currentIndex)&quot;</span> + <span class="string">&quot;.jpg&quot;</span>)!</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>核心动画给我们展示的只是一个假象，layer的的frame、bounds、position并不会在动画完毕之后发生改变。</li>
<li>UIView封装的动画，会使会真实修改view的一些属性</li>
<li>以上就是小编总结的关于Core Animation核心动画的相关分类</li>
<li>总结的知识点比较简单, 个人感觉有点low</li>
<li>如有不足之处,还望路过的大神多多指教</li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>CoreAnimation</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS组件化之私有库</title>
    <url>/post/7c5c4661.html</url>
    <content><![CDATA[<ul>
<li>随着公司业务的不断发展，应用的代码体积将会越来越大，业务代码耦合也越来越多，代码量也是急剧增加</li>
<li>如果仅仅完成代码拆分还不足以解决业务之间的代码耦合，而组件化是一种能够解决代码耦合、业务工程能够独立运行的技术</li>
<li>这篇文章主要介绍远程私有库的创建和管理以及本地索引库的使用, 并且可参照<a href="https://www.titanjun.top/2018/06/29/%E5%8F%91%E5%B8%83%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6%E5%88%B0CocoaPods%E5%85%A5%E5%9D%91%E6%8C%87%E5%8D%97/">发布开源框架到CocoaPods入坑指南</a></li>
</ul>
<span id="more"></span>


<h2 id="本地库方案"><a href="#本地库方案" class="headerlink" title="本地库方案"></a>本地库方案</h2><h3 id="创建本地私有库"><a href="#创建本地私有库" class="headerlink" title="创建本地私有库"></a>创建本地私有库</h3><ul>
<li>首先需要一个宿主工程<code>MainMoudle</code>和一个用于存放所有本地私有库的文件夹<code>AllMoudles</code>, 这两个文件夹在同一目录下</li>
<li>在<code>AllMoudles</code>文件夹中创建一个私有库<code>TitanFMBase</code>, 在子目录创建<code>Classes</code>用于存放所有的文件, 目录如下: <code>AllMoudles/TitanFMBase/Classes</code></li>
<li>在<code>Classes</code>文件夹中添加文件, 并提交到本地<code>git</code></li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//进入TitanFMBase文件夹</span></span><br><span class="line">cd xxx/AllMoudles/TitanFMBase</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化git</span></span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line"><span class="comment">//将本地代码提交到本地仓库</span></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交修改到本地仓库</span></span><br><span class="line">git commit -m <span class="string">&#x27;你的修改记录&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建spec文件</span></span><br><span class="line">pod spec cteate TitanFMBase</span><br></pre></td></tr></table></figure>

<p>最后打开<code>TitanFMBase</code>文件夹中的<code>TitanFMBase.podspec</code>, 修改对应的配置信息, 可<a href="https://www.titanjun.top/2018/06/29/%E5%8F%91%E5%B8%83%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6%E5%88%B0CocoaPods%E5%85%A5%E5%9D%91%E6%8C%87%E5%8D%97/">参考修改博客</a>或可参考<a href="https://guides.cocoapods.org/syntax/podspec.html#specification">官方文档</a></p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Pod::Spec</span>.new <span class="keyword">do</span> |<span class="params">s</span>|</span><br><span class="line">    s.name          = <span class="string">&#x27;TitanModel&#x27;</span> <span class="comment">#项目名</span></span><br><span class="line">    s.version       = <span class="string">&#x27;0.1.0&#x27;</span> <span class="comment">#相应的版本号</span></span><br><span class="line">    s.summary       = <span class="string">&#x27;A short description of YJDemoSDK.&#x27;</span> <span class="comment">#简述</span></span><br><span class="line">    s.description   = &lt;&lt;‐ <span class="variable constant_">DESC</span> <span class="comment">#详细描述</span></span><br><span class="line">    <span class="variable constant_">TODO</span>: Add long description of the pod here.</span><br><span class="line">                      <span class="variable constant_">DESC</span></span><br><span class="line">    s.homepage      = <span class="string">&#x27;https://github.com/CoderTitan/TitanModel&#x27;</span> <span class="comment">#项目主页</span></span><br><span class="line">    s.license       = &#123; <span class="symbol">:type</span> =&gt; <span class="string">&#x27;MIT&#x27;</span>, <span class="symbol">:file</span> =&gt; <span class="string">&#x27;LICENSE&#x27;</span> &#125; <span class="comment">#开源协议</span></span><br><span class="line">    s.author        = &#123; <span class="string">&#x27;CoderTitan&#x27;</span> =&gt; <span class="string">&#x27;quanjunt@163.com&#x27;</span> &#125; <span class="comment">#作者</span></span><br><span class="line">    s.platform      = <span class="symbol">:ios</span>, <span class="string">&#x27;8.0&#x27;</span> <span class="comment">#支持的平台</span></span><br><span class="line">    s.requires_arc  = <span class="literal">true</span> <span class="comment">#arc和mrc选项</span></span><br><span class="line">    s.libraries     = <span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27;sqlite3&#x27;</span> <span class="comment">#表示依赖的系统类库，比如libz.dylib等</span></span><br><span class="line">    s.frameworks    = <span class="string">&#x27;UIKit&#x27;</span>,<span class="string">&#x27;AVFoundation&#x27;</span> <span class="comment">#表示依赖系统的框架</span></span><br><span class="line">    s.ios.vendored_frameworks = <span class="string">&#x27;TKBase/TKBase.framework&#x27;</span> <span class="comment"># 依赖的第三方/自己的framework</span></span><br><span class="line">    s.vendored_libraries = <span class="string">&#x27;Library/Classes/libWeChatSDK.a&#x27;</span> <span class="comment">#表示依赖第三方/自己的静态库（比如libWeChatSDK.a）</span></span><br><span class="line">    <span class="comment">#依赖的第三方的或者自己的静态库文件必须以lib为前缀进行命名，否则会出现找不到的情况，这一点非常重要</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#平台信息</span></span><br><span class="line">    s.platform      = <span class="symbol">:ios</span>, <span class="string">&#x27;7.0&#x27;</span></span><br><span class="line">    s.ios.deployment_target = <span class="string">&#x27;7.0&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#文件配置项</span></span><br><span class="line">    s.source        = &#123; <span class="symbol">:git</span> =&gt; <span class="string">&#x27;https://github.com/CoderTitan/TitanModel.git&#x27;</span>, <span class="symbol">:tag</span> =&gt; s.version.to_s &#125;</span><br><span class="line">    <span class="comment">#配置项目的目标路径，如果不是本地开发，pod init/update会从这个路去拉去代码</span></span><br><span class="line"></span><br><span class="line">    s.source_files = <span class="string">&#x27;TitanModel/Classes/**/*&#x27;</span> <span class="comment">#你的源码位置</span></span><br><span class="line">    s.resources     = [<span class="string">&#x27;TitanModel/Assets/*&#x27;</span>] <span class="comment">#资源，比如图片，音频文件等</span></span><br><span class="line">    s.public_header_files = <span class="string">&#x27;TitanModel/Classes/TitanModel.h&#x27;</span>   <span class="comment">#需要对外开放的头文件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#依赖的项目内容 可以多个</span></span><br><span class="line">    s.dependency <span class="string">&#x27;MJExtension&#x27;</span></span><br><span class="line">    s.dependency <span class="string">&#x27;AFNetworking&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>


<div class="note warning"><p>注意点</p></div>

<p>在<code>source</code>配置中, 本地库的git地址不需要填</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s.source = &#123; :git =&gt; &quot;&quot;, :tag =&gt; &quot;#&#123;s.version&#125;&quot; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用本地私有库"><a href="#使用本地私有库" class="headerlink" title="使用本地私有库"></a>使用本地私有库</h3><ul>
<li>安装和使用本地私有库和和远程私有库步骤一样, 不同的是:<ul>
<li>远程私有库不需要指明库的地址</li>
<li>本地私有库需要制定库地址(相对路径即可)</li>
</ul>
</li>
<li>使用<code>path</code>的形式添加框架依赖</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pod &#x27;TitanFMBase&#x27;, :path =&gt; &#x27;../AllMoudles/TitanFMBase&#x27;</span><br></pre></td></tr></table></figure>

<div class="note warning"><p>注意点</p></div>

<ul>
<li>入伙时本地私有库, 不需要使用<code>pod lib lint</code>或者<code>pod spec lint</code>验证<code>spec</code>文件的正确性</li>
<li>因为有些字段只有远程私有库才需要设置, 只要保证本地私有库的路径正确, 并不影响使用</li>
</ul>
<h2 id="远程私有库"><a href="#远程私有库" class="headerlink" title="远程私有库"></a>远程私有库</h2><ul>
<li>当我们在终端执行<code>pod search</code>命令时, 搜索的其实是本地缓存的<code>spec</code>文件, 当然第一次使用时需要先更新本地的<code>spec</code>文件</li>
<li>可在终端执行<code>pod repo</code>命令查看当前本地的索引库, 或者查看目录<code>~/.cocoapods/repos/master/Specs</code></li>
<li>在组件化开发过程中, 为防止代码泄露, 我们必须要创建自己的本地索引库</li>
<li><a href="https://www.titanjun.top/2018/06/29/%E5%8F%91%E5%B8%83%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6%E5%88%B0CocoaPods%E5%85%A5%E5%9D%91%E6%8C%87%E5%8D%97/">发布开源框架到CocoaPods入坑指南</a>文章中提到了一种创建方式<ul>
<li>但是上述提到的创建方式, 需要手动创建<code>podspec</code>文件</li>
<li>需要手动进行git管理, 不能测试, 需要手动添加测试工程</li>
</ul>
</li>
<li>执行<code>pod repo add TitanSpec http://xxxx</code>命令, 可创建一个新的本地索引库</li>
<li>创建远程索引库, <a href="https://coding.net/">码市</a></li>
<li>除图中红色箭头外, 其他地方不需要填写, 新建即可</li>
</ul>
<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-7cf6d111ae63b9f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="CreateSpec"></p>
<h3 id="创建远程私有库"><a href="#创建远程私有库" class="headerlink" title="创建远程私有库"></a>创建远程私有库</h3><ul>
<li><code>pod lib create xxx</code></li>
<li>规范创建私有库, 执行上述命令, 可同时创建<code>spec</code>文件和测试工程等</li>
<li>根据提示创建不同的配置文件即可, 创建完成后, 将需要添加的私有库文件放到<code>xxx/xxx/Classes</code>文件夹下即可, 默认创建的.m文件可删除</li>
<li>最后需要打开<code>Example</code>目录下的测试工程, 并执行<code>pod install</code>命令, 将你的私有库文件安装到测试工程</li>
<li>最后修改<code>xxx</code>文件下的<code>xxx.podspec</code>文件中相关配置即可</li>
</ul>
<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-dfc5111dd4b02a01.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="createLib"></p>
<p>做完上述工作即可将项目所有文件提交到远程私有库了</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将本地代码加入本地仓库里</span></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交修改到本地仓库</span></span><br><span class="line">git commit -m <span class="string">&#x27;你的修改记录&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看当前的远程连接</span></span><br><span class="line">git remote</span><br><span class="line"><span class="comment">// 添加名称为origin的远程连接</span></span><br><span class="line">git remote add origin <span class="string">&#x27;你的github项目地址&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在push之前, 查看spec是否配置有问题</span></span><br><span class="line"><span class="comment">// 验证本地spec文件是否有误</span></span><br><span class="line">pod lib lint</span><br><span class="line"><span class="comment">// 验证远程spec文件是否有误</span></span><br><span class="line">pod spec lint</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推送master分支的代码到名称为origin的远程仓库</span></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure>


<ul>
<li>正常情况下本地验证一般没问题, 远程验证正常情况下会有问题</li>
<li>本地验证不会验证<code>s.source</code>后面的<code>tag</code></li>
<li>远程验证会验证<code>tag</code>, 而至此我们的<code>tag</code>还没有设置, 所以验证不会通过, 需要打标签</li>
<li>设置好<code>tag</code>, 再次验证应该就是没问题的了</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查看当前的tag值</span></span><br><span class="line">git tag</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置tag值</span></span><br><span class="line">git tag <span class="string">&quot;0.0.1&quot;</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 上传提交tag</span></span><br><span class="line">git push --tags</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除标签相关命令</span></span><br><span class="line"><span class="comment">// 先删除本地再删除远程标签, 删除后需要重新打标签</span></span><br><span class="line"><span class="comment">// 删除本地标签</span></span><br><span class="line">git tag -d <span class="number">0.0</span><span class="number">.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除远程标签</span></span><br><span class="line">git push origin :<span class="number">0.0</span><span class="number">.1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="提交私有的SpecRepo"><a href="#提交私有的SpecRepo" class="headerlink" title="提交私有的SpecRepo"></a>提交私有的SpecRepo</h3><p>向私有的<code>SpecRepo</code>中提交<code>podspec</code>: </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pod repo push SpecName XXX.podspec</span><br></pre></td></tr></table></figure>

<div class="note warning"><p>注意点</p></div>

<ul>
<li>提交<code>podspec</code>的过程中会有验证, 最好在提交之前先验证<code>spec</code>文件的配置是有问题<code>pod lib lint</code><ul>
<li>警告可以使用<code>--allow-warings</code>忽略</li>
<li>但是涉及到的错误信息一定要解决</li>
</ul>
</li>
<li>提交过程中, 会提交信息到远程私有索引库</li>
</ul>
<h3 id="使用私有库"><a href="#使用私有库" class="headerlink" title="使用私有库"></a>使用私有库</h3><ul>
<li>检索私有库: <code>pod search XXX</code><ul>
<li>如果检索不到, 可以先到私有索引库内, 看看是否存在私有库</li>
<li>如果存在还是检索不到, 则直接删除私有库索引文件, 重新配置</li>
</ul>
</li>
<li>在<code>Podfile</code>文件中, 同事使用私有库和第三方库是需要指定对应的<code>source</code>源</li>
<li><code>pod repo</code>命令执行后的结果</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">master</span><br><span class="line">- Type: git (master)</span><br><span class="line">- URL:  <span class="string">&#x27;https://github.com/CocoaPods/Specs.git&#x27;</span></span><br><span class="line">- Path: /Users/xxx/.cocoapods/repos/master</span><br><span class="line"></span><br><span class="line">TitanFMSpec</span><br><span class="line">- Type: git (master)</span><br><span class="line">- URL:  <span class="string">&#x27;https://git.coding.net/CoderTitan/TitanFMSpec.git&#x27;</span></span><br><span class="line">- Path: /Users/xxx/.cocoapods/repos/TitanFMSpec</span><br></pre></td></tr></table></figure>


<p><code>Podfile</code>文件中配置信息</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 远程私有库</span></span><br><span class="line">source <span class="string">&#x27;https://git.coding.net/CoderTitan/TitanFMSpec.git&#x27;</span></span><br><span class="line"><span class="comment">// 官方仓库</span></span><br><span class="line">source <span class="string">&#x27;https://github.com/CocoaPods/Specs.git&#x27;</span></span><br><span class="line"></span><br><span class="line">platform :ios, <span class="string">&#x27;8.0&#x27;</span></span><br><span class="line"></span><br><span class="line">target <span class="string">&#x27;TitanjunFM&#x27;</span> <span class="keyword">do</span></span><br><span class="line">  use_frameworks!</span><br><span class="line"></span><br><span class="line">pod <span class="string">&#x27;TitanFMBase&#x27;</span></span><br><span class="line">pod <span class="string">&#x27;MJExtension&#x27;</span></span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>


<h2 id="更新私有库"><a href="#更新私有库" class="headerlink" title="更新私有库"></a>更新私有库</h2><h3 id="更新远程私有库"><a href="#更新远程私有库" class="headerlink" title="更新远程私有库"></a>更新远程私有库</h3><ol>
<li>修改<code>xxx/xxx/Classes</code>文件夹下对应的库文件</li>
<li>更新测试工程的<code>Pod</code>库文件: <code>pod update --no-repo-update</code></li>
<li>更新<code>xxx.podspec</code>文件的配置信息, 版本号一定要改</li>
<li>提交代码到远程仓库: <code>git push origin master</code></li>
<li>更新<code>tag</code>标签: <code>git push --tags</code></li>
<li>更新远程和本地的私有索引库: <code>pod repo push SpecName XXX.podspec</code></li>
</ol>
<h3 id="私有库依赖"><a href="#私有库依赖" class="headerlink" title="私有库依赖"></a>私有库依赖</h3><h4 id="初步设计方案"><a href="#初步设计方案" class="headerlink" title="初步设计方案"></a>初步设计方案</h4><ul>
<li>在设计私有库的过程中难免可能会涉及到使用其他第三方库的情况, 又该如何解决这种问题</li>
<li>添加组件依赖: 在<code>podspec</code>文件配置中, 添加如下依赖代码</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">s.dependency <span class="string">&#x27;AFNetworking&#x27;</span></span><br><span class="line">s.dependency <span class="string">&#x27;SDWebImage&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>注意依赖, 以及框架头文件中, 不要直接导入依赖框架的头文件</li>
<li>也就是说, 上述涉及到的所依赖的第三方库, 在项目的<code>Podfile</code>文件中, 不会再导入该类库</li>
</ul>
<h4 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h4><blockquote>
<p>上述方案存在的问题: 假如另外一个业务线, 仅仅需要依赖一些基础配置, 但是, 如果把整个库作为依赖, 便会导入一些不用的冗余代码</p>
</blockquote>
<ul>
<li>这样, 我们现在终端执行<code>pod search AFNetworking</code>, 看一下<code>AFNetworking</code>的搜索结果</li>
<li>会看到<code>Subspecs</code>中, 将<code>AFNetworking</code>分成了几个不同的部分, 这样我们就可以根据不同的功能需求导入不同部分的代码即可, 防止代码冗余</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-&gt; AFNetworking (3.2.1)</span><br><span class="line">   A delightful iOS and OS X networking framework.</span><br><span class="line">   pod &#x27;AFNetworking&#x27;, &#x27;~&gt; 3.2.1&#x27;</span><br><span class="line">   - Homepage: https://github.com/AFNetworking/AFNetworking</span><br><span class="line">   - Source:   https://github.com/AFNetworking/AFNetworking.git</span><br><span class="line">   - Versions: 3.2.1, ......,0.5.1 [master repo]</span><br><span class="line">   - Subspecs:</span><br><span class="line">     - AFNetworking/Serialization (3.2.1)</span><br><span class="line">     - AFNetworking/Security (3.2.1)</span><br><span class="line">     - AFNetworking/Reachability (3.2.1)</span><br><span class="line">     - AFNetworking/NSURLSession (3.2.1)</span><br><span class="line">     - AFNetworking/UIKit (3.2.1)</span><br></pre></td></tr></table></figure>


<blockquote>
<p>为解决将私有库中的代码分成不同的功能模块, 使用<code>subspec</code>语法配置<code>podspec</code>文件, 如下:</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//格式:</span></span><br><span class="line">s.subspec <span class="string">&#x27;XXX&#x27;</span> <span class="keyword">do</span> |x|</span><br><span class="line">    <span class="comment">//需要导入的所有文件的相对路径</span></span><br><span class="line">    x.source_files = <span class="string">&#x27;相对路径/**/*&#x27;</span></span><br><span class="line">    <span class="comment">//需要导入的.h头文件的相对路径</span></span><br><span class="line">    x.public_header_files = <span class="string">&#x27;相对路径/**/*.h&#x27;</span></span><br><span class="line">    <span class="comment">//需要导入的资源文件的相对路径</span></span><br><span class="line">    x.resource = <span class="string">&quot;相对路径/**/*.&#123;bundle,nib,xib&#125;&quot;</span></span><br><span class="line">    <span class="comment">//所依赖的其他的库</span></span><br><span class="line">    x.dependency <span class="string">&#x27;AFNetworking&#x27;</span>, <span class="string">&#x27;~&gt; 1.0.0&#x27;</span></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="comment">//示例:</span></span><br><span class="line">s.subspec <span class="string">&#x27;Network&#x27;</span> <span class="keyword">do</span> |n|</span><br><span class="line">    n.source_files = <span class="string">&#x27;XMGFMBase/Classes/Network/**/*&#x27;</span></span><br><span class="line">    n.dependency <span class="string">&#x27;AFNetworking&#x27;</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<ul>
<li>将原来的<code>s.source_files</code>改成上述语法即可</li>
<li>外部使用时只需导入<code>pod &#39;AFNetworking/Reachability&#39;</code>即可</li>
</ul>
<h2 id="私有库的资源引用"><a href="#私有库的资源引用" class="headerlink" title="私有库的资源引用"></a>私有库的资源引用</h2><h3 id="xib-amp-storyboard"><a href="#xib-amp-storyboard" class="headerlink" title="xib&amp;storyboard"></a><code>xib&amp;storyboard</code></h3><ul>
<li>所有私有库中的<code>xib</code>必须动态获取</li>
<li>私有库中引用图片资源或者<code>Xib</code>资源时, 又该如何引用呢?</li>
<li>都知道项目中引用<code>Xib</code>时, 通常方式是<code>[[NSBundle mainBundle] load]</code>方式, 但是这种方式在私有库中显然不适用</li>
<li>在私有库中加载私有库中的<code>XIb</code>, 使用方法<code>[NSBundle bundleForClass:self]</code>动态获取, 具体看一下</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MiddleView.m</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSBundle</span> *mainBundle = [<span class="built_in">NSBundle</span> mainBundle];</span><br><span class="line"><span class="built_in">NSBundle</span> *bundle = [<span class="built_in">NSBundle</span> bundleForClass:<span class="keyword">self</span>];</span><br><span class="line">    </span><br><span class="line">MiddleView *middleView = [[bundle loadNibNamed:<span class="string">@&quot;MiddleView&quot;</span> owner:<span class="literal">nil</span> options:<span class="literal">nil</span>] firstObject];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印一下上述两个bundle如下:</span></span><br><span class="line"><span class="comment">// mainBundle:</span></span><br><span class="line"><span class="built_in">NSBundle</span> &lt;/Users/xxx/Library/Developer/CoreSimulator/Devices/<span class="number">6</span>B74958F<span class="number">-560</span>F<span class="number">-4</span>BF4<span class="number">-9</span>BDF<span class="number">-9</span>AD789379FC9/data/Containers/Bundle/Application/FC9747F0<span class="number">-8</span>A82<span class="number">-4643</span>-AC7E-BDC268190B8D/TitanFM.app&gt;</span><br><span class="line"><span class="comment">// bundle:</span></span><br><span class="line"><span class="built_in">NSBundle</span> &lt;/Users/xxx/Library/Developer/CoreSimulator/Devices/<span class="number">6</span>B74958F<span class="number">-560</span>F<span class="number">-4</span>BF4<span class="number">-9</span>BDF<span class="number">-9</span>AD789379FC9/data/Containers/Bundle/Application/FC9747F0<span class="number">-8</span>A82<span class="number">-4643</span>-AC7E-BDC268190B8D/TitanFM.app/Frameworks/TitanFMMain.framework&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>从上述信息中可以看到, 项目中正常的<code>Xib</code>等资源文件是放在<code>TitanFM.app</code>中的</li>
<li>而私有库的<code>Xib</code>等资源文件是放在<code>TitanFM.app/Frameworks/TitanFMMain.framework</code>文件目录下的, 所以私有库中的资源文件加载, 要到对应的文件目录下</li>
<li>具体也可以到<code>TitanFM.app</code>中查看, 找到对应的<code>app</code>文件, 显示包内容, 即可层级查看</li>
</ul>
<h3 id="图片资源"><a href="#图片资源" class="headerlink" title="图片资源"></a>图片资源</h3><h4 id="图片存放问题"><a href="#图片存放问题" class="headerlink" title="图片存放问题"></a>图片存放问题</h4><ul>
<li>正常项目中, 我们的图片一般都会放在类似后缀<code>.xcassets</code>的文件中</li>
<li>在设计私有库时, 在<code>Classes</code>的同级目录中会默认创建一个<code>Assets</code>的文件夹, 用于存放图片等资源</li>
<li>在<code>podspec</code>文件中, 同样修改加载文件资源的配置, 如下:</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">s.resource_bundles = &#123;</span><br><span class="line">   <span class="string">&#x27;MainMoudle&#x27;</span> =&gt; [<span class="string">&#x27;MainMoudle/Assets/*&#x27;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>修改完配置信息和图片记得执行<code>pod install</code>把资源文件导入到项目中</p>
</blockquote>
<h4 id="私有库图片的使用"><a href="#私有库图片的使用" class="headerlink" title="私有库图片的使用"></a>私有库图片的使用</h4><p>在<code>xib</code>中加载图片, 需要在图片前面加上组件的主<code>bundle</code>, 类似: <code>MainMoudle.bundle/tabbat_back</code></p>
<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-5602c779a1e54291.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="xibimage"></p>
<p>私有库中使用代码加载图片, 一定不能使用<code>imageNamed</code>方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 获取当前的bundleName</span></span><br><span class="line"><span class="built_in">NSBundle</span> *currentBundle = [<span class="built_in">NSBundle</span> bundleForClass:[<span class="keyword">self</span> <span class="keyword">class</span>]];</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 根据图片名称, 在bundle中检索图片路径</span></span><br><span class="line"><span class="built_in">NSString</span> *path = [currentBundle pathForResource:<span class="string">@&quot;tabbar_np_play@2x.png&quot;</span> ofType:<span class="literal">nil</span> inDirectory:<span class="string">@&quot;MainMoudle.bundle&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取图片</span></span><br><span class="line"><span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithContentsOfFile:path];</span><br></pre></td></tr></table></figure>

<div class="note warning"><p>引用图片需要注意的的是</p></div>

<ul>
<li>图片引用过程中不会自动选择<code>@2x和@3x</code>的图片, 所以必须手动指定具体的图片名称包括图片后缀名</li>
<li>获取路径的方法<code>pathForResource</code>, 也要必须指明图片所在的<code>bundle</code>路径, 即<code>inDirectory</code>参数不可为空</li>
</ul>
<div class="note info"><p>提交本地的私有库索引</p></div>

<ul>
<li>当你的私有库中引用了其他的私有库框架, 比如<code>MainMoudle</code>中引用了<code>TitanFMBase/Category</code>部分</li>
<li>则切记不要进行本地和远程的<code>spec</code>验证, 否则可能回报错, 原因只是因为<code>spec</code>中默认的依赖库是共有的索引库, 私有库无法检索到, 错误信息如下图</li>
<li>提交本地索引的过程中遇到类似错误则可以, 直接忽略提交即可, 但是其他的错误信息, 切记需要修改好, 警告可以忽略, 但是错误信息不能忽略(依赖私有库的问题除外)</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 提交本地私有索引库需要忽略警告的命令</span></span><br><span class="line">pod repo push TitanjunSpec MainMoudle.podspec --allow-warnings</span><br></pre></td></tr></table></figure>


<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-aa9b20f9428c9fd8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="podspec"></p>
<h3 id="相关参考"><a href="#相关参考" class="headerlink" title="相关参考"></a>相关参考</h3><ul>
<li><a href="http://www.cocoachina.com/ios/20180312/22536.html">iOS组件化参考文章</a></li>
</ul>
<hr>
]]></content>
      <categories>
        <category>组件化开发</category>
      </categories>
      <tags>
        <tag>CocoaPods</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS神技之动态更换APP的Icon图</title>
    <url>/post/632f54a6.html</url>
    <content><![CDATA[<ul>
<li>在iOS10.3系统发布之前, 众所周知, 在App Store上架的APP如果要更换Icon图, 只能更新版本替换;</li>
<li>这次苹果却在iOS10.3系统中加入了了更换应用图标的新功能，当应用安装后，开发者可以为应用提供多个应用图标选择。</li>
<li>用户可以自由的在这些图标之间切换，并及时生效。</li>
<li>这是因为 10.3 里引入了一个新的 API，它允许在 App 运行的时候，通过代码为 app 更换 icon</li>
</ul>
<span id="more"></span>

<h2 id="项目配置"><a href="#项目配置" class="headerlink" title="项目配置"></a>项目配置</h2><ul>
<li><p>虽然提供了更换的功能，但更换的 icon 是有限制的</p>
</li>
<li><p>它只能更换项目中提前添加配置好的Icon图</p>
</li>
<li><p>具体可参考demo–<a href="https://github.com/CoderTitan/ChangeIcon">github项目地址</a></p>
</li>
<li><p>这里先看个效果</p>
</li>
</ul>
<p><img data-src="https://upload-images.jianshu.io/upload_images/4122543-66b9c476748f1937.gif?imageMogr2/auto-orient/strip" alt="更换icon.gif"></p>
<h3 id="备选Icon"><a href="#备选Icon" class="headerlink" title="备选Icon"></a>备选Icon</h3><ul>
<li>首先你需要将备选的Icon图添加到项目中,</li>
<li>注意:<ul>
<li>图片不要放到<code>Assets.xcassets</code>, 而应该直接放到工程中, 不然可能导致更换Icon时, 找不到图片, 更换失败</li>
<li>在<code>info.plist</code> 的配置中，图片的文件名应该尽量不带 @2x&#x2F;@3x 后缀扩展名，而让它自动选择</li>
</ul>
</li>
</ul>
<p><img data-src="https://upload-images.jianshu.io/upload_images/4122543-49f0f45c2657a229.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="Snip20180315_1.png"></p>
<h3 id="配置info-plist文件"><a href="#配置info-plist文件" class="headerlink" title="配置info.plist文件"></a>配置<code>info.plist</code>文件</h3><ul>
<li>在<code>info.plist</code>文件中，添加对应的<code>CFBundleAlternateIcons</code>的信息</li>
<li>这里也可以查看<a href="https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Introduction/Introduction.html#//apple_ref/doc/uid/TP40009247">官方的相关介绍</a></li>
</ul>
<p><img data-src="https://upload-images.jianshu.io/upload_images/4122543-8886cf5e071a1c59.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="Snip20180315_2.png"></p>
<blockquote>
<p><code>Source Code</code>添加方式如下</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">      &lt;key&gt;<span class="built_in">CFBundleAlternateIcons</span>&lt;/key&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">	&lt;key&gt;天天特价&lt;/key&gt;</span><br><span class="line">	&lt;dict&gt;</span><br><span class="line">		&lt;key&gt;<span class="built_in">CFBundleIconFiles</span>&lt;/key&gt;</span><br><span class="line">		&lt;array&gt;</span><br><span class="line">			&lt;string&gt;天天特价&lt;/string&gt;</span><br><span class="line">		&lt;/array&gt;</span><br><span class="line">		&lt;key&gt;<span class="built_in">UIPrerenderedIcon</span>&lt;/key&gt;</span><br><span class="line">		&lt;<span class="literal">false</span>/&gt;</span><br><span class="line">	&lt;/dict&gt;</span><br><span class="line">	&lt;key&gt;小房子&lt;/key&gt;</span><br><span class="line">	&lt;dict&gt;</span><br><span class="line">		&lt;key&gt;<span class="built_in">CFBundleIconFiles</span>&lt;/key&gt;</span><br><span class="line">		&lt;array&gt;</span><br><span class="line">			&lt;string&gt;小房子&lt;/string&gt;</span><br><span class="line">		&lt;/array&gt;</span><br><span class="line">		&lt;key&gt;<span class="built_in">UIPrerenderedIcon</span>&lt;/key&gt;</span><br><span class="line">		&lt;<span class="literal">false</span>/&gt;</span><br><span class="line">	&lt;/dict&gt;</span><br><span class="line">	&lt;key&gt;小猫&lt;/key&gt;</span><br><span class="line">	&lt;dict&gt;</span><br><span class="line">		&lt;key&gt;<span class="built_in">CFBundleIconFiles</span>&lt;/key&gt;</span><br><span class="line">		&lt;array&gt;</span><br><span class="line">			&lt;string&gt;小猫&lt;/string&gt;</span><br><span class="line">		&lt;/array&gt;</span><br><span class="line">		&lt;key&gt;<span class="built_in">UIPrerenderedIcon</span>&lt;/key&gt;</span><br><span class="line">		&lt;<span class="literal">false</span>/&gt;</span><br><span class="line">	&lt;/dict&gt;</span><br><span class="line">	&lt;key&gt;邮件信息&lt;/key&gt;</span><br><span class="line">	&lt;dict&gt;</span><br><span class="line">		&lt;key&gt;<span class="built_in">CFBundleIconFiles</span>&lt;/key&gt;</span><br><span class="line">		&lt;array&gt;</span><br><span class="line">			&lt;string&gt;邮件信息&lt;/string&gt;</span><br><span class="line">		&lt;/array&gt;</span><br><span class="line">		&lt;key&gt;<span class="built_in">UIPrerenderedIcon</span>&lt;/key&gt;</span><br><span class="line">		&lt;<span class="literal">false</span>/&gt;</span><br><span class="line">	&lt;/dict&gt;</span><br><span class="line">&lt;/dict&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>注意事项:<ul>
<li>虽然文档中写着<code>「You must declare your app&#39;s primary and alternate icons using the CFBundleIcons key of your app&#39;s Info.plist file. 」</code>，但经测试，<code>CFBundlePrimaryIcon</code> 可以省略掉。在工程配置 <code>App Icons and Launch Image</code> - <code>App Icons Source</code> 中使用 <code>asset catalog</code>（默认配置），删除 <code>CFBundlePrimaryIcon</code> 的配置也是没有问题的。</li>
<li>省略这个配置的好处是，避免处理 <code>App icon</code> 的尺寸。现在的工程中，大家一般都使用 <code>asset catalog</code> 进行 icon 的配置，而一个 icon 对应有很多尺寸的文件。省略 <code>CFBundlePrimaryIcon</code> 就可以沿用 <code>Asset</code> 中的配置。</li>
<li>如果想设置回默认 icon，在 <code>setAlternateIconName</code> 中传入 nil 即可</li>
</ul>
</li>
</ul>
<h2 id="API调用"><a href="#API调用" class="headerlink" title="API调用"></a>API调用</h2><p>下面我们看一下系统提供的三个API, 这里产看<a href="https://developer.apple.com/documentation/uikit/uiapplication/2806818-setalternateiconname">官方文档</a></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">var supportsAlternateIcons: Bool</span><br><span class="line"><span class="comment">//一个布尔值，指示是否允许应用程序更改其图标</span></span><br><span class="line"></span><br><span class="line">var alternateIconName: String?</span><br><span class="line"><span class="comment">//可选图标的名称，在app的Info.plist文件中声明的CFBundleAlternateIcons中设置。</span></span><br><span class="line"><span class="comment">//如果要显示应用程序的主图标alternateIconName 传nil即可，主图标使用CFBundlePrimaryIcon声明，CFBundleAlternateIcons与CFBundlePrimaryIcon两个key都是CFBundleIcons的子条目</span></span><br><span class="line"></span><br><span class="line">func setAlternateIconName(_ alternateIconName: String?,</span><br><span class="line">        completionHandler: ((Error?) -&gt; Void)? = <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">//更改应用程序的图标</span></span><br><span class="line"><span class="comment">//completionHandler: 当有结果的时候的回调</span></span><br><span class="line"><span class="comment">//成功改变图标的的时候，error为nil，如果发生错误，error描述发生什么了。并且alternateIconName的值保持不变</span></span><br></pre></td></tr></table></figure>

<p>具体的实现代码:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="meta">#available(iOS 10.3, *) &#123;</span></span><br><span class="line">    <span class="comment">//判断是否支持替换图标, false: 不支持</span></span><br><span class="line">    guard <span class="built_in">UIApplication</span>.shared.supportsAlternateIcons <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果支持, 替换icon</span></span><br><span class="line">    <span class="built_in">UIApplication</span>.shared.setAlternateIconName(imageStr) &#123; (error) <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">if</span> error != <span class="literal">nil</span> &#123;</span><br><span class="line">            print(error ?? <span class="string">&quot;更换icon发生错误&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            print(<span class="string">&quot;更换成功&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="消除alert弹窗"><a href="#消除alert弹窗" class="headerlink" title="消除alert弹窗"></a>消除alert弹窗</h2><p><img data-src="https://upload-images.jianshu.io/upload_images/4122543-8ffa3280a84c46ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="Snip20180315_3.png"></p>
<ul>
<li>动态更换App图标会有弹框, 有时候这个弹框看上去可能会很别扭, 但是这个弹框是系统直接调用弹出的, 我们又如何消除呢</li>
<li>通过层级关系可以看到这个弹框就是一个<code>UIAlertController</code>, 并且是通过<code>presentViewController:animated:completion:</code>方法弹出的</li>
<li>所以可以考虑使用<code>runtime</code>, 拦截并替换该方法, 让更换icon的时候, 不弹</li>
<li>下面看一下具体代码:</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">extension NoAlertChangeViewController &#123;</span><br><span class="line">    fileprivate func runtimeReplaceAlert() &#123;</span><br><span class="line">        DispatchQueue.once(token: <span class="string">&quot;UIAlertController&quot;</span>) &#123;</span><br><span class="line">            let originalSelector = <span class="meta">#selector(present(_:animated:completion:))</span></span><br><span class="line">            let swizzledSelector = <span class="meta">#selector(noAlert_present(_:animated:completion:))</span></span><br><span class="line"></span><br><span class="line">            let originalMethod = class_getInstanceMethod(NoAlertChangeViewController.self, originalSelector)</span><br><span class="line">            let swizzledMethod = class_getInstanceMethod(NoAlertChangeViewController.self, swizzledSelector)</span><br><span class="line"></span><br><span class="line">            <span class="comment">//交换实现的方法</span></span><br><span class="line">            method_exchangeImplementations(originalMethod!, swizzledMethod!)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @objc fileprivate func noAlert_present(_ viewControllerToPresent: <span class="built_in">UIViewController</span>, animated flag: Bool, completion: (() -&gt; Swift.Void)? = <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="comment">//判断是否是alert弹窗</span></span><br><span class="line">        <span class="keyword">if</span> viewControllerToPresent.isKind(of: <span class="built_in">UIAlertController</span>.self) &#123;</span><br><span class="line">            print(<span class="string">&quot;title: \(String(describing: (viewControllerToPresent as? UIAlertController)?.title))&quot;</span>)</span><br><span class="line">            print(<span class="string">&quot;message: \(String(describing: (viewControllerToPresent as? UIAlertController)?.message))&quot;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 换图标时的提示框的title和message都是nil，由此可特殊处理</span></span><br><span class="line">            let alertController = viewControllerToPresent as? <span class="built_in">UIAlertController</span></span><br><span class="line">            <span class="keyword">if</span> alertController?.title == <span class="literal">nil</span> &amp;&amp; alertController?.message == <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="comment">//是更换icon的提示</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//其他的弹框提示正常处理</span></span><br><span class="line">                noAlert_present(viewControllerToPresent, animated: flag, completion: completion)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        noAlert_present(viewControllerToPresent, animated: flag, completion: completion)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>这里用到了<code>DispatchQueue.once</code>, 这个<code>once</code>是我对<code>DispatchQueue</code>加了一个扩展</li>
<li>在Swift4.0以后, <code>static dispatch_once_t onceToken;</code>这个已经不能用了</li>
<li>关于这方面的详细介绍, 大家可以看看我的这篇文章–<a href="https://www.titanjun.top/2017/08/25/%E5%8D%87%E7%BA%A7Swift4.0%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/">升级Swift4.0遇到的坑</a></li>
<li></li>
</ul>
<h2 id="支持不同尺寸的Icon"><a href="#支持不同尺寸的Icon" class="headerlink" title="支持不同尺寸的Icon"></a>支持不同尺寸的Icon</h2><ul>
<li>一个标准的Icon图集, 需要十几种尺寸, 比如: 20, 29, 40, 60等</li>
<li>对于 <code>info.plist</code> 中的每个 <code>icon</code> 配置，<code>CFBundleIconFiles</code> 的值是一个数组，我们可以在其中填入这十几种规格的图片名称。经测试:<ul>
<li>文件的命名没有强制的规则，可以随意取，</li>
<li>数组中的文件名也不关心先后顺序。</li>
</ul>
</li>
<li>总之把对应的文件名填进去即可，它会自动选择合适分辨率的文件（比如在 setting 中显示 icon 时，它会找到提供的数组中分辨率为 29pt 的那个文件）。</li>
<li>具体相关官方文档可参考, <a href="https://developer.apple.com/ios/human-interface-guidelines/overview/themes/#app-icon-sizes">官方介绍</a></li>
<li>首先, 针对不同的尺寸, 我们要有不同的命名, 具体参考下图</li>
</ul>
<p><img data-src="https://upload-images.jianshu.io/upload_images/4122543-c86a7e13288a1722?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="不同尺寸图片配置图"></p>
<ul>
<li>文件扩展名，如@2x,@3x，要么统一不写，那么系统会自动寻找合适的尺寸。</li>
<li>要写就需要把每张icon的扩展名写上，和上图的格式一样</li>
<li>代码中调用图片名, 更不需要加上尺寸:</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="meta">#available(iOS 10.3, *) &#123;</span></span><br><span class="line">    <span class="comment">//判断是否支持替换图标, false: 不支持</span></span><br><span class="line">    guard <span class="built_in">UIApplication</span>.shared.supportsAlternateIcons <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果支持, 替换icon</span></span><br><span class="line">    <span class="built_in">UIApplication</span>.shared.setAlternateIconName(<span class="string">&quot;Sunday&quot;</span>) &#123; (error) <span class="keyword">in</span></span><br><span class="line">        <span class="comment">//点击弹框的确认按钮后的回调</span></span><br><span class="line">        <span class="keyword">if</span> error != <span class="literal">nil</span> &#123;</span><br><span class="line">            print(error ?? <span class="string">&quot;更换icon发生错误&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            print(<span class="string">&quot;更换成功&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>具体可参考demo–<a href="https://github.com/CoderTitan/ChangeIcon">github项目地址</a></li>
</ul>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS黑科技之(CoreImage)静态人脸识别(一)</title>
    <url>/post/81c63b4c.html</url>
    <content><![CDATA[<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-3f1d091e07de5a9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Core Image框架图.png"></p>
<span id="more"></span>


<blockquote>
<p>人脸识别原理简介：每一张图片都是由每一个像素点组成，而每一个像素点中又有对应的颜色值(如RGB)，人的面部特征中，不同的五官，颜色值肯定存在差异，而人脸识别技术就是通过对照片中每一个像素的识别进行大量的算法处理，最终得出五官的轮廓</p>
</blockquote>
<ul>
<li>这里我们将使用<code>CoreImage</code>框架,进行静态的人脸识别(类似照片, 图像等)</li>
<li>苹果原生的人脸识别并不是一个独立的框架，而是放在<code>CoreImage</code>框架中</li>
<li>Apple 已经帮我们把image的分类处理好了</li>
<li>CoreImage是iOS5新增的强大类库之一，它可以处理图片的各种效果，什么饱和度啊，旋转变形啊，色彩啊等等。</li>
<li>在使用CoreImage之前要导入CoreImage.framework框架</li>
</ul>
<h2 id="主要类介绍"><a href="#主要类介绍" class="headerlink" title="主要类介绍"></a>主要类介绍</h2><ul>
<li><p>CIImage</p>
<ul>
<li>Core Image中的图像类，类似于UIKit中的UIImage类。</li>
</ul>
</li>
<li><p>CIContext: 上下文对象</p>
<ul>
<li>所有图像处理都在CIContext对象中实现，通过Quartz 2D、OpenGL渲染CIImage对象; 如滤镜、颜色等渲染处理</li>
</ul>
</li>
<li><p>CIColor：颜色</p>
<ul>
<li>图片的关联与画布、图片像素颜色的处理。</li>
</ul>
</li>
<li><p>CIVector：向量</p>
<ul>
<li>图片的坐标向量等几何方法处理。</li>
</ul>
</li>
<li><p>CIDetector<br>特征识别类</p>
<ul>
<li>该类集成了苹果有关特征识别的一些功能。</li>
<li>可检测图片中人脸的眼睛、嘴巴、等等</li>
</ul>
</li>
<li><p>CIFilter</p>
<ul>
<li>滤镜类，包含一个字典结构，对各种滤镜定义了属于自己的属性</li>
<li>CIFilter 产生一个CIImage</li>
<li>接受一到多的图片作为输入，经过一些过滤操作，产生指定输出的图片</li>
</ul>
</li>
<li><p>CIFeature: 代表由 detector处理后产生的特征</p>
</li>
</ul>
<h2 id="项目代码介绍"><a href="#项目代码介绍" class="headerlink" title="项目代码介绍"></a>项目代码介绍</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><h4 id="这里要先介绍一下检测器的类别"><a href="#这里要先介绍一下检测器的类别" class="headerlink" title="这里要先介绍一下检测器的类别"></a>这里要先介绍一下检测器的类别</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//人脸检测器</span></span><br><span class="line">public let <span class="built_in">CIDetectorTypeFace</span>: String</span><br><span class="line"></span><br><span class="line"><span class="comment">//矩形识别</span></span><br><span class="line">public let <span class="built_in">CIDetectorTypeRectangle</span>: String</span><br><span class="line"></span><br><span class="line"><span class="comment">//二维码识别</span></span><br><span class="line">public let <span class="built_in">CIDetectorTypeQRCode</span>: String</span><br><span class="line"></span><br><span class="line"><span class="comment">//文本识别</span></span><br><span class="line">public let <span class="built_in">CIDetectorTypeText</span>: String</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定检测精度</span></span><br><span class="line">public let <span class="built_in">CIDetectorAccuracy</span>: String</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定使用特征跟踪，这个功能就像相机中的人脸跟踪功能</span></span><br><span class="line">public let <span class="built_in">CIDetectorTracking</span>: String</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置将要识别的特征的最小尺寸</span></span><br><span class="line">public let <span class="built_in">CIDetectorMinFeatureSize</span>: String</span><br><span class="line"></span><br><span class="line"><span class="comment">//针对矩形探测器的，用于设置返回矩形特征的最多个数。</span></span><br><span class="line"><span class="comment">//这个关键字的值是一个1~...的NSNumber值。有效范围1 &lt; = CIDetectorMaxFeatureCount &lt; = 256。默认值为1</span></span><br><span class="line">public let <span class="built_in">CIDetectorMaxFeatureCount</span>: String</span><br><span class="line"></span><br><span class="line"><span class="comment">//脸部透视数, 值为包含1、3、5、7、9、11的NSNumber对象</span></span><br><span class="line">public let <span class="built_in">CIDetectorNumberOfAngles</span>: String</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置识别方向，值是一个从1 ~ 8的整型的NSNumber</span></span><br><span class="line">public let <span class="built_in">CIDetectorImageOrientation</span>: String</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置这个参数为true(bool类型的NSNumber)，识别器将提取眨眼特征</span></span><br><span class="line">public let <span class="built_in">CIDetectorEyeBlink</span>: String</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果设置这个参数为ture(bool类型的NSNumber)，识别器将提取微笑特征</span></span><br><span class="line">public let <span class="built_in">CIDetectorSmile</span>: String</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于设置每帧焦距，值得类型为floot类型的NSNumber</span></span><br><span class="line">public let <span class="built_in">CIDetectorFocalLength</span>: String</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于设置矩形的长宽比，值得类型为floot类型的NSNumber</span></span><br><span class="line">public let <span class="built_in">CIDetectorAspectRatio</span>: String</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制文本检测器是否应该检测子特征。默认值是否，值的类型为bool类型的NSNumber</span></span><br><span class="line">public let <span class="built_in">CIDetectorReturnSubFeatures</span>: String</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>这里需要的是人脸识别的<code>CIDetectorTypeFace</code></li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 创建上下文对象</span></span><br><span class="line">let context = <span class="built_in">CIContext</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. UIImage转成CIImage</span></span><br><span class="line">guard let image = imageView.image  <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">guard let ciImage = <span class="built_in">CIImage</span>(image: image) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 参数设置(精度设置)</span></span><br><span class="line">let parmes = [<span class="built_in">CIDetectorAccuracy</span>: <span class="built_in">CIDetectorAccuracyHigh</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 创建识别类</span></span><br><span class="line">let detector = <span class="built_in">CIDetector</span>(ofType: <span class="built_in">CIDetectorTypeFace</span>, context: context, options: parmes)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h3><ul>
<li>这里设置了一个识别精度CIDetectorAccuracy，识别精度的值有：</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//识别精度低，但识别速度快、性能高</span></span><br><span class="line">public let <span class="built_in">CIDetectorAccuracyLow</span>: String </span><br><span class="line"></span><br><span class="line"><span class="comment">// 识别精度高，但识别速度慢、性能低</span></span><br><span class="line">public let <span class="built_in">CIDetectorAccuracyHigh</span>: String </span><br></pre></td></tr></table></figure>
<ul>
<li>除了精度的设置，还有<code>CIDetectorMinFeatureSize</code>用于设置将要识别的特征的最小尺寸，也就是说小于这个尺寸的特征将不识别。<ul>
<li>对于人脸检测器，这个关键字的值是从0.0 ~ 1.0的<code>NSNumber</code>值，这个值表示：基于输入图像短边长度的百分比。有效值范围:0.01 &lt;&#x3D; <code>CIDetectorMinFeatureSize</code> &lt;&#x3D; 0.5。为这个参数设定更高值仅用于提高性能。默认值是0.15。</li>
<li>对于矩形探测器，这个关键字的值是从0.0 ~ 1.0的<code>NSNumber</code>值，这个值表示：基于输入图像短边长度的百分比。有效值范围:0.2 &lt;&#x3D; <code>CIDetectorMinFeatureSize</code> &lt;&#x3D; 1.0的默认值是0.2。</li>
<li>对于文本探测器，这个关键字的值是一个范围从0.0 ~ 1.0的<code>NSNumber</code>值，这个值表示：基于输入图像高度的百分比。有效值范围:0.0 &lt;&#x3D; <code>CIDetectorMinFeatureSize</code> &lt;&#x3D; 1.0。默认值是10&#x2F;(输入图像的高度)</li>
</ul>
</li>
</ul>
<h3 id="CIFaceFeature概述"><a href="#CIFaceFeature概述" class="headerlink" title="CIFaceFeature概述"></a>CIFaceFeature概述</h3><ul>
<li><code>CIFaceFeature</code>是保存脸部所有信息的类</li>
<li><code>CIFaceFeature</code>是<code>CIFeature</code>的子类</li>
<li><code>CIFeature</code>类只保存基本信息， 所有的附加信息由子类(<code>CIFaceFeature</code>)保存</li>
<li>各属性简介:</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//检测到的脸部在图片中的frame</span></span><br><span class="line">open var bounds: <span class="built_in">CGRect</span> &#123; get &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//是否检测到左眼的位置</span></span><br><span class="line">open var hasLeftEyePosition: Bool &#123; get &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//左眼的位置</span></span><br><span class="line">open var leftEyePosition: <span class="built_in">CGPoint</span> &#123; get &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//是否检测到右眼的位置</span></span><br><span class="line">open var hasRightEyePosition: Bool &#123; get &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//右眼的位置</span></span><br><span class="line">open var rightEyePosition: <span class="built_in">CGPoint</span> &#123; get &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//是否检测到嘴巴的位置</span></span><br><span class="line">open var hasMouthPosition: Bool &#123; get &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//嘴巴的位置</span></span><br><span class="line">open var mouthPosition: <span class="built_in">CGPoint</span> &#123; get &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//脸部是否倾斜    </span></span><br><span class="line">open var hasFaceAngle: Bool &#123; get &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//脸部倾斜角度</span></span><br><span class="line">open var faceAngle: Float &#123; get &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//是否微笑    </span></span><br><span class="line">open var hasSmile: Bool &#123; get &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//左眼是否闭上</span></span><br><span class="line">open var leftEyeClosed: Bool &#123; get &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//右眼是否闭上</span></span><br><span class="line">open var rightEyeClosed: Bool &#123; get &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Core-Image坐标系问题"><a href="#Core-Image坐标系问题" class="headerlink" title="Core Image坐标系问题"></a><code>Core Image</code>坐标系问题</h3><ul>
<li>如图:</li>
</ul>
<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-a8af4dc80c214d1b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt="坐标系对比.png"></p>
<ul>
<li><code>UIView</code>坐标系<ul>
<li>图中上半部分坐标系</li>
<li>Y轴自上而下依次增大</li>
</ul>
</li>
<li><code>Core Image</code>坐标系<ul>
<li>图中下半部分显示坐标系</li>
<li>X轴与<code>UIView</code>坐标系相同, Y轴坐标系最底部为0, 自下而上依次增大, 与<code>UIView</code>坐标系相反</li>
<li>所以需要对以次坐标设置frame的控件, 做一次针对Y轴的翻转, 如下:</li>
</ul>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">resultView.transform = <span class="built_in">CGAffineTransform</span>(scaleX: <span class="number">1</span>, y: <span class="number">-1</span>)</span><br></pre></td></tr></table></figure>


<h3 id="人脸检测-核心代码"><a href="#人脸检测-核心代码" class="headerlink" title="人脸检测(核心代码)"></a>人脸检测(核心代码)</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 通过人脸识别提取有效的人脸图片</span></span><br><span class="line"><span class="keyword">static</span> func faceImagesByFaceRecognition(imageView: <span class="built_in">UIImageView</span>, resultCallback: @escaping ((_ count: Int) -&gt; ())) &#123;</span><br><span class="line">    <span class="comment">//0. 删除子控件</span></span><br><span class="line">    let subViews = imageView.subviews</span><br><span class="line">    <span class="keyword">for</span> subview <span class="keyword">in</span> subViews &#123;</span><br><span class="line">        <span class="keyword">if</span> subview.isKind(of: <span class="built_in">UIView</span>.self) &#123;</span><br><span class="line">            subview.removeFromSuperview()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1. 创建上下文对象</span></span><br><span class="line">    let context = <span class="built_in">CIContext</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2. UIImage转成CIImage</span></span><br><span class="line">    guard let image = imageView.image  <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    guard let ciImage = <span class="built_in">CIImage</span>(image: image) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3. 参数设置(精度设置)</span></span><br><span class="line">    let parmes = [<span class="built_in">CIDetectorAccuracy</span>: <span class="built_in">CIDetectorAccuracyHigh</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4. 创建识别类</span></span><br><span class="line">    let detector = <span class="built_in">CIDetector</span>(ofType: <span class="built_in">CIDetectorTypeFace</span>, context: context, options: parmes)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//5. 找到识别其中的人连对象</span></span><br><span class="line">    guard let faceArr = detector?.features(<span class="keyword">in</span>: ciImage) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//6. 添加识别的红框</span></span><br><span class="line">    let resultView = <span class="built_in">UIView</span>(frame: <span class="built_in">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: imageView.frame.width, height: imageView.frame.height))</span><br><span class="line">    imageView.addSubview(resultView)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//7. 遍历扫描结果</span></span><br><span class="line">    <span class="keyword">for</span> faceFeature <span class="keyword">in</span> faceArr &#123;</span><br><span class="line">        resultView.addSubview(addRedrectangleView(rect: faceFeature.bounds))</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//7.1 如果识别到眼睛</span></span><br><span class="line">        guard let feature = faceFeature as? <span class="built_in">CIFaceFeature</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        <span class="comment">//左眼</span></span><br><span class="line">        <span class="keyword">if</span> feature.hasLeftEyePosition &#123;</span><br><span class="line">            let leftView = addRedrectangleView(rect: <span class="built_in">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">5</span>, height: <span class="number">5</span>))</span><br><span class="line">            leftView.center = feature.leftEyePosition</span><br><span class="line">            resultView.addSubview(leftView)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//右眼</span></span><br><span class="line">        <span class="keyword">if</span> feature.hasRightEyePosition &#123;</span><br><span class="line">            let rightView = addRedrectangleView(rect: <span class="built_in">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">5</span>, height: <span class="number">5</span>))</span><br><span class="line">            rightView.setValue(feature.rightEyePosition, forKey: <span class="string">&quot;center&quot;</span>)</span><br><span class="line">            resultView.addSubview(rightView)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//7.2 识别嘴巴</span></span><br><span class="line">        <span class="keyword">if</span> feature.hasMouthPosition &#123;</span><br><span class="line">            let mouthView = addRedrectangleView(rect: <span class="built_in">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">10</span>, height: <span class="number">5</span>))</span><br><span class="line">            mouthView.setValue(feature.mouthPosition, forKey: <span class="string">&quot;center&quot;</span>)</span><br><span class="line">            resultView.addSubview(mouthView)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//8. 将resultView沿x轴翻转</span></span><br><span class="line">    resultView.transform = <span class="built_in">CGAffineTransform</span>(scaleX: <span class="number">1</span>, y: <span class="number">-1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//9. 结果回调</span></span><br><span class="line">    resultCallback(faceArr.count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="检测结果展示"><a href="#检测结果展示" class="headerlink" title="检测结果展示"></a>检测结果展示</h3><ul>
<li>检测到的人脸部位展示红色矩形框</li>
<li>眼镜和嘴巴部位显示红色矩形框</li>
<li>照片随机选取的, 不喜勿喷</li>
</ul>
<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-424e5a9f1da0e4b5.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="WechatIMG29.jpeg"></p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项:"></a>注意事项:</h3><ul>
<li>image的实际尺寸需要和imageView的尺寸完全一样,获取的脸部各个部位的尺寸才能完全吻合</li>
<li>这里我只做了简单的尺寸比例转换</li>
<li>代码如下:</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> func getScale(imageView: <span class="built_in">UIImageView</span>, image: <span class="built_in">UIImage</span>) -&gt; <span class="built_in">CGFloat</span>&#123;</span><br><span class="line">    let viewSize = imageView.frame.size</span><br><span class="line">    let imageSize = image.size</span><br><span class="line">    </span><br><span class="line">    let widthScale = imageSize.width / viewSize.width</span><br><span class="line">    let heightScale = imageSize.height / viewSize.height</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> widthScale &gt; heightScale ? widthScale : heightScale</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<hr>
<h3 id="GitHub–Demo地址"><a href="#GitHub–Demo地址" class="headerlink" title="GitHub–Demo地址"></a>GitHub–<a href="https://github.com/coderQuanjun/JunFaceRecognition">Demo地址</a></h3><ul>
<li>注意:  </li>
<li>这里只是列出了主要的核心代码,具体的代码逻辑请参考demo</li>
<li>文中相关介绍有的地方如果有不是很详细或者有更好建议的,欢迎联系小编</li>
</ul>
]]></content>
      <categories>
        <category>Swift框架</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>AVFoundation</tag>
        <tag>CoreImage</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS黑科技之(AVFoundation)动态人脸识别(二)</title>
    <url>/post/584be10c.html</url>
    <content><![CDATA[<blockquote>
<p>人脸识别原理简介：每一张图片都是由每一个像素点组成，而每一个像素点中又有对应的颜色值(如RGB)，人的面部特征中，不同的五官，颜色值肯定存在差异，而人脸识别技术就是通过对照片中每一个像素的识别进行大量的算法处理，最终得出五官的轮廓</p>
</blockquote>
<span id="more"></span>

<h2 id="首先介绍一些人脸识别的方式"><a href="#首先介绍一些人脸识别的方式" class="headerlink" title="首先介绍一些人脸识别的方式"></a>首先介绍一些人脸识别的方式</h2><h3 id="CoreImage静态人脸识别-可识别照片-图像等"><a href="#CoreImage静态人脸识别-可识别照片-图像等" class="headerlink" title="CoreImage静态人脸识别, 可识别照片, 图像等"></a><code>CoreImage</code>静态人脸识别, 可识别照片, 图像等</h3><ul>
<li>详情可查看上一篇博客介绍</li>
</ul>
<h3 id="Face"><a href="#Face" class="headerlink" title="Face++"></a>Face++</h3><ul>
<li>是北京旷视科技有限公司旗下的新型视觉服务平台, 旨在提供简单易用，功能强大，平台通用的视觉服务</li>
<li>Face++是新一代云端视觉服务平台，提供一整套世界领先的人脸检测，人脸识别，面部分析的视觉技术服务</li>
<li><a href="https://baike.baidu.com/item/Face++/6754083">Face++百度百科介绍</a></li>
<li><a href="https://www.faceplusplus.com.cn/pricing/">Face++官网</a></li>
</ul>
<h3 id="OpenCV"><a href="#OpenCV" class="headerlink" title="OpenCV"></a>OpenCV</h3><ul>
<li>由一系列 C 函数和少量 C++ 类构成, 实现了图像处理和计算机视觉方面的很多通用算法, 其他的具体的不是很了解</li>
<li><a href="https://baike.baidu.com/item/opencv/10320623?fr=aladdin">这是百度百科的内容</a></li>
</ul>
<h3 id="Vision"><a href="#Vision" class="headerlink" title="Vision"></a>Vision</h3><ul>
<li>Vision 是 Apple 在 WWDC 2017 伴随iOS 11推出的基于CoreML的图像识别框架</li>
<li>根据<a href="https://developer.apple.com/documentation/vision">Vision官方文档看</a>，<code>Vision</code> 本身就有<code>Face Detection and Recognition</code>(人脸检测识别)、<code>Machine Learning Image Analysis</code>(机器学习图片分析)、<code>Barcode Detection</code>(条形码检测)、<code>Text Detection</code>(文本检测)。。。。。等等这些功能</li>
<li>感兴趣的同学可以查看相关文档学习一下, 这里小编就不过多作介绍了</li>
</ul>
<h4 id="AVFoundation"><a href="#AVFoundation" class="headerlink" title="AVFoundation"></a>AVFoundation</h4><ul>
<li>可以用来使用和创建基于时间的视听媒体的框架</li>
<li>这里我们使用的人脸识别方式也是使用<code>AVFoundation</code>框架</li>
</ul>
<h2 id="对关键类的简单介绍"><a href="#对关键类的简单介绍" class="headerlink" title="对关键类的简单介绍"></a>对关键类的简单介绍</h2><h3 id="AVCaptureDevice-代表硬件设备"><a href="#AVCaptureDevice-代表硬件设备" class="headerlink" title="AVCaptureDevice:代表硬件设备"></a><code>AVCaptureDevice</code>:代表硬件设备</h3><ul>
<li>我们可以从这个类中获取手机硬件的照相机、声音传感器等。</li>
<li>当我们在应用程序中需要改变一些硬件设备的属性（例如：切换摄像头、闪光模式改变、相机聚焦改变）的时候必须要先为设备加锁，修改完成后解锁。</li>
<li>示例: 切换摄像头</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//4. 移除旧输入，添加新输入</span></span><br><span class="line"><span class="comment">//4.1 设备加锁</span></span><br><span class="line">session.beginConfiguration()</span><br><span class="line"><span class="comment">//4.2. 移除旧设备</span></span><br><span class="line">session.removeInput(deviceIn)</span><br><span class="line"><span class="comment">//4.3 添加新设备</span></span><br><span class="line">session.addInput(newVideoInput)</span><br><span class="line"><span class="comment">//4.4 设备解锁</span></span><br><span class="line">session.commitConfiguration()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="AVCaptureDeviceInput-设备输入数据管理对象"><a href="#AVCaptureDeviceInput-设备输入数据管理对象" class="headerlink" title="AVCaptureDeviceInput:设备输入数据管理对象"></a><code>AVCaptureDeviceInput</code>:设备输入数据管理对象</h3><ul>
<li>可以根据<code>AVCaptureDevice</code>创建对应的AVCaptureDeviceInput对象，</li>
<li>该对象将会被添加到AVCaptureSession中管理,代表输入设备，它配置抽象硬件设备的ports。通常的输入设备有（麦克风，相机等）</li>
</ul>
<h3 id="AVCaptureOutput-代表输出数据"><a href="#AVCaptureOutput-代表输出数据" class="headerlink" title="AVCaptureOutput: 代表输出数据"></a><code>AVCaptureOutput</code>: 代表输出数据</h3><ul>
<li>输出的可以是图片（<code>AVCaptureStillImageOutput</code>）或者视频（<code>AVCaptureMovieFileOutput</code>）</li>
</ul>
<h3 id="AVCaptureSession-媒体（音、视频）捕捉会话"><a href="#AVCaptureSession-媒体（音、视频）捕捉会话" class="headerlink" title="AVCaptureSession: 媒体（音、视频）捕捉会话"></a><code>AVCaptureSession</code>: 媒体（音、视频）捕捉会话</h3><ul>
<li>负责把捕捉的音频视频数据输出到输出设备中。</li>
<li>一个<code>AVCaptureSession</code>可以有多个输入或输出。</li>
<li>是连接<code>AVCaptureInput</code>和<code>AVCaptureOutput</code>的桥梁，它协调input到output之间传输数据。</li>
<li>它有startRunning和stopRunning两种方法来开启会话和结束会话。</li>
<li>每个session称之为一个会话，也就是在应用运行过程中如果你需要改变会话的一些配置（例如：切换摄像头）,此时需要先开启配置，配置完成之后再提交配置。</li>
</ul>
<h3 id="AVCaptureVideoPreviewLayer-图片预览层"><a href="#AVCaptureVideoPreviewLayer-图片预览层" class="headerlink" title="AVCaptureVideoPreviewLayer: 图片预览层"></a><code>AVCaptureVideoPreviewLayer</code>: 图片预览层</h3><ul>
<li>我们的照片以及视频是如何显示在手机上的呢？那就是通过把这个对象添加到<code>UIView</code>的<code>layer</code>上的</li>
</ul>
<blockquote>
<p>好了, 上面吧啦吧啦的说了那么多废话, 那么我们的人脸识别究竟是怎样实现的呢? 下面干货来了</p>
</blockquote>
<h2 id="添加扫描设备"><a href="#添加扫描设备" class="headerlink" title="添加扫描设备"></a>添加扫描设备</h2><ul>
<li>获取设备(摄像头)</li>
<li>创建输入设备</li>
<li>创建扫描输出</li>
<li>创建捕捉回话</li>
</ul>
<h3 id="输出设备"><a href="#输出设备" class="headerlink" title="输出设备"></a>输出设备</h3><ul>
<li>这里使用<code>AVCaptureMetadataOutput</code>, 可以扫描人脸, 二维码, 条形码等信息</li>
<li>必须设置代理, 否则获取不到扫描结果</li>
<li>需要设置要输出什么样的数据: face(人脸), qr(二维码)等等</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//3.创建原数据的输出对象</span></span><br><span class="line">let metadataOutput = <span class="built_in">AVCaptureMetadataOutput</span>()</span><br><span class="line">        </span><br><span class="line"><span class="comment">//4.设置代理监听输出对象输出的数据，在主线程中刷新</span></span><br><span class="line">metadataOutput.setMetadataObjectsDelegate(<span class="keyword">self</span>, queue: DispatchQueue.main)</span><br><span class="line"></span><br><span class="line"><span class="comment">//7.告诉输出对象要输出什么样的数据,识别人脸, 最多可识别10张人脸</span></span><br><span class="line">metadataOutput.metadataObjectTypes = [.face]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>主要代码如下:</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">fileprivate func addScaningVideo()&#123;</span><br><span class="line">    <span class="comment">//1.获取输入设备（摄像头）</span></span><br><span class="line">    guard let device = <span class="built_in">AVCaptureDevice</span>.default(<span class="keyword">for</span>: .video) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.根据输入设备创建输入对象</span></span><br><span class="line">    guard let deviceIn = try? <span class="built_in">AVCaptureDeviceInput</span>(device: device) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    deviceInput = deviceIn</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.创建原数据的输出对象</span></span><br><span class="line">    let metadataOutput = <span class="built_in">AVCaptureMetadataOutput</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4.设置代理监听输出对象输出的数据，在主线程中刷新</span></span><br><span class="line">    metadataOutput.setMetadataObjectsDelegate(<span class="keyword">self</span>, queue: DispatchQueue.main)</span><br><span class="line">    <span class="comment">//4.2 设置输出代理</span></span><br><span class="line">    faceDelegate = previewView</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//5.设置输出质量(高像素输出)</span></span><br><span class="line">    session.sessionPreset = .high</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//6.添加输入和输出到会话</span></span><br><span class="line">    <span class="keyword">if</span> session.canAddInput(deviceInput!) &#123;</span><br><span class="line">        session.addInput(deviceInput!)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> session.canAddOutput(metadataOutput) &#123;</span><br><span class="line">        session.addOutput(metadataOutput)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//7.告诉输出对象要输出什么样的数据,识别人脸, 最多可识别10张人脸</span></span><br><span class="line">    metadataOutput.metadataObjectTypes = [.face]</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//8.创建预览图层</span></span><br><span class="line">    previewLayer = <span class="built_in">AVCaptureVideoPreviewLayer</span>(session: session)</span><br><span class="line">    previewLayer.videoGravity = .resizeAspectFill</span><br><span class="line">    previewLayer.frame = view.bounds</span><br><span class="line">    previewView.layer.insertSublayer(previewLayer, at: <span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//9.设置有效扫描区域(默认整个屏幕区域)（每个取值0~1, 以屏幕右上角为坐标原点）</span></span><br><span class="line">    metadataOutput.rectOfInterest = previewView.bounds</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//10. 开始扫描</span></span><br><span class="line">    <span class="keyword">if</span> !session.isRunning &#123;</span><br><span class="line">        DispatchQueue.global().async &#123;</span><br><span class="line">            <span class="keyword">self</span>.session.startRunning()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="切换摄像头"><a href="#切换摄像头" class="headerlink" title="切换摄像头"></a>切换摄像头</h3><ul>
<li>获取当前摄像头方向</li>
<li>创建新的输入input</li>
<li>移除旧输入<code>capture</code>, 添加新的输入<code>capture</code></li>
<li>具体代码如下:</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">@IBAction func switchCameraAction(_ sender: Any) &#123;</span><br><span class="line">    <span class="comment">//1. 执行转场动画</span></span><br><span class="line">    let anima = <span class="built_in">CATransition</span>()</span><br><span class="line">    anima.type = <span class="string">&quot;oglFlip&quot;</span></span><br><span class="line">    anima.subtype = <span class="string">&quot;fromLeft&quot;</span></span><br><span class="line">    anima.duration = <span class="number">0.5</span></span><br><span class="line">    view.layer.add(anima, forKey: <span class="literal">nil</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2. 获取当前摄像头</span></span><br><span class="line">    guard let deviceIn = deviceInput <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    let position: <span class="built_in">AVCaptureDevice</span>.Position = deviceIn.device.position == .back ? .front : .back</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3. 创建新的input</span></span><br><span class="line">    let deviceSession = <span class="built_in">AVCaptureDevice</span>.DiscoverySession(deviceTypes: [.builtInWideAngleCamera], mediaType: .video, position: position)</span><br><span class="line">    guard let newDevice = deviceSession.devices.filter(&#123; $<span class="number">0.</span>position == position &#125;).first <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    guard let newVideoInput = try? <span class="built_in">AVCaptureDeviceInput</span>(device: newDevice) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4. 移除旧输入，添加新输入</span></span><br><span class="line">    <span class="comment">//4.1 设备加锁</span></span><br><span class="line">    session.beginConfiguration()</span><br><span class="line">    <span class="comment">//4.2. 移除旧设备</span></span><br><span class="line">    session.removeInput(deviceIn)</span><br><span class="line">    <span class="comment">//4.3 添加新设备</span></span><br><span class="line">    session.addInput(newVideoInput)</span><br><span class="line">    <span class="comment">//4.4 设备解锁</span></span><br><span class="line">    session.commitConfiguration()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//5. 保存最新输入</span></span><br><span class="line">    deviceInput = newVideoInput</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="处理扫描结果"><a href="#处理扫描结果" class="headerlink" title="处理扫描结果"></a>处理扫描结果</h3><blockquote>
<p>实现<code>AVCaptureMetadataOutputObjectsDelegate</code>该协议的协议方法(只有一个方法)</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//`metadataObjects`就是返回的扫描结果</span><br><span class="line">optional public func metadataOutput(_ output: AVCaptureMetadataOutput, didOutput metadataObjects: [AVMetadataObject], from connection: AVCaptureConnection)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="AVMetadataFaceObject介绍"><a href="#AVMetadataFaceObject介绍" class="headerlink" title="AVMetadataFaceObject介绍"></a><code>AVMetadataFaceObject</code>介绍</h3><ul>
<li><code>faceID</code>: 人脸的唯一标识 <ul>
<li>扫描出来的每一个人, 有不同的<code>faceID</code></li>
<li>同一个人, 不同的状态下(摇头, 歪头, 抬头等), 都会有不同<code>faceID</code></li>
</ul>
</li>
<li><code>hasRollAngle</code>: 是否有倾斜角,侧倾角(左右歪头)(BOOL类型)</li>
<li><code>rollAngle</code>: 倾斜角,侧倾角的角度(<code>CGFloat</code>类型)</li>
<li><code>hasYawAngle</code>: 是否有偏转角(左右摇头)</li>
<li><code>yawAngle</code>: 偏转角角度</li>
</ul>
<h3 id="处理扫描结果-1"><a href="#处理扫描结果-1" class="headerlink" title="处理扫描结果"></a>处理扫描结果</h3><h4 id="获取预览图层的人脸数组"><a href="#获取预览图层的人脸数组" class="headerlink" title="获取预览图层的人脸数组"></a>获取预览图层的人脸数组</h4><ul>
<li>遍历扫描的人脸数组, 转换成在预览图层的人脸数组</li>
<li>主要是人脸在图层的左边的转换</li>
<li>返回转换后的新的数组</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">fileprivate func transformedFaces(faceObjs: [<span class="built_in">AVMetadataObject</span>]) -&gt; [<span class="built_in">AVMetadataObject</span>] &#123;</span><br><span class="line">    var faceArr = [<span class="built_in">AVMetadataObject</span>]()</span><br><span class="line">    <span class="keyword">for</span> face <span class="keyword">in</span> faceObjs &#123;</span><br><span class="line">        <span class="comment">//将扫描的人脸对象转成在预览图层的人脸对象(主要是坐标的转换)</span></span><br><span class="line">        <span class="keyword">if</span> let transFace = previewLayer.transformedMetadataObject(<span class="keyword">for</span>: face)&#123;</span><br><span class="line">            faceArr.append(transFace)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> faceArr</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="根据人脸位置添加红框"><a href="#根据人脸位置添加红框" class="headerlink" title="根据人脸位置添加红框"></a>根据人脸位置添加红框</h4><ul>
<li>设置红框的frame</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">faceLayer?.frame = face.bounds</span><br></pre></td></tr></table></figure>

<ul>
<li>根据偏转角和倾斜角的角度获取<code>CATransform3D</code></li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">fileprivate func transformDegress(yawAngle: <span class="built_in">CGFloat</span>) -&gt; <span class="built_in">CATransform3D</span> &#123;</span><br><span class="line">    let yaw = degreesToRadians(degress: yawAngle)</span><br><span class="line">    <span class="comment">//围绕Y轴旋转</span></span><br><span class="line">    let yawTran = <span class="built_in">CATransform3DMakeRotation</span>(yaw, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="comment">//红框旋转问题</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CATransform3DConcat</span>(yawTran, <span class="built_in">CATransform3DIdentity</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理偏转角问题</span></span><br><span class="line">fileprivate func transformDegress(rollAngle: <span class="built_in">CGFloat</span>) -&gt; <span class="built_in">CATransform3D</span> &#123;</span><br><span class="line">    let roll = degreesToRadians(degress: rollAngle)</span><br><span class="line">    <span class="comment">//围绕Z轴旋转</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CATransform3DMakeRotation</span>(roll, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//角度转换</span></span><br><span class="line">fileprivate func degreesToRadians(degress: <span class="built_in">CGFloat</span>) -&gt; <span class="built_in">CGFloat</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> degress * <span class="built_in">CGFloat</span>(Double.pi) / <span class="number">180</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>根据有无偏转角和倾斜角旋转红框</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//3.4 设置偏转角(左右摇头)</span></span><br><span class="line"><span class="keyword">if</span> face.hasYawAngle&#123;</span><br><span class="line">    let tranform3D = transformDegress(yawAngle: face.yawAngle)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//矩阵处理</span></span><br><span class="line">    faceLayer?.transform = <span class="built_in">CATransform3DConcat</span>(faceLayer!.transform, tranform3D)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.5 设置倾斜角,侧倾角(左右歪头)</span></span><br><span class="line"><span class="keyword">if</span> face.hasRollAngle&#123;</span><br><span class="line">    let tranform3D = transformDegress(rollAngle: face.rollAngle)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//矩阵处理</span></span><br><span class="line">    faceLayer?.transform = <span class="built_in">CATransform3DConcat</span>(faceLayer!.transform, tranform3D)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>至此, 动态的人脸识别就完成了, 会在人脸位置增加红框显示, 并且红框会根据人脸的位置动态的, 实时的调整</li>
<li>下面就快拿起你的相机测试吧</li>
</ul>
<hr>
<h3 id="GitHub–Demo地址"><a href="#GitHub–Demo地址" class="headerlink" title="GitHub–Demo地址"></a>GitHub–<a href="https://github.com/coderQuanjun/JunFaceRecognition">Demo地址</a></h3><ul>
<li>注意:  </li>
<li>这里只是列出了主要的核心代码,具体的代码逻辑请参考demo</li>
<li>文中相关介绍有的地方如果有不是很详细或者有更好建议的,欢迎联系小编</li>
</ul>
]]></content>
      <categories>
        <category>Swift框架</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>AVFoundation</tag>
      </tags>
  </entry>
  <entry>
    <title>升级Swift4.0遇到的坑</title>
    <url>/post/f1e7dff2.html</url>
    <content><![CDATA[<ul>
<li>并不是所有库都能做到及时支持<code>Swift4.0</code>，更何况是在现在连<code>Xcode9</code>也还是beta的状态</li>
<li>所以我们仅能做到将自己的业务代码（主工程代码）部分升级到<code>Swift4.0</code>，然后同时保留各种pod库在<code>Swift3.2</code>版本。</li>
<li>没办法，谁叫<code>Swift4.0</code>也还无法做到API兼容呢（但愿能在<code>Swift5</code>之前实现吧）。</li>
<li>至于我说的同时使用两个版本的<code>Swift</code>，这是没问题的，Xcode9支持在项目中同时使用<code>Swift3.2</code>和<code>Swift4.0</code>。</li>
</ul>
<span id="more"></span>

<h2 id="修改Swift版本"><a href="#修改Swift版本" class="headerlink" title="修改Swift版本"></a>修改Swift版本</h2><h3 id="指定主工程的Swift版本为4-0"><a href="#指定主工程的Swift版本为4-0" class="headerlink" title="指定主工程的Swift版本为4.0"></a>指定主工程的Swift版本为4.0</h3><p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-1a9aeacc47b262a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Xcode图示.png"></p>
<h3 id="修改pod库"><a href="#修改pod库" class="headerlink" title="修改pod库"></a>修改pod库</h3><ul>
<li>在Podfile文件的最下方加入如下代码，指定pod库的Swift版本为3.2(这样会使得所有的第三方pod库的Swift版本都为3.2)</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">post_install <span class="keyword">do</span> |installer|</span><br><span class="line">  installer.pods_project.targets.each <span class="keyword">do</span> |target|</span><br><span class="line">    target.build_configurations.each <span class="keyword">do</span> |config|</span><br><span class="line">      config.build_settings[<span class="string">&#x27;SWIFT_VERSION&#x27;</span>] = <span class="string">&#x27;3.2&#x27;</span></span><br><span class="line">    end</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h2 id="主工程中的代码修改"><a href="#主工程中的代码修改" class="headerlink" title="主工程中的代码修改"></a>主工程中的代码修改</h2><h3 id="Swift3-2到Swift4-0的改变"><a href="#Swift3-2到Swift4-0的改变" class="headerlink" title="Swift3.2到Swift4.0的改变"></a>Swift3.2到Swift4.0的改变</h3><ul>
<li><p>1). <code>Swift4.0</code>中对于扩展的属性(包括实例属性、<code>static</code>属性、<code>class</code>属性)，都只能使用get方法，不可使用set方法</p>
</li>
<li><p>2). <code>Swift4.0</code>中不再允许复写扩展中的方法(包括实例方法、<code>static</code>方法、<code>class</code>方法)</p>
<ul>
<li>比如:自定义的协议方法在<code>extension</code>中实现,若某个类遵循了该协议,其子类便不能重写该协议方法</li>
<li>解决的方法是: 在每个需要该协议的类里面都重新遵循该协议,实现协议方法</li>
<li>个人想到的办法,不知道有没有其他解决办法可以提供一下</li>
</ul>
</li>
<li><p>3). <code>swift3</code>使用<code>#selector</code>指定的方法，只有当方法权限为private时需要加<code>@objc</code>修饰符，现在<code>Swift4.0</code>全都要加<code>@objc</code>修饰符</p>
</li>
<li><p>4). 自定义的<code>protocol</code>协议中,有<code>optional</code>修饰的非必须实现的方法,需要用<code>@objc</code>修饰</p>
</li>
<li><p>5). 字体方面的一些重命名</p>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSFontAttributeName</span> --- .font</span><br><span class="line"><span class="comment">//或者NSAttributedStringKey.font</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSForegroundColorAttributeName</span> --- .foregroundColor</span><br><span class="line"><span class="comment">//NSAttributedStringKey.foregroundColor</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSStrikethroughStyleAttributeName</span> --- .strikethroughStyle</span><br><span class="line"><span class="comment">//NSAttributedStringKey.strikethroughStyle</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串类型的,添加rawValue</span></span><br><span class="line"><span class="built_in">NSAttributedStringKey</span>.font.rawValue</span><br><span class="line"></span><br><span class="line"><span class="comment">//等等等等..........</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//大部分类似以下,涉及富文本的方法均已改为了NSAttributedStringKey类型</span></span><br><span class="line">addAttributes(_ attrs: [<span class="built_in">NSAttributedStringKey</span> : Any] = [:], range: <span class="built_in">NSRange</span>)</span><br></pre></td></tr></table></figure>

<h2 id="一些的报错问题"><a href="#一些的报错问题" class="headerlink" title="一些的报错问题"></a>一些的报错问题</h2><h3 id="“Closure-cannot-implicitly-capture-a-mutating-self-parameter”错误"><a href="#“Closure-cannot-implicitly-capture-a-mutating-self-parameter”错误" class="headerlink" title="“Closure cannot implicitly capture a mutating self parameter”错误"></a>“Closure cannot implicitly capture a mutating self parameter”错误</h3><blockquote>
<p>在struct中，如果我们在闭包中使用self，就会得到Closure cannot implicitly capture a mutating self parameter的错误提示。比如：</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> RecordModel &#123;</span><br><span class="line">    <span class="comment">/// 定义一个闭包</span></span><br><span class="line">    var action: (() -&gt; ())?</span><br><span class="line">    var height = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.action = &#123;</span><br><span class="line">        <span class="keyword">self</span>.height = <span class="number">20</span></span><br><span class="line">        <span class="comment">//Closure cannot implicitly capture a mutating self parameter报错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>并且由<code>于RecordModel</code>的类型是<code>struct</code>，我们也没发在<code>action</code>闭包里添加截获列表。那么是不是就必须使用<code>class</code>了？答案是否定的。有两种方式可以解决这个问题。</p>
</blockquote>
<h4 id="方案一：为closure增加一个inout类型的参数"><a href="#方案一：为closure增加一个inout类型的参数" class="headerlink" title="方案一：为closure增加一个inout类型的参数"></a>方案一：为<code>closure</code>增加一个inout类型的参数</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> RecordModel &#123;</span><br><span class="line">    <span class="comment">/// 定义一个闭包</span></span><br><span class="line">    var action: ((_ inSelf: <span class="keyword">inout</span> RecordModel) -&gt; ())?</span><br><span class="line">    var height = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.action = &#123; (inSelf) <span class="keyword">in</span></span><br><span class="line">        inSelf.height = <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>根据inout类型的说明，我们知道，实际上这相当于增加了一个隐藏的临时变量，self被复制，然后在closure(闭包)中使用，完成后，再复制回self。也就是说，这个方法有额外的内存开销。如果是struct较大的情形，这么做并不划算。</p>
</blockquote>
<h4 id="方案二：使用UnsafeMutablePointer-lt-Pointee-gt"><a href="#方案二：使用UnsafeMutablePointer-lt-Pointee-gt" class="headerlink" title="方案二：使用UnsafeMutablePointer&lt;Pointee&gt;"></a>方案二：使用<code>UnsafeMutablePointer&lt;Pointee&gt;</code></h4><ul>
<li>这次采用直接指针的方式对于struct来进行操作，采用指针的好处是self不会被多次复制，性能较高。缺点是你需要自行确定你的代码的安全。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> RecordModel &#123;</span><br><span class="line">    <span class="comment">/// 定义一个闭包</span></span><br><span class="line">    var action: (() -&gt; ())?</span><br><span class="line">    var height = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">    let selfPointer = UnsafeMutablePointer(&amp;<span class="keyword">self</span>)</span><br><span class="line">    <span class="keyword">self</span>.action = &#123;</span><br><span class="line">        selfPointer.pointee.height = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p><code>Closure cannot implicitly capture a mutating self parameter</code>错误的原因是在进出<code>closure(闭包)</code>之后，self的一致性没办法得到保证，所以编译器默认不允许在<code>struct的closure(闭包)</code>中使用self。如果我们确定这么做是安全的，就可以通过上面的两种方式解决这个问题。其中，方法二的性能更好一些。</p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><blockquote>
<h4 id="这里可以记一下指针和swift变量之间的关系："><a href="#这里可以记一下指针和swift变量之间的关系：" class="headerlink" title="这里可以记一下指针和swift变量之间的关系："></a>这里可以记一下指针和swift变量之间的关系：</h4></blockquote>
<ul>
<li><code>UnsafePointer对应let</code></li>
<li><code>UnsafeMutablePointer对应var</code></li>
<li><code>AutoreleasingUnsafeMutablePointer对应unowned UnsafeMutablePointer</code>，用于inout的参数类型</li>
<li><code>UnsafeRawPointer对应let Any</code>，raw系列都是对应相应的Any类型</li>
<li><code>UnsafeBufferPointer是non-owning的类型（unowned</code>），用于collection的elements, buffer系列均如此</li>
</ul>
<h3 id="Declarations-from-extensions-cannot-be-overridden-yet-错误"><a href="#Declarations-from-extensions-cannot-be-overridden-yet-错误" class="headerlink" title="Declarations from extensions cannot be overridden yet 错误"></a><code>Declarations from extensions cannot be overridden yet</code> 错误</h3><p>这个错误大致是因为,协议方法是在<code>extension</code>里面的,不能被重写</p>
<blockquote>
<p>解决办法:(仅供参考,如有更好的建议还望多多指教)</p>
</blockquote>
<ul>
<li>小编想到的解决办法就是在每一个需要此协议的类里面,重新遵循代理,实现该协议方法</li>
</ul>
<h3 id="quot-Method-39-initialize-39-defines-Objective-C-class-method-39-initialize-39-which-is-not-permitted-by-Swift-quot"><a href="#quot-Method-39-initialize-39-defines-Objective-C-class-method-39-initialize-39-which-is-not-permitted-by-Swift-quot" class="headerlink" title="&quot;Method &#39;initialize()&#39; defines Objective-C class method &#39;initialize&#39;, which is not permitted by Swift&quot;"></a><code>&quot;Method &#39;initialize()&#39; defines Objective-C class method &#39;initialize&#39;, which is not permitted by Swift&quot;</code></h3><p>报错原因: 在于已经废弃的initialize方法,示例如下</p>
<ul>
<li>方法交叉(Method Swizzling)</li>
<li>有时为了方便，也有可能是解决某些框架内的 bug，或者别无他法时，需要修改一个已经存在类的方法的行为。方法交叉可以让你交换两个方法的实现，相当于是用你写的方法来重载原有方法，并且还能够是原有方法的行为保持不变。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">extension <span class="built_in">UIViewController</span> &#123;</span><br><span class="line">    public override <span class="keyword">class</span> func initialize() &#123;<span class="comment">//此处报错</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//此处省略100行代码</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>initialize该方法已经被Swift4.0废弃</li>
<li>在Swift3.0还勉强可以使用,但是会有警告;但是在4.0已经被完全废弃</li>
</ul>
<blockquote>
<p>替代方法:</p>
</blockquote>
<ul>
<li>在 app delegate 中实现方法交叉</li>
<li>像上面通过类扩展进行方法交叉，而是简单地在 app delegate 的 application(_:didFinishLaunchingWithOptions:) 方法调用时调用该方法</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">extension <span class="built_in">UIViewController</span> &#123;</span><br><span class="line">    public override <span class="keyword">class</span> func initializeOnceMethod() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//此处省略100行代码</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在AppDelegate的方法中调用:</span></span><br><span class="line">func application(_ application: <span class="built_in">UIApplication</span>, didFinishLaunchingWithOptions launchOptions: [<span class="built_in">UIApplicationLaunchOptionsKey</span> : Any]? = <span class="literal">nil</span>) -&gt; Bool &#123;</span><br><span class="line">    <span class="comment">//此处省略100行代码</span></span><br><span class="line">    <span class="built_in">UIViewController</span>.initializeOnceMethod()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="39-dispatch-once-39-is-unavailable-in-Swift-Use-lazily-initialized-globals-instead"><a href="#39-dispatch-once-39-is-unavailable-in-Swift-Use-lazily-initialized-globals-instead" class="headerlink" title="&#39;dispatch_once&#39; is unavailable in Swift: Use lazily initialized globals instead"></a><code>&#39;dispatch_once&#39; is unavailable in Swift: Use lazily initialized globals instead</code></h3><blockquote>
<p>报错原因: <code>dispatch_once在Swift4.0</code>也已经被废弃</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">extension <span class="built_in">UITableView</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> once&#123;</span><br><span class="line">        <span class="keyword">static</span> var onceTaken:Int = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;once.onceTaken) &#123; () -&gt; Void <span class="keyword">in</span></span><br><span class="line">    <span class="comment">//在这里dispatch_once就会报错</span></span><br><span class="line">        <span class="comment">//此处省略1000000行代码    </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success"><p>解决方法: 通过给DispatchQueue添加扩展实现</p></div>


<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">extension DispatchQueue &#123;</span><br><span class="line">    private <span class="keyword">static</span> var _onceTracker = [String]()</span><br><span class="line">    public <span class="keyword">class</span> func once(token: String, block: () -&gt; ()) &#123;</span><br><span class="line">        objc_sync_enter(<span class="keyword">self</span>)</span><br><span class="line">        defer &#123;</span><br><span class="line">            objc_sync_exit(<span class="keyword">self</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> _onceTracker.contains(token) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        _onceTracker.append(token)</span><br><span class="line">        block()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func async(block: @escaping ()-&gt;()) &#123;</span><br><span class="line">        <span class="keyword">self</span>.async(execute: block)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func after(time: DispatchTime, block: @escaping ()-&gt;()) &#123;</span><br><span class="line">        <span class="keyword">self</span>.asyncAfter(deadline: time, execute: block)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用字符串token作为once的ID，执行once的时候加了一个锁，避免多线程下的token判断不准确的问题。<br>使用的时候可以传token</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">DispatchQueue.once(token: <span class="string">&quot;tableViewOnce&quot;</span>) &#123;</span><br><span class="line">    print( <span class="string">&quot;Do This Once!&quot;</span> )  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>或者使用UUID也可以：</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">private let _onceToken = <span class="built_in">NSUUID</span>().uuidString</span><br><span class="line"></span><br><span class="line">DispatchQueue.once(token: _onceToken) &#123;  </span><br><span class="line">    print( <span class="string">&quot;Do This Once!&quot;</span> )  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>后续又遇到别的问题会继续更新</li>
<li>文章中如有解释不足之处,还望多多指教</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Swift学习数据结构和算法</title>
    <url>/post/a192b018.html</url>
    <content><![CDATA[<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/ios/stract.png?x-oss-process=style/titanjun" alt="stract.png"></p>
<span id="more"></span>




<ul>
<li>主要分享最近学习的数据结构和排序算法</li>
<li>文章只涉及每一种数据结构通过代码实现的函数定义</li>
<li>涉及的每一种数据结构或者算法基本都通过代码实现了</li>
<li>GitHub代码地址: <a href="https://github.com/CoderTitan/structureAlgorithm">数据结构和算法</a></li>
</ul>
<h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/ios/linear_list.png?x-oss-process=style/titanjun" alt="linear_list.png"></p>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><ul>
<li>链表是一种链式存储的线性结构, 所有元素的内存地址不一定是连续的</li>
<li>下表是为四种链表和<a href="https://github.com/CoderTitan/structureAlgorithm">测试项目</a>中对应的类名</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">List</span>&lt;<span class="title class_">E</span>: <span class="title class_">Comparable</span>&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清除所有元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">clear</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 元素的数量</span></span><br><span class="line"><span class="comment">     * @return</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">size</span>() -&gt; <span class="type">Int</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否为空</span></span><br><span class="line"><span class="comment">     * @return</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">isEmpty</span>() -&gt; <span class="type">Bool</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否包含某个元素</span></span><br><span class="line"><span class="comment">     * @param element</span></span><br><span class="line"><span class="comment">     * @return</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">contains</span>(<span class="keyword">_</span> <span class="params">element</span>: <span class="type">E</span>) -&gt; <span class="type">Bool</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加元素到尾部</span></span><br><span class="line"><span class="comment">     * @param element</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">add</span>(<span class="keyword">_</span> <span class="params">element</span>: <span class="type">E</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取index位置的元素</span></span><br><span class="line"><span class="comment">     * @param index</span></span><br><span class="line"><span class="comment">     * @return</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">get</span>(<span class="keyword">_</span> <span class="params">index</span>: <span class="type">Int</span>) -&gt; <span class="type">E</span>? &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 替换index位置的元素</span></span><br><span class="line"><span class="comment">     * @param index</span></span><br><span class="line"><span class="comment">     * @param element</span></span><br><span class="line"><span class="comment">     * @return 原来的元素ֵ</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">set</span>(<span class="params">by</span> <span class="params">index</span>: <span class="type">Int</span>, <span class="params">element</span>: <span class="type">E</span>) -&gt; <span class="type">E</span>? &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在index位置插入一个元素</span></span><br><span class="line"><span class="comment">     * @param index</span></span><br><span class="line"><span class="comment">     * @param element</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">add</span>(<span class="params">by</span> <span class="params">index</span>: <span class="type">Int</span>, <span class="params">element</span>: <span class="type">E</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除index位置的元素</span></span><br><span class="line"><span class="comment">     * @param index</span></span><br><span class="line"><span class="comment">     * @return</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">remove</span>(<span class="keyword">_</span> <span class="params">index</span>: <span class="type">Int</span>) -&gt; <span class="type">E</span>? &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查看元素的索引</span></span><br><span class="line"><span class="comment">     * @param element</span></span><br><span class="line"><span class="comment">     * @return</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">indexOf</span>(<span class="keyword">_</span> <span class="params">element</span>: <span class="type">E</span>) -&gt; <span class="type">Int</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<table>
<thead>
<tr>
<th>链表</th>
<th>类名</th>
</tr>
</thead>
<tbody><tr>
<td>单向链表</td>
<td>SingleLinkList</td>
</tr>
<tr>
<td>双向链表</td>
<td>DoubleLinkList</td>
</tr>
<tr>
<td>单向循环链表</td>
<td>CircleSingleLineList</td>
</tr>
<tr>
<td>双向循环链表</td>
<td>CircleDoubleLinkList</td>
</tr>
</tbody></table>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><ul>
<li>栈是一种特殊的线性表, 只能在一端进行操作</li>
<li>栈遵循后进先出的原则, Last in First out</li>
<li><a href="https://github.com/CoderTitan/structureAlgorithm">Statck</a></li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Statck</span>&lt;<span class="title class_">E</span>&gt; &#123;</span><br><span class="line">    <span class="comment">/// 元素个数</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">size</span>() -&gt; <span class="type">Int</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 是否为空</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">isEmpty</span>() -&gt; <span class="type">Bool</span> &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 入栈</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">push</span>(<span class="keyword">_</span> <span class="params">element</span>: <span class="type">E</span>?) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 出栈</span></span><br><span class="line">    <span class="keyword">@discardableResult</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">pop</span>() -&gt; <span class="type">E</span>? &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 获取栈顶元素</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">peek</span>() -&gt; <span class="type">E</span>? &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 清空</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">clear</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><ul>
<li>队列是一种特殊的线性表, 只能在头尾两端进行操作</li>
<li>队列遵循后进先出的原则(单端队列), First in First out</li>
<li>下表是为队列和<a href="https://github.com/CoderTitan/structureAlgorithm">测试项目</a>中对应的类名</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span>&lt;<span class="title class_">E</span>: <span class="title class_">Comparable</span>&gt; &#123;</span><br><span class="line">    <span class="comment">/// 元素数量</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">size</span>() -&gt; <span class="type">Int</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 是否为空</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">isEmpty</span>() -&gt; <span class="type">Bool</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 清除所有元素</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">clear</span>() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 入队</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">enQueue</span>(<span class="keyword">_</span> <span class="params">element</span>: <span class="type">E</span>?) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 出队</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">deQueue</span>() -&gt; <span class="type">E</span>? &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 获取队列的头元素</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">front</span>() -&gt; <span class="type">E</span>? &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">string</span>() -&gt; <span class="type">String</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<table>
<thead>
<tr>
<th>队列</th>
<th>类名</th>
</tr>
</thead>
<tbody><tr>
<td>单端队列</td>
<td>SingleQueue</td>
</tr>
<tr>
<td>双端队列</td>
<td>SingleDeque</td>
</tr>
<tr>
<td>单端循环队列</td>
<td>CircleQueue</td>
</tr>
<tr>
<td>双端循环队列</td>
<td>CircleDeque</td>
</tr>
</tbody></table>
<h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><ul>
<li>哈希表也称之为散列表, 童年各国数组存储(非单纯的数组)</li>
<li>利用哈希函数生成key对应的index值为数组索引存储value值</li>
<li>两个不同的key值通过哈希函数可能得到相同的索引, 即哈希冲突</li>
<li>解决哈希冲突的常见方法<ul>
<li>开放定址法: 按照一定规则向其他地址探测, 知道遇到空桶</li>
<li>再哈希法: 设计多个复杂的哈希函数</li>
<li>链地址法: 通过链表将同一index索引的与元素串起来, <a href="https://github.com/CoderTitan/structureAlgorithm">测试项目</a>中使用的这种方式</li>
</ul>
</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Map</span>&lt;<span class="title class_">K</span>: <span class="title class_">Hashable</span>, <span class="title class_">V</span>: <span class="title class_">Comparable</span>&gt; &#123;</span><br><span class="line">    <span class="comment">/// 元素数量</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">count</span>() -&gt; <span class="type">Int</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 是否为空</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">isEmpty</span>() -&gt; <span class="type">Bool</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 清除所有元素</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">clear</span>() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 添加元素</span></span><br><span class="line">    <span class="keyword">@discardableResult</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">put</span>(<span class="params">key</span>: <span class="type">K</span>?, <span class="params">val</span>: <span class="type">V</span>?) -&gt; <span class="type">V</span>? &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 删除元素</span></span><br><span class="line">    <span class="keyword">@discardableResult</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">remove</span>(<span class="params">key</span>: <span class="type">K</span>) -&gt; <span class="type">V</span>? &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 根据元素查询value</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">get</span>(<span class="params">key</span>: <span class="type">K</span>) -&gt; <span class="type">V</span>? &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 是否包含Key</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">containsKey</span>(<span class="params">key</span>: <span class="type">K</span>) -&gt; <span class="type">Bool</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 是否包含Value</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">containsValue</span>(<span class="params">val</span>: <span class="type">V</span>) -&gt; <span class="type">Bool</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 所有key</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">keys</span>() -&gt; [<span class="type">K</span>] &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 所有value</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">values</span>() -&gt; [<span class="type">V</span>] &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 遍历</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">traversal</span>(<span class="params">visitor</span>: ((<span class="type">K</span>?, <span class="type">V</span>?) -&gt; ())) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><ul>
<li>二叉树是n(n&gt;&#x3D;0)个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树组成</li>
</ul>
<table>
<thead>
<tr>
<th>二叉树</th>
<th>类名</th>
</tr>
</thead>
<tbody><tr>
<td>二叉树</td>
<td>BinaryTree</td>
</tr>
<tr>
<td>二叉搜索树</td>
<td>BinarySearchTree</td>
</tr>
</tbody></table>
<p>AVL树和红黑树是两种平衡二叉搜索树</p>
<table>
<thead>
<tr>
<th>平衡二叉搜索树</th>
<th>类名</th>
</tr>
</thead>
<tbody><tr>
<td>二叉平衡树</td>
<td>BinaryBalanceTree</td>
</tr>
<tr>
<td>二叉平衡搜索树</td>
<td>BinaryBalanceSearchTree</td>
</tr>
<tr>
<td>红黑树</td>
<td>RedBlackTree</td>
</tr>
</tbody></table>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p><a href="https://github.com/CoderTitan/structureAlgorithm">测试项目</a>中分别用链表, 红黑树, 哈希表实现了三种集合</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Set</span>&lt;<span class="title class_">E</span>: <span class="title class_">Comparable</span> &amp; <span class="title class_">Hashable</span>&gt; &#123;</span><br><span class="line">    <span class="comment">/// 元素个数</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">size</span>() -&gt; <span class="type">Int</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 是否为空</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">isEmpty</span>() -&gt; <span class="type">Bool</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 清除所有元素</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">clear</span>() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 是否包含某元素</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">contains</span>(<span class="keyword">_</span> <span class="params">val</span>: <span class="type">E</span>) -&gt; <span class="type">Bool</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 添加元素</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">add</span>(<span class="params">val</span>: <span class="type">E</span>) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 删除元素</span></span><br><span class="line">    <span class="keyword">@discardableResult</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">remove</span>(<span class="params">val</span>: <span class="type">E</span>) -&gt; <span class="type">E</span>? &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 获取所有元素</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">lists</span>() -&gt; [<span class="type">E</span>] &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>集合</th>
<th>类名</th>
</tr>
</thead>
<tbody><tr>
<td>双向链表集合</td>
<td>ListSet</td>
</tr>
<tr>
<td>红黑树集合</td>
<td>TreeSet</td>
</tr>
<tr>
<td>哈希表集合</td>
<td>HashSet</td>
</tr>
</tbody></table>
<h2 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h2><p>堆是一种树状的数据结构, 二叉堆只是其中一种, 除此之外还有</p>
<ul>
<li>多叉堆</li>
<li>索引堆</li>
<li>二项堆</li>
<li>….</li>
</ul>
<p><a href="https://github.com/CoderTitan/structureAlgorithm">测试项目</a>中是以二叉堆实现了最大堆和最小堆</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractHeap</span>&lt;<span class="title class_">E</span>: <span class="title class_">Comparable</span>&gt; &#123;</span><br><span class="line">    <span class="comment">/// 元素的数量</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">count</span>() -&gt; <span class="type">Int</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 是否为空</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">isEmpty</span>() -&gt; <span class="type">Bool</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 清空</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">clear</span>() &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 添加元素</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">add</span>(<span class="params">val</span>: <span class="type">E</span>) &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 添加元素数组</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">addAll</span>(<span class="params">vals</span>: [<span class="type">E</span>]) &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 获得堆顶元素</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">top</span>() -&gt; <span class="type">E</span>? &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 删除堆顶元素</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">remove</span>() -&gt; <span class="type">E</span>? &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 删除堆顶元素的同时插入一个新元素</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">replace</span>(<span class="params">val</span>: <span class="type">E</span>) -&gt; <span class="type">E</span>? &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<table>
<thead>
<tr>
<th>二叉堆</th>
<th>类名</th>
</tr>
</thead>
<tbody><tr>
<td>二叉堆</td>
<td>BinaryHeap</td>
</tr>
<tr>
<td>最大堆</td>
<td>MinHeap</td>
</tr>
<tr>
<td>最小堆</td>
<td>MaxHeap</td>
</tr>
</tbody></table>
<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><ul>
<li>并查集也叫不相交集合, 有查找和合并两个核心操作</li>
<li>查找: 查找元素所在的集</li>
<li>合并: 将两个元素所在的集合并为一个集</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line">    <span class="comment">/// 查找V所属的集合(根节点)</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">find</span>(<span class="params">v</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 合并v1, v2所在的集合</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">union</span>(<span class="params">v1</span>: <span class="type">Int</span>, <span class="params">v2</span>: <span class="type">Int</span>) &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 检查v1, v2是否属于同一个集合</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">isSame</span>(<span class="params">v1</span>: <span class="type">Int</span>, <span class="params">v2</span>: <span class="type">Int</span>) -&gt; <span class="type">Bool</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th>并查集</th>
<th>类名</th>
</tr>
</thead>
<tbody><tr>
<td>Quick Find</td>
<td>UnionFind_QF</td>
</tr>
<tr>
<td>Quick Union</td>
<td>UnionFind_QU</td>
</tr>
<tr>
<td>QU基于size优化</td>
<td>UnionFind_QU_Size</td>
</tr>
<tr>
<td>QU基于size优化</td>
<td>UnionFind_QU_Size</td>
</tr>
<tr>
<td>QU基于rank优化</td>
<td>UnionFind_QU_Rank</td>
</tr>
<tr>
<td>QU基于rank的优化, 路径压缩</td>
<td>UnionFind_QU_Rank_PC</td>
</tr>
<tr>
<td>QU基于rank的优化, 路径分裂</td>
<td>UnionFind_QU_Rank_PS</td>
</tr>
<tr>
<td>QU基于rank的优化, 路径减半</td>
<td>UnionFind_QU_Rank_PH</td>
</tr>
<tr>
<td>泛型并查集</td>
<td>GenericUnionFind</td>
</tr>
</tbody></table>
<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><ul>
<li>图由顶点和边组成, 分有向图和无向图 —&gt; <code>ListGraph</code></li>
<li><code>ListGraph</code>继承自<code>Graph</code></li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span>&lt;<span class="title class_">V</span>: <span class="title class_">Comparable</span> &amp; <span class="title class_">Hashable</span>, <span class="title class_">E</span>: <span class="title class_">Comparable</span> &amp; <span class="title class_">Hashable</span>&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 边的个数</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">edgesSize</span>() -&gt; <span class="type">Int</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 顶点个数</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">verticesSize</span>() -&gt; <span class="type">Int</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 添加顶点</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">addVertex</span>(<span class="params">val</span>: <span class="type">V</span>) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 添加边</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">addEdge</span>(<span class="params">from</span>: <span class="type">V</span>, <span class="params">to</span>: <span class="type">V</span>) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 添加边(带权重)</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">addEdge</span>(<span class="params">from</span>: <span class="type">V</span>, <span class="params">to</span>: <span class="type">V</span>, <span class="params">weight</span>: <span class="type">Double</span>?) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 删除顶点</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">removeVertex</span>(<span class="params">val</span>: <span class="type">V</span>) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 删除边</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">removeEdge</span>(<span class="params">from</span>: <span class="type">V</span>, <span class="params">to</span>: <span class="type">V</span>) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 广度优先搜索(Breadth First Search)</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">breadthFirstSearch</span>(<span class="params">begin</span>: <span class="type">V</span>?, <span class="params">visitor</span>: ((<span class="type">V</span>) -&gt; ())) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 深度优先搜索(Depth First Search)[非递归]</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">depthFirstSearch</span>(<span class="params">begin</span>: <span class="type">V</span>?, <span class="params">visitor</span>: ((<span class="type">V</span>) -&gt; ())) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 深度优先搜索(Depth First Search)[递归]</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">depthFirstSearchCircle</span>(<span class="params">begin</span>: <span class="type">V</span>?, <span class="params">visitor</span>: ((<span class="type">V</span>) -&gt; ())) &#123;&#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 拓扑排序</span></span><br><span class="line"><span class="comment">     * AOV网的遍历, 把AOV的所有活动排成一个序列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">topologicalSort</span>() -&gt; [<span class="type">V</span>] &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 最小生成树</span></span><br><span class="line"><span class="comment">     * 最小权值生成树, 最小支撑树</span></span><br><span class="line"><span class="comment">     * 所有生成树中, 权值最小的那颗</span></span><br><span class="line"><span class="comment">     * prim算法方式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">mstPrim</span>() -&gt; <span class="type">HashSet</span>&lt;<span class="type">EdgeInfo</span>&lt;<span class="type">V</span>, <span class="type">E</span>&gt;&gt;? &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 最小生成树</span></span><br><span class="line"><span class="comment">     * 最小权值生成树, 最小支撑树</span></span><br><span class="line"><span class="comment">     * 所有生成树中, 权值最小的那颗</span></span><br><span class="line"><span class="comment">     * prim算法方式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">mstKruskal</span>() -&gt; <span class="type">HashSet</span>&lt;<span class="type">EdgeInfo</span>&lt;<span class="type">V</span>, <span class="type">E</span>&gt;&gt;? &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 有向图</span></span><br><span class="line"><span class="comment">     * 从某一点出发的最短路径(权值最小)</span></span><br><span class="line"><span class="comment">     * 返回权值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">shortestPath</span>(<span class="keyword">_</span> <span class="params">begin</span>: <span class="type">V</span>) -&gt; <span class="type">HashMap</span>&lt;<span class="type">V</span>, <span class="type">Double</span>&gt;? &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Dijkstra: 单源最短路径算法,用于计算一个顶点到其他所有顶点的最短路径</span></span><br><span class="line"><span class="comment">     * 不支持有负权边</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">dijkstraShortPath</span>(<span class="keyword">_</span> <span class="params">begin</span>: <span class="type">V</span>) -&gt; <span class="type">HashMap</span>&lt;<span class="type">V</span>, <span class="type">PathInfo</span>&lt;<span class="type">V</span>, <span class="type">E</span>&gt;&gt;? &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * bellmanFord: 单源最短路径算法,用于计算一个顶点到其他所有顶点的最短路径</span></span><br><span class="line"><span class="comment">     * 支持有负权边</span></span><br><span class="line"><span class="comment">     * 支持检测是否有负权环</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">bellmanFordShortPath</span>(<span class="keyword">_</span> <span class="params">begin</span>: <span class="type">V</span>) -&gt; <span class="type">HashMap</span>&lt;<span class="type">V</span>, <span class="type">PathInfo</span>&lt;<span class="type">V</span>, <span class="type">E</span>&gt;&gt;? &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Floyd: 多源最短路径算法,用于计算任意两个顶点的最短路径</span></span><br><span class="line"><span class="comment">     * 支持有负权边</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">floydShortPath</span>() -&gt; <span class="type">HashMap</span>&lt;<span class="type">V</span>, <span class="type">HashMap</span>&lt;<span class="type">V</span>, <span class="type">PathInfo</span>&lt;<span class="type">V</span>, <span class="type">E</span>&gt;&gt;&gt;? &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 输出字符串</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">printString</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><table>
<thead>
<tr>
<th>排序</th>
<th>类名</th>
</tr>
</thead>
<tbody><tr>
<td>冒泡排序</td>
<td>BubbleSorted2</td>
</tr>
<tr>
<td>选择排序</td>
<td>SelectedSorted</td>
</tr>
<tr>
<td>插入排序</td>
<td>InsertionSorted1</td>
</tr>
<tr>
<td>归并排序</td>
<td>MergeSort</td>
</tr>
<tr>
<td>希尔排序</td>
<td>ShellSort</td>
</tr>
<tr>
<td>快速排序</td>
<td>QuickSorted</td>
</tr>
<tr>
<td>堆排序</td>
<td>HeapSorted</td>
</tr>
<tr>
<td>计数排序</td>
<td>CountingSorted</td>
</tr>
<tr>
<td>基数排序</td>
<td>RadixSorted</td>
</tr>
<tr>
<td>桶排序</td>
<td>BucketSorted</td>
</tr>
</tbody></table>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 快速排序</span></span><br><span class="line"><span class="keyword">let</span> arr <span class="operator">=</span> [<span class="number">126</span>, <span class="number">69</span>, <span class="number">593</span>, <span class="number">23</span>, <span class="number">6</span>, <span class="number">89</span>, <span class="number">54</span>, <span class="number">8</span>]</span><br><span class="line"><span class="keyword">let</span> quick <span class="operator">=</span> <span class="type">QuickSorted</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line"><span class="built_in">print</span>(quick.sorted(by: arr))</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 桶排序</span></span><br><span class="line"><span class="keyword">let</span> sort <span class="operator">=</span> <span class="type">BucketSorted</span>()</span><br><span class="line"><span class="keyword">let</span> array <span class="operator">=</span> [<span class="number">0.34</span>, <span class="number">0.47</span>, <span class="number">0.29</span>, <span class="number">0.84</span>, <span class="number">0.45</span>, <span class="number">0.38</span>, <span class="number">0.35</span>, <span class="number">0.76</span>]</span><br><span class="line"><span class="built_in">print</span>(sort.sorted(by: array))</span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>数据结构部分除了跳表和串其他的基本都实现了</li>
<li>算法部分除了排序, 其他都暂时还没有学习</li>
<li>这部分的学习就暂时告一段落, 接下来我要准备11月份的考试</li>
<li>GitHub代码地址: <a href="https://github.com/CoderTitan/structureAlgorithm">数据结构和算法</a></li>
</ul>
<hr>
]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>发布开源框架到CocoaPods入坑指南</title>
    <url>/post/75198337.html</url>
    <content><![CDATA[<ul>
<li>在开发过程中一定会用到一些第三方框架, 只要安装了<code>CocoaPods</code>, 然后通过<code>pod install</code>命令, 就可以集成框架到项目中了</li>
<li>可是如果想要把自己的框架或者组件也开源出去, 让别人也可以使用, 那该如何入手 ?</li>
<li>对于<code>CocoaPods</code>还不是很了解的或者没有安装的童鞋, 可自行百度或者参考<a href="http://blog.devtang.com/2014/05/25/use-cocoapod-to-manage-ios-lib-dependency/">用CocoaPods做程序的依赖</a></li>
</ul>
<span id="more"></span>

<h2 id="搭建框架"><a href="#搭建框架" class="headerlink" title="搭建框架"></a>搭建框架</h2><h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h3><ul>
<li><code>CocoaPods</code>项目的源码在<code>Github</code>上管理,所以第一步我们需要创建一个属于自己的仓库</li>
<li>根据图下图所示创建自己的项目</li>
</ul>
<p><img data-src="https://upload-images.jianshu.io/upload_images/4122543-d600fd516421d3a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/714/format/webp" alt="创建仓库"></p>
<h3 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h3><ul>
<li>要开发框架必然就要上传文件, 这里推荐<code>SourceTree</code>和<code>GitHub</code>客户端, 当然也可以使用终端命令上传</li>
<li>使用<code>git</code>管理工具我们这里暂不赘述, 不懂得可以自行百度</li>
<li>终端使用<code>git</code>命令上传, 主要命令如下</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//cd到当前文件夹</span></span><br><span class="line"><span class="comment">// 创建本地仓库</span></span><br><span class="line">git init</span><br><span class="line"><span class="comment">// 添加名称为origin的远程连接</span></span><br><span class="line">git remote add origin <span class="string">&#x27;你的github项目地址&#x27;</span></span><br><span class="line"><span class="comment">// 将本地代码加入本地仓库里</span></span><br><span class="line">git add .</span><br><span class="line"><span class="comment">// 提交修改到本地仓库</span></span><br><span class="line">git commit -m <span class="string">&#x27;你的修改记录&#x27;</span></span><br><span class="line"><span class="comment">// 推送master分支的代码到名称为origin的远程仓库</span></span><br><span class="line">git push origin master</span><br><span class="line"><span class="comment">//本地打标签备份</span></span><br><span class="line">git tag <span class="string">&quot;v0.0.1&quot;</span></span><br><span class="line"><span class="comment">//提交标签</span></span><br><span class="line">git push --tags</span><br><span class="line"><span class="comment">//删除本地标签</span></span><br><span class="line">git tag -d 标签名称</span><br><span class="line"><span class="comment">//删除远程标签</span></span><br><span class="line">git push origin: 标签名称</span><br></pre></td></tr></table></figure>


<h3 id="使用CocoaPods"><a href="#使用CocoaPods" class="headerlink" title="使用CocoaPods"></a>使用CocoaPods</h3><h4 id="检索第三方框架"><a href="#检索第三方框架" class="headerlink" title="检索第三方框架"></a>检索第三方框架</h4><ul>
<li>使用命令<code>pod search xxx</code></li>
<li>从本地缓存的–第三方框架描述信息–生成的检索文件中检索到响应的框架信息</li>
<li>本地缓存的框架描述信息位置: <code>~/Library/Caches/CocoaPods/search_index.json</code></li>
<li>如执行命令时出现错误, 可删除改索引文件, 执行命令: <code>rm ~/Library/Caches/CocoaPods/search_index.json</code></li>
</ul>
<h4 id="安装第三方框架"><a href="#安装第三方框架" class="headerlink" title="安装第三方框架"></a>安装第三方框架</h4><ul>
<li>创建<code>Podfile</code>文件, 到自己工程内(一级目录): <code>pod init</code><ul>
<li><code>Podfile</code>文件: 答: 其实就是使用<code>ruby</code>语法编写的 “框架依赖描述文件”; 就是告诉<code>cocoapods</code>需要下载集成哪些框架</li>
</ul>
</li>
<li>安装框架<ul>
<li><code>pod install</code></li>
<li><code>cocoapods</code>在1.0.1以后版本, 会直接就是根据<code>Podfile</code>文件找到, 框架信息, 然后下载集成</li>
<li>但是1.0.1之前的版本, 会先更新本地的框架描述信息(非常耗时), 然后再根据文件下载</li>
<li>下载完成后会生成一个<code>Podfile.lock</code>文件, 记录着上一次下载的框架最新版本</li>
</ul>
</li>
<li><code>pod install</code>和<code>pod update</code><ul>
<li><code>pod install</code><ul>
<li>如果<code>Podfile.lock</code>文件存在, 直接从此文件中读取框架信息下载安装</li>
<li>如果不存在, 依然会读取<code>Podfile</code>文件内的框架信息, 下载好之后, 再根据下载好的框架信息, 生成<code>Podfile.lock</code>文件</li>
</ul>
</li>
<li><code>pod update</code><ul>
<li>不管<code>Podfile.lock</code>是否存在, 都会读取<code>Podfile</code>文件的的框架信息去下载</li>
<li>下载好之后, 再根据下载好的框架信息, 生成<code>Podfile.lock</code>文件</li>
</ul>
</li>
<li>主要区别在于, <code>Podfile</code>文件内的框架信息, 版本描述没有指定具体版本</li>
<li>一般情况下, 每个人从共享库把项目下载下来之后, 都会执行<code>pod install</code>命令安装!这样可以保证大家使用的第三方框架版本一致!!如果以后大家需要统一升级第三方框架, 那么每个人在执行 pod update</li>
</ul>
</li>
</ul>
<h4 id="CocoaPods相关操作"><a href="#CocoaPods相关操作" class="headerlink" title="CocoaPods相关操作"></a>CocoaPods相关操作</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//创建Podfile文件</span><br><span class="line">pod init</span><br><span class="line">//搜索框架</span><br><span class="line">pod search</span><br><span class="line">//安装框架</span><br><span class="line">pod install</span><br><span class="line">//更新框架</span><br><span class="line">pod update</span><br><span class="line"></span><br><span class="line">//初始化(下载服务器中所有的第三方框架信息缓存到电脑本地)</span><br><span class="line">pod setup</span><br><span class="line">//查看第三方框架仓库源</span><br><span class="line">pod repo</span><br><span class="line">//移除仓库源</span><br><span class="line">pod repo remove master</span><br><span class="line">//添加仓库源</span><br><span class="line">//pod repo add master https://xxxx....</span><br></pre></td></tr></table></figure>

<h4 id="CocoaPods相关路径"><a href="#CocoaPods相关路径" class="headerlink" title="CocoaPods相关路径"></a><code>CocoaPods</code>相关路径</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//索引缓存路径</span><br><span class="line">//如果发现框架信息本地已经缓存, 但是就是无法搜索框架, 可以删除这个索引文件, 重新生成</span><br><span class="line"> ~/Library/Caches/CocoaPods/</span><br><span class="line"> </span><br><span class="line"> //pod命令安装路径</span><br><span class="line"> /usr/local/bin</span><br><span class="line"> </span><br><span class="line"> //pod框架索引信息缓存路径</span><br><span class="line"> /Users/apple/.cocoapods/repos/master</span><br></pre></td></tr></table></figure>



<h3 id="创建Podspec描述文件"><a href="#创建Podspec描述文件" class="headerlink" title="创建Podspec描述文件"></a>创建Podspec描述文件</h3><ul>
<li>该文件为<code>Cocoapods</code>依赖库的描述文件，每个<code>Cocoapods</code>依赖库必须有且仅有那么一个描述文件</li>
<li>简单地讲就是让<code>CocoaPods</code>搜索引擎知道你的代码的作者、版本号、源代码地址、依赖库等信息的文件</li>
<li>文件名称要和我们想创建的依赖库名称保持一致</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">pod spec create 框架名字</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例:</span></span><br><span class="line">pod spec create TitanModel</span><br></pre></td></tr></table></figure>

<ul>
<li>该命令将在本目录产生一个名为<code>TitanModel.podspec</code>文件</li>
<li>可用<code>Sublime Text</code>或者<code>Atom</code>打开该文件，里面已经有非常丰富的说明文档, 但是很多都是我们不需要的</li>
<li>官方<code>Podspec</code>文件的编写格式可参考 <a href="https://guides.cocoapods.org/syntax/podspec.html">Podspec Syntax Reference</a></li>
<li>下面介绍如何声明第三方库的代码目录和资源目录，还有该第三方库所依赖<code>ios</code>核心框架和第三方库</li>
<li>去掉文件中的一些注释信息, 可以看到也就剩下以下内容了</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Pod::Spec</span>.new <span class="keyword">do</span> |<span class="params">s</span>|</span><br><span class="line">    s.name          = <span class="string">&#x27;TitanModel&#x27;</span> <span class="comment">#项目名</span></span><br><span class="line">    s.version       = <span class="string">&#x27;0.1.0&#x27;</span> <span class="comment">#相应的版本号</span></span><br><span class="line">    s.summary       = <span class="string">&#x27;A short description of YJDemoSDK.&#x27;</span> <span class="comment">#简述</span></span><br><span class="line">    s.description   = &lt;&lt;‐ <span class="variable constant_">DESC</span> <span class="comment">#详细描述</span></span><br><span class="line">    <span class="variable constant_">TODO</span>: Add long description of the pod here.</span><br><span class="line">                      <span class="variable constant_">DESC</span></span><br><span class="line">    s.homepage      = <span class="string">&#x27;https://github.com/CoderTitan/TitanModel&#x27;</span> <span class="comment">#项目主页</span></span><br><span class="line">    s.license       = &#123; <span class="symbol">:type</span> =&gt; <span class="string">&#x27;MIT&#x27;</span>, <span class="symbol">:file</span> =&gt; <span class="string">&#x27;LICENSE&#x27;</span> &#125; <span class="comment">#开源协议</span></span><br><span class="line">    s.author        = &#123; <span class="string">&#x27;CoderTitan&#x27;</span> =&gt; <span class="string">&#x27;quanjunt@163.com&#x27;</span> &#125; <span class="comment">#作者</span></span><br><span class="line">    s.platform      = <span class="symbol">:ios</span>, <span class="string">&#x27;8.0&#x27;</span> <span class="comment">#支持的平台</span></span><br><span class="line">    s.requires_arc  = <span class="literal">true</span> <span class="comment">#arc和mrc选项</span></span><br><span class="line">    s.libraries     = <span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27;sqlite3&#x27;</span> <span class="comment">#表示依赖的系统类库，比如libz.dylib等</span></span><br><span class="line">    s.frameworks    = <span class="string">&#x27;UIKit&#x27;</span>,<span class="string">&#x27;AVFoundation&#x27;</span> <span class="comment">#表示依赖系统的框架</span></span><br><span class="line">    s.ios.vendored_frameworks = <span class="string">&#x27;TKBase/TKBase.framework&#x27;</span> <span class="comment"># 依赖的第三方/自己的framework</span></span><br><span class="line">    s.vendored_libraries = <span class="string">&#x27;Library/Classes/libWeChatSDK.a&#x27;</span> <span class="comment">#表示依赖第三方/自己的静态库（比如libWeChatSDK.a）</span></span><br><span class="line">    <span class="comment">#依赖的第三方的或者自己的静态库文件必须以lib为前缀进行命名，否则会出现找不到的情况，这一点非常重要</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#平台信息</span></span><br><span class="line">    s.platform      = <span class="symbol">:ios</span>, <span class="string">&#x27;7.0&#x27;</span></span><br><span class="line">    s.ios.deployment_target = <span class="string">&#x27;7.0&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#文件配置项</span></span><br><span class="line">    s.source        = &#123; <span class="symbol">:git</span> =&gt; <span class="string">&#x27;https://github.com/CoderTitan/TitanModel.git&#x27;</span>, <span class="symbol">:tag</span> =&gt; s.version.to_s &#125;</span><br><span class="line">    <span class="comment">#配置项目的目标路径，如果不是本地开发，pod init/update会从这个路去拉去代码</span></span><br><span class="line"></span><br><span class="line">    s.source_files = <span class="string">&#x27;TitanModel/Classes/**/*&#x27;</span> <span class="comment">#你的源码位置</span></span><br><span class="line">    s.resources     = [<span class="string">&#x27;TitanModel/Assets/*&#x27;</span>] <span class="comment">#资源，比如图片，音频文件等</span></span><br><span class="line">    s.public_header_files = <span class="string">&#x27;TitanModel/Classes/TitanModel.h&#x27;</span>   <span class="comment">#需要对外开放的头文件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#依赖的项目内容 可以多个</span></span><br><span class="line">    s.dependency <span class="string">&#x27;MJExtension&#x27;</span></span><br><span class="line">    s.dependency <span class="string">&#x27;AFNetworking&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>s.name</code>：名称，<code>pod search</code>搜索的关键词,注意这里一定要和<code>.podspec</code>的名称一样,否则报错</li>
<li><code>s.version</code>：版本号，<code>to_s</code>：返回一个字符串</li>
<li><code>s.summary</code>: 项目简短的简介</li>
<li><code>s.description</code>: 这个是详细的描述, 要注意的是字数要比<code>summary</code>的长, 否则上传的时候可能会爆出警告</li>
<li><code>s.homepage</code>: 项目主页地址</li>
<li><code>s.license</code>: 许可证</li>
<li><code>s.author</code>: 作者</li>
<li><code>s.source</code>: 项目源码所在地址</li>
<li><code>s.platform</code>: 项目支持平台</li>
<li><code>s.requires_arc</code>: 是否支持<code>ARC</code></li>
<li><code>s.source_files</code>: 需要包含的源文件</li>
<li><code>s.public_header_files</code>: 需要包含的头文件</li>
<li><code>s.ios.deployment_target</code>: 支持的<code>pod</code>最低版本</li>
<li><code>s.social_media_url</code>: 社交网址</li>
<li><code>s.resources</code>: 资源文件</li>
<li><code>s.dependency</code>: 依赖库，不能依赖未发布的库</li>
</ul>
<blockquote>
<p><code>source_files</code>写法及含义</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;TitanModel&quot;</span></span><br><span class="line"><span class="string">&quot;Classes/**/*.&#123;h,m&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>*</code>表示匹配所有文件</li>
<li><code>*.&#123;h,m&#125;</code>表示匹配所有以<code>.h</code>和<code>.m</code>结尾的文件</li>
<li><code>**</code>表示匹配所有子目录</li>
</ul>
<h3 id="将自己的项目打成tag"><a href="#将自己的项目打成tag" class="headerlink" title="将自己的项目打成tag"></a>将自己的项目打成<code>tag</code></h3><ul>
<li>因为<code>cocoapods</code>是依赖<code>tag</code>版本的,所以必须打<code>tag</code>,以后再次更新只需要把你的项目打一个<code>tag</code>，然后修改<code>.podspec</code>文件中的版本接着提交到<code>cocoapods</code>官方就可以了</li>
<li>要注意的是, 这里提交的版本号要和<code>TitanModel.podspec</code>文件中的版本号一致</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git tag &quot;v0.0.1&quot;  </span><br><span class="line">git push --tags</span><br></pre></td></tr></table></figure>

<h3 id="上传Podspec"><a href="#上传Podspec" class="headerlink" title="上传Podspec"></a>上传<code>Podspec</code></h3><ul>
<li><code>Podspec</code>修改完成后, 上传到服务器时, 我们需要使用<code>trunk</code>进行上传</li>
<li>首先要注册<code>trunk</code>, 在注册<code>trunk</code>之前，我们需要确认当前的<code>CocoaPods</code>版本是否足够新。<code>trunk</code>需要<code>pod</code>在<code>0.33</code>及以上版本，如果你不满足要求, 需要重新安装<code>pod</code></li>
<li>更新结束后，我们开始注册<code>trunk</code>, 可参考官方文档<a href="https://guides.cocoapods.org/making/getting-setup-with-trunk.html">Getting setup with Trunk</a></li>
<li>终端输入以下命令</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pod trunk register 邮箱地址 &#x27;用户名&#x27; --description=&#x27;描述&#x27;</span><br><span class="line"></span><br><span class="line">// 示例</span><br><span class="line">pod trunk register quanjunt@163.com &#x27;CoderTitan&#x27; --description=&#x27;macbook&#x27;</span><br></pre></td></tr></table></figure>

<p>执行该命令后, 你的邮箱会受到一封邮件, 但是邮件要到垃圾邮件中才能找到, 打开邮件找到邮件中的网址并打开</p>
<p><img data-src="https://upload-images.jianshu.io/upload_images/4122543-a7ec0659f716c755.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="image"></p>
<p>如果打开邮件中的链接和下面的页面一样, 则表示注册成功</p>
<p><img data-src="https://upload-images.jianshu.io/upload_images/4122543-cc70f97600d6b4bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/785/format/webp" alt="注册成功"></p>
<p>最后输入如下命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pod trunk push TitanModel.podspec</span><br></pre></td></tr></table></figure>

<p>时间较长，耐性等待，大概5-10分钟, 成功后结果如下</p>
<p><img data-src="https://upload-images.jianshu.io/upload_images/4122543-de1a8d5fe072d85b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="trunk"></p>
<ul>
<li>上面图片中可以看到执行了<code>Updating spec repo master</code>命令, 该命令主要就是更新本地的<code>Specs</code>文件</li>
<li>查看文件夹位置, 打开访达文件夹, <code>Shift+command+G</code>快捷键, 打开前往文件夹操作, 输入如下目录即可查看</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~/.cocoapods/repos/master/Specs</span><br></pre></td></tr></table></figure>

<h3 id="测试自己的cocoapods"><a href="#测试自己的cocoapods" class="headerlink" title="测试自己的cocoapods"></a>测试自己的cocoapods</h3><ul>
<li>终端输入<code>pod search TitanModel</code>查看</li>
<li>但是如果输入上述命令后, 终端输出如下错误</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[!] Unable to find a pod with name, author, summary, or description matching `TitanModel`</span><br></pre></td></tr></table></figure>

<p>这是因为你的框架已经上传, 但是你的本地的搜索文件<code>search_index.json</code>没有更新, 所以搜索不到, 可以执行下面命令删除<code>search_index.json</code>文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rm ~/Library/Caches/CocoaPods/search_index.json</span><br></pre></td></tr></table></figure>

<ul>
<li>也可以直接找到该文件删除</li>
<li>查看文件夹位置, 打开访达文件夹, <code>Shift+command+G</code>快捷键, 打开前往文件夹操作, 输入如下目录即可查看</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~/Library/Caches/CocoaPods/</span><br></pre></td></tr></table></figure>

<div class="note success"><p>搜索成功</p></div>

<p><img data-src="https://upload-images.jianshu.io/upload_images/4122543-860729c04860ca64.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/649/format/webp" alt="search"></p>
<h2 id="错误整理"><a href="#错误整理" class="headerlink" title="错误整理"></a>错误整理</h2><h3 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h3><ul>
<li>设置版本号的时候一般有两种方式, 一种是前面带<code>v</code>的, 如: <code>v0.0.1</code>;另 一种是前面不带<code>v</code>的, 如:<code> 0.0.1</code></li>
<li>因为<code>v</code>而导致的报错</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">warning: Could not find remote branch 0.0.1 to clone.</span><br><span class="line"></span><br><span class="line">fatal: Remote branch 0.0.1 not found in upstream origin</span><br></pre></td></tr></table></figure>

<p>为解决以上问题, 设置版本号的方式和<code>spec</code>文件内的版本号方式一定要一致</p>
<h4 id="不带v方式"><a href="#不带v方式" class="headerlink" title="不带v方式:"></a>不带v方式:</h4><p>设置版本号时:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 这里设置时, 不要带v</span><br><span class="line">git tag &#x27;0.0.1&#x27;  </span><br><span class="line">git push --tags  </span><br></pre></td></tr></table></figure>

<p><code>spec</code>文件中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//这里不要带v</span><br><span class="line">s.version = &quot;0.0.2&quot;</span><br><span class="line">s.source = &#123; :git =&gt; &quot;https://github.com/CoderTitan/TitanModell.git&quot;, :tag =&gt; s.version &#125;</span><br><span class="line">//这里的tag也可以设置成具体的版本号, 只要与上面一样就好</span><br></pre></td></tr></table></figure>

<h4 id="带v方式"><a href="#带v方式" class="headerlink" title="带v方式:"></a>带v方式:</h4><p>设置版本号时:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 这里设置时, 要带v</span><br><span class="line">git tag &#x27;v0.0.1&#x27;  </span><br><span class="line">git push --tags  </span><br></pre></td></tr></table></figure>

<p><code>spec</code>文件中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//这里要带v</span><br><span class="line">s.version = &quot;v0.0.2&quot;</span><br><span class="line">s.source = &#123; :git =&gt; &quot;https://github.com/CoderTitan/TitanModell.git&quot;, :tag =&gt; &quot;v#&#123;s.version&#125; &#125;</span><br><span class="line">//这里的tag也可以设置成具体的版本号, 只要与上面一样就好</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后对上述涉及到的终端命令做一个简单的总结</p>
<h3 id="终端命令"><a href="#终端命令" class="headerlink" title="终端命令"></a>终端命令</h3><ol>
<li>开源库发布之后，需要给项目打上<code>tag</code></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git tag &quot;0.0.1&quot;  </span><br><span class="line">git push --tags</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>进入到项目根目录下，创建<code>podspec</code>文件</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pod spec create TitanModel</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>编辑<code>podspec</code>文件中的相关信息，有两个比较重要的地方<code>s.source</code>和<code>s.source_files</code>, 修改完成后, 验证是否有误</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pod spec lint TitanModel.podspec</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>注册<code>pod trunk</code></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pod trunk register orta@cocoapods.org &#x27;Orta Therox&#x27; --description=&#x27;macbook air&#x27;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>发布到<code>trunk</code></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pod trunk push TitanModel.podspec</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>搜索发布的框架</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pod search TitanModel</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>组件化开发</category>
      </categories>
      <tags>
        <tag>CocoaPods</tag>
      </tags>
  </entry>
  <entry>
    <title>基于GitHub和Hexo搭建个人博客</title>
    <url>/post/ab9cc174.html</url>
    <content><![CDATA[<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/hexo-next/hexohome.png?x-oss-process=style/titanjun" alt="Hexo博客"></p>
<span id="more"></span>



<p>本文是使用Mac电脑, 基于GitHub和Hexo搭建个人博客, 搞了两三天, 反复尝试了无数次, 踩了无数坑搭建起来的, 主要跟大家分享一点小经验, 希望对大家能有帮助!</p>
<h2 id="github博客简介"><a href="#github博客简介" class="headerlink" title="github博客简介"></a>github博客简介</h2><p>github 是全球最大的社交编程及代码托管网站，GitHub可以托管各种git库，并提供一个web界面，但与其它像SourceForge或Google Code这样的服务不同，GitHub的独特卖点在于从另外一个项目进行分支的简易性。这里着重写如何使用Github的page功能搭建个人博客!</p>
<blockquote>
<p>使用github pages服务搭建博客的好处有：</p>
</blockquote>
<ul>
<li>全是静态文件，访问速度快；</li>
<li>免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；</li>
<li>可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；</li>
<li>数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行；</li>
<li>博客内容可以轻松打包、转移、发布到其它平台；</li>
</ul>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul>
<li>有一个<a href="https://github.com/login?return_to=/join?source=header-home">github账号</a>，没有的话去<a href="https://github.com/join?source=header-home">GitHub注册</a>一个</li>
<li>安装了<a href="https://nodejs.org/en/">node.js</a>、npm，并了解相关基础知识</li>
<li>安装了git</li>
</ul>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h3><ul>
<li>用来生成静态页面, 到<a href="https://nodejs.org/en/">Node.js官网</a>，下载最新版本, 根据提示一路安装即可</li>
<li><code>Node.js</code>默认会安装 npm</li>
<li>也可以使用<code>Homebrew</code>进行命令安装, 详情参考<a href="https://reactnative.cn/docs/0.51/getting-started.html#content">React Native中文网</a>安装方法</li>
</ul>
<h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><ul>
<li>用来将本地Hexo内容提交到Github上。下载的Xcode自带Git，这里不再赘述。</li>
<li>如果没有Xcode可以参考<a href="https://hexo.io/docs/">Hexo官网</a>上的安装方法</li>
<li>通用版的<a href="https://www.git-scm.com/download/win">Git安装</a>, 无法下载的童鞋，可以去网上搜索下载</li>
</ul>
<h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>当Node.js和Git都安装好后就可以正式安装Hexo了，终端执行如下命令：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">sudo npm install -g hexo</span><br></pre></td></tr></table></figure>

<p>此时, 会提示你输入管理员密码(电脑密码), 开始安装</p>
<h2 id="本地搭建-hexo-静态博客"><a href="#本地搭建-hexo-静态博客" class="headerlink" title="本地搭建 hexo 静态博客"></a>本地搭建 hexo 静态博客</h2><ul>
<li>在电脑中新建一个文件夹, 文件夹名字随意, 如MyBlog</li>
<li>在终端, cd 进入该文件夹</li>
<li>终端运行 git, 生成hexo模板，可能要翻墙</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>

<p> 安装完模板, 安装npm</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>

<p>最后, 开启hexo服务器</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p>此时，浏览器中打开网址<a href="http://localhost:4000，能看到如下页面：">http://localhost:4000，能看到如下页面：</a></p>
<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-dfe49f13bcfd743d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="Snip20180303_1.png"></p>
<h2 id="将博客与Github关联"><a href="#将博客与Github关联" class="headerlink" title="将博客与Github关联"></a>将博客与Github关联</h2><h3 id="在GitHub上配置SSH-key"><a href="#在GitHub上配置SSH-key" class="headerlink" title="在GitHub上配置SSH key"></a>在GitHub上配置SSH key</h3><p>为什么要配置这个呢？因为你提交代码肯定要拥有你的github权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用ssh key来解决本地和服务器的连接问题。</p>
<h4 id="首先检查本机是否存在的ssh密钥"><a href="#首先检查本机是否存在的ssh密钥" class="headerlink" title="首先检查本机是否存在的ssh密钥"></a>首先检查本机是否存在的ssh密钥</h4><ul>
<li>如果存在, 直接进行步骤1.3, 否则执行步骤1.2生成新的密钥</li>
<li>打开终端输入, 注意<code>~/.ssh</code>之间没有空格</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">cd ~/.ssh</span><br></pre></td></tr></table></figure>
<p>如果提示：No such file or directory 说明你是第一次使用git, 或者之前没有安装过SSh密钥</p>
<h4 id="生成新的ssh-key"><a href="#生成新的ssh-key" class="headerlink" title="生成新的ssh key"></a>生成新的ssh key</h4><p>注意后面添加自己注册GitHub的邮箱地址, 打开终端输入</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;邮件地址&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>输入命令后, 然后连续回车, 默认会在相应路径下（~&#x2F;.ssh&#x2F;id_rsa.pub）生成id_rsa和id_rsa.pub两个文件</li>
<li>打开’访达’, 选择进入文件夹(快捷键Command+Shift+G), 输入~&#x2F;.ssh, 进入该文件夹</li>
</ul>
<h4 id="将ssh-key添加到Github中"><a href="#将ssh-key添加到Github中" class="headerlink" title="将ssh key添加到Github中"></a>将ssh key添加到Github中</h4><p>打开用户目录，找到.ssh\id_rsa.pub文件，记事本打开并复制里面的内容，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key：</p>
<p>将刚复制的内容粘贴到key那里，title随便填，保存</p>
<h4 id="测试SSH配置是否成功"><a href="#测试SSH配置是否成功" class="headerlink" title="测试SSH配置是否成功"></a>测试SSH配置是否成功</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com  </span><br></pre></td></tr></table></figure>
<p>如果提示<code>Are you sure you want to continue connecting (yes/no)?</code>，输入<code>yes</code>，然后会看到：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Hi XXXX! You<span class="string">&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span></span><br></pre></td></tr></table></figure>

<p>看到这个信息说明SSH已配置成功！</p>
<h4 id="更改GitHub用户名和邮箱"><a href="#更改GitHub用户名和邮箱" class="headerlink" title="更改GitHub用户名和邮箱"></a>更改GitHub用户名和邮箱</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name XXXX<span class="comment">// 你的github用户名，非昵称</span></span><br><span class="line">$ git config --global user.email  <span class="string">&quot;xxx@qq.com&quot;</span><span class="comment">// 填写你的github注册邮箱</span></span><br></pre></td></tr></table></figure>

<h3 id="关联Github"><a href="#关联Github" class="headerlink" title="关联Github"></a>关联Github</h3><h4 id="新建XXX-github-io-的项目"><a href="#新建XXX-github-io-的项目" class="headerlink" title="新建XXX.github.io 的项目"></a>新建XXX.github.io 的项目</h4><p> 在 Github 上创建名字为 XXX.github.io 的项目，XXX为必须和自己的 github 用户名一模一样</p>
<h4 id="修改-config-yml文件配置"><a href="#修改-config-yml文件配置" class="headerlink" title="修改_config.yml文件配置"></a>修改<code>_config.yml</code>文件配置</h4><ul>
<li>打开本地的 MyBlog 文件夹项目内的_config.yml 配置文件</li>
<li>将其中的 type 设置为git，repository 是你 github.io 仓库的 git 地址, 如下所示</li>
<li>此处切记, 每一个毛好的后面都要加一个空格, 垂直方向一定要对齐, 否则可能会报错</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https:<span class="comment">//github.com/CoderTitan/CoderTitan.github.io.git</span></span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<h4 id="将配置文件上传GitHub"><a href="#将配置文件上传GitHub" class="headerlink" title="将配置文件上传GitHub"></a>将配置文件上传GitHub</h4><ul>
<li>打开终端, cd到MyBlog文件夹下, 以下命令均在MyBlog文件夹下执行</li>
</ul>
<p>在blog文件夹目录下执行生成静态页面命令：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">hexo generate     或者：hexo g</span><br></pre></td></tr></table></figure>

<p>此时若出现如下报错：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">ERROR Local hexo not found <span class="keyword">in</span> ~/blog</span><br><span class="line">ERROR Try runing: <span class="string">&#x27;npm install hexo --save&#x27;</span></span><br></pre></td></tr></table></figure>

<p>则执行命令：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">npm install hexo --save</span><br></pre></td></tr></table></figure>

<p>再执行配置命令：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">hexo deploy           或者：hexo d</span><br></pre></td></tr></table></figure>

<p>报错一: 若执行命令hexo deploy仍然报错：无法连接git或找不到git，则执行如下命令来安装hexo-deployer-git：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>报错二: 若执行命令hexo d报以下错误:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">ERROR Plugin load failed: hexo-server</span><br><span class="line"><span class="comment">//或者类似的错误</span></span><br><span class="line">ERROR Plugin load failed: hexo-renderer-sass</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>则执行响应的命令:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">sudo npm install hexo-server</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">sudo npm install hexo-renderer-sass</span><br></pre></td></tr></table></figure>

<p>解决玩错误之后, 最后在执行</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<blockquote>
<p>几个注意的地方：</p>
<ol>
<li>注册的邮箱一定要验证，否则不会成功；</li>
<li>仓库名字必须是：<code>username.github.io</code>，其中<code>username</code>是你的用户名；</li>
<li>仓库创建成功不会立即生效，需要过一段时间，大概10-30分钟，或者更久，我的等了半个小时才生效；</li>
<li>hexo d命令执行成功后，浏览器中打开网址<code>http://XXX.github.io</code>（将XXX换成你的用户名）能看到和打开http:<code>//localhost:4000</code>时一样的页面</li>
</ol>
</blockquote>
<h2 id="安装theme主题"><a href="#安装theme主题" class="headerlink" title="安装theme主题"></a>安装theme主题</h2><ul>
<li>搭建好的默认的主题真的是很丑, 所以这里我们先替换一个好看的主题, 大家更可以到<a href="https://hexo.io/themes/">官方主题</a>去选择自己喜欢的主题样式</li>
<li>示例主题: <a href="hexo-theme-random">Random</a></li>
</ul>
<p>终端cd到 MyBlog 目录下执行如下命令：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">git clone https:<span class="comment">//github.com/stiekel/hexo-theme-random.git themes/random</span></span><br></pre></td></tr></table></figure>

<p>修改_config.yml中的theme: landscape改为theme: random，然后重新执行hexo g来重新生成</p>
<p>终端cd到MyBlog目录下执行如下命令(每次部署文章的步骤)：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">hexo clean           <span class="comment">//清除缓存文件 (db.json) 和已生成的静态文件 (public)</span></span><br><span class="line"></span><br><span class="line">hexo g             <span class="comment">//生成缓存和静态文件</span></span><br><span class="line"> </span><br><span class="line">hexo d             <span class="comment">//重新部署到服务器</span></span><br></pre></td></tr></table></figure>

<h2 id="域名绑定"><a href="#域名绑定" class="headerlink" title="域名绑定"></a>域名绑定</h2><ul>
<li>现在使用的域名是Github提供的二级域名<code>XXX.github.io</code>，也可以绑定为自己的个性域名。</li>
<li>购买域名，可以到<a href="https://sg.godaddy.com/zh/">GoDaddy官网</a>，现在 <code>GoDaddy</code>已经有中文版了，虽然国家显示是新加坡，但不影响使用, 还可使用支付宝支付</li>
<li>也可以到<a href="https://wanwang.aliyun.com/?utm_content=se_1010380">阿里万网</a>购买, 我是在万网买的，可直接在其网站做域名解析</li>
</ul>
<h3 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h3><p>如果将域名指向一个域名，实现与被指向域名相同的访问效果，需要增加CNAME记录。登录万网，在你购买的域名后边点击：解析, 如下图</p>
<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-952aa0a8a84a089f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20180303_4.png"></p>
<p>进入解析页面后点击添加解析, 向你的 DNS 配置中添加 3 条记录, 如下图<br>注意CNAME记录添加的是username.github.io.(不要忘记后面的.), 可能最后一个点不显示(我的就不显示)</p>
<p><img data-src="http://upload-images.jianshu.io/upload_images/4122543-b2435667d603f844.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20180303_5.png"></p>
<h3 id="设置GitHub配置信息"><a href="#设置GitHub配置信息" class="headerlink" title="设置GitHub配置信息"></a>设置GitHub配置信息</h3><ul>
<li>打开你的XXX.github.io项目地址, 找到设置页面</li>
<li>滚动到下方找到<code>GitHub Pages</code>模块, 在<code>Custom domain</code>, 输入你购买的域名, 点击Save保存</li>
</ul>
<h3 id="创建CNAME文件"><a href="#创建CNAME文件" class="headerlink" title="创建CNAME文件"></a>创建CNAME文件</h3><ul>
<li>在&#x2F;MyBlog&#x2F;themes&#x2F;landscape&#x2F;source目录下新建文件名为：CNAME文件，注意没有后缀名！直接将自己的域名写入</li>
<li><code>CNAME</code>一定要大写</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在终端cd到该目录下, 然后输入命令, 即可创建该文件</span></span><br><span class="line">touch <span class="built_in">CNAME</span></span><br></pre></td></tr></table></figure>

<ul>
<li>完成上述步骤后, 终端cd到MyBlog目录下执行如下命令重新部署：</li>
<li>最后, 等十分钟左右，刷新浏览器，用你自己域名访问下试试</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line"></span><br><span class="line">$ hexo g</span><br><span class="line"></span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure>

<blockquote>
<h4 id="至此也算终于大功告成了-感受一下-https-www-titanjun-top"><a href="#至此也算终于大功告成了-感受一下-https-www-titanjun-top" class="headerlink" title="至此也算终于大功告成了, 感受一下: https://www.titanjun.top"></a>至此也算终于大功告成了, 感受一下: <a href="https://www.titanjun.top/">https://www.titanjun.top</a></h4></blockquote>
]]></content>
      <categories>
        <category>Hexo博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>探索KVC和KVO的本质</title>
    <url>/post/478f6c1.html</url>
    <content><![CDATA[<ul>
<li>这篇文章主要介绍<code>KVO</code>和<code>KVC</code>, 机器底层是如何实现的</li>
<li><code>KVO</code>的全称是<code>Key-Value Observing</code>，俗称键值监听，可以用于监听某个对象属性值的改变</li>
<li><code>KVO</code>是使用获取其他对象的特定属性变化的通知机制,控制器层的绑定技术就是严重依赖键值观察获得模型层和控制器层的变化通知的</li>
<li>对于不依赖控制器层类的应用程序，键值观察提供了一种简化的方法来实现检查器并更新用户界面值</li>
<li><code>KVC</code>和<code>KVO</code>都是基于<code>OC</code>的动态特性和<code>Runtime</code>机制的</li>
</ul>
<span id="more"></span>


<h2 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h2><h3 id="添加监听"><a href="#添加监听" class="headerlink" title="添加监听"></a>添加监听</h3><p>如下所示, 我们为<code>person</code>对象添加一个监听</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.person = [[Person alloc]init];</span><br><span class="line">    <span class="keyword">self</span>.person.age = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 给person添加KVO监听</span></span><br><span class="line">    <span class="built_in">NSKeyValueObservingOptions</span> options = <span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span>;</span><br><span class="line">    [<span class="keyword">self</span>.person addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@&quot;age&quot;</span> options:options context:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="keyword">self</span>.person.age = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当监听的对象发生改变时就会调用</span></span><br><span class="line">- (<span class="type">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="type">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="type">id</span>&gt; *)change context:(<span class="type">void</span> *)context &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面添加监听的方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">addObserver:forKeyPath:options:context:</span><br><span class="line">监听方法各个参数的作用分别是什么</span><br><span class="line"></span><br><span class="line">[object addObserver: observer forKeyPath: <span class="string">@&quot;frame&quot;</span> options: <span class="number">0</span> context: <span class="literal">nil</span>];</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">object： 被观察者</span></span><br><span class="line"><span class="comment">observer： 观察者</span></span><br><span class="line"><span class="comment">KeyPath: 被观察者索贝观察的属性</span></span><br><span class="line"><span class="comment">options： 有四个值</span></span><br><span class="line"><span class="comment">    1、NSKeyValueObservingOptionNew 把更改之前的值提供给处理方法</span></span><br><span class="line"><span class="comment">    2、NSKeyValueObservingOptionOld 把更改之后的值提供给处理方法</span></span><br><span class="line"><span class="comment">    3、NSKeyValueObservingOptionInitial 把初始化的值提供给处理方法，一旦注  册，立马就会调用一次。通常它会带有新值，而不会带有旧值。</span></span><br><span class="line"><span class="comment">    4、NSKeyValueObservingOptionPrior 分2次调用。在值改变之前和值改变之后。</span></span><br><span class="line"><span class="comment">context：上下文，可以带一些参数，任何类型都可以</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>当被监听的对象的属性发生改变时就会调用下面的方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="type">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="type">id</span>&gt; *)change context:(<span class="type">void</span> *)context &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 1. keyPath: 被监听的属性</span></span><br><span class="line"><span class="comment"> 2. object: 被监听的对象</span></span><br><span class="line"><span class="comment"> 3. change 属性变化字典（新／旧）</span></span><br><span class="line"><span class="comment"> 4. 上下文，与监听的时候传递的一致</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="KVO的本质"><a href="#KVO的本质" class="headerlink" title="KVO的本质"></a>KVO的本质</h3><p>这里我们创建两个<code>pweson</code>对象, 但是只对<code>person1</code>实行监听</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.person1 = [[Person alloc]init];</span><br><span class="line"><span class="keyword">self</span>.person2 = [[Person alloc]init];</span><br><span class="line"><span class="keyword">self</span>.person1.age = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">self</span>.person2.age = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给person添加KVO监听</span></span><br><span class="line"><span class="built_in">NSKeyValueObservingOptions</span> options = <span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span>;</span><br><span class="line">[<span class="keyword">self</span>.person1 addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@&quot;age&quot;</span> options:options context:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>

<p>下面我们可以在<code>touchesBegan</code>方法中分别添加断点打印两个对象的<code>isa</code>, 如下</p>
<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/ios/kvo-isa.png" alt="image"></p>
<ul>
<li>从上面可以看出,未添加监听的<code>pweson2</code>对象的<code>isa</code>依然是<code>Person</code>, 但是添加<code>KVO</code>监听的<code>person1</code>的<code>isa</code>变成了<code>NSKVONotifying_Person</code></li>
<li><code>NSKVONotifying_Person</code>这个类是由<code>Runtime</code>在运行状态下动态创建的一个类, 是<code>Person</code>的一个子类</li>
<li>当我们对<code>age</code>属性进行赋值操作的时候, 其实调用的是<code>Person</code>类的<code>setAge</code>方法<ul>
<li><code>person1</code>通过<code>isa</code>找到其对应的类对象<code>Person</code>类, 并调用<code>Person</code>类的<code>setAge</code>方法</li>
<li><code>person2</code>通过<code>isa</code>找到其对应的类对象<code>NSKVONotifying_Person</code>类, 并调用<code>NSKVONotifying_Person</code>类的<code>setAge</code>方法</li>
<li>两个类的<code>setAge</code>方法的实现是不一样的, 后面会详解</li>
</ul>
</li>
<li><code>Person</code>和<code>NSKVONotifying_Person</code>对应的类对象如下所示</li>
</ul>
<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/ios/person_class.png" alt="image"></p>
<p>使用了<code>KVO</code>监听的对象动态生成的<code>NSKVONotifying_Person</code>类</p>
<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/ios/nskvo_class.png" alt="image"></p>
<p>实际上<code>NSKVONotifying_Person</code>类中的<code>setAge:</code>方法内部是调用了<code>Foundation</code>的<code>_NSSetIntValueAndNotify</code>方法, 有兴趣的可以反编译一下<code>Foundation.framwork</code>的源码, 查看其伪代码, 大致的可以推出内部方法的实现, 代码大致如下</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)setAge:(<span class="type">int</span>)age</span><br><span class="line">&#123;</span><br><span class="line">    _NSSetIntValueAndNotify();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line"><span class="type">void</span> _NSSetIntValueAndNotify()</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@&quot;age&quot;</span>];</span><br><span class="line">    [<span class="variable language_">super</span> setAge:age];</span><br><span class="line">    [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@&quot;age&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)didChangeValueForKey:(<span class="built_in">NSString</span> *)key</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 通知监听器，某某属性值发生了改变</span></span><br><span class="line">    [oberser observeValueForKeyPath:key ofObject:<span class="keyword">self</span> change:<span class="literal">nil</span> context:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>从上面的代码可以看出<code>_NSSetIntValueAndNotify</code>其实重写了<code>willChangeValueForKey</code>和<code>didChangeValueForKey</code>两个方法</li>
<li>而且监听属性值变化的是在<code>didChangeValueForKey</code>方法中实现的</li>
<li>下面我们就来验证一下上述代码</li>
</ul>
<blockquote>
<p>首先我们在<code>Person</code>类内部重写<code>willChangeValueForKey</code>和<code>didChangeValueForKey</code>两个方法, 在运行的过程中分别加断点进行调试, 如下</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)setAge:(<span class="type">int</span>)age&#123;</span><br><span class="line">    _age = age;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;setAge:&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)willChangeValueForKey:(<span class="built_in">NSString</span> *)key&#123;</span><br><span class="line">    [<span class="variable language_">super</span> willChangeValueForKey:key];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;willChangeValueForKey&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)didChangeValueForKey:(<span class="built_in">NSString</span> *)key&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;didChangeValueForKey - begin&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    [<span class="variable language_">super</span> didChangeValueForKey:key];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;didChangeValueForKey - end&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在如下代码中加断点</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当监听对象的属性值发生改变时，就会调用</span></span><br><span class="line">- (<span class="type">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="type">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="type">id</span>&gt; *)change context:(<span class="type">void</span> *)context</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;监听到%@的%@属性值改变了 - %@ - %@&quot;</span>, object, keyPath, change, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在输出结果中可以看到代码的执行顺序, 从下面的代码可以看出监听属性的改变其实是在<code>didChangeValueForKey</code>方法中实现的</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">setAge:</span><br><span class="line"></span><br><span class="line">didChangeValueForKey - begin</span><br><span class="line"></span><br><span class="line">监听到&lt;MJPerson: <span class="number">0x60000389b680</span>&gt;的age属性值改变了 </span><br><span class="line"></span><br><span class="line">didChangeValueForKey - end</span><br></pre></td></tr></table></figure>


<h2 id="KVC"><a href="#KVC" class="headerlink" title="KVC"></a>KVC</h2><ul>
<li><code>KVC</code>全称是<code>Key Value Coding</code>（键值编码），是一个基于<code>NSKeyValueCoding</code>非正式协议实现的机制，它可以直接通过<code>key</code>值对对象的属性进行存取操作，而不需通过调用明确的存取方法</li>
<li>这样就可以在运行时动态在访问和修改对象的属性，而不是在编译时确定</li>
<li><code>KVC</code>提供了一种间接访问属性方法或成员变量的机制，可以通过字符串来访问对象的的属性方法或成员变量</li>
<li>相关常见的API有</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通用的访问方法</span></span><br><span class="line">- (<span class="type">id</span>)valueForKey:(<span class="built_in">NSString</span> *)key; </span><br><span class="line">- (<span class="type">void</span>)setValue:(<span class="type">id</span>)value forKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line"><span class="comment">// 衍生的keyPath方法, 用来进行深层访问（key使用点语法)，也可单层访问：</span></span><br><span class="line">- (<span class="type">void</span>)setValue:(<span class="type">id</span>)value forKeyPath:(<span class="built_in">NSString</span> *)keyPath;</span><br><span class="line">- (<span class="type">id</span>)valueForKeyPath:(<span class="built_in">NSString</span> *)keyPath;</span><br></pre></td></tr></table></figure>

<p>通用访问方法使用示例</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line">Person *person = [[Person alloc] init];</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 赋值</span></span><br><span class="line">[person setValue:<span class="string">@&quot;titan&quot;</span> forKey:<span class="string">@&quot;name&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取值</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;-------name = %@&quot;</span>,person.name);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;-------name = %@&quot;</span>,[person valueForKey:<span class="string">@&quot;name&quot;</span>]);</span><br></pre></td></tr></table></figure>

<p><code>keyPath</code>方法使用示例</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意，这里要想使用keypath对adress的属性进行赋值，必须先给myself赋一个Address对象</span></span><br><span class="line">Address *myAddress = [[Address alloc] init];</span><br><span class="line">   </span><br><span class="line">[myself setValue:myAddress forKey:<span class="string">@&quot;address&quot;</span>];</span><br><span class="line">   </span><br><span class="line"><span class="comment">//KeyPath为多级访问</span></span><br><span class="line">[myself setValue:<span class="string">@&quot;rizhao&quot;</span> forKeyPath:<span class="string">@&quot;address.city&quot;</span>];</span><br><span class="line"> </span><br><span class="line"><span class="comment">//取值</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;-------city = %@&quot;</span>,myself.address.city);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;-------city = %@&quot;</span>,[myself valueForKeyPath:<span class="string">@&quot;address.city&quot;</span>]);</span><br></pre></td></tr></table></figure>


<h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><h4 id="setValue-forKey"><a href="#setValue-forKey" class="headerlink" title="setValue:forKey:"></a><code>setValue:forKey:</code></h4><p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/ios/setvalue.png" alt="image"></p>
<p><strong>0. 我们先创建一个<code>Person</code>类, 并在<code>Person.h</code>文件中声明一个<code>age</code>属性, 如下</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>下面我们在<code>ViewController.m</code>里面调用一下看看</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    Person *person = [[Person alloc]init];</span><br><span class="line">    <span class="comment">// 这种方式调用的是setAge方法</span></span><br><span class="line">    person.age = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 内部其实是调用的setAge方法</span></span><br><span class="line">    [person setValue:@<span class="number">20</span> forKey:<span class="string">@&quot;age&quot;</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%d&quot;</span>, person.age);</span><br><span class="line">    <span class="comment">// 打印结果20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果在<code>Person.h</code>文件中没有声明<code>age</code>属性,也就是在<code>Person.m</code>文件中没有默认生成的<code>setAge</code>和<code>getAge</code>方法</li>
<li>那么调用<code>setValue</code>方法对<code>age</code>存值的时候就会导致程序崩溃, 并会报出<code>setValue:forUndefinedKey:]</code>的错误</li>
<li>如同上图中所示, <code>setValue:forKey:</code>的原理实际上就是先按照<code>setAge:</code>和<code>_setAge:</code>顺序查找方法, 如果找到了对应方法中的一个, 则代码可以执行成功, 下面我们就一个个验证一下吧</li>
</ul>
<p><strong>1. 验证<code>setKey</code>和<code>_setKey</code>方法, 代码如下</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_BEGIN</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// .h文件中不添加age属性</span></span><br><span class="line"><span class="comment">//@property (assign, nonatomic) int age;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>在<code>.m</code>文件中分别添加一下两个方法, 侧其中一个方法的时候, 可以先注释掉另外一个方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;Person.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)setAge:(<span class="type">int</span>)age &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;setAge--&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)_setAge:(<span class="type">int</span>)age &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;_setAge--&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>然后在<code>ViewController.m</code>调用<code>setValue</code>方法的时候, 可以看到打印对应的输出, 当上述两个方法同事存在的时候, 则会默认执行<code>setAge</code>方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[person setValue:@<span class="number">20</span> forKey:<span class="string">@&quot;age&quot;</span>];</span><br></pre></td></tr></table></figure>


<p><strong>2. 如果没有<code>setKey:</code>和<code>_setKey:</code>两个方法, 则会继续查找<code>Person.m</code>文件中是否有<code>accessInstanceVariablesDirectly</code>方法, 如果没有程序会奔溃</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;Person.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="type">BOOL</span>)accessInstanceVariablesDirectly &#123;</span><br><span class="line">    <span class="comment">// 默认返回值是YES</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>accessInstanceVariablesDirectly</code>方法默认是返回<code>YES</code>的, 如果<code>return NO</code>, 则程序同样会崩溃, 并抛出<code>NSUnknownKeyException</code>异常</li>
<li>在<code>return YES</code>的情况下, 会按照顺序查找<code>_key、_isKey、key、isKey</code>等成员变量, 如果找不到依然会抛出<code>NSUnknownKeyException</code>异常</li>
<li>下面在<code>Person.h</code>文件中, 分别声明四个变量</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">@public</span></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">int</span> isAge;</span><br><span class="line">    <span class="type">int</span> _age;</span><br><span class="line">    <span class="type">int</span> _isAge;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>在<code>ViewController.m</code>中添加如下代码, 执行结果如下所示</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    Person *person = [[Person alloc]init];</span><br><span class="line"></span><br><span class="line">    [person setValue:@<span class="number">20</span> forKey:<span class="string">@&quot;age&quot;</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;-----------&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/ios/setvalueage.png" alt="image"></p>
<ul>
<li>当我们在<code>Person.h</code>中声明<code>age、isAge、_age、_isAge</code>四个变量的时候, 上述代码会默认赋值给<code>_age</code>变量</li>
<li>当我们不声明<code>_age</code>属性时, 则会默认赋值给<code>_isAge</code>属性, 以此类推依次是<code>age</code>和<code>isAge</code>变量, 有兴趣的可以亲自测试一番</li>
</ul>
<h4 id="valueForKey"><a href="#valueForKey" class="headerlink" title="valueForKey"></a><code>valueForKey</code></h4><p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/ios/getvalue.png" alt="image"></p>
<p><code>valueForKey</code>通过<code>key</code>进行取值的时候, 取值流程和<code>setValue</code>类似, 途中也比较清晰, 这里就不在赘述了</p>
<hr>
]]></content>
      <categories>
        <category>OC底层原理</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈OC中Block的本质</title>
    <url>/post/2080e3a.html</url>
    <content><![CDATA[<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/ios/block-ios.jpeg" alt="Block"></p>
<span id="more"></span>



<h2 id="Block简介"><a href="#Block简介" class="headerlink" title="Block简介"></a><code>Block</code>简介</h2><ul>
<li><code>block</code>是将函数及其执行上下文封装起来的一个对象</li>
<li>在<code>block</code>实现的内部，有很多变量，因为<code>block</code>也是一个对象</li>
<li>其中包含了诸如<code>isa</code>指针，<code>imp</code>指针等对象变量，还有储存其截获变量的对象等</li>
</ul>
<h3 id="定义和使用"><a href="#定义和使用" class="headerlink" title="定义和使用"></a>定义和使用</h3><p><code>block</code>根据有无参数和有无返回值有以下几种简单使用方式</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无参数无返回值</span></span><br><span class="line"><span class="type">void</span> (^ BlockOne)(<span class="type">void</span>) = ^(<span class="type">void</span>)&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;无参数，无返回值&quot;</span>);  </span><br><span class="line">&#125;;  </span><br><span class="line">BlockOne();<span class="comment">//block的调用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有参数无返回值</span></span><br><span class="line"><span class="type">void</span> (^BlockTwo)(<span class="type">int</span> a) = ^(<span class="type">int</span> a)&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;有参数，无返回值, 参数 = %d，&quot;</span>,a);</span><br><span class="line">&#125;;  </span><br><span class="line">BlockTwo(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有参数有返回值</span></span><br><span class="line"><span class="type">int</span> (^BlockThree)(<span class="type">int</span>,<span class="type">int</span>) = ^(<span class="type">int</span> a,<span class="type">int</span> b)&#123;    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;有参数，有返回值&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> a + b; </span><br><span class="line">&#125;;  </span><br><span class="line">BlockThree(<span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无参数有返回值</span></span><br><span class="line"><span class="type">int</span>(^BlockFour)(<span class="type">void</span>) = ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;无参数，有返回值&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">&#125;;</span><br><span class="line">BlockFour();</span><br></pre></td></tr></table></figure>

<p>可是以上四种<code>block</code>底层又是如何实现的呢? 其本质到底如何? 接下来我们一起探讨一下</p>
<h3 id="Block的本质"><a href="#Block的本质" class="headerlink" title="Block的本质"></a>Block的本质</h3><ul>
<li>为了方便我们这里新建一个<code>Command Line Tool</code>项目, 在<code>main</code>函数中执行上述中一个<code>block</code></li>
<li>探索<code>Block</code>的本质, 就要查看其源码, 这里我们使用下面命令把<code>main.m</code>文件生成与其对应的<code>c++</code>代码文件</li>
<li>在<code>main.m</code>文件所在的目录下, 执行如下命令, 会生成一个<code>main.cpp</code>文件</li>
<li>把<code>main.cpp</code>文件添加到项目中, 并使其不参与项目的编译, 下面我们就具体看一下<code>block</code>的底层到底是如何实现的</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m</span><br></pre></td></tr></table></figure>

<p>打开<code>main.cpp</code>文件, 找到文件最底部, 可以看到<code>block</code>的相关源码如下</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// block的结构体</span></span><br><span class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</span><br><span class="line">  <span class="comment">// 结构体的成员变量</span></span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 构造函数</span></span><br><span class="line">  __main_block_impl_0(<span class="type">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="type">int</span> flags=<span class="number">0</span>) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装了block执行逻辑的函数</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_ty_804897ld2zg4pfcgx2p4wqh80000gn_T_main_11c959_mi_0);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0)&#125;;</span><br><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义block变量</span></span><br><span class="line">        <span class="type">void</span> (* BlockOne)(<span class="type">void</span>) = ((<span class="type">void</span> (*)())&amp;__main_block_impl_0((<span class="type">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行block内部的源码</span></span><br><span class="line">        ((<span class="type">void</span> (*)(__block_impl *))((__block_impl *)BlockOne)-&gt;FuncPtr)((__block_impl *)BlockOne);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> IMAGE_INFO &#123; <span class="type">unsigned</span> version; <span class="type">unsigned</span> flag; &#125; _OBJC_IMAGE_INFO = &#123; <span class="number">0</span>, <span class="number">2</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>其中<code>block</code>的声明和调用的对应关系如下</p>
<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/ios/block-bottom.png" alt="image"></p>
<p>删除其中的强制转换的相关代码后</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义block变量</span></span><br><span class="line"><span class="type">void</span> (* BlockOne)(<span class="type">void</span>) = &amp;__main_block_impl_0(</span><br><span class="line">                                                (<span class="type">void</span> *)__main_block_func_0,</span><br><span class="line">                                                &amp;__main_block_desc_0_DATA</span><br><span class="line">                                            );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行block内部的源码</span></span><br><span class="line">BlockOne-&gt;FuncPtr(BlockOne);</span><br></pre></td></tr></table></figure>

<p>上述代码中<code>__main_block_impl_0</code>函数接受两个参数, 并有一个返回值, 最后把函数的地址返回给<code>BlockOne</code>, 下面找到<code>__main_block_impl_0</code>的定义</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 结构体</span></span><br><span class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// c++中的构造函数, 类似于OC中的init方法</span></span><br><span class="line">  <span class="comment">// flags: 默认参数, 调用时可不传</span></span><br><span class="line">  __main_block_impl_0(<span class="type">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="type">int</span> flags=<span class="number">0</span>) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>__main_block_impl_0</code>函数中的第一个参数<code>__main_block_func_0</code>赋值给了<code>fp</code>, <code>fp</code>又赋值给了<code>impl.FuncPtr</code>, 也就意味着<code>impl.FuncPtr</code>中存储的就是我们要执行的<code>__main_block_func_0</code>函数的地址</li>
<li><code>Block</code>结构体中的<code>isa</code>指向了<code>_NSConcreteStackBlock</code>, 说明<code>Block</code>是一个<code>_NSConcreteStackBlock</code>类型, 具体后面会详解</li>
<li><code>__main_block_impl_0</code>函数中的第二个参数<code>__main_block_desc_0_DATA</code></li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0)&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>其中<code>reserved</code>赋值为0</li>
<li><code>Block_size</code>被赋值为<code>sizeof(struct __main_block_impl_0)</code>, 即为<code>__main_block_impl_0</code>这个结构体占用内存的大小</li>
<li><code>__main_block_impl_0</code>的第二个参数, 接受的即为<code>__main_block_desc_0</code>结构体的变量(<code>__main_block_desc_0_DATA</code>)的地址</li>
</ul>
<h2 id="Block变量捕获"><a href="#Block变量捕获" class="headerlink" title="Block变量捕获"></a>Block变量捕获</h2><p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/ios/block_var.png" alt="image"></p>
<ul>
<li>局部变量分为两大类: <code>auto</code>和<code>static</code><ul>
<li><code>auto</code>: 自动变量, 离开作用域就会自动销毁, 默认情况下定义的局部变量都是<code>auto</code>修饰的变量, 系统都会默认给添加一个<code>auto</code></li>
<li><code>auto</code>不能修饰全局变量, 会报错</li>
<li><code>static</code>作用域内修饰局部变量, 可以修饰全局变量</li>
</ul>
</li>
<li>全局变量</li>
</ul>
<h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><h4 id="auto变量捕获"><a href="#auto变量捕获" class="headerlink" title="auto变量捕获"></a>auto变量捕获</h4><blockquote>
<p><code>auto</code>局部变量在<code>Block</code>中是值传递</p>
</blockquote>
<p>下述代码输出值为多少？</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> age = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> (^BlockTwo)(<span class="type">void</span>) = ^(<span class="type">void</span>)&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;age = %d，&quot;</span>,age);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">age = <span class="number">13</span>;</span><br><span class="line">BlockTwo();</span><br><span class="line"><span class="comment">// 输出10</span></span><br></pre></td></tr></table></figure>

<p>输出值为什么是10而不是13呢? 我们还是生成<code>main.cpp</code>代码看一下吧, 相关核心代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  // 这里多了一个age属性</span><br><span class="line">  int age;</span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _age, int flags=0) : age(_age) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  int age = __cself-&gt;age; // bound by copy</span><br><span class="line"></span><br><span class="line">            NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_ty_804897ld2zg4pfcgx2p4wqh80000gn_T_main_80d62b_mi_0,age);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">static struct __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool;  </span><br><span class="line">        // 定义属性</span><br><span class="line">        int age = 10;</span><br><span class="line"></span><br><span class="line">        // block的定义</span><br><span class="line">        void (*BlockTwo)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, age));</span><br><span class="line">        </span><br><span class="line">        // 改变属性值</span><br><span class="line">        age = 13;</span><br><span class="line">        // 调用block</span><br><span class="line">        ((void (*)(__block_impl *))((__block_impl *)BlockTwo)-&gt;FuncPtr)((__block_impl *)BlockTwo);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">static struct IMAGE_INFO &#123; unsigned version; unsigned flag; &#125; _OBJC_IMAGE_INFO = &#123; 0, 2 &#125;;</span><br></pre></td></tr></table></figure>

<p>那么下面我们一步步看一下, 吧一些强制转换的代码去掉之后</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> age = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> (*BlockTwo)(<span class="type">void</span>) = &amp;__main_block_impl_0(</span><br><span class="line">                                            __main_block_func_0,</span><br><span class="line">                                            &amp;__main_block_desc_0_DATA,</span><br><span class="line">                                            age</span><br><span class="line">                                            );</span><br><span class="line"></span><br><span class="line">age = <span class="number">13</span>;</span><br><span class="line">BlockTwo-&gt;FuncPtr(BlockTwo);</span><br></pre></td></tr></table></figure>

<p>在上面的<code>__main_block_impl_0</code>函数里面相比于之前的, 多了一个<code>age</code>参数</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</span><br><span class="line">  <span class="comment">// 新的属性age</span></span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">  <span class="comment">// 构造函数, 多了_age参数</span></span><br><span class="line">  __main_block_impl_0(<span class="type">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="type">int</span> _age, <span class="type">int</span> flags=<span class="number">0</span>) : age(_age) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>上面的构造方法<code>__main_block_impl_0</code>中, 多了一个<code>_age</code>参数</li>
<li>同时后面多了一条<code>age(_age)</code>语句, 在<code>c++</code>中, <code>age(_age)</code>相当于<code>age = _age</code>, 即给<code>age</code>属性赋值, 存储构造函数传过来的<code>age</code>属性的值</li>
<li>所以在后面调用<code>block</code>的时候, <code>block</code>对应的结构体所存储的<code>age</code>属性的值仍然是10, 并没有被更新</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 及时这里重新对age进行了赋值</span></span><br><span class="line">age = <span class="number">13</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里调用BlockTwo的时候, 结构体重的age属性的值并没有被更新</span></span><br><span class="line">BlockTwo-&gt;FuncPtr(BlockTwo);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后在执行block内部逻辑的时候, </span></span><br><span class="line"><span class="keyword">static</span> <span class="type">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</span><br><span class="line">    <span class="type">int</span> age = __cself-&gt;age; <span class="comment">// bound by copy</span></span><br><span class="line">    <span class="comment">// 这里的age, 仍然是block结构体中的age, 值并没有改变, 所以输出结果还是10</span></span><br><span class="line">    <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_ty_804897ld2zg4pfcgx2p4wqh80000gn_T_main_80d62b_mi_0,age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="static变量捕获"><a href="#static变量捕获" class="headerlink" title="static变量捕获"></a>static变量捕获</h4><blockquote>
<p><code>static</code>局部变量在<code>Block</code>中是指针传递, 看一下下面代码的输出情况</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">auto <span class="type">int</span> age = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> weight = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> (^BlockTwo)(<span class="type">void</span>) = ^(<span class="type">void</span>)&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;age = %d, weight = %d，&quot;</span>,age, weight);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">age = <span class="number">13</span>;</span><br><span class="line">weight = <span class="number">23</span>;</span><br><span class="line">BlockTwo();</span><br></pre></td></tr></table></figure>

<ul>
<li>上面代码输出结果: <code>age = 10, weight = 23</code></li>
<li>重新赋值后<code>age</code>的结果不变, 之前已经说过了</li>
<li>可是<code>weight</code>的结果却是赋值后的结果, 至于为什么, 请继续向下看吧…</li>
<li>我们还是生成<code>main.cpp</code>代码看一下吧, 相关核心代码如下</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">  <span class="type">int</span> *weight;</span><br><span class="line">  __main_block_impl_0(<span class="type">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="type">int</span> _age, <span class="type">int</span> *_weight, <span class="type">int</span> flags=<span class="number">0</span>) : age(_age), weight(_weight) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="type">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  <span class="type">int</span> age = __cself-&gt;age; <span class="comment">// bound by copy</span></span><br><span class="line">  <span class="type">int</span> *weight = __cself-&gt;weight; <span class="comment">// bound by copy</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_ty_804897ld2zg4pfcgx2p4wqh80000gn_T_main_282a93_mi_0,age, (*weight));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0)&#125;;</span><br><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line">        auto <span class="type">int</span> age = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="type">int</span> weight = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">void</span> (*BlockTwo)(<span class="type">void</span>) = ((<span class="type">void</span> (*)())&amp;__main_block_impl_0((<span class="type">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, age, &amp;weight));</span><br><span class="line"></span><br><span class="line">        age = <span class="number">13</span>;</span><br><span class="line">        weight = <span class="number">23</span>;</span><br><span class="line">        ((<span class="type">void</span> (*)(__block_impl *))((__block_impl *)BlockTwo)-&gt;FuncPtr)((__block_impl *)BlockTwo);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> IMAGE_INFO &#123; <span class="type">unsigned</span> version; <span class="type">unsigned</span> flag; &#125; _OBJC_IMAGE_INFO = &#123; <span class="number">0</span>, <span class="number">2</span> &#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>从上面代码可以看到<code>__main_block_impl_0</code>类中多了两个成员变量<code>age</code>和<code>weight</code>, 说明两个变量我们都可以捕获到</li>
<li>不同的是, 同样都是<code>int</code>变量, 使用不同的修饰词修饰, <code>__main_block_impl_0</code>类中也是不同的</li>
<li><code>static</code>修饰的变量<code>weight</code>在<code>block</code>中存储的是<code>weight</code>的地址, 在后面的<code>block</code>函数中我们使用的也是其地址</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="type">int</span> *weight;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &amp;weight</span></span><br><span class="line"><span class="type">void</span> (*BlockTwo)(<span class="type">void</span>) = &amp;__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA, age, &amp;weight);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面构造方法中, 同样(weight(_weight)方法之前讲过)将传过来的weight的地址赋值给了 (int *weight;)</span></span><br><span class="line"> __main_block_impl_0(<span class="type">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="type">int</span> _age, <span class="type">int</span> *_weight, <span class="type">int</span> flags=<span class="number">0</span>) : age(_age), weight(_weight) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>也就是说上面的构造函数中<ul>
<li><code>age</code>保存的是一个准确的值</li>
<li><code>weight</code>保存的是<code>weight</code>所在的内存地址</li>
</ul>
</li>
<li>所以在最后调用<code>block</code>内部逻辑的时候</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</span><br><span class="line">    <span class="type">int</span> age = __cself-&gt;age; <span class="comment">// bound by copy</span></span><br><span class="line">    <span class="type">int</span> *weight = __cself-&gt;weight; <span class="comment">// bound by copy</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// (*weight)相当于从weight的内存地址中取值, 在执行操作</span></span><br><span class="line">    <span class="comment">// 然而weight内存中的值已经在后面赋值的时候被更新了, 所以这里取出的值是赋值后的</span></span><br><span class="line">    <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_ty_804897ld2zg4pfcgx2p4wqh80000gn_T_main_282a93_mi_0,age, (*weight));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>也就是说, 同样是局部变量</li>
<li><code>auto</code>修饰的变量在<code>block</code>中存储的是变量的值(值传递)</li>
<li><code>static</code>修饰的变量在<code>block</code>中存储的是变量的内存地址(地址传递)</li>
</ul>
<h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> age = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> weight = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="type">void</span> (^BlockTwo)(<span class="type">void</span>) = ^(<span class="type">void</span>)&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;age = %d, weight = %d，&quot;</span>,age, weight);</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        age = <span class="number">13</span>;</span><br><span class="line">        weight = <span class="number">23</span>;</span><br><span class="line">        BlockTwo();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码的输出结果, 毫无疑问是13和23, 相关<code>c++</code>代码如下</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> age = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> weight = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</span><br><span class="line">  __main_block_impl_0(<span class="type">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="type">int</span> flags=<span class="number">0</span>) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="type">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 封装了block执行逻辑的函数</span></span><br><span class="line">            <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_ty_804897ld2zg4pfcgx2p4wqh80000gn_T_main_0ee0bb_mi_0,age, weight);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0)&#125;;</span><br><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义block变量</span></span><br><span class="line">        <span class="type">void</span> (*BlockTwo)(<span class="type">void</span>) = ((<span class="type">void</span> (*)())&amp;__main_block_impl_0((<span class="type">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</span><br><span class="line"></span><br><span class="line">        age = <span class="number">13</span>;</span><br><span class="line">        weight = <span class="number">23</span>;</span><br><span class="line">        ((<span class="type">void</span> (*)(__block_impl *))((__block_impl *)BlockTwo)-&gt;FuncPtr)((__block_impl *)BlockTwo);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> IMAGE_INFO &#123; <span class="type">unsigned</span> version; <span class="type">unsigned</span> flag; &#125; _OBJC_IMAGE_INFO = &#123; <span class="number">0</span>, <span class="number">2</span> &#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>从上面代码可以看出<code>__main_block_impl_0</code>结构体重并没有捕获到<code>age</code>和<code>weight</code>的成员变量</li>
<li>同样在定义<code>block</code>变量的时候中也不需要传入<code>age</code>和<code>weight</code>的变量</li>
<li>在封装了<code>block</code>执行逻辑的函数中, 就可以直接使用全局的变量即可</li>
</ul>
<h2 id="Block的类型"><a href="#Block的类型" class="headerlink" title="Block的类型"></a>Block的类型</h2><h3 id="Block的三种类型"><a href="#Block的三种类型" class="headerlink" title="Block的三种类型"></a>Block的三种类型</h3><ul>
<li>在之前的<code>C++</code>源码中, <code>__main_block_impl_0</code>结构体中<code>isa</code>指向的类型是<code>_NSConcreteStackBlock</code></li>
<li>下面就具体看一下, <code>Block</code>的只要类型有那些</li>
<li>先看一下下面这部分代码的输出结果</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void (^block)(void) = ^(void)&#123;</span><br><span class="line">    NSLog(@&quot;Hello World&quot;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;%@&quot;, [block class]);</span><br><span class="line">NSLog(@&quot;%@&quot;, [[block class] superclass]);</span><br><span class="line">NSLog(@&quot;%@&quot;, [[[block class] superclass] superclass]);</span><br><span class="line">NSLog(@&quot;%@&quot;, [[[[block class] superclass] superclass] superclass]);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> 2019-06-24 15:46:32.506386+0800 Block[3307:499032] __NSGlobalBlock__</span><br><span class="line"> 2019-06-24 15:46:32.506578+0800 Block[3307:499032] __NSGlobalBlock</span><br><span class="line"> 2019-06-24 15:46:32.506593+0800 Block[3307:499032] NSBlock</span><br><span class="line"> 2019-06-24 15:46:32.506605+0800 Block[3307:499032] NSObject</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

<ul>
<li><code>block</code>的类型<code>NSBlock</code>最终也是继承自<code>NSObject</code></li>
<li>这也可以解释为什么<code>block</code>的结构体<code>__main_block_impl_0</code>中会有一个<code>isa</code>指针了</li>
<li>此外, <code>block</code>共有三种类型, 可以通过调用<code>class</code>方法或者<code>isa</code>指针查看具体类型, 最终都是继承自<code>NSBlock</code>类型<ul>
<li><code>__NSGlobalBlock__</code>或者<code>_NSConcreteGlobalBlock</code></li>
<li><code>__NSStackBlock__</code>或者<code>_NSConcreteStackBlock</code></li>
<li><code>__NSMallocBlock__</code>或者<code>_NSConcreteMallocBlock</code></li>
</ul>
</li>
</ul>
<h3 id="block在内存中的分配"><a href="#block在内存中的分配" class="headerlink" title="block在内存中的分配"></a>block在内存中的分配</h3><ul>
<li><code>_NSConcreteGlobalBlock</code>: 在数据区域</li>
<li><code>_NSConcreteStackBlock</code>: 在栈区域</li>
<li><code>_NSConcreteMallocBlock</code>: 在堆区域</li>
</ul>
<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/ios/application.png" alt="内存分配图"></p>
<ul>
<li>应用程序的内存分配图如上图所示, 自上而下依次为内存的低地址–&gt;内存的高地址</li>
<li>程序区域:  代码段, 用于存放代码</li>
<li>数据区域: 数据段, 用于存放全局变量</li>
<li>堆: 动态分配内存，需要程序员自己申请，程序员自己管理, 通常是<code>alloc</code>或者<code>malloc</code>方式申请的内存</li>
<li>栈: 用于存放局部变量, 系统会自动分配内存, 自动销毁内存</li>
</ul>
<h3 id="区分不同的block类型"><a href="#区分不同的block类型" class="headerlink" title="区分不同的block类型"></a>区分不同的block类型</h3><ul>
<li>上面提到, 一共有三种<code>block</code>类型, 且不同的<code>block</code>类型存放在内存的不同位置</li>
<li>但是如何区分所定义的<code>block</code><br>到底是哪一种类型呢<br>看看下面代码的执行情况, 运行环境实在<code>MRC</code>环境下</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> age = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> weight = <span class="number">21</span>;</span><br><span class="line">        <span class="type">void</span> (^block1)(<span class="type">void</span>) = ^(<span class="type">void</span>)&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;Hello World&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">void</span> (^block2)(<span class="type">void</span>) = ^(<span class="type">void</span>)&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;age  =  %d&quot;</span>, age);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">void</span> (^block3)(<span class="type">void</span>) = ^(<span class="type">void</span>)&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;age  =  %d&quot;</span>, weight);</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;block1 = %@&quot;</span>, [block1 <span class="keyword">class</span>]);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;block2 = %@&quot;</span>, [block2 <span class="keyword">class</span>]);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;block3 = %@&quot;</span>, [block3 <span class="keyword">class</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         2019-06-24 21:13:14.555206+0800 Block[30548:1189724] block1 = __NSGlobalBlock__</span></span><br><span class="line"><span class="comment">         2019-06-24 21:13:14.555444+0800 Block[30548:1189724] block2 = __NSGlobalBlock__</span></span><br><span class="line"><span class="comment">         2019-06-24 21:13:14.555465+0800 Block[30548:1189724] block3 = __NSStackBlock__</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>针对各种不同的<code>block</code>总结如下</p>
<table>
<thead>
<tr>
<th><code>block</code>类型</th>
<th>环境</th>
</tr>
</thead>
<tbody><tr>
<td><code>__NSGlobalBlock__</code></td>
<td>没有访问auto变量</td>
</tr>
<tr>
<td><code>__NSStackBlock__</code></td>
<td>访问了auto变量</td>
</tr>
<tr>
<td><code>__NSMallocBlock__</code></td>
<td><code>__NSStackBlock__</code>调用了copy</td>
</tr>
</tbody></table>
<ul>
<li>由于<code>__NSMallocBlock__</code>是放在堆区域</li>
<li>要想创建出<code>__NSMallocBlock__</code>类型的<code>block</code>, 我们可以调用<code>copy</code>方法</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> (^block3)(<span class="type">void</span>) = ^(<span class="type">void</span>)&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;age  =  %d&quot;</span>, weight);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;block3 = %@&quot;</span>, [block3 <span class="keyword">class</span>]);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;block3 = %@&quot;</span>, [[block3 <span class="keyword">copy</span>] <span class="keyword">class</span>]);</span><br><span class="line"><span class="comment">/* 输出分别是: </span></span><br><span class="line"><span class="comment">block3 = __NSStackBlock__</span></span><br><span class="line"><span class="comment">block3 = __NSMallocBlock__</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>从上面的代码中我们可以明显看到, <code>__NSStackBlock__</code>类型的<code>block</code>调用<code>copy</code>方法后, 就会变成<code>__NSMallocBlock__</code>类型的<code>block</code></li>
<li>相当于生成的<code>block</code>是在堆区域的</li>
<li>那么另外两种类型调用<code>copy</code>方法后,又会如何? 下面一起来看一下吧</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> weight = <span class="number">21</span>;</span><br><span class="line"><span class="type">void</span> (^block1)(<span class="type">void</span>) = ^(<span class="type">void</span>)&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;Hello World&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> (^block3)(<span class="type">void</span>) = ^(<span class="type">void</span>)&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;age  =  %d&quot;</span>, weight);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;block1 = %@&quot;</span>, [block1 <span class="keyword">class</span>]);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;block1 = %@&quot;</span>, [[block1 <span class="keyword">copy</span>] <span class="keyword">class</span>]);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;block3 = %@&quot;</span>, [block3 <span class="keyword">class</span>]);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;block3 = %@&quot;</span>, [[block3 <span class="keyword">copy</span>] <span class="keyword">class</span>]);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;block3 = %@&quot;</span>, [[[block3 <span class="keyword">copy</span>] <span class="keyword">copy</span>] <span class="keyword">class</span>]);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> __NSGlobalBlock__</span></span><br><span class="line"><span class="comment"> __NSGlobalBlock__</span></span><br><span class="line"><span class="comment"> __NSStackBlock__</span></span><br><span class="line"><span class="comment"> __NSMallocBlock__</span></span><br><span class="line"><span class="comment"> __NSMallocBlock__</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<ul>
<li>从上面的代码可以看到, 只有<code>__NSStackBlock__</code>类型的<code>block</code>调用<code>copy</code>之后才会变成<code>__NSMallocBlock__</code>类型, 其他的都是原类型</li>
<li>主要也是<code>__NSStackBlock__</code>类型的作用域是在栈中, 作用域中的局部变量会在函数结束时自动销毁</li>
<li><code>__NSStackBlock__</code>调用<code>copy</code>操作后，分配的内存地址相当于从栈复制到堆；副本存储位置是堆</li>
<li>其他的则可参考下面表格</li>
</ul>
<table>
<thead>
<tr>
<th>Block类</th>
<th>副本源的配置存储域</th>
<th>复制效果</th>
</tr>
</thead>
<tbody><tr>
<td><code>__NSStackBlock__</code></td>
<td>栈</td>
<td>从栈复制到堆</td>
</tr>
<tr>
<td><code>__NSGlobalBlock__</code></td>
<td>程序的数据区域</td>
<td>什么也不做</td>
</tr>
<tr>
<td><code>__NSMallocBlock__</code></td>
<td>堆</td>
<td>引用计数增加</td>
</tr>
</tbody></table>
<ul>
<li>在<code>ARC</code>环境下, 编译器会根据情况自动将站上的<code>block</code>复制到堆上, 类似以下情况<ul>
<li><code>block</code>作为函数返回值时</li>
<li>将<code>block</code>赋值给<code>__strong</code>修饰的指针时</li>
<li><code>block</code>作为<code>GCD</code>的方法参数时</li>
</ul>
</li>
</ul>
<h2 id="block修饰符"><a href="#block修饰符" class="headerlink" title="__block修饰符"></a>__block修饰符</h2><p><strong>Question: 定义一个auto修饰的局部变量, 并在<code>block</code>中修改该变量的值, 能否修改成功呢?</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">auto <span class="type">int</span> width = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> height = <span class="number">20</span>;</span><br><span class="line"><span class="type">void</span> (^block)(<span class="type">void</span>) = ^(<span class="type">void</span>)&#123;</span><br><span class="line">    <span class="comment">// 事实证明, 在Xcode中这行代码是报错的</span></span><br><span class="line">    width = <span class="number">22</span>;</span><br><span class="line">    <span class="comment">// 但是static修饰的变量, 却是可以赋值, 不会报错</span></span><br><span class="line">    height = <span class="number">22</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;width = %d, height = %d&quot;</span>, width, height);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">block();</span><br><span class="line"></span><br><span class="line"><span class="comment">// width = 10, height = 22</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在之前提到, 在<code>block</code>中, <code>auto</code>修饰的变量是值传递</li>
<li><code>static</code>修饰的变量是指针传递, 所以在上述代码中, <code>block</code>存储的只是<code>height</code>的内存地址</li>
<li>同样<code>auto</code>变量实在<code>main</code>函数中定义的, 而<code>block</code>的执行逻辑是在<code>__main_block_func_0</code>结构体的方法中执行的, 相当于局部变量不能跨函数访问</li>
<li>至于<code>static</code>修饰的变量为什么可以修改?<ul>
<li>在<code>__main_block_impl_0</code>结构体中<code>height</code>存储的是其内存地址, 在其他函数或者结构体中访问和改变<code>height</code>的方式都是通过其真真访问的</li>
<li>类似赋值方式: <code>(*height) = 22;</code></li>
<li>取值方式: <code>(*height)</code></li>
</ul>
</li>
</ul>
<h3 id="block修饰auto变量"><a href="#block修饰auto变量" class="headerlink" title="__block修饰auto变量"></a>__block修饰auto变量</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">__block auto <span class="type">int</span> width = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> (^block)(<span class="type">void</span>) = ^(<span class="type">void</span>) &#123;</span><br><span class="line">    <span class="comment">// 很明显, 这里就可以修改了</span></span><br><span class="line">    width = <span class="number">12</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;width = %d&quot;</span>, width);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">block();</span><br><span class="line"><span class="comment">// width = 12</span></span><br></pre></td></tr></table></figure>

<p><strong>为什么上面的代码就可以修改变量了呢, 这是为什么呢…..请看源码</strong></p>
<p>下面是生成的<code>block</code>的结构体</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 这里的width被包装成了一个__Block_byref_width_0对象</span></span><br><span class="line">  __Block_byref_width_0 *width; <span class="comment">// by ref</span></span><br><span class="line">  <span class="comment">// 这里可以对比一下之前的未被__block修饰的int变量</span></span><br><span class="line">  <span class="comment">// int width;</span></span><br><span class="line">  </span><br><span class="line">  __main_block_impl_0(<span class="type">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, __Block_byref_width_0 *_width, <span class="type">int</span> flags=<span class="number">0</span>) : width(_width-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>上述代码看到<code>__block</code>可以用于解决<code>block</code>内部无法修改<code>auto</code>修饰的变量值得问题</li>
<li>但是<code>__block</code>不能修饰全局变量和<code>static</code>修饰的静态变量(同样也不需要, 因为在<code>block</code>内部可以直接修改)</li>
<li>经过<code>__block</code>修饰的变量会被包装成一个对象(<code>__Block_byref_width_0</code>)</li>
<li>下面是<code>width</code>被包装后的对象的结构体, 在结构体内, 会有一个<code>width</code>成员变量</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> __Block_byref_width_0 &#123;</span><br><span class="line">  <span class="type">void</span> *__isa;</span><br><span class="line">  <span class="comment">// 一个指向自己本身的成员变量</span></span><br><span class="line">  __Block_byref_width_0 *__forwarding;</span><br><span class="line">  <span class="type">int</span> __flags;</span><br><span class="line">  <span class="type">int</span> __size;</span><br><span class="line">  <span class="comment">// 外部定义的auto变量</span></span><br><span class="line">  <span class="type">int</span> width;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>下面我们先看一下, <code>auto</code>和<code>block</code>的定义和调用</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line">        <span class="comment">// __block auto int width = 10;</span></span><br><span class="line">        auto __Block_byref_width_0 width = &#123;</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            &amp;width,</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            <span class="keyword">sizeof</span>(__Block_byref_width_0),</span><br><span class="line">            <span class="number">10</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">void</span> (*block)(<span class="type">void</span>) = &amp;__main_block_impl_0(</span><br><span class="line">            __main_block_func_0,</span><br><span class="line">            &amp;__main_block_desc_0_DATA,</span><br><span class="line">            &amp;width,</span><br><span class="line">            <span class="number">570425344</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        block-&gt;FuncPtr(block);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>可以看到在定义的<code>__Block_byref_width_0</code>类型的<code>width</code>中的每一个参数分别赋值给了<code>__Block_byref_width_0</code>结构体中的每一个成员变量</li>
<li>而在<code>block</code>内部重新对<code>width</code>重新赋值的逻辑中</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</span><br><span class="line">    __Block_byref_width_0 *width = __cself-&gt;width; <span class="comment">// bound by ref</span></span><br><span class="line"></span><br><span class="line">    (width-&gt;__forwarding-&gt;width) = <span class="number">12</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_ty_804897ld2zg4pfcgx2p4wqh80000gn_T_main_9241d5_mi_0, (width-&gt;__forwarding-&gt;width));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>上面代码中的<code>width</code>是一个<code>__Block_byref_width_0</code>类型的变量</li>
<li><code>width</code>对象通过找到内部的<code>__forwarding</code>成员变量</li>
<li>在<code>__Block_byref_width_0</code>结构体中<code>__forwarding</code>是一个指向自己本身的成员变量</li>
<li>所以最后再通过<code>__forwarding</code>找到<code>__Block_byref_width_0</code>的成员变量<code>width</code>, 在进行重新赋值</li>
<li>在<code>NSLog</code>中也是通过这种逻辑获取<code>width</code>的值</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>OC底层原理</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>Block</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈Swift的内存管理</title>
    <url>/post/30039fb5.html</url>
    <content><![CDATA[<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/ios/swift.jpg?x-oss-process=style/titanjun" alt="Swift"></p>
<span id="more"></span>

<ul>
<li>原文博客地址: <a href="https://www.titanjun.top/%E6%B5%85%E8%B0%88Swift%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html">浅谈Swift的内存管理</a></li>
<li>2020年的第一篇博客, 算是2020年开了个好头, 希望能够继续坚持下去, 继续记录分享更多更高质量的文章</li>
<li>今年期待已久的<code>Swift5.0</code>稳定版就已经发布了, 感兴趣的小伙伴可看我的这篇博客:<a href="https://www.titanjun.top/Swift%205.0%E6%96%B0%E7%89%B9%E6%80%A7%E6%9B%B4%E6%96%B0.html">Swift 5.0新特性更新</a></li>
<li>这篇博客可主要分享<code>Swift</code>的内存管理的相关介绍和剖析, 测试环境: <code>Xcode 11.2.1</code>, <code>Swift 5.1.2</code></li>
</ul>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><ul>
<li>和<code>OC</code>一样, 在<code>Swift</code>中也是采用基于引用计数的<code>ARC</code>内存管理方案(针对堆空间的内存管理)</li>
<li>在<code>Swift</code>的<code>ARC</code>中有三种引用<ul>
<li>强引用(<code>strong reference</code>)：默认情况下，代码中涉及到的引用都是强引用</li>
<li>弱引用(<code>weak reference</code>)：通过<code>weak</code>定义弱引用</li>
<li>无主引用(<code>unowned reference</code>)：通过<code>unowned</code>定义无主引用</li>
</ul>
</li>
</ul>
<h3 id="weak"><a href="#weak" class="headerlink" title="weak"></a>weak</h3><ul>
<li>弱引用(<code>weak reference</code>)：通过<code>weak</code>定义弱引用<ul>
<li>必须是可选类型的<code>var</code>，因为实例销毁后，<code>ARC</code>会自动将弱引用设置为<code>nil</code></li>
<li><code>ARC</code>自动给弱引用设置<code>nil</code>时，不会触发属性观察</li>
</ul>
</li>
<li>在介绍<code>weak</code>弱引用之前, 先看一下下面一段代码</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Animal deinit&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">test</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> animal <span class="operator">=</span> <span class="type">Animal</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;will deinit&quot;</span>)</span><br><span class="line">test()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;did deinit&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>上面这段代码中在<code>test</code>函数调用结束之后, 该作用的内存就会被回收, <code>animal</code>对象自然就会被销毁, 毫无疑问上面的输出结果应该是</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">will <span class="keyword">deinit</span></span><br><span class="line"><span class="type">Animal</span> <span class="keyword">deinit</span></span><br><span class="line">did <span class="keyword">deinit</span></span><br></pre></td></tr></table></figure>

<p>同样下面这段代码, 同样也是在<code>a1</code>对象被置为<code>nil</code>的时候内存会被回收, 对象就会被销毁</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a1: <span class="type">Animal</span>? <span class="operator">=</span> <span class="type">Animal</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;will deinit&quot;</span>)</span><br><span class="line">a1 <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;did deinit&quot;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>下面是一个被<code>weak</code>修饰的弱引用对象, </li>
<li>我们都知道, 被<code>weak</code>修饰的弱引用对象, 在对象销毁的时候, 会被自动置为<code>nil</code></li>
<li>所以被<code>weak</code>修饰的弱引用对象必须是可选类型的<code>var</code>, 两个条件缺一不可</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">weak</span> <span class="keyword">var</span> a2: <span class="type">Animal</span>? <span class="operator">=</span> <span class="type">Animal</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下两种方式都会报错的</span></span><br><span class="line"><span class="keyword">weak</span> <span class="keyword">var</span> a2: <span class="type">Animal</span> <span class="operator">=</span> <span class="type">Animal</span>()</span><br><span class="line"><span class="keyword">weak</span> <span class="keyword">let</span> a2: <span class="type">Animal</span>? <span class="operator">=</span> <span class="type">Animal</span>()</span><br></pre></td></tr></table></figure>

<h3 id="unowned"><a href="#unowned" class="headerlink" title="unowned"></a>unowned</h3><ul>
<li>无主引用(<code>unowned reference</code>)：通过<code>unowned</code>定义无主引用</li>
<li>不会产生强引用，实例销毁后仍然存储着实例的内存地址(类似于OC中的<code>unsafe_unretained</code>）</li>
<li>试图在实例销毁后访问无主引用，会产生运行时错误（如下野指针)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Fatal error: Attempted to read an unowned reference but object 0x0 was already deallocate</span><br></pre></td></tr></table></figure>

<div class="note warning"><p>需要注意的是</p></div>

<p><code>weak</code>、<code>unowned</code>只能用在类实例上面, 如下所示</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 该协议表示只能被类遵守, AnyObject代表所有的类实例</span></span><br><span class="line"><span class="keyword">protocol</span> <span class="title class_">Liveable</span>: <span class="title class_">AnyObject</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">weak</span> <span class="keyword">var</span> p0: <span class="type">Person</span>?</span><br><span class="line"><span class="keyword">weak</span> <span class="keyword">var</span> p1: <span class="type">AnyObject</span>?</span><br><span class="line"><span class="comment">// 所有能遵循Liveable协议的肯定都是类</span></span><br><span class="line"><span class="keyword">weak</span> <span class="keyword">var</span> p2: <span class="type">Liveable</span>?</span><br><span class="line"></span><br><span class="line"><span class="keyword">unowned</span> <span class="keyword">var</span> p10: <span class="type">Person</span>?</span><br><span class="line"><span class="keyword">unowned</span> <span class="keyword">var</span> p11: <span class="type">AnyObject</span>?</span><br><span class="line"><span class="keyword">unowned</span> <span class="keyword">var</span> p12: <span class="type">Liveable</span>?</span><br></pre></td></tr></table></figure>


<h2 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h2><ul>
<li><code>weak</code>、<code>unowned</code>都能解决循环引用的问题，<code>unowned</code>要比<code>weak</code>少一些性能消耗</li>
<li>在生命周期中可能会变为<code>nil</code>的使用<code>weak</code></li>
<li>初始化赋值后再也不会变为<code>nil</code>的使用<code>unowne</code></li>
<li>说道循环引用就自然想到了闭包</li>
</ul>
<h3 id="闭包的循环引用"><a href="#闭包的循环引用" class="headerlink" title="闭包的循环引用"></a>闭包的循环引用</h3><p>闭包表达式默认会对用到的外层对象产生额外的强引用（对外层对象进行了<code>retain</code>操作）, 看一下下面的代码中<code>deinit</code>会被调用吗?</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> fn: (() -&gt; ())<span class="operator">?</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">run</span>() &#123; <span class="built_in">print</span>(<span class="string">&quot;run&quot;</span>) &#125;</span><br><span class="line">    <span class="keyword">deinit</span> &#123; <span class="built_in">print</span>(<span class="string">&quot;deinit&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">test</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> p <span class="operator">=</span> <span class="type">Person</span>()</span><br><span class="line">    p.fn <span class="operator">=</span> &#123; </span><br><span class="line">        p.run()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test()</span><br></pre></td></tr></table></figure>


<ul>
<li>上面代码中, <code>p</code>对象强引用着<code>fn</code>闭包, <code>fn</code>闭包也强引用着<code>p</code>对象, 自然就造成了循环引用问题</li>
<li>最后没有任何输出结果, 我们看一下上述代码的汇编执行过程</li>
</ul>
<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/swift/weak.png" alt="weak"></p>
<ul>
<li>从上面汇编代码可以看出, 整个过程经历了</li>
<li>一次<code>init</code>引用计数为: 1</li>
<li>一次<code>retain</code>引用计数会加(1), 结果为: 2</li>
<li>一次<code>release</code>引用计数会减(1), 结果为: 1</li>
<li>那么最后的引用计数就是1, 所以<code>p</code>对象肯定没有被释放</li>
<li>下面是使用解决循环引用的情况<ul>
<li>在闭包表达式的捕获列表里, 声明<code>weak</code>或<code>unowned</code>引用，用以解决循环引用问题</li>
</ul>
</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用weak</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">test</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> p <span class="operator">=</span> <span class="type">Person</span>()</span><br><span class="line">    p.fn <span class="operator">=</span> &#123; [<span class="keyword">weak</span> p] <span class="keyword">in</span></span><br><span class="line">        p<span class="operator">?</span>.run()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用unowned</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">test</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> p <span class="operator">=</span> <span class="type">Person</span>()</span><br><span class="line">    p.fn <span class="operator">=</span> &#123; [<span class="keyword">unowned</span> p] <span class="keyword">in</span></span><br><span class="line">        p.run()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>上述两种方式都可以解决循环引用的问题, 运行后就发现<code>Person</code>对象调用了<code>deinit</code></li>
<li>这里我们再看一下汇编代码如下, 从下面汇编代码中可以很明显看到, 引用计数最后为0, 对象被释放</li>
</ul>
<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/swift/weak1.png" alt="weak"></p>
<div class="note success"><p>下面这段代码其实是等价的</p></div>


<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">test</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> p <span class="operator">=</span> <span class="type">Person</span>()</span><br><span class="line">    p.fn <span class="operator">=</span> &#123; [<span class="keyword">unowned</span> p] <span class="keyword">in</span></span><br><span class="line">        p.run()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 和上面等价代码</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">test</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> p <span class="operator">=</span> <span class="type">Person</span>()</span><br><span class="line">    p.fn <span class="operator">=</span> &#123; [<span class="keyword">unowned</span> ownedP <span class="operator">=</span> p, <span class="keyword">weak</span> weakP <span class="operator">=</span> p] <span class="keyword">in</span></span><br><span class="line">        ownedP.run()</span><br><span class="line">        <span class="comment">// weakP?.run()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note warning"><p>特别注意点</p></div>

<p>这里要区分捕获列表和参数列表, 下面看看<code>fn</code>有参数的情况下</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> fn: ((<span class="type">Int</span>) -&gt; ())<span class="operator">?</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">run</span>() &#123; <span class="built_in">print</span>(<span class="string">&quot;run&quot;</span>) &#125;</span><br><span class="line">    <span class="keyword">deinit</span> &#123; <span class="built_in">print</span>(<span class="string">&quot;deinit&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">test</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> p <span class="operator">=</span> <span class="type">Person</span>()</span><br><span class="line">    p.fn <span class="operator">=</span> &#123;</span><br><span class="line">        (num) <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;num = <span class="subst">\(num)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么闭包的参数列表和捕获列表同时存在的情况如下代码所示</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">test</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> p <span class="operator">=</span> <span class="type">Person</span>()</span><br><span class="line">    p.fn <span class="operator">=</span> &#123;</span><br><span class="line">        [<span class="keyword">weak</span> p](num) <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;num = <span class="subst">\(num)</span>&quot;</span>)</span><br><span class="line">        p<span class="operator">?</span>.run()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="self的循环引用"><a href="#self的循环引用" class="headerlink" title="self的循环引用"></a>self的循环引用</h3><ul>
<li>如果想在引用闭包的同时引用<code>self</code>, 这个闭包必须是<code>lazy</code>的</li>
<li>因为实例在初始化完毕之后才能引用<code>self</code></li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">lazy</span> <span class="keyword">var</span> fn: (() -&gt; ()) <span class="operator">=</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.run()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">run</span>() &#123; <span class="built_in">print</span>(<span class="string">&quot;run&quot;</span>) &#125;</span><br><span class="line">    <span class="keyword">deinit</span> &#123; <span class="built_in">print</span>(<span class="string">&quot;deinit&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">test</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> p <span class="operator">=</span> <span class="type">Person</span>()</span><br><span class="line">    p.fn()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test()</span><br></pre></td></tr></table></figure>

<ul>
<li>上面代码中如果<code>fn</code>闭包去掉<code>lazy</code>, 编译器会直接报错</li>
<li>在<code>Swift</code>中, 为了保证初始化的安全, 设定了两段式初始化, 在所有的存储属性被初始化完成之后, 初始化器才能够使用<code>self</code></li>
<li>而且在上述<code>fn</code>闭包中, 如果<code>fn</code>内部用到了实例成员(属性和方法), 则编译器会强制要求明确写出<code>self</code></li>
<li><code>lazy</code>既保证只有在使用的时候才会被初始化一次</li>
<li>但是上述代码同样存在循环引用的问题, <code>Person</code>对象强引用着<code>fn</code>闭包, <code>fn</code>闭包也强引用着<code>self</code></li>
<li>同样使用<code>weak</code>和<code>unowned</code>解决循环引用的问题</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// weak解决循环引用</span></span><br><span class="line"><span class="keyword">lazy</span> <span class="keyword">var</span> fn: (() -&gt; ()) <span class="operator">=</span> &#123;</span><br><span class="line">    [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">self</span><span class="operator">?</span>.run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// unowned解决循环引用</span></span><br><span class="line"><span class="keyword">lazy</span> <span class="keyword">var</span> fn: (() -&gt; ()) <span class="operator">=</span> &#123;</span><br><span class="line">    [<span class="keyword">unowned</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">self</span>.run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外再看看下面这种情况, 是都存在循环引用的问题</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span> <span class="operator">=</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">lazy</span> <span class="keyword">var</span> getAge: <span class="type">Int</span> <span class="operator">=</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.age</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">deinit</span> &#123; <span class="built_in">print</span>(<span class="string">&quot;deinit&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">test</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> p <span class="operator">=</span> <span class="type">Student</span>()</span><br><span class="line">    <span class="built_in">print</span>(p.getAge)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test()</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">deinit</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<p>通过输出结果看一看出调用了<code>deinit</code>, 说明对象最终被释放, 并未出现循环引用的问题, 下面比较一下</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 存在循环引用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">lazy</span> <span class="keyword">var</span> fn: (() -&gt; ()) <span class="operator">=</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.run()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">run</span>() &#123; <span class="built_in">print</span>(<span class="string">&quot;run&quot;</span>) &#125;</span><br><span class="line">    <span class="keyword">deinit</span> &#123; <span class="built_in">print</span>(<span class="string">&quot;deinit&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不存在循环引用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span> <span class="operator">=</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">lazy</span> <span class="keyword">var</span> getAge: <span class="type">Int</span> <span class="operator">=</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.age</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">deinit</span> &#123; <span class="built_in">print</span>(<span class="string">&quot;deinit&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>上述两种写法的区别, 本质上说</li>
<li><code>Person</code>对象中的<code>fn</code>闭包属于闭包赋值</li>
<li><code>Student</code>对象那个中的<code>getAge</code>属于闭包调用(类似函数调用)</li>
<li>相当于在在<code>Student</code>对象调用<code>getAge</code>结束之后, 作用域内的变量就会被释放</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// getAge也可以写成如下形式</span></span><br><span class="line"><span class="keyword">lazy</span> <span class="keyword">var</span> getAge: <span class="type">Int</span> <span class="operator">=</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.age</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以理解为</span></span><br><span class="line"><span class="keyword">lazy</span> <span class="keyword">var</span> getAge: <span class="type">Int</span> <span class="operator">=</span> <span class="keyword">self</span>.age</span><br></pre></td></tr></table></figure>

<h2 id="内存访问冲突"><a href="#内存访问冲突" class="headerlink" title="内存访问冲突"></a>内存访问冲突</h2><p>在<code>Swift</code>中的内存访问冲突主要在两个访问满足下列条件时发生</p>
<ul>
<li>至少一个是写入操作</li>
<li>它们访问的是同一块内存</li>
<li>它们的访问时间重叠(比如在同一个函数内)</li>
<li>对比看看以下两个函数操作</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不存在内存访问冲突</span></span><br><span class="line"><span class="keyword">var</span> number <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">plus</span>(<span class="keyword">_</span> <span class="params">num</span>: <span class="keyword">inout</span> <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num <span class="operator">+</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">number <span class="operator">=</span> plus(<span class="operator">&amp;</span>number)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存在内存访问冲突</span></span><br><span class="line"><span class="keyword">var</span> step <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">increment</span>(<span class="keyword">_</span> <span class="params">num</span>: <span class="keyword">inout</span> <span class="type">Int</span>) &#123;</span><br><span class="line">    num <span class="operator">+=</span> step</span><br><span class="line">&#125;</span><br><span class="line">increment(<span class="operator">&amp;</span>step)</span><br></pre></td></tr></table></figure>

<p>上面第二部分代码就是同时对<code>step</code>变量执行读写操作, 运行时会报出如下错误</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Simultaneous accesses to 0x100002028, but modification requires exclusive access.</span><br></pre></td></tr></table></figure>

<p>再看下面对于结构体和元组的使用, 这里先定义一个全局函数和一个结构体</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 改变两个传入参数的值, 读取并修改传入参数的值</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">balance</span>(<span class="keyword">_</span> <span class="params">x</span>: <span class="keyword">inout</span> <span class="type">Int</span>, <span class="keyword">_</span> <span class="params">y</span>: <span class="keyword">inout</span> <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> sum <span class="operator">=</span> x <span class="operator">+</span> y</span><br><span class="line">    x <span class="operator">=</span> sum <span class="operator">/</span> <span class="number">2</span></span><br><span class="line">    y <span class="operator">=</span> sum <span class="operator">-</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义Player结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Player</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> health: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> energy: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">shareHealth</span>(<span class="params">with</span> <span class="params">teammate</span>: <span class="keyword">inout</span> <span class="type">Player</span>) &#123;</span><br><span class="line">        balance(<span class="operator">&amp;</span>teammate.health, <span class="operator">&amp;</span>health)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看下面的使用示例, 两者都会有一个内存访问冲突的错误</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里读写的是同一个maria</span></span><br><span class="line"><span class="keyword">var</span> maria <span class="operator">=</span> <span class="type">Player</span>(name: <span class="string">&quot;Maria&quot;</span>, health: <span class="number">50</span>, energy: <span class="number">10</span>)</span><br><span class="line">balance(<span class="operator">&amp;</span>maria.health, <span class="operator">&amp;</span>maria.energy)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里读写的是同一个tuple</span></span><br><span class="line"><span class="keyword">var</span> tuple <span class="operator">=</span> (health: <span class="number">10</span>, energy: <span class="number">20</span>)</span><br><span class="line">balance(<span class="operator">&amp;</span>tuple.health, <span class="operator">&amp;</span>tuple.energy)</span><br></pre></td></tr></table></figure>

<p>但是有时候的确会有上面这种访问同一块内存的需求, 如果下面的条件满足, 就说明重叠访问结构体的属性是安全的</p>
<ul>
<li>访问的是实例存储属性, 不是计算属性或者类属性</li>
<li>结构体是局部变量而非全局变量</li>
<li>结构体要么没有被闭包捕获要么只被非逃逸闭包捕获</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里可以在局部作用域内定义成局部变量, 就不会有问题了</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">test</span>() &#123;</span><br><span class="line">    <span class="keyword">var</span> maria <span class="operator">=</span> <span class="type">Player</span>(name: <span class="string">&quot;Maria&quot;</span>, health: <span class="number">50</span>, energy: <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">var</span> tuple <span class="operator">=</span> (health: <span class="number">10</span>, energy: <span class="number">20</span>)</span><br><span class="line">    balance(<span class="operator">&amp;</span>tuple.health, <span class="operator">&amp;</span>tuple.energy)</span><br><span class="line">    balance(<span class="operator">&amp;</span>maria.health, <span class="operator">&amp;</span>maria.energy)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> person <span class="operator">=</span> <span class="type">Person</span>()</span><br></pre></td></tr></table></figure>

<ul>
<li>在<code>Swift</code>中<code>class</code>声明的类(<code>Person</code>)是引用类型, 初始化的<code>person</code>对象其本质上就是一个指针变量</li>
<li>而<code>person</code>里面存储的就是这个指针变量的地址值, 也就可以根据这个地址值去访问被分配的内存空间</li>
<li>指针在某种意义上被定性为不安全的, 举个例子:<ul>
<li>当前指针变量的地址值对应的空间只有32个字节, 但有可能访问的是超过32个字节的空间, 这样就可能会出问题的</li>
</ul>
</li>
</ul>
<h3 id="指针分类"><a href="#指针分类" class="headerlink" title="指针分类"></a>指针分类</h3><p>在<code>Swift</code>中也有专门的指针类型，这些都被定性为<code>Unsafe</code>（不安全的），常见的有以下4种类型</p>
<ul>
<li><code>UnsafePointer&lt;Pointee&gt;</code>, 类似于C语言中的<code>const Pointee *</code>, 只能访问内存不能修改内存, 这里的<code>Pointee</code>是指泛型</li>
<li><code>UnsafeMutablePointer&lt;Pointee&gt;</code>类似于C语言中的<code>Pointee *</code>, 可以访问和修改内存, 这里的<code>Pointee</code>是指泛型 </li>
<li><code>UnsafeRawPointer</code>类似于<code>const void *</code>, 不支持泛型</li>
<li><code>UnsafeMutableRawPointer</code>类似于<code>void</code>, 不支持泛型</li>
</ul>
<p>下面看一下具体的使用示例</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> age <span class="operator">=</span> <span class="number">10</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">sum1</span>(<span class="keyword">_</span> <span class="params">ptr</span>: <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Int</span>&gt;) &#123;</span><br><span class="line">    <span class="comment">// 通过访问pointee属性, 获取ptr指针的内存地址所存储的值</span></span><br><span class="line">    <span class="comment">// UnsafeMutablePointer的pointee属性是可读可写的</span></span><br><span class="line">    ptr.pointee <span class="operator">+=</span> <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">func</span> <span class="title function_">sum2</span>(<span class="keyword">_</span> <span class="params">ptr</span>: <span class="type">UnsafePointer</span>&lt;<span class="type">Int</span>&gt;) &#123;</span><br><span class="line">    <span class="comment">// UnsafePointer的pointee属性是只读的</span></span><br><span class="line">    <span class="comment">// ptr.pointee += 10</span></span><br><span class="line">    <span class="built_in">print</span>(ptr.pointee)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">func</span> <span class="title function_">sum3</span>(<span class="keyword">_</span> <span class="params">num</span>: <span class="keyword">inout</span> <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    num <span class="operator">+=</span> <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 和inout输入输出参数一样接受变量的地址值</span></span><br><span class="line">sum1(<span class="operator">&amp;</span>age)</span><br><span class="line">sum2(<span class="operator">&amp;</span>age)</span><br><span class="line">sum3(<span class="operator">&amp;</span>age)</span><br><span class="line"><span class="built_in">print</span>(age)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">sum4</span>(<span class="keyword">_</span> <span class="params">ptr</span>: <span class="type">UnsafeMutableRawPointer</span>) &#123;</span><br><span class="line">    <span class="comment">// 可读可写, 取值</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;age = &quot;</span>, ptr.load(as: <span class="type">Int</span>.<span class="keyword">self</span>))</span><br><span class="line">    <span class="comment">// 可读可写, 赋值</span></span><br><span class="line">    ptr.storeBytes(of: <span class="number">50</span>, as: <span class="type">Int</span>.<span class="keyword">self</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">func</span> <span class="title function_">sum5</span>(<span class="keyword">_</span> <span class="params">ptr</span>: <span class="type">UnsafeRawPointer</span>) &#123;</span><br><span class="line">    <span class="comment">// 只读, 取值</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;age = &quot;</span>, ptr.load(as: <span class="type">Int</span>.<span class="keyword">self</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum4(<span class="operator">&amp;</span>age)</span><br><span class="line">sum5(<span class="operator">&amp;</span>age)</span><br></pre></td></tr></table></figure>


<h3 id="获得变量的指针"><a href="#获得变量的指针" class="headerlink" title="获得变量的指针"></a>获得变量的指针</h3><p><code>Swift</code>中有可以直接获取变量的指针的方法</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取可变的变量指针, value参数接受变量地址</span></span><br><span class="line"><span class="keyword">@inlinable</span> <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">withUnsafeMutablePointer</span>&lt;<span class="type">T</span>, <span class="type">Result</span>&gt;(<span class="params">to</span> <span class="params">value</span>: <span class="keyword">inout</span> <span class="type">T</span>, <span class="keyword">_</span> <span class="params">body</span>: (<span class="type">UnsafeMutablePointer</span>&lt;<span class="type">T</span>&gt;) <span class="keyword">throws</span> -&gt; <span class="type">Result</span>) <span class="keyword">rethrows</span> -&gt; <span class="type">Result</span></span><br><span class="line"><span class="comment">// 获取不可变的变量指针, value参数接受变量</span></span><br><span class="line"><span class="keyword">@inlinable</span> <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">withUnsafePointer</span>&lt;<span class="type">T</span>, <span class="type">Result</span>&gt;(<span class="params">to</span> <span class="params">value</span>: <span class="type">T</span>, <span class="keyword">_</span> <span class="params">body</span>: (<span class="type">UnsafePointer</span>&lt;<span class="type">T</span>&gt;) <span class="keyword">throws</span> -&gt; <span class="type">Result</span>) <span class="keyword">rethrows</span> -&gt; <span class="type">Result</span></span><br><span class="line"><span class="comment">// 获取不可变的变量指针, value参数接受变量地址</span></span><br><span class="line"><span class="keyword">@inlinable</span> <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">withUnsafePointer</span>&lt;<span class="type">T</span>, <span class="type">Result</span>&gt;(<span class="params">to</span> <span class="params">value</span>: <span class="keyword">inout</span> <span class="type">T</span>, <span class="keyword">_</span> <span class="params">body</span>: (<span class="type">UnsafePointer</span>&lt;<span class="type">T</span>&gt;) <span class="keyword">throws</span> -&gt; <span class="type">Result</span>) <span class="keyword">rethrows</span> -&gt; <span class="type">Result</span></span><br></pre></td></tr></table></figure>


<p>上述方法中返回值默认是变量的指针地址, 也可以是其他的数据类型, 主要取决于<code>body</code>闭包的返回值, 返回值类型由闭包中的<code>Result</code>泛型决定</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> age <span class="operator">=</span> <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> ptr1 <span class="operator">=</span> <span class="built_in">withUnsafeMutablePointer</span>(to: <span class="operator">&amp;</span>age) &#123; <span class="variable">$0</span> &#125;   <span class="comment">// UnsafeMutablePointer&lt;Int&gt;</span></span><br><span class="line"><span class="keyword">var</span> ptr2 <span class="operator">=</span> <span class="built_in">withUnsafePointer</span>(to: <span class="operator">&amp;</span>age) &#123; <span class="variable">$0</span> &#125;          <span class="comment">// UnsafePointer&lt;Int&gt;</span></span><br><span class="line">ptr1.pointee <span class="operator">=</span> <span class="number">22</span></span><br><span class="line"><span class="built_in">print</span>(ptr2.pointee) <span class="comment">// 22</span></span><br><span class="line"><span class="built_in">print</span>(ptr2)         <span class="comment">// 0x0000000100008310</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ptr3 <span class="operator">=</span> <span class="built_in">withUnsafeMutablePointer</span>(to: <span class="operator">&amp;</span>age) &#123; <span class="type">UnsafeMutableRawPointer</span>(<span class="variable">$0</span>) &#125;   <span class="comment">// UnsafeMutableRawPointer</span></span><br><span class="line"><span class="keyword">var</span> ptr4 <span class="operator">=</span> <span class="built_in">withUnsafePointer</span>(to: <span class="operator">&amp;</span>age) &#123; <span class="type">UnsafeRawPointer</span>(<span class="variable">$0</span>) &#125;                 <span class="comment">// UnsafeRawPointer</span></span><br><span class="line"><span class="comment">// as参数是需要存储什么类型的数据</span></span><br><span class="line">ptr3.storeBytes(of: <span class="number">33</span>, as: <span class="type">Int</span>.<span class="keyword">self</span>)</span><br><span class="line"><span class="built_in">print</span>(ptr4.load(as: <span class="type">Int</span>.<span class="keyword">self</span>)) <span class="comment">// 33</span></span><br><span class="line"><span class="built_in">print</span>(ptr4)         <span class="comment">// 0x0000000100008310</span></span><br></pre></td></tr></table></figure>


<h3 id="创建指针"><a href="#创建指针" class="headerlink" title="创建指针"></a>创建指针</h3><ul>
<li>之前获取到的指针都是根据已经存在的内存获取的</li>
<li>这里就看看重新分配一块内存指向堆空间</li>
</ul>
<h4 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h4><p><code>Swift</code>提供了<code>malloc</code>直接分配内存创建指针的方式</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据需要分配的内存大小创建一个指针</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">malloc</span>(<span class="keyword">_</span> <span class="params">__size</span>: <span class="type">Int</span>) -&gt; <span class="type">UnsafeMutableRawPointer</span>!</span><br><span class="line"><span class="comment">// 释放内存</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">free</span>(<span class="keyword">_</span>: <span class="type">UnsafeMutableRawPointer</span>!)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面这两个函数, 是赋值和取值的函数, 之前简单介绍过</span></span><br><span class="line"><span class="comment">// 参数一: 需要存储的值</span></span><br><span class="line"><span class="comment">// 参数二: 偏移量, 从第几个字节开始存储, 默认从第一个</span></span><br><span class="line"><span class="comment">// 参数三: 需要存储的值的类型</span></span><br><span class="line"><span class="keyword">@inlinable</span> <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">storeBytes</span>&lt;<span class="type">T</span>&gt;(<span class="params">of</span> <span class="params">value</span>: <span class="type">T</span>, <span class="params">toByteOffset</span> <span class="params">offset</span>: <span class="type">Int</span> <span class="operator">=</span> <span class="number">0</span>, <span class="params">as</span>: <span class="type">T</span>.<span class="keyword">Type</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数一: 偏移量, 从第几个字节开始存储, 默认从第一个</span></span><br><span class="line"><span class="comment">// 参数二: 需要存储的值的类型</span></span><br><span class="line"><span class="keyword">@inlinable</span> <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">load</span>&lt;<span class="type">T</span>&gt;(<span class="params">fromByteOffset</span> <span class="params">offset</span>: <span class="type">Int</span> <span class="operator">=</span> <span class="number">0</span>, <span class="params">as</span> <span class="params">type</span>: <span class="type">T</span>.<span class="keyword">Type</span>) -&gt; <span class="type">T</span></span><br></pre></td></tr></table></figure>

<p>代码示例如下</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建指针</span></span><br><span class="line"><span class="keyword">var</span> ptr <span class="operator">=</span> malloc(<span class="number">16</span>)</span><br><span class="line"><span class="comment">// 存储值</span></span><br><span class="line">ptr<span class="operator">?</span>.storeBytes(of: <span class="number">10</span>, as: <span class="type">Int</span>.<span class="keyword">self</span>)</span><br><span class="line"><span class="comment">// 这里toByteOffset参数如果传0, 就会覆盖前8个字节的数据</span></span><br><span class="line">ptr<span class="operator">?</span>.storeBytes(of: <span class="number">12</span>, toByteOffset: <span class="number">8</span>, as: <span class="type">Int</span>.<span class="keyword">self</span>)</span><br><span class="line"><span class="comment">// 取值</span></span><br><span class="line"><span class="built_in">print</span>(ptr<span class="operator">?</span>.load(as: <span class="type">Int</span>.<span class="keyword">self</span>) <span class="operator">??</span> <span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(ptr<span class="operator">?</span>.load(fromByteOffset: <span class="number">8</span>, as: <span class="type">Int</span>.<span class="keyword">self</span>) <span class="operator">??</span> <span class="number">0</span>)</span><br><span class="line"><span class="comment">// 销毁, 释放内存</span></span><br><span class="line">free(ptr)</span><br></pre></td></tr></table></figure>

<h4 id="allocate"><a href="#allocate" class="headerlink" title="allocate"></a>allocate</h4><p>使用<code>allocate</code>方式创建指针, 代码示例如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// byteCount: 需要申请的字节数, alignment: 对其字节数</span><br><span class="line">var ptr2 = UnsafeMutableRawPointer.allocate(byteCount: 16, alignment: 1)</span><br><span class="line">// 存储</span><br><span class="line">ptr2.storeBytes(of: 9, as: Int.self)</span><br><span class="line"></span><br><span class="line">// 根据字节偏移存储</span><br><span class="line">// 这里的ptr3是ptr2偏移8个字节的新的指针地址</span><br><span class="line">var ptr3 = ptr2.advanced(by: 8)  // UnsafeMutableRawPointer</span><br><span class="line">ptr3.storeBytes(of: 12, as: Int.self)</span><br><span class="line"></span><br><span class="line">// 上面这种方式等价于</span><br><span class="line">ptr2.storeBytes(of: 12, toByteOffset: 8, as: Int.self)</span><br><span class="line"></span><br><span class="line">// 取值同样</span><br><span class="line">print(ptr2.load(as: Int.self))</span><br><span class="line">// 下面这两种取值方式也是一样的</span><br><span class="line">print(ptr2.advanced(by: 8).load(as: Int.self))</span><br><span class="line">print(ptr2.load(fromByteOffset: 8, as: Int.self))</span><br><span class="line"></span><br><span class="line">// 释放内存</span><br><span class="line">ptr2.deallocate()</span><br></pre></td></tr></table></figure>

<div class="note warning"><p>这里需要注意的地方</p></div>

<ul>
<li>只有<code>UnsafeMutableRawPointer</code>才有<code>allocate</code>分配方法, <code>UnsafeRawPointer</code>是没有这个方法的</li>
<li>下面说到的<code>UnsafeMutablePointer&lt;T&gt;</code>类型也是, <code>UnsafePointer&lt;T&gt;</code>没有<code>allocate</code>分配方法</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// capacity: 容量, 即可以存储3个Int类型的数据, 也就是24个字节</span></span><br><span class="line"><span class="keyword">var</span> ptr <span class="operator">=</span> <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Int</span>&gt;.allocate(capacity: <span class="number">3</span>)</span><br><span class="line"><span class="comment">// 初始化内存, 用10初始化钱8个字节</span></span><br><span class="line">ptr.initialize(to: <span class="number">10</span>)</span><br><span class="line"><span class="comment">// 用10初始化前两个容量的内存, 即16个字节</span></span><br><span class="line">ptr.initialize(repeating: <span class="number">10</span>, count: <span class="number">2</span>)</span><br><span class="line"><span class="comment">// 使用successor获取下一个存储位, 也就是下一个Int的位置</span></span><br><span class="line"><span class="keyword">var</span> ptr1 <span class="operator">=</span> ptr.successor()  <span class="comment">//  UnsafeMutablePointer&lt;Int&gt;</span></span><br><span class="line">ptr1.initialize(to: <span class="number">20</span>)</span><br><span class="line"><span class="comment">// 存储第三个Int值</span></span><br><span class="line">ptr.successor().successor().initialize(to: <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取值的两种方式</span></span><br><span class="line"><span class="built_in">print</span>(ptr.pointee)        <span class="comment">// 第一个值</span></span><br><span class="line"><span class="built_in">print</span>((ptr <span class="operator">+</span> <span class="number">1</span>).pointee)  <span class="comment">// 第二个值</span></span><br><span class="line"><span class="built_in">print</span>((ptr <span class="operator">+</span> <span class="number">2</span>).pointee)  <span class="comment">// 第三个值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面这种方式和上面等价</span></span><br><span class="line"><span class="built_in">print</span>(ptr[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(ptr[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(ptr[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前面如果使用了initialize, 则必须调用反初始化</span></span><br><span class="line"><span class="comment">// 而且count要和上面allocate(capacity: 3)的capacity一致, 否则会造成内存泄露的问题</span></span><br><span class="line">ptr.deinitialize(count: <span class="number">3</span>)</span><br><span class="line">ptr.deallocate()</span><br></pre></td></tr></table></figure>


<h3 id="指针之间的转换"><a href="#指针之间的转换" class="headerlink" title="指针之间的转换"></a>指针之间的转换</h3><p>前面提到过<code>Swift</code>中的指针类型有四种</p>
<ul>
<li><code>UnsafePointer&lt;Pointee&gt;</code>类似于<code>const Pointee *</code></li>
<li><code>UnsafeMutablePointer&lt;Pointee&gt;</code>类似于<code>Pointee *</code></li>
<li><code>UnsafeRawPointer</code>类似于<code>const void *</code></li>
<li><code>UnsafeMutableRawPointer</code>类似于<code>void *</code></li>
<li>那么上面的类型, 能否通过其中的一种创建另外一种指针呢, 下面我们来看一下</li>
</ul>
<h4 id="init"><a href="#init" class="headerlink" title="init"></a>init</h4><p><code>UnsafeMutableRawPointer</code>中有一个初始化方法可以根据<code>UnsafeMutablePointer</code>创建自身</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">init</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">_</span> <span class="params">other</span>: <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">T</span>&gt;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ptr <span class="operator">=</span> <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Int</span>&gt;.allocate(capacity: <span class="number">3</span>)</span><br><span class="line"><span class="keyword">var</span> ptr1 <span class="operator">=</span> <span class="type">UnsafeMutableRawPointer</span>(ptr)</span><br></pre></td></tr></table></figure>


<h4 id="assumingMemoryBound"><a href="#assumingMemoryBound" class="headerlink" title="assumingMemoryBound"></a>assumingMemoryBound</h4><p>反过来, <code>UnsafeMutableRawPointer</code>也提供了一个方法用于创建<code>UnsafePointer</code></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">assumingMemoryBound</span>&lt;<span class="type">T</span>&gt;(<span class="params">to</span>: <span class="type">T</span>.<span class="keyword">Type</span>) -&gt; <span class="type">UnsafePointer</span>&lt;<span class="type">T</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ptr <span class="operator">=</span> <span class="type">UnsafeMutableRawPointer</span>.allocate(byteCount: <span class="number">16</span>, alignment: <span class="number">1</span>)</span><br><span class="line"><span class="keyword">var</span> ptr1 <span class="operator">=</span> ptr.assumingMemoryBound(to: <span class="type">Int</span>.<span class="keyword">self</span>)</span><br><span class="line"><span class="comment">// 初始化前8个字节</span></span><br><span class="line">ptr1.pointee <span class="operator">=</span> <span class="number">11</span></span><br><span class="line"><span class="comment">// 初始化后8个字节</span></span><br><span class="line"><span class="comment">// 特别注意, 这里的(ptr + 8)是指ptr向后偏移8个字节, 要和之前的区分开</span></span><br><span class="line">(ptr <span class="operator">+</span> <span class="number">8</span>).assumingMemoryBound(to: <span class="type">Int</span>.<span class="keyword">self</span>).pointee <span class="operator">=</span> <span class="number">12</span></span><br><span class="line"></span><br><span class="line">ptr.deallocate()</span><br></pre></td></tr></table></figure>


<h4 id="unsafeBitCast"><a href="#unsafeBitCast" class="headerlink" title="unsafeBitCast"></a>unsafeBitCast</h4><p><code>unsafeBitCast</code>是忽略数据类型的强制转换，不会因为数据类型的变化而改变原来的内存数</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 把第一个参数类型转成第二个参数类型</span></span><br><span class="line"><span class="keyword">@inlinable</span> <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">unsafeBitCast</span>&lt;<span class="type">T</span>, <span class="type">U</span>&gt;(<span class="keyword">_</span> <span class="params">x</span>: <span class="type">T</span>, <span class="params">to</span> <span class="params">type</span>: <span class="type">U</span>.<span class="keyword">Type</span>) -&gt; <span class="type">U</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ptr <span class="operator">=</span> <span class="type">UnsafeMutableRawPointer</span>.allocate(byteCount: <span class="number">16</span>, alignment: <span class="number">1</span>)</span><br><span class="line"><span class="built_in">unsafeBitCast</span>(ptr, to: <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Int</span>&gt;.<span class="keyword">self</span>).pointee <span class="operator">=</span> <span class="number">13</span></span><br><span class="line"><span class="comment">// 注意, 这里的(ptr + 8)是指ptr向后偏移8个字节, 要和之前的区分开</span></span><br><span class="line"><span class="built_in">unsafeBitCast</span>(ptr <span class="operator">+</span> <span class="number">8</span>, to: <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Double</span>&gt;.<span class="keyword">self</span>).pointee <span class="operator">=</span> <span class="number">14.23</span></span><br><span class="line"></span><br><span class="line">ptr.deallocate()</span><br></pre></td></tr></table></figure>


<hr>
]]></content>
      <categories>
        <category>Swift底层原理</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈Swift的属性(Property)</title>
    <url>/post/bde391d5.html</url>
    <content><![CDATA[<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/ios/swift.jpg?x-oss-process=style/titanjun" alt="Swift"></p>
<span id="more"></span>


<ul>
<li>今年期待已久的<code>Swift5.0</code>稳定版就已经发布了, 感兴趣的小伙伴可看我的这篇博客:<a href="https://www.titanjun.top/2019/01/28/Swift%205.0%E6%96%B0%E7%89%B9%E6%80%A7%E6%9B%B4%E6%96%B0/">Swift 5.0新特性更新</a></li>
<li>这篇博客可主要分享<code>Swift</code>的属性的相关介绍和剖析, 测试环境: <code>Xcode 11.2.1</code>, <code>Swift 5.1.2</code></li>
</ul>
<h2 id="属性分类"><a href="#属性分类" class="headerlink" title="属性分类"></a>属性分类</h2><p>在<code>Swift</code>中, 严格意义上来讲属性可以分为两大类: 实例属性和类型属性</p>
<ul>
<li>实例属性(<code>Instance Property</code>): 只能通过实例去访问的属性<ul>
<li>存储实例属性(<code>Stored Instance Property</code>): 存储在市里的内存中, 每个实例都只有一份</li>
<li>计算实例属性(<code>Computed Instance Property</code>)</li>
</ul>
</li>
<li>类型属性(<code>Type Property</code>): 只能通过类型去访问的属性<ul>
<li>存储类型属性(<code>Stored Type Property</code>): 整个程序运行过程中就只有一份内存(类似全局变量)</li>
<li>计算类型属性(<code>Computed Type Property</code>)</li>
<li>类型属性可以通过<code>static</code>关键字定义; 如果是类也可以通过<code>class</code>关键字定义</li>
</ul>
</li>
<li>实例属性属于一个特定类型的实例，每创建一个实例，实例都拥有属于自己的一套属性值，实例之间的属性相互独立</li>
<li>为类型本身定义属性，无论创建了多少个该类型的实例，这些属性全局都只有唯一一份，这种属性就是类型属性</li>
</ul>
<h2 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h2><p>上面提到<code>Swift</code>中跟市里相关的属性可以分为两大类:存储属性和计算属性</p>
<ul>
<li>存储属性(<code>Stored Property</code>)<ul>
<li>类似于成员变量，系统会为其分配内存空间，存储属性存储在实例的内存中</li>
<li>存储属性可以是变量存储属性(用关键字<code>var</code>定义)，也可以是常量存储属性(用关键字<code>let</code>定义)</li>
<li>结构体和类可以定义存储属性, 枚举不可以定义存储属性</li>
</ul>
</li>
<li>计算属性(<code>Computed Property</code>)<ul>
<li>计算属性其本质就是方法(函数), 系统不会为其分配内存空间, 所以计算属性不会占用实例对象的内存</li>
<li>计算属性不直接存储值，而是提供一个<code>getter</code>和一个可选的<code>setter</code>，来间接获取和设置其他属性或变量的值</li>
<li>枚举、绝构体和类都可以定义计算属性</li>
</ul>
</li>
</ul>
<h3 id="存储属性"><a href="#存储属性" class="headerlink" title="存储属性"></a>存储属性</h3><ul>
<li>在<code>Swift</code>中存储属性可以是<code>var</code>修饰的变量, 也可以是<code>let</code>修饰的常量</li>
<li>但是在创建类或结构体的实例时, 必须为所有的存储属性设置一个合适的初始值, 否则会报错的</li>
<li>可以在定义属性的时候, 为其设置一个初始值</li>
<li>可以在<code>init</code>初始化器里为存储实行设置一个初始值</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">// 定义的时候设置初始值</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span> <span class="operator">=</span> <span class="number">24</span></span><br><span class="line">    <span class="keyword">var</span> weight: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用init初始化器设置初始值</span></span><br><span class="line"><span class="keyword">var</span> person1 <span class="operator">=</span> <span class="type">Person</span>(weight: <span class="number">75</span>)</span><br><span class="line"><span class="keyword">var</span> person2 <span class="operator">=</span> <span class="type">Person</span>(age: <span class="number">25</span>, weight: <span class="number">80</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>上面两个属性是会占用实例的内存空间的</li>
<li>可以使用<code>MemoryLayout</code>获取数据类型占用的内存大小</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Person结构体实际占用的内存大小</span></span><br><span class="line"><span class="type">MemoryLayout</span>&lt;<span class="type">Person</span>&gt;.size         <span class="comment">// 16</span></span><br><span class="line"><span class="comment">// 系统为Person分配的内存大小</span></span><br><span class="line"><span class="type">MemoryLayout</span>&lt;<span class="type">Person</span>&gt;.stride       <span class="comment">// 16</span></span><br><span class="line"><span class="comment">// 内存对其参数</span></span><br><span class="line"><span class="type">MemoryLayout</span>&lt;<span class="type">Person</span>&gt;.alignment    <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>

<div class="note primary"><p>还有一种使用方式, 输出结果一致</p></div>


<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person <span class="operator">=</span> <span class="type">Person</span>(weight: <span class="number">75</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">MemoryLayout</span>.size(ofValue: person)</span><br><span class="line"><span class="type">MemoryLayout</span>.stride(ofValue: person)</span><br><span class="line"><span class="type">MemoryLayout</span>.alignment(ofValue: person)</span><br></pre></td></tr></table></figure>


<h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><ul>
<li>枚举、绝构体和类都可以定义计算属性</li>
<li>计算属性不直接存储值，而是提供一个<code>getter</code>和一个可选的<code>setter</code>，来间接获取和设置其他属性或变量的值</li>
<li>计算属性其本质就是方法(函数), 系统不会为其分配内存空间, 所以计算属性不会占用实例对象的内存</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Square</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> side: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> girth: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            side <span class="operator">=</span> newValue <span class="operator">/</span> <span class="number">4</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> side <span class="operator">*</span> <span class="number">4</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其中set也可以使用下面方式</span></span><br><span class="line"><span class="keyword">set</span>(newGirth) &#123;</span><br><span class="line">    side <span class="operator">=</span> newGirth <span class="operator">/</span> <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面我们先看一下<code>Square</code>所占用的内存大小, 这里方便查看都去掉了<code>print</code>函数</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> squ <span class="operator">=</span> <span class="type">Square</span>(side: <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">MemoryLayout</span>.size(ofValue: squ)        <span class="comment">// 8</span></span><br><span class="line"><span class="type">MemoryLayout</span>.stride(ofValue: squ)      <span class="comment">// 8</span></span><br><span class="line"><span class="type">MemoryLayout</span>.alignment(ofValue: squ)   <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>

<p>从上面输出结果可以看出, <code>Square</code>只占用8个内存大小, 也就是一个<code>Int</code>占用的内存大小, 如果还是看不出来, 可以看一下下面这个</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Square</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> girth: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">4</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="type">MemoryLayout</span>&lt;<span class="type">Square</span>&gt;.size)   <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<ul>
<li>从上面两个输出结果可以看出, 计算属性并不占用内存空间</li>
<li>此外, 计算属性虽然不直接存储值, 但是却需要<code>get、set</code>方法来取值或赋值</li>
<li>其中通过<code>set</code>方法修改其他相关联的属性的值; 如果该计算属性是只读的, 则不需要<code>set</code>方法, 传入的新值默认值<code>newValue</code>, 也可以自定义</li>
<li>通过<code>get</code>方法获取该计算属性的值, 即使是只读的, 计算属性的值也是可能发生改变的</li>
<li>定义计算属性只能使用<code>var</code>, 不能使用<code>let</code></li>
<li>下面我们通过汇编的方式来看一下执行过程, 在下图中勾上<code>Always Show Disassembly</code>, 右断点时<code>Xcode</code>就会在运行过程中自动跳到断点的汇编代码中</li>
</ul>
<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/swift/always.png" alt="Disassembly"></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> squ <span class="operator">=</span> <span class="type">Square</span>(side: <span class="number">4</span>)</span><br><span class="line"><span class="keyword">var</span> c <span class="operator">=</span> squ.girth    <span class="comment">// 在此处加上断点时</span></span><br></pre></td></tr></table></figure>

<p>上述代码的执行流程, 通过汇编的方式看, 核心代码如下所示</p>
<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/swift/square1.png" alt="Square1"></p>
<p>下面是在iOS模拟器环境下一些汇编常用的指令</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将rax的值赋值给rdi</span></span><br><span class="line">movq   %rax, %rdi</span><br><span class="line"><span class="comment">// 将rbp-0x18这个地址值赋值给rsi</span></span><br><span class="line">leaq   <span class="number">-0x18</span>(%rbp), %rsi</span><br><span class="line"><span class="comment">// 函数跳转指令</span></span><br><span class="line">callq  <span class="number">0x100005428</span> </span><br></pre></td></tr></table></figure>


<p>从上图可以看到上面代码对应的汇编代码, 其核心代码大概可以分为四部分</p>
<ol>
<li><code>Square</code>调用<code>init</code>初始化器, 即<code>Square</code>的初始化(详细汇编代码可进入<code>callq  0x100001300</code>中查看)</li>
<li>讲已经出初始化的<code>Square</code>的对象的内存地址赋值给一个全局变量, 即<code>squ</code></li>
<li>调用<code>Square</code>对象里面<code>girth</code>计算属性的<code>getter</code>方法, 获取<code>girth</code>的值</li>
<li>把获取的<code>girth</code>的值赋值给一个全局变量</li>
</ol>
<blockquote>
<p>如上图中中断点位置, 当断点执行到此处时, 执行<code>si</code>命令即可查看<code>getter</code>函数的的执行过程, 如下图所示, 其中<code>imulq</code>是执行乘法指令</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 把rdx和rax的相乘的结果在赋值给rax</span></span><br><span class="line">imulq  %rdx, %rax</span><br></pre></td></tr></table></figure>



<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/swift/square2.png" alt="Square1"></p>
<p>下面再看一下, 计算属性的赋值操作, 代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var squ = Square(side: 4)</span><br><span class="line">squ.girth = 12;</span><br><span class="line">print(squ.side)   // 3</span><br></pre></td></tr></table></figure>

<p>对应的汇编代码如下, 执行流程和上面的取值操作类似, 不同的是赋值操作最后执行的是<code>girth</code>的<code>setter</code>方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="number">0x1000010c9</span> &lt;+<span class="number">25</span>&gt;: callq  <span class="number">0x100001300</span>               ; SwiftLanguage.Square.init(side: Swift.Int) -&gt; SwiftLanguage.Square at main.swift:<span class="number">11</span></span><br><span class="line"><span class="number">0x1000010ce</span> &lt;+<span class="number">30</span>&gt;: leaq   <span class="number">0x6123</span>(%rip), %rsi        ; SwiftLanguage.squ : SwiftLanguage.Square</span><br><span class="line"><span class="number">0x1000010d5</span> &lt;+<span class="number">37</span>&gt;: xorl   %ecx, %ecx</span><br><span class="line"><span class="number">0x1000010d7</span> &lt;+<span class="number">39</span>&gt;: movq   %rax, <span class="number">0x611a</span>(%rip)        ; SwiftLanguage.squ : SwiftLanguage.Square</span><br><span class="line"><span class="number">0x1000010de</span> &lt;+<span class="number">46</span>&gt;: movq   %rsi, %rdi</span><br><span class="line"><span class="number">0x1000010e1</span> &lt;+<span class="number">49</span>&gt;: leaq   <span class="number">-0x20</span>(%rbp), %rsi</span><br><span class="line"><span class="number">0x1000010e5</span> &lt;+<span class="number">53</span>&gt;: movl   $<span class="number">0x21</span>, %edx</span><br><span class="line"><span class="number">0x1000010ea</span> &lt;+<span class="number">58</span>&gt;: callq  <span class="number">0x10000540a</span>               ; symbol stub <span class="keyword">for</span>: swift_beginAccess</span><br><span class="line"><span class="number">0x1000010ef</span> &lt;+<span class="number">63</span>&gt;: movl   $<span class="number">0xc</span>, %edi</span><br><span class="line"><span class="number">0x1000010f4</span> &lt;+<span class="number">68</span>&gt;: leaq   <span class="number">0x60fd</span>(%rip), %r13        ; SwiftLanguage.squ : SwiftLanguage.Square</span><br><span class="line"><span class="number">0x1000010fb</span> &lt;+<span class="number">75</span>&gt;: callq  <span class="number">0x100001200</span>               ; SwiftLanguage.Square.girth.setter : Swift.Int at main.swift:<span class="number">14</span></span><br></pre></td></tr></table></figure>

<ul>
<li>只读计算属性, 只有<code>get</code>没有<code>set</code> </li>
<li>只读计算属性的值, 则是根据关联值的变化而变化, 不可被赋值</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 你可以这样写</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Square</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> side: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> girth: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> side <span class="operator">*</span> <span class="number">4</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以这样写</span></span><br><span class="line"><span class="keyword">var</span> girth: <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> side <span class="operator">*</span> <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 还可以这样写</span></span><br><span class="line"><span class="keyword">var</span> girth: <span class="type">Int</span> &#123; side <span class="operator">*</span> <span class="number">4</span> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> squ <span class="operator">=</span> <span class="type">Square</span>(side: <span class="number">4</span>)</span><br><span class="line"><span class="comment">// 不可赋值修改</span></span><br><span class="line"><span class="comment">//squ.girth = 12;</span></span><br><span class="line"><span class="built_in">print</span>(squ.girth)</span><br></pre></td></tr></table></figure>

<h3 id="枚举的rawValue"><a href="#枚举的rawValue" class="headerlink" title="枚举的rawValue"></a>枚举的rawValue</h3><p>枚举的<code>rawValue</code>的本质就是计算属性, 而且是只读的计算属性</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Test</span>: <span class="title class_">Int</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> test1 <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> test2 <span class="operator">=</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c <span class="operator">=</span> <span class="type">Test</span>.test1.rawValue</span><br><span class="line"><span class="built_in">print</span>(c)    <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>至于如何确定, 那么久简单粗暴点, 看汇编</p>
<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/swift/square3.png" alt="Square"></p>
<ul>
<li>上图中可以看到获取<code>rawValue</code>的值, 其实就是调用的<code>rawValue</code>的<code>getter</code>方法</li>
<li>另外如下所示, 我们对<code>rawValue</code>进行重新赋值, 会报错</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Test</span>.test1.rawValue <span class="operator">=</span> <span class="number">2</span></span><br><span class="line"><span class="comment">// 这里报错: Cannot assign to property: &#x27;rawValue&#x27; is immutable</span></span><br></pre></td></tr></table></figure>

<p>那么我们就可以根据<code>rawValue</code>的计算属性修改<code>rawValue</code>的值</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Test</span>: <span class="title class_">Int</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> test1 <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> test2 <span class="operator">=</span> <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> rawValue: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .test1:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">10</span></span><br><span class="line">        <span class="keyword">case</span> .test2:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">20</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c <span class="operator">=</span> <span class="type">Test</span>.test1.rawValue   <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<h3 id="延迟存储属性"><a href="#延迟存储属性" class="headerlink" title="延迟存储属性"></a>延迟存储属性</h3><ul>
<li>使用<code>lazy</code>可以定义一个延迟存储属性(<code>Lazy Stored Property</code>), 延迟存储属性只有在第一次使用的时候才会进行初始化</li>
<li><code>lazy</code>属性修饰必须是<code>var</code>, 不能是<code>let</code></li>
<li><code>let</code>修饰的常量必须在实例的初始化方法完成之前就拥有值</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Car init&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">run</span>() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Car is runing&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">lazy</span> <span class="keyword">var</span> car  <span class="operator">=</span> <span class="type">Car</span>()</span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Person init&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">goOut</span>() &#123;</span><br><span class="line">        car.run()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person <span class="operator">=</span> <span class="type">Person</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;--------&quot;</span>)</span><br><span class="line">person.goOut()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">// Person init</span></span><br><span class="line"><span class="comment">// --------</span></span><br><span class="line"><span class="comment">// Car init</span></span><br><span class="line"><span class="comment">// Car is runing</span></span><br></pre></td></tr></table></figure>

<p>上述代码, 在初始化<code>car</code>的时候如果没有<code>lazy</code>, 则输出结果如下</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Car init</span></span><br><span class="line"><span class="comment">Person init</span></span><br><span class="line"><span class="comment">--------</span></span><br><span class="line"><span class="comment">Car is runing</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>这也就证明了延迟存储属性只有在第一次使用的时候才会被初始化</li>
<li>此外还有一种复杂的延迟存储属性, 有点类似于<code>OC</code>中的懒加载</li>
<li>下面代码中实际上是一个闭包, 可以吧相关逻辑处理放在闭包中处理</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Preview &#123;</span><br><span class="line">    lazy var image: Image = &#123;</span><br><span class="line">        let url = &quot;https://titanjun.oss-cn-hangzhou.aliyuncs.com/swift/square3.png&quot;</span><br><span class="line">        let data = Data.init(contentsOf: url)</span><br><span class="line">        return Image(data: data)</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="属性观察器"><a href="#属性观察器" class="headerlink" title="属性观察器"></a>属性观察器</h3><p>在<code>Swift</code>中可以为非<code>lazy</code>的并且只能是<code>var</code>修饰的存储属性设置属性观察器, 形式如下</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">willSet</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;willSet&quot;</span>, newValue)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;didSet&quot;</span>, oldValue, age)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">self</span>.age <span class="operator">=</span> <span class="number">3</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Person init&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p <span class="operator">=</span> <span class="type">Person</span>()</span><br><span class="line">p.age <span class="operator">=</span> <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(p.age)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">Person init</span></span><br><span class="line"><span class="comment">willSet 10</span></span><br><span class="line"><span class="comment">didSet 3 10</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在存储属性中定义<code>willSet</code>或<code>didSet</code>观察者，来观察和响应属性值的变化, 从上述输出结果我们也可以看到<ul>
<li><code>willSet</code>会传递新值, 在存储值之前被调用, 其默认的参数名是<code>newValue</code></li>
<li><code>didSet</code>会传递旧值, 在存储新值之后立即被调用, 其默认的参数名是<code>oldValue</code></li>
</ul>
</li>
<li>当每次给存储属性设置新值时，都会调用属性观察者，即使属性的新值与当前值相同</li>
<li>在初始化器中设置属性和在定义属性是设置初始值都不会触发<code>willSet</code>或<code>didSet</code></li>
</ul>
<h2 id="类型属性"><a href="#类型属性" class="headerlink" title="类型属性"></a>类型属性</h2><ul>
<li>存储类型属性(<code>Stored Type Property</code>): 整个程序运行过程中就只有一份内存(类似全局变量)</li>
<li>计算类型属性(<code>Computed Type Property</code>): 不占用系统内存</li>
<li>类型属性可以通过<code>static</code>关键字定义; 如果是类也可以通过<code>class</code>关键字定义</li>
<li>存储类型属性可以声明为变量或常量，计算类型属性只能被声明为变量</li>
<li>存储类型属性必须设置初始值, 因为存数类型属性没有<code>init</code>初始化器去设置初始值的方式</li>
<li>存储类型属性默认就是延迟属性(<code>lazy</code>), 不需要使用<code>lazy</code>修饰符标记, 只会在第一次使用的时候初始化, 即使是被多个线程访问, 也能保证只会被初始化一次</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在结构体中只能使用static</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> weight: <span class="type">Int</span> <span class="operator">=</span> <span class="number">30</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> height: <span class="type">Int</span> <span class="operator">=</span> <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取值</span></span><br><span class="line"><span class="keyword">let</span> a <span class="operator">=</span> <span class="type">Person</span>.weight</span><br><span class="line"><span class="keyword">let</span> b <span class="operator">=</span> <span class="type">Person</span>.height</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值</span></span><br><span class="line"><span class="type">Person</span>.weight <span class="operator">=</span> <span class="number">12</span></span><br><span class="line"><span class="comment">// let修饰的不可被赋值</span></span><br><span class="line"><span class="comment">//Person.height = 10</span></span><br></pre></td></tr></table></figure>

<div class="note info"><p>在类中可以使用`static`和`class`</p></div>




<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> name: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;name&quot;</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">var</span> <span class="title class_">age</span>: <span class="title class_">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取值</span></span><br><span class="line"><span class="keyword">let</span> a1 <span class="operator">=</span> <span class="type">Animal</span>.name</span><br><span class="line"><span class="keyword">let</span> a2 <span class="operator">=</span> <span class="type">Animal</span>.age</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值</span></span><br><span class="line"><span class="type">Animal</span>.name <span class="operator">=</span> <span class="string">&quot;animal&quot;</span></span><br><span class="line"><span class="comment">// class定义的属性是只读的</span></span><br><span class="line"><span class="comment">// Animal.age = 20</span></span><br></pre></td></tr></table></figure>




<h3 id="static"><a href="#static" class="headerlink" title="static"></a><code>static</code></h3><ul>
<li>可以修饰<code>class</code>、<code>struct</code>、<code>enum</code>类型的属性或者方法</li>
<li>被修饰的<code>class</code>中的属性和方法不可以在子类中被重写, 重写会报错</li>
<li>修饰存储属性</li>
<li>修饰计算属性</li>
<li>修饰类型方法</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">// 存储属性</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> weight: <span class="type">Int</span> <span class="operator">=</span> <span class="number">30</span></span><br><span class="line">    <span class="comment">// 计算属性</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> height: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="number">140</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 类型方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">goShoping</span>() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Person shoping&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="class"><a href="#class" class="headerlink" title="class"></a><code>class</code></h3><ul>
<li>只能修饰类的计算属性和方法</li>
<li>不能修饰类的存储属性</li>
<li>修饰的计算属性和方法可以被子类重写</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="comment">// 计算属性</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">var</span> <span class="title class_">height</span>: <span class="title class_">Int</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="number">140</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 类型方法</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">func</span> <span class="title class_">running</span>() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Person running&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="内存分析"><a href="#内存分析" class="headerlink" title="内存分析"></a>内存分析</h3><p>先看下下面这行代码的内存地址</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 <span class="operator">=</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">var</span> num2 <span class="operator">=</span> <span class="number">5</span></span><br><span class="line"><span class="keyword">var</span> num3 <span class="operator">=</span> <span class="number">7</span></span><br></pre></td></tr></table></figure>


<ul>
<li>看到的核心汇编代码如下所示, 就是把3, 5, 7分别赋值给了三个全局变量</li>
<li>在汇编语言中, <code>rip</code>作为指令指针,</li>
<li><code>rip</code>中存储着<code>CPU</code>下一条要执行的指令的地址</li>
<li>一旦<code>CPU</code>读取一条指令, <code>rip</code>会自动指向下一条指令(存储下一条指令的地址)</li>
<li>比如下面代码中第二条指令中的<code>rip</code>存储的地址就是第三条指令的地址<code>0x10000138c</code></li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="number">0x10000137f</span> &lt;+<span class="number">15</span>&gt;:  xorl   %ecx, %ecx</span><br><span class="line"><span class="comment">// $0x3赋值给num1, 则num1的地址值就是: 0x10000138c + 0x5e6c = 0x1000071F8</span></span><br><span class="line"><span class="number">0x100001381</span> &lt;+<span class="number">17</span>&gt;:  movq   $<span class="number">0x3</span>, <span class="number">0x5e6c</span>(%rip)        ; lazy cache variable <span class="keyword">for</span> type metadata <span class="keyword">for</span> Swift.Array&lt;Swift.UInt8&gt; + <span class="number">4</span></span><br><span class="line"><span class="comment">// $0x5赋值给num2, 则num2的地址值就是: 0x100001397 + 0x5e69 = 0x100007200</span></span><br><span class="line"><span class="number">0x10000138c</span> &lt;+<span class="number">28</span>&gt;:  movq   $<span class="number">0x5</span>, <span class="number">0x5e69</span>(%rip)        ; SwiftLanguage.num1 : Swift.Int + <span class="number">4</span></span><br><span class="line"><span class="comment">// $0x7赋值给num3, 则num3的地址值就是: 0x1000013a2 + 0x5e66 = 0x100007208</span></span><br><span class="line"><span class="number">0x100001397</span> &lt;+<span class="number">39</span>&gt;:  movq   $<span class="number">0x7</span>, <span class="number">0x5e66</span>(%rip)        ; SwiftLanguage.num2 : Swift.Int + <span class="number">4</span></span><br><span class="line"><span class="number">0x1000013a2</span> &lt;+<span class="number">50</span>&gt;:  movl   %edi, <span class="number">-0x1c</span>(%rbp)</span><br></pre></td></tr></table></figure>


<ul>
<li>从上面三个内存地址可以看出三个全局变量的内存地址是相邻的</li>
<li>并且彼此相差8个字节, 因为每一个<code>Int</code>就占用8个字节</li>
<li>下面再看一下类型属性和全局变量的内存地址</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> age: <span class="type">Int</span> <span class="operator">=</span> <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num1 <span class="operator">=</span> <span class="number">3</span></span><br><span class="line"><span class="type">Animal</span>.age <span class="operator">=</span> <span class="number">7</span></span><br><span class="line"><span class="keyword">var</span> num2 <span class="operator">=</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>

<div class="note info"><p>相关汇编代码如图所示</p></div>



<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/swift/property.png" alt="property"></p>
<p>根据图中的相关核心代码, 分别计算出<code>num1</code>, <code>age</code>和<code>num2</code>的内存地址如下</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// $0x3赋值给num1, 则num1的地址值就是: 0x100000fd3 + 0x6785 = 0x100007330</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过register命令得到rax的地址为0x100007338, 即为age所在的内存地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// $0x5赋值给num2, 则num2的地址值就是: 0x100001027 + 0x6319 = 0x100007340</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0x100007330</span></span><br><span class="line"><span class="comment">0x100007338</span></span><br><span class="line"><span class="comment">0x100007340</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 上述三个内存地址同样也是相邻, 并且彼此相差8个字节</span></span><br></pre></td></tr></table></figure>


<div class="note success"><p>所以</p></div>

<p>类型属性也可以理解为全局变量, 不同的是全局变量可以直接访问, 类型属性必须通过类名访问, 有一定的访问限制而已</p>
<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><ul>
<li>上面有提到, 存储类型属性默认就是延迟属性(<code>lazy</code>), 不需要使用<code>lazy</code>修饰符标记, 只会在第一次使用的时候初始化</li>
<li>即使是被多个线程访问, 也能保证只会被初始化一次, 是线程安全的</li>
</ul>
<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/swift/property.png" alt="property"></p>
<ul>
<li>从图中可以看出, 在断点处给类型属性<code>age</code>赋值之前, 执行了很多汇编代码</li>
<li>其中最重要的一条函数跳转指令<code>callq</code></li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 进入查看具体执行的那些操作</span></span><br><span class="line"><span class="number">0x100000fda</span> &lt;+<span class="number">26</span>&gt;:  callq  <span class="number">0x1000010d0</span>  ; SwiftLanguage.Animal.age.unsafeMutableAddressor : Swift.Int at main.swift</span><br></pre></td></tr></table></figure>

<p>将断点加在此处, 执行<code>si</code>指令即可进入该模块</p>
<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/swift/property1.png" alt="property1"></p>
<ul>
<li>这里看到<code>swift_once</code>, 自然就能够联想到<code>dispatch_once</code>和<code>OC</code>中的单例模式</li>
<li>那就继续向下看, 看看<code>swift_once</code>里面到底是如何操作的, 还是在<code>swift_once</code>加上断点, 并执行<code>si</code>指令, 如下图所示</li>
</ul>
<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/swift/property2.png" alt="property2"></p>
<div class="note success"><p>所以</p></div>

<ul>
<li>类型属性的线程安全最终就是通过<code>dispatch_once</code>实现的</li>
<li>属性的赋值操作相当于就是放在<code>dispatch_once</code>里面执行的, 保证<code>age</code>的初始化操作永远只被执行一次, 类似<code>OC</code>中的单例</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>Swift底层原理</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>Property</tag>
      </tags>
  </entry>
  <entry>
    <title>移动开发之Fastlane自动化</title>
    <url>/post/d1078e95.html</url>
    <content><![CDATA[<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/ios/fastlanetext.jpg?x-oss-process=style/titanjun" alt="fastlane_text"></p>
<span id="more"></span>


<ul>
<li>在组件化开发过程中, 提交一个私有库需要执行很多操作和命令, 详情可参考<a href="https://www.titanjun.top/2018/08/29/iOS%E7%BB%84%E4%BB%B6%E5%8C%96%E4%B9%8B%E7%A7%81%E6%9C%89%E5%BA%93/">iOS组件化之私有库</a></li>
<li>然而开发和更新私有库的大量操作却都是重复性的: 修改<code>spec</code>文件, 提交到远程仓库, 打标签等</li>
<li>所以有没有什么办法可以自动执行, 实现自动化管理呢?</li>
<li>何为自动化: 自动化就是通过一条简单的命令, 去执行一组固定的操作<ul>
<li>自动创建和维护<code>iOS</code>代码签名证书</li>
<li>自动创建和打包<code>iOS</code>的<code>APP</code></li>
<li>上传屏幕截图、元数据和<code>App</code>到<code>APP</code>商店审核</li>
<li>…….</li>
</ul>
</li>
</ul>
<h2 id="FastLane介绍"><a href="#FastLane介绍" class="headerlink" title="FastLane介绍"></a><code>FastLane</code>介绍</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul>
<li><a href="https://fastlane.tools/">Fastlane官网</a>, </li>
<li>用于配置<code>iOS</code>和<code>Android</code>的持续集成的神器</li>
<li><code>Fastlane</code>是一套工具，帮助你简化和自动化 App 发布或部署的过程，将之变成一条平直的工作流</li>
<li><code>Fastlane</code>是用<code>Ruby</code>语言编写的一套自动化工具集和框架，每一个工具实际都对应一个<code>Ruby</code>脚本，用来执行某一个特定的任务</li>
<li><code>Fastlane</code>核心框架则允许使用者通过类似配置文件的形式，将不同的工具有机而灵活的结合在一起，从而形成一个个完整的自动化流程</li>
<li><code>Fastlane</code>是一个ruby脚本集合，它可以按照我们指定的路线，在指定位置执行我们所要执行的操作。这里我们称这样的路线为「航道(lane)」，这样的操作称为<code>Action</code></li>
<li>到目前为止，<code>Fastlane</code>的工具集大约包含170多个小工具，基本上涵盖了打包，签名，测试，部署，发布，库管理等等移动开发中涉及到的内容, 工具的描述和使用可参考: <a href="https://docs.fastlane.tools/actions/">Action官方文档</a>和<a href="https://github.com/fastlane/fastlane/tree/master/fastlane/lib/fastlane/actions">Github源码</a></li>
<li>如果这些工具仍然没有符合你需求的，没有关系，得益于Fastlane本身强大的Action和Plugin机制，如果你恰好懂一些Ruby开发的话，可以很轻易的编写出自己想要的工具</li>
</ul>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ol>
<li>确保ruby为最新版本</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew update</span><br><span class="line">brew install ruby</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>安装<code>fastlane</code></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo gem install -n /usr/local/bin fastlane</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><code>fastlane</code>相关操作命令</li>
</ol>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查看当前fastlane版本</span></span><br><span class="line">fastlane --version</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看所有action</span></span><br><span class="line">fastlane actions</span><br><span class="line"></span><br><span class="line"><span class="comment">// fastlane初始化</span></span><br><span class="line">fastlane init</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>如果出现类似的错误, 则可能是<code>ruby</code>源问题, 可更换<code>ruby</code>源后重新安装</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ERROR:  Could not find a valid gem &#x27;fastlane&#x27; (&gt;= 0), here is why:</span><br><span class="line">          Unable to download data from https://gems.ruby-china.org/ - bad response Not Found 404 (https://gems.ruby-china.org/specs.4.8.gz)</span><br></pre></td></tr></table></figure>

<div class="note info"><p>更换`ruby`源</p></div>

<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 官方https://gems.ruby-china.com/把org改成了com, 使用时注意替换</span></span><br><span class="line"><span class="comment">// 查看gem源</span></span><br><span class="line">gem sources</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除默认的gem源</span></span><br><span class="line">gem sources --remove https:<span class="comment">//gems.ruby-china.org/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加gem源</span></span><br><span class="line">gem sources -a https:<span class="comment">//gems.ruby-china.com/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看当前的gem源</span></span><br><span class="line">gem sources</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空源缓存</span></span><br><span class="line">gem sources -c</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新源缓存</span></span><br><span class="line">gem sources -u</span><br></pre></td></tr></table></figure>


<h2 id="fastlane提交私有库"><a href="#fastlane提交私有库" class="headerlink" title="fastlane提交私有库"></a><code>fastlane</code>提交私有库</h2><h3 id="初始化fastlane"><a href="#初始化fastlane" class="headerlink" title="初始化fastlane"></a>初始化<code>fastlane</code></h3><p>cd 到当前目录, 执行<code>fastlane init</code>命令</p>
<p>但是对于提交私有库来说这个过程会创建一些无用的文件, 包括双穿需要的<code>appleID</code>等, 有雨我们不涉及这些, 所以我们还可以直接创建所需文件</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">cd 根目录</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个fastlane文件夹</span></span><br><span class="line">mkdir fastlane</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进入fastlane目录</span></span><br><span class="line">cd xxx/xxx/fastlane</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个Fastfile文件</span></span><br><span class="line">touch Fastfile</span><br></pre></td></tr></table></figure>

<p>接下来就是编写<code>Fastfile</code>文件内容</p>
<h3 id="配置Fastfile-96-文件"><a href="#配置Fastfile-96-文件" class="headerlink" title="配置Fastfile&#96;文件"></a>配置Fastfile&#96;文件</h3><h4 id="语法解析"><a href="#语法解析" class="headerlink" title="语法解析"></a>语法解析</h4><p><code>fastlane init</code>创建好文件后, 打开<code>Fastfile</code>文件, 默认内容如下</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">default_platform(<span class="symbol">:ios</span>)</span><br><span class="line"></span><br><span class="line">platform <span class="symbol">:ios</span> <span class="keyword">do</span></span><br><span class="line">  desc <span class="string">&quot;Description of what the lane does&quot;</span></span><br><span class="line">  lane <span class="symbol">:custom_lane</span> <span class="keyword">do</span></span><br><span class="line">    <span class="comment"># add actions here: https://docs.fastlane.tools/actions</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>platform</code>: 使用的平台</li>
<li><code>desc</code>: 描述航道的作用</li>
<li><code>lane</code>: 命名航道名称和相关<code>Action</code><ul>
<li><code>custom_lane</code>: 即为航道名称, 可自定义</li>
<li>如需外界传递参数, 可在do后面添加<code>|options|</code></li>
</ul>
</li>
<li>接受外界传递参数, 在添加<code>options</code>后, 可定义如下参数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tagName = options[:tag]</span><br></pre></td></tr></table></figure>

<p>外部使用命令是, 即可通过<code>xxx tag: 0.0.1</code>进行传值</p>
<div class="note warning"><p>`Fastfile`文件</p></div>

<ul>
<li><code>Fastfile</code>文件的作用就是把正常使用的命令转成<code>fastlane</code>的语法, 并在该文件中执行, 可在<a href="https://docs.fastlane.tools/actions/">官方文档</a>中查找对应的语法</li>
<li>以&#x3D;&#x3D;提交私有库到远程&#x3D;&#x3D;为例, 就是把所有相关命令, 找到对应的<code>fastlane</code>命令写在<code>Fastfile</code>文件中执行</li>
</ul>
<h4 id="Fastfile文件配置"><a href="#Fastfile文件配置" class="headerlink" title="Fastfile文件配置"></a><code>Fastfile</code>文件配置</h4><p>提交私有库时, 需要执行的命令如下</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将本地库更像到测试项目</span></span><br><span class="line">pod install</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将本地代码加入本地仓库里</span></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交修改到本地仓库</span></span><br><span class="line">git commit -m <span class="string">&#x27;你的修改记录&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加名称为origin的远程连接</span></span><br><span class="line">git remote add origin <span class="string">&#x27;你的github项目地址&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在push之前, 查看spec是否配置有问题</span></span><br><span class="line"><span class="comment">// 验证本地spec文件是否有误</span></span><br><span class="line">pod lib lint</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推送master分支的代码到名称为origin的远程仓库</span></span><br><span class="line">git push origin master</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置tag值</span></span><br><span class="line">git tag <span class="string">&quot;0.0.1&quot;</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 上传提交tag</span></span><br><span class="line">git push --tags</span><br></pre></td></tr></table></figure>

<ul>
<li>打开<a href="https://docs.fastlane.tools/actions/">官方文档</a>搜索</li>
<li>例如: 搜索<code>pod install</code>, 对应的即为<code>cocoapods</code>, 如下</li>
</ul>
<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/ios/fastlanepod.jpg?x-oss-process=style/titanjun" alt="fastlanepod"></p>
<p><code>Fastfile</code>文件配置内容如下, 可做响应的参考</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">default_platform(<span class="symbol">:ios</span>)</span><br><span class="line"></span><br><span class="line">platform <span class="symbol">:ios</span> <span class="keyword">do</span></span><br><span class="line">  desc <span class="string">&quot;用于对私有库的升级维护和提交&quot;</span></span><br><span class="line">  lane <span class="symbol">:DownloadLane</span> <span class="keyword">do</span> |<span class="params">options</span>|</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 0. 需要外界传入的参数</span></span><br><span class="line">    tagName = options[<span class="symbol">:tag</span>]</span><br><span class="line">	targetName = options[<span class="symbol">:target</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  	<span class="comment"># 1. 将本地库更像到测试项目</span></span><br><span class="line">	<span class="comment"># pod install</span></span><br><span class="line">	cocoapods(</span><br><span class="line">  		<span class="symbol">clean:</span> <span class="literal">true</span>,</span><br><span class="line">  		<span class="comment"># 该目录为执行Podfile未见的相对路径</span></span><br><span class="line">  		<span class="symbol">podfile:</span> <span class="string">&quot;./Example/Podfile&quot;</span></span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 2. 将本地代码加入本地仓库里</span></span><br><span class="line">	<span class="comment"># git add .</span></span><br><span class="line">	<span class="comment"># path为需要提交的文件的路径, 这里是所有文件</span></span><br><span class="line">	git_add(<span class="symbol">path:</span> <span class="string">&quot;.&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 3. 提交修改到本地仓库</span></span><br><span class="line">	<span class="comment"># git commit -m &#x27;你的修改记录&#x27;</span></span><br><span class="line">	<span class="comment"># message: 提交信息</span></span><br><span class="line">	git_commit(<span class="symbol">path:</span> <span class="string">&quot;.&quot;</span>, <span class="symbol">message:</span> <span class="string">&quot;这里是提交信息&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 4. 在push之前, 查看spec是否配置有问题</span></span><br><span class="line">	<span class="comment">#  验证本地spec文件是否有误</span></span><br><span class="line">	<span class="comment"># pod lib lint</span></span><br><span class="line">	<span class="comment"># allow_warnings: 允许警告的存在</span></span><br><span class="line">	pod_lib_lint(<span class="symbol">allow_warnings:</span> <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 5. 推送master分支的代码到名称为origin的远程仓库</span></span><br><span class="line">	<span class="comment"># git push origin master</span></span><br><span class="line">	push_to_git_remote  <span class="comment"># 更多的信息可查看官网</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 6. 判断标签是否存在, 重复添加标签会报错</span></span><br><span class="line">	<span class="comment"># if-else-end和if-end判断语句</span></span><br><span class="line">	<span class="keyword">if</span> git_tag_exists(<span class="symbol">tag:</span> tagName)</span><br><span class="line">		<span class="comment"># UI.message: 打印信息</span></span><br><span class="line">    	<span class="variable constant_">UI</span>.message(<span class="string">&quot;发现tag:<span class="subst">#&#123;tagName&#125;</span> 该标签已经存在&quot;</span>)</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">	<span class="comment"># 7. 设置tag值</span></span><br><span class="line">	<span class="comment"># git tag &quot;0.0.1&quot;  </span></span><br><span class="line">	add_git_tag(</span><br><span class="line">		<span class="symbol">tag:</span> tagName</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 8. 上传提交tag</span></span><br><span class="line">	<span class="comment"># git push --tags</span></span><br><span class="line">	push_git_tags</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 9. 更新索引库</span></span><br><span class="line">	<span class="comment"># pod repo push XXXX xxx.podspec</span></span><br><span class="line">	pod_push(<span class="symbol">path:</span> <span class="string">&quot;<span class="subst">#&#123;targetName&#125;</span>.podspec&quot;</span>, <span class="symbol">repo:</span> <span class="string">&quot;TitanjunSpec&quot;</span>, <span class="symbol">allow_warnings:</span> <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>Fastfile</code>文件编写完成, 需要检测文件语法是否有误, cd 进入根目录, 执行<code>fastlane lanes</code></li>
<li>如果没问题, 执行命令<code>fastlane 航道名称 参数1:值1  参数2:值2</code></li>
<li>示例: <code>fastlane DownloadLane tag:0.1.0 target:TKDownLoad</code></li>
<li>正常情况下, 私有库已经被提交到远程仓库了, 并更新了对应的索引库</li>
</ul>
<h2 id="自定义Action"><a href="#自定义Action" class="headerlink" title="自定义Action"></a>自定义Action</h2><ul>
<li>有的时候官方提供的所有的<code>Action</code>并不能满足我们的需求, 不过<code>fastlane</code>具有很好的扩展性, 支持自定义<code>Action</code></li>
<li>找了半天才发现一个删除远程私有库标签的命令, <a href="https://docs.fastlane.tools/actions/">官方文档</a>中没有提供</li>
<li>这里我们就自定义一个删除远程私有库标签的<code>Action</code></li>
</ul>
<h3 id="创建ruby文件"><a href="#创建ruby文件" class="headerlink" title="创建ruby文件"></a>创建<code>ruby</code>文件</h3><ul>
<li>首先打开终端, cd 进入<code>fastlane</code>文件夹所在的上级目录</li>
<li>执行<code>fastlane new_action</code>命令, 创建新的<code>Action</code>, 过程中会让你输入你自定义的<code>Action</code>名字</li>
<li>注意命令规范, 单词之间可用下划线连接</li>
</ul>
<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/ios/fastlaneaction.jpg?x-oss-process=style/titanjun" alt="fastlaneaction"></p>
<p>之后<code>fastlane</code>文件内会多一个<code>actions</code>的文件件, 内有<code>delete_tag.rb</code>文件, 如下</p>
<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/ios/fastlanetag.jpg?x-oss-process=style/titanjun" alt="actionsName"></p>
<ul>
<li>最后就是编辑该<code>rb</code>文件, 当然可能需要懂一些<code>ruby</code>语言的语法, 如果不懂也没关系, 到<a href="https://github.com/fastlane/fastlane/tree/master/fastlane/lib/fastlane/actions">Github源码</a>找一个类似功能的<code>rb</code>文件, 照葫芦画瓢吧!</li>
</ul>
<p>下面把我自定义的<code>actions</code>的相关代码贴出来</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> Fastlane</span><br><span class="line">  <span class="keyword">module</span> Actions</span><br><span class="line">    <span class="keyword">module</span> SharedValues</span><br><span class="line">      <span class="variable constant_">DELETE_TAG_CUSTOM_VALUE</span> = <span class="symbol">:DELETE_TAG_CUSTOM_VALUE</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">DeleteTagAction</span> &lt; <span class="title class_ inherited__">Action</span></span><br><span class="line">      <span class="keyword">def</span> <span class="title function_">self</span>.run(params)</span><br><span class="line">        <span class="comment"># 运行该action最终需要执行的代码, 在这里写</span></span><br><span class="line">        tagName = params[<span class="symbol">:tag</span>]</span><br><span class="line">        isRemoveLocalTag = params[<span class="symbol">:rL</span>]</span><br><span class="line">        isRemoveRemoteTag = params[<span class="symbol">:rR</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 1. 先定义一个数组, 用来存储所有需要执行的命令</span></span><br><span class="line">        cmds = []</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 2. 往数组里面, 添加相应的命令</span></span><br><span class="line">        <span class="comment"># 删除本地标签</span></span><br><span class="line">        <span class="comment"># git tag -d 标签名称</span></span><br><span class="line">        <span class="keyword">if</span> isRemoveLocalTag</span><br><span class="line">          cmds &lt;&lt; <span class="string">&quot;git tag -d <span class="subst">#&#123;tagName&#125;</span> &quot;</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">      </span><br><span class="line">        <span class="comment"># 删除远程标签</span></span><br><span class="line">        <span class="comment"># git push origin :标签名称</span></span><br><span class="line">        <span class="keyword">if</span> isRemoveRemoteTag</span><br><span class="line">          cmds &lt;&lt; <span class="string">&quot; git push origin :<span class="subst">#&#123;tagName&#125;</span>&quot;</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#3. 执行数组里面的所有命令</span></span><br><span class="line">        result = Actions.sh(cmds.join(<span class="string">&#x27;&amp;&#x27;</span>));</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">def</span> <span class="title function_">self</span>.description</span><br><span class="line">        <span class="comment"># 间断的说明该Action的作用是什么, 不超过80个字符</span></span><br><span class="line">        <span class="string">&quot;删除标签&quot;</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">def</span> <span class="title function_">self</span>.details</span><br><span class="line">        <span class="comment"># 详细的描述当前的Action</span></span><br><span class="line">        <span class="string">&quot;使用该action, 可删除本地或远程标签&quot;</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">def</span> <span class="title function_">self</span>.available_options</span><br><span class="line">        <span class="comment"># 该action需要的参数, 使用同构数组进行分割的, 可以根据每一个参数, 确定其作用</span></span><br><span class="line">        [</span><br><span class="line">          <span class="comment"># key: 参数名称, description: 参数描述或作用, optional: 是否是可选, is_string: 是否是string类型, default_value: 默认值, verify_block: 验证的block</span></span><br><span class="line">          <span class="title class_">FastlaneCore::ConfigItem</span>.new(<span class="symbol">key:</span> <span class="symbol">:tag</span>,</span><br><span class="line">                                             <span class="symbol">description:</span> <span class="string">&quot;需要被删除的标签名称&quot;</span>,</span><br><span class="line">                                             <span class="symbol">optional:</span> <span class="literal">false</span>,</span><br><span class="line">                                             <span class="symbol">is_string:</span> <span class="literal">true</span>),</span><br><span class="line">          <span class="title class_">FastlaneCore::ConfigItem</span>.new(<span class="symbol">key:</span> <span class="symbol">:rL</span>,</span><br><span class="line">                                       <span class="symbol">description:</span> <span class="string">&quot;是否需要删除本地标签&quot;</span>,</span><br><span class="line">                                       <span class="symbol">optional:</span> <span class="literal">true</span>,</span><br><span class="line">                                       <span class="symbol">is_string:</span> <span class="literal">false</span>,</span><br><span class="line">                                       <span class="symbol">default_value:</span> <span class="literal">true</span>),</span><br><span class="line">          <span class="title class_">FastlaneCore::ConfigItem</span>.new(<span class="symbol">key:</span> <span class="symbol">:rR</span>,</span><br><span class="line">                                       <span class="symbol">description:</span> <span class="string">&quot;是否需要删除远程标签&quot;</span>,</span><br><span class="line">                                       <span class="symbol">optional:</span> <span class="literal">true</span>,</span><br><span class="line">                                       <span class="symbol">is_string:</span> <span class="literal">false</span>,</span><br><span class="line">                                       <span class="symbol">default_value:</span> <span class="literal">true</span>)</span><br><span class="line">        ]</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">def</span> <span class="title function_">self</span>.output</span><br><span class="line">        <span class="comment"># 表示输出的内容</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">def</span> <span class="title function_">self</span>.return_value</span><br><span class="line">        <span class="comment"># 返回值</span></span><br><span class="line">        <span class="literal">nil</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">def</span> <span class="title function_">self</span>.authors</span><br><span class="line">        <span class="comment"># 作者</span></span><br><span class="line">        [<span class="string">&quot;CoderTitan&quot;</span>]</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">def</span> <span class="title function_">self</span>.is_supported?(platform)</span><br><span class="line">        <span class="comment"># 支持的平台</span></span><br><span class="line">        platform == <span class="symbol">:ios</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后需要验证<code>rb</code>文件是否格式正确, 终端输入<code>fastlane action delete_tag</code></p>
<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/ios/fastlaneTest.jpg?x-oss-process=style/titanjun" alt="fastlaneTest"></p>
]]></content>
      <categories>
        <category>组件化开发</category>
      </categories>
      <tags>
        <tag>fastlane</tag>
      </tags>
  </entry>
  <entry>
    <title>简析OC中对象占用内存的原理</title>
    <url>/post/84ca04ec.html</url>
    <content><![CDATA[<ul>
<li><code>OC</code>即<code>Objective-C</code>, 是<code>iOS</code>的开发语言之一, 其底层都是通过<code>C/C++</code>实现</li>
<li><code>OC</code>代码在编译过程中都会被转成<code>C/C++</code>代码, 之后再转成汇编语言, 最后才转成机器语言(0和1)</li>
<li>所以<code>OC</code>的面向对象都是基于<code>C/C++</code>的数据结构实现的, 具体一点就是通过机构提实现的(这个后面会详解)</li>
</ul>
<span id="more"></span>



<h2 id="C-C-代码转换"><a href="#C-C-代码转换" class="headerlink" title="C/C++代码转换"></a><code>C/C++</code>代码转换</h2><ul>
<li>上面说到, <code>OC</code>代码在编译过程中都会转成<code>C/C++</code>代码, 不过这个过程我们看不到, 也拿不到转化后的<code>C/C++</code>代码</li>
<li>所以下面我们手动将<code>OC</code>代码转成<code>C/C++</code>代码</li>
<li>使用下面的命令行</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">xcrun  -sdk  iphoneos  clang  -arch  arm64  -rewrite-objc OC源文件  -o  输出的CPP文件</span><br><span class="line"></span><br><span class="line"><span class="comment">// xcrun --&gt; xcode run的简写</span></span><br><span class="line"><span class="comment">// iphoneos --&gt; 指运行在iOS平台</span></span><br><span class="line"><span class="comment">// -arch --&gt; 支持的设备架构: 模拟器(i386)、32bit(armv7)、64bit（arm64）, iOS的架构现在基本都是arm64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开终端到文件目录下, 输入以下示例代码即可</span></span><br><span class="line">xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main.cpp</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其中<code>cpp</code>就是指<code>c plus plus</code>, 也就是<code>c++</code>的意思</p>
</blockquote>
<h2 id="OC对象的本质"><a href="#OC对象的本质" class="headerlink" title="OC对象的本质"></a>OC对象的本质</h2><p>在说<code>OC</code>对象的本质之前, 我们可以先点进去看一下<code>NSObject</code>对象的底层定义, 如下</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> &lt;<span class="title">NSObject</span>&gt; </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> clang diagnostic push</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> clang diagnostic ignored <span class="string">&quot;-Wobjc-interface-ivars&quot;</span></span></span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> clang diagnostic pop</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>抛开定义的宏不考虑, 其实就只有一个<code>Class</code>类型的<code>isa</code>属性</li>
<li>下面从上一步中生成的<code>main.cpp</code>文件中, 看一下<code>NSObject</code>在内存中是如何声明的</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="built_in">NSObject_IMPL</span> &#123;</span><br><span class="line">    Class isa;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>NSObject</code>最后转成了<code>NSObject_IMPL</code>(结构体), 我们的<code>OC</code>对象最后其实就是转成了结构体; 也就是说,<code>c++</code>的结构体支撑了<code>OC</code>语法中的面相对象</p>
</blockquote>
<p>至于<code>isa</code>是什么? 我们可以点进去看一下, 其实也就是一个指向结构体<code>struct objc_class</code>的指针, 那么他在64位的环境下占8个字节，在32环境上占4个字节</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</span><br></pre></td></tr></table></figure>


<h2 id="方法底层"><a href="#方法底层" class="headerlink" title="方法底层"></a>方法底层</h2><ul>
<li>现在我们在回到最初的问题, 一个<code>NSObject</code>对象占用多少内存?</li>
<li>上面说到一个<code>isa</code>就需要占用8个字节, 那么一个<code>NSObject</code>对象就至少需要8个字节</li>
<li>但是系统真的就为一个<code>NSObject</code>对象分配了8个字节的存储空间吗??</li>
<li>下面我们通过两个方法来计算对象所占用内存大小</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// runtime方法</span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line">        </span><br><span class="line"><span class="comment">// 获取NSObject类的示例对象的大小, (至少需要多少内存, 成员变量所占用的存储大小)</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%zd&quot;</span>, class_getInstanceSize([<span class="built_in">NSObject</span> <span class="keyword">class</span>]));</span><br><span class="line"><span class="comment">// 输出 8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// malloc方法</span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;malloc/malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSObject</span> *obj = [[<span class="built_in">NSObject</span> alloc]init];</span><br><span class="line"><span class="comment">// 获取obj指针所指向的内存的大小, 实际上分配的内容(最少为16)</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%zd&quot;</span>, malloc_size((__bridge <span class="keyword">const</span> <span class="type">void</span> *) obj));</span><br><span class="line"><span class="comment">// 输出 16</span></span><br></pre></td></tr></table></figure>

<p>从上面的代码可以看出两个方法打印出来的结果是不一样的, 但是为什么不一样呢, 方法内部优势如何实现的呢??下面我们就具体来看一下</p>
<h3 id="class-getInstanceSize"><a href="#class-getInstanceSize" class="headerlink" title="class_getInstanceSize"></a>class_getInstanceSize</h3><ul>
<li><code>class_getInstanceSize</code>是<code>runtime</code>中的方法, 用于获取<code>NSObject</code>类的示例对象的大小</li>
<li>使用时需要导入对应的头文件<code>#import &lt;objc/runtime.h&gt;</code></li>
<li>至于其方法内部是如何实现的, 这里我们可以查看他的源码, OC所有开发的源码可以到这里查找: <a href="https://opensource.apple.com/tarballs">https://opensource.apple.com/tarballs</a></li>
<li>打开网页, 搜索并找到<code>objc4</code>的文件夹</li>
</ul>
<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/ios/object4.png" alt="runtime源码"></p>
<p>打开<code>objc4</code>所在文件夹, 找到最新版本的代码(数字越大版本越薪)下载, 下载完成，打开项目，然后找到<code>class_getInstanceSize</code>方法的的实现(<code>.mm</code>文件中)</p>
<p><img data-src="https://titanjun.oss-cn-hangzhou.aliyuncs.com/ios/getclasssize.png" alt="image"></p>
<p>接下来, 我们就具体看下方法内部到底是如何实现的</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法的实现</span></span><br><span class="line">size_t class_getInstanceSize(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> cls-&gt;alignedInstanceSize();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Class&#x27;s ivar size rounded up to a pointer-size boundary.</span></span><br><span class="line">uint32_t alignedInstanceSize() &#123;</span><br><span class="line">    <span class="keyword">return</span> word_align(unalignedInstanceSize());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>从上面代码中<code>alignedInstanceSize</code>方法的注释中就可明白, 该方法返回的是当前类(<code>NSObject</code>)的成员变量的大小</li>
<li>当前<code>NSObject</code>中就只有一个<code>isa</code>指针, 所以返回8个字节</li>
<li>上面方法中提到了一个<code>word_align</code>, 可以理解为内存对齐, 后面对具体详解</li>
</ul>
<h3 id="malloc-size"><a href="#malloc-size" class="headerlink" title="malloc_size"></a>malloc_size</h3><ul>
<li><code>malloc_size</code>是<code>malloc</code>中的方法, 用于获取<code>obj</code>指针所指向的内存的大小, 即系统实际分配的内存大小(最少为16)</li>
<li>使用时需要导入对应的头文件<code>#import &lt;malloc/malloc.h&gt;</code></li>
<li>同样根据上面的方式下载源码, 找到<code>libmalloc</code></li>
<li><code>malloc_size</code>方法的实现代码如下</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">size_t</span><br><span class="line">malloc_size(<span class="keyword">const</span> <span class="type">void</span> *ptr)</span><br><span class="line">&#123;</span><br><span class="line">	size_t size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!ptr) &#123;</span><br><span class="line">		<span class="keyword">return</span> size;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	(<span class="type">void</span>)find_registered_zone(ptr, &amp;size);</span><br><span class="line">	<span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




































]]></content>
      <categories>
        <category>OC底层原理</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
</search>
